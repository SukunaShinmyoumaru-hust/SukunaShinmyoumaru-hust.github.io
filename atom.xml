<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Suwa shrine</title>
  
  <subtitle>灵山之上神风起</subtitle>
  <link href="https://sukunashinmyoumaru-hust.github.io/atom.xml" rel="self"/>
  
  <link href="https://sukunashinmyoumaru-hust.github.io/"/>
  <updated>2024-12-18T11:55:00.524Z</updated>
  <id>https://sukunashinmyoumaru-hust.github.io/</id>
  
  <author>
    <name>Sukuna</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些校招八股文的准备</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/12/18/javainterview/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/12/18/javainterview/</id>
    <published>2024-12-18T06:56:02.000Z</published>
    <updated>2024-12-18T11:55:00.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>线程和进程的区别和相同之处。</li></ol><p>相同之处：</p><ul><li>都是操作系统来进行管理的。</li><li>都需要陷入到操作系统的内核态进行操作。</li><li>临时变量都会放入到操作系统的内核栈中。</li></ul><p>不同之处：</p><ul><li>进程是资源分配（文件，内存等）的基本单位，线程是程序执行（占用CPU）的基本单位。</li><li>切换的时候，进程需要保存和切换页表，栈，寄存器，文件句柄等信息，而线程只需要保存和切换一部分寄存器和栈，页表不会切换。</li><li>开销：进程创建和销毁需要创建和销毁PCB（进程控制块）而线程创建销毁只用处理PC，状态码，部分寄存器值和栈即可。</li><li>进程之间通信需要操作系统协同，而线程之间通信可以访问进程数据段（如全局变量）来进行通信。</li><li>进程的并发性是通过不同进程间切换实现的，而线程的并发是一个进程多个内部线程并发执行。（意思是同一时刻只有一个进程占用CPU资源，但是一个进程附属的若干个线程会占用CPU的每个核）</li></ul><p>两者之间的关系：</p><ul><li>一个程序的运行会创建一个或若干个进程。进程是运行的程序。</li><li>线程是轻量级的进程，一个进程会创建若干个线程（其中包括一个主线程）。你可以认为线程是进程的从属。</li><li>主线程结束，进程结束，子线程也会结束。（pthread_exit()和_exit()的区别）</li><li>当操作系统切换进程时，线程也会终止运行并被替换。</li></ul><ol start="2"><li>一个进程可以创建多少线程？</li></ol><p>如果是32位系统，那么虚拟空间只有3G，如果创建线程时分配空间为aMB，那么可以创建$\frac{3000}{a}$个线程</p><p>如果是64为系统，那么虚拟空间有128T，线程的创建不受虚拟空间的限制，而会受系统的参数和性能限制。</p><ol start="3"><li>外中断、异常和自陷之区别。</li></ol><p>外中断是由CPU执行以外的时间引起，例如IO中断，表示设备的输入或者输出完成；时钟中断等。</p><p>异常是由于CPU执行导致的错误，比如说除以0等。</p><p>自陷是自己引发中断，比如说syscall指令，早期汇编的inv指令等。</p><ol start="4"><li>进程调度算法？</li></ol><ul><li>先来先服务（FCFS）顾名思义，不利于短作业。</li><li>短作业优先（SJF）顾名思义，但是长作业可能会饿死。</li><li>最短剩余时间优先（SRTN）看谁剩的短谁先做，会抢占。</li><li>时间片轮转，构建一个就绪队列，每次调度时，从就绪队列中取一个开始，过一个固定的时间后换一个。</li><li>优先级调度，可以认为是把上面的就绪队列改成优先队列，优先级高的先调度。</li><li>多级反馈队列，有n个就绪队列，从i号就绪队列取出来之后执行$S_i$时间，然后进入i+1号就绪队列。（如果i &#x3D; n，就进入i号就绪队列）</li></ul><ol start="5"><li>Linux进程通信方式？</li></ol><ul><li>管道：分成无名和有名两种，管道的数据是单向流动的，无名管道通常只能在父子进程间使用而有名管道就没有这种限制。</li><li>共享内存：几个进程都可以同时访问一段内存。</li><li>消息队列：有消息的链表，存放在内核中并由消息队列标识符标记。</li><li>套接字：Socket</li><li>信号</li><li>信号量（PV操作）</li></ul><ol start="6"><li>进程同步机制？</li></ol><p>临界资源就是多个进程都会用到的资源，换句话说就是</p><ul><li>信号量：P-V操作，可以用于进程同步。</li><li>锁：可以有很多种锁，除了互斥锁以外还有睡眠锁，读写锁等等。只能用于线程同步。</li></ul><ol start="7"><li>快表是什么，有什么用？</li></ol><p>快表（TLB）是页表的cache。作用是在访问页表的时候起到一次cache的作用。</p><p>如果TLB命中，那么访存只需要一次TLB + 一次读内存。如果TLB没有命中，那么访存就是一次TLB + 一次读页表 + 一次读内存，如果读页表也miss了，还要承担一次缺页异常的损耗。</p><ol start="8"><li>动态分区算法</li></ol><ul><li>首次适应，从低地址查找，找到第一个能满足的空闲区。</li><li>最佳适应，空闲分区按照容量递增顺序连接，找到大小能满足要求的第一个空闲分区。会有太多小碎片了，算法开销大。</li><li>最坏适应，空闲分区按照容量递减顺序连接，找到大小能满足要求的第一个空闲分区。大分区会很快用完，算法开销大。</li><li>邻近适应，从上一次分配的地址开始找（递增地址），找到第一个能满足要求的空闲分区。</li></ul><ol start="9"><li>操作系统的虚拟技术。</li></ol><ul><li>时分复用：进程时间片技术，多线程和多进程。</li><li>空分复用：虚拟内存技术。两个进程的逻辑使用空间一致，物理使用空间不一致。</li></ul><ol start="10"><li>进程状态</li></ol><p>分为就绪态，等待态和运行态。在一个操作系统中只能存在一个运行态的进程。</p><ul><li>就绪-&gt;运行，运行-&gt;就绪：时间片到了，从就绪队列取一个进程进行运行，原本运行的进程，进入就绪队列。</li><li>运行-&gt;等待，就绪-&gt;运行：进程运行到某一步被PV操作、IO或者wait卡住了，进入等待状态。</li><li>等待-&gt;就绪：某一个被卡住的进程要等待的东西来了，就可以进入就绪状态。</li></ul><p>只存在这四种转移模式。</p><ol start="11"><li>C&#x2F;C++编译过程。</li></ol><ul><li>预编译：处理所有宏定义，条件预编译指令（#if等），include，注释，#pragma等（.i）</li><li>编译：词法分析，语法分析，语义分析，前端优化（中间代码生成），目标代码生成（.s）</li><li>汇编：将生成的汇编代码生成中间文件（.o）</li><li>链接：分为静态链接（直接把静态库的代码复制到二进制文件里，运行快）和动态链接（程序运行的时候再连接成一个完成的程序，在链接的时候只标记位置，占用空间少）</li></ul><ol start="12"><li>va to pa？</li></ol><p>将va$(V|O)$拆成两部分，页内偏移$O$和页号$V$。然后查页表，一般来说操作系统会管理一个页表基寄存器PTR，然后查$PTR + Vk$（k为一个页表项的长度）这个地址对应的页表项，找到对应的物理块号$P$，则物理地址为$(P|O)$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程和进程的区别和相同之处。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都是操作系统来进</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>每日两个积分题（一直更新到微积分考前）</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/12/17/integrate-everyday/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/12/17/integrate-everyday/</id>
    <published>2024-12-17T15:56:31.000Z</published>
    <updated>2024-12-17T09:29:49.764Z</updated>
    
    <content type="html"><![CDATA[<p>2024-12-17</p><p>1. </p><p>$$\int \frac{sinx + cosx}{\sqrt[3]{sinx - cosx}}dx$$</p><ol start="2"><li></li></ol><p>$$\int \frac{tanxcos^6x}{sin^4x}dx$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2024-12-17&lt;/p&gt;
&lt;p&gt;1. &lt;/p&gt;
&lt;p&gt;$$&#92;int &#92;frac{sinx + cosx}{&#92;sqrt[3]{sinx - cosx}}dx$$&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$&#92;int &#92;frac{tanx</summary>
      
    
    
    
    <category term="算法题" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb学习笔记</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/12/17/javaweb/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/12/17/javaweb/</id>
    <published>2024-12-17T09:32:02.000Z</published>
    <updated>2024-12-18T06:56:32.123Z</updated>
    
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一个有趣的C语言ub</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/12/12/cub/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/12/12/cub/</id>
    <published>2024-12-12T03:55:31.000Z</published>
    <updated>2024-12-12T04:18:50.265Z</updated>
    
    <content type="html"><![CDATA[<p>下面两段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,p++,++p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,++p,p++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的输出，在Ubuntu中使用gcc编译器进行编译，上面的是1 2，下面的是2 0。</p><p>这就不得不提到自增表达式的值了，p++返回的值是做++操作前p的值，++p返回的是做完所有自增（++，+&#x3D;之类的）语句之后p的值。然后是函数调用处理实参的方法，gcc是使用从右到左的顺序处理实参。第一段代码首先做++p，p变成1，然后做p++，p变成2，做p++的时候p为1，那么就返回1.第二段代码同理。两端代码都是做了两次++操作，所以在做完分号内所有语句之后p的值一定是2.</p><p>比如说这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(++p)+(p++,++p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是6，(p++,++p)的返回值是逗号最右的值，而是3.</p><p>比如说这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(p+=<span class="number">2</span>)+(p++,++p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是8.</p><p>这说明了++p返回是有向上面阐述的那样的滞后性。当然正常人不可能会这样写C语言的代码，本文也只是探究一下这样的C语言ub。</p><p>下面我们来看看x86汇编之后的汇编语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;1.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;%d %d\n&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$16, %rsp</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">addl$1, -4(%rbp)</span><br><span class="line">movl-4(%rbp), %eax</span><br><span class="line">leal1(%rax), %edx</span><br><span class="line">movl%edx, -4(%rbp)</span><br><span class="line">movl-4(%rbp), %edx</span><br><span class="line">movl%eax, %esi</span><br><span class="line">leaq.LC0(%rip), %rdi</span><br><span class="line">movl$0, %eax</span><br><span class="line">callprintf@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">.section.note.gnu.property,&quot;a&quot;</span><br><span class="line">.align 8</span><br><span class="line">.long 1f - 0f</span><br><span class="line">.long 4f - 1f</span><br><span class="line">.long 5</span><br><span class="line">0:</span><br><span class="line">.string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">.align 8</span><br><span class="line">.long 0xc0000002</span><br><span class="line">.long 3f - 2f</span><br><span class="line">2:</span><br><span class="line">.long 0x3</span><br><span class="line">3:</span><br><span class="line">.align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;2.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string&quot;%d %d\n&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">endbr64</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$16, %rsp</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">movl-4(%rbp), %eax</span><br><span class="line">leal1(%rax), %edx</span><br><span class="line">movl%edx, -4(%rbp)</span><br><span class="line">addl$1, -4(%rbp)</span><br><span class="line">movl-4(%rbp), %ecx</span><br><span class="line">movl%eax, %edx</span><br><span class="line">movl%ecx, %esi</span><br><span class="line">leaq.LC0(%rip), %rdi</span><br><span class="line">movl$0, %eax</span><br><span class="line">callprintf@PLT</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">.section.note.gnu.property,&quot;a&quot;</span><br><span class="line">.align 8</span><br><span class="line">.long 1f - 0f</span><br><span class="line">.long 4f - 1f</span><br><span class="line">.long 5</span><br><span class="line">0:</span><br><span class="line">.string &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">.align 8</span><br><span class="line">.long 0xc0000002</span><br><span class="line">.long 3f - 2f</span><br><span class="line">2:</span><br><span class="line">.long 0x3</span><br><span class="line">3:</span><br><span class="line">.align 8</span><br><span class="line">4:</span><br></pre></td></tr></table></figure><p>汇编语句一开始首先给main开了个临时变量栈。-4(%rbp)是p。然后对p进行自增操作，把p++应该返回的值传递给eax寄存器。这里汇编和我当时学汇编的时候不一样的点在于，在进行函数调用的时候，并没有按照栈帧进行传参。而是直接使用寄存器进行传参。rdi是第一个参数（地址量，因为是64位汇编），esi是第二个参数，edx是第三个参数。eax是返回值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面两段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣面试经典150题</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/11/20/150/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/11/20/150/</id>
    <published>2024-11-20T15:56:31.000Z</published>
    <updated>2024-12-12T03:51:20.547Z</updated>
    
    <content type="html"><![CDATA[<p>E 是Easy N 是 Normal，也就是Medium，H 是 Hard</p><h2 id="Array-String"><a href="#Array-String" class="headerlink" title="Array &#x2F; String"></a>Array &#x2F; String</h2><ol><li>Merge Sorted Array E</li></ol><p>设置答案表ans，设置两个指针i和j，表示当前所指的位置，一开始指针指向表头。比较两个指针所指元素大小，谁小谁先进ans表。如果有一个指针指到了表尾就不比了，直接把剩下没处理完的内容直接放进ans表。</p><ol start="2"><li>Remove Element E</li></ol><p>太简单，略过。至于怎么使用O(1)的空间复杂度来进行操作。可以用双指针进行操作。i是表头，j是表尾，如果i表示的元素要被删除，就从j中取一个元素放到i对应的位置。（这样就被删掉了），如果不要被删除，那么让i+1就好。</p><ol start="3"><li>Remove Duplicates from Sorted Array E</li></ol><p>这是有序数组，那么一切都好办了。规定一个双指针i和j都指向开头，如果这是重复元素，就移动j，如果不是重复元素，是新元素，那就先把j上的元素放到i处，然后i和j都移动（j是快指针，i是慢指针）</p><ol start="4"><li>Remove Duplicates from Sorted Array II N</li></ol><p>这和上一题的区别就是只允许存在一次和两次的区别。改动也就是重复元素的判断。上一题是判断i和i-1是不是相等，这一题是i和i-2是不是相等。</p><ol start="5"><li>Majority Element E</li></ol><p>可以使用哈希表，统计每个元素出现的次数，然后输出出现次数最多的元素。如果想省空间复杂度的话可以先排序，然后最中间的那个元素就是结果（因为）</p><ol start="6"><li>Rotate Array N</li></ol><p>这一题可以使用数组翻转。比如说 1 2 3 4 5 6 7，移动k下，新数组的[0,k - 1]来源于尾部的k个元素。那么可以做一次翻转（把后面的k个元素放到前面），然后对[0,k - 1]和[k,n - 1]的元素进行调转。（把顺序调整回来）</p><ol start="7"><li>Best Time to Buy and Sell Stock E</li></ol><p>不知道为什么现在就出现了dp，我们可以把这个状态记录在dp[i][j]。j&#x3D;0的时候表示在第i天已经买入股票的收入最大值。j&#x3D;1的时候就是在第i天卖出股票的收入最大值。</p><p>那么dp[i][0] &#x3D; max(dp[i-1][0],-price[i])。dp[i][1] &#x3D; max(dp[i-1][1],dp[i][0] + price[i])。初始值dp[0][0] &#x3D; -price[0],dp[0][1] &#x3D; 0。</p><ol start="8"><li>Best Time to Buy and Sell Stock II N</li></ol><p>上面一题从只可以买一次编程可以买两次。那么dp的的第二维就是有4个状态。买了一个，买了一个卖了一个，买了两个卖了一个，买了两个卖了两个。</p><p>dp[i][0] &#x3D; max(dp[i-1][0],-price[i])。dp[i][1] &#x3D; max(dp[i-1][1],dp[i][0] + price[i])。dp[i][2] &#x3D; max(dp[i-2][2],dp[i][1] - prices[i])。dp[i][3] &#x3D; max(dp[i-1][3],dp[i][2] + price[i])。</p><ol start="9"><li>Jump Game N</li></ol><p>这一题看题解似乎是可以用贪心。但我用倒推dp做的，dp[i]记录了可以到达最后结束位置的可能性。dp[最后一个位置]肯定为1，记录一个使dp[k]&#x3D;1最小的k值，然后依次往后倒，如果nums[i] + i &lt;&#x3D; k的话就说明可以到达。dp[i] &#x3D; 1，否则为0，看看dp[0]的取值就好。</p><ol start="10"><li>Jump Game II N</li></ol><p>这一题相较于上一题多了一个记录最小步数的。那么这次就用dp[i]表示从0到这里最少几步。这里可以有这样的递推方程对于j属于[i,i+nums[i]],dp[j]&#x3D;min(dp[j],dp[i]+1)</p><ol start="11"><li>H-Index N</li></ol><p>对文章引用进行排序。h指的是什么，是h个index比h高的数，那就从0开始试，如果index[size - h - 1] &gt; h，说明可以往上升。</p><ol start="12"><li>Insert Delete GetRandom O(1) N</li></ol><p>O(1)的CURD，空间换时间，用一个额外的哈希表记录是否有重复元素。这个哈希表不记录元素的个数，记录元素在表中的索引。添加的时候在表中添加这个元素，哈希表记录index。删除k，如果k没有，就返回false，如果k有的话，那么找到index。表的index位置替换成表尾元素。删掉表尾元素更换哈希表。在O(1)时间内查询不说，太简单。</p><ol start="13"><li>Product of Array Except Self N</li></ol><p>这里为什么不能计算出所有元素的积然后再除本元素呢，是因为可能本元素是0，所以可能有问题。所以可以进行一次前缀后缀积。s[i]记录从0一直积到i的值，[i]记录从最后积到i的值，后面就是s[i-1]*b[i+1]（注意考虑一下边界）</p><ol start="14"><li>Gas Station N</li></ol><p>先从0开始走，如果能绕一圈自然是好的，但是如果不能的话，在哪里走不动了，就在哪里的下一站试。为什么呢，比如说0-&gt;1-&gt;2，到2走不动了，那么从1出发从2出发也是不行的，只能试一下从3出发。这样可以减少搜索的次数。</p><ol start="15"><li>Candy H</li></ol><p>分糖果，那么可以进行两次贪心。首先先从左往右走，如果i比i-1大，那么s[i] &#x3D; s[i-1] + 1，如果小，s[i] &#x3D; 1。然后从右往左走，如果i比i+1大，那么b[i] &#x3D; b[i+1] + 1，如果小那么b[i] &#x3D; 1。最后这个小孩分配的糖果数量是max(s[i],b[i])。首先这样可以保证题目的条件满足，如果是2 1 2的情况，那么就是1，如果是1 2 1的情况，那么就是max（左，右）。如果是3 2 1的情况，那么就以右边 + 1为准，右边+1怎么都比1大。所以这样做是可以保证对的。其次由于是贪心，我们可以保证分配的糖果数量是最少的。</p><ol start="16"><li>Trapping Rain Water H</li></ol><p>维护一个单调栈，这里就是记录从[s[i],i]中的元素都满足单调性。（这里是单调递减）。这里说一下单调栈的维护，其实就是比较。如果元素比栈顶大，那么栈顶退出，一直到元素比栈顶小或者栈中没元素了。</p><p>如果栈中有元素退栈了，但是栈中元素还是不空，这是发生了什么呢？就是有水背围住了，这个时候可以记录水的数量了。这里套用题解就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int currWidth = i - left - 1;</span><br><span class="line">int currHeight = min(height[left], height[i]) - height[top];</span><br><span class="line">ans += currWidth * currHeight;</span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ol start="17"><li>Roman to Integer E</li></ol><p>模拟即可。对字符串进行遍历。</p><ol start="18"><li>Integer to Roman N</li></ol><p>贪心算法，先算有多少个1000，再算900，再算500，再算400，以此类推。然后做字符串的加运算即可，有多少个1000就加多少个’M’。</p><ol start="19"><li>Integer to Roman E</li></ol><p>统计连续的非空格字符数。有一种优化方式是从后往前遍历字符串，遇到非空格字符开始计数，计数到遇到空格字符，即为答案。</p><ol start="20"><li>Longest Common Prefix E</li></ol><p>找最长公共前缀。就遍历一下即可。比如说第一个单词的第一个字母是A，看看别的单词的第一个字母是不是A，是的话就把A放入答案中，以此类推，直到有差异或者到了一个单词的末尾。</p><ol start="21"><li>Reverse Words in a String N</li></ol><p>这道题就是考验对字符串处理的基本功，首先把所有的单词提取出来，然后把单词逆序处理即可。提取出来的办法我想得比较笨，就是str +&#x3D; 非空格元素。遇到空格就代表单词处理完毕了，加入到一个单词表中。</p><ol start="22"><li>Zigzag Conversion N</li></ol><p>数学题，首先先计算要用到的行数和列数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int route = numRows + (numRows &gt; 1? numRows - 2:0);</span><br><span class="line">int lie = numRows &lt; 2 ? 1 : numRows - 1;</span><br></pre></td></tr></table></figure><p>然后分配一下具体的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(r &lt; numRows) c[r][lie * p] = s[i];</span><br><span class="line">else c[2 * numRows - r - 2][lie * p + r - numRows + 1] = s[i];</span><br></pre></td></tr></table></figure><p>其实就是数学题，建立字符串和Zigzag的映射。</p><ol start="23"><li>Find the Index of the First Occurrence in a String E</li></ol><p>可以使用KMP算法进行匹配，但这里没有使用。就是使用朴素匹配的思路就可以。当然用KMP算法会更快。</p><ol start="24"><li>Text Justification</li></ol><p>暂时略过。</p><h2 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h2><ol start="25"><li>Valid Palindrome E</li></ol><p>设置两个指针i和j，i指向字符串头，j指向字符串尾。i和j相等的话就往内移。不相等返回false。如果i和j相遇了(i &gt;&#x3D; j)，就可以返回true。</p><ol start="26"><li>Is Subsequence E</li></ol><p>这个比字符串匹配要简单一点，设置两个指针i和j，i指向长串，j指向慢串。i和j对应的相等，则i后移j后移，否则就只有i后移。当i移动到最后j没移动到最后就返回false，否则返回true。</p><ol start="27"><li>Two Sum II - Input Array Is Sorted N</li></ol><p>设置两个指针i和j，i指向表前，j指向表后。如果s[i]+s[j]大了，那就j–，如果小了i++，如果j比i小了，说明没结果。如果s[i]+s[j]刚刚好，说明结果找到了！</p><ol start="28"><li>Container With Most Water N</li></ol><p>设置两个指针i和j，i指向表前，j指向表后。记录ans &#x3D; min(height[i],height[j]) * (j - i)的最大值。如果s[i] &lt; s[j]，那就i++，否则j–，一直到j &lt; i为止。（贪心+双指针）</p><ol start="29"><li>3Sum N</li></ol><p>基于第27题的题目，其实在第27题的基础上加了一个遍历。遍历1-n为i，然后在i+1~n之间做一次二数之和。</p><h2 id="Sliding-Window（滑动窗口【单调队列】）"><a href="#Sliding-Window（滑动窗口【单调队列】）" class="headerlink" title="Sliding Window（滑动窗口【单调队列】）"></a>Sliding Window（滑动窗口【单调队列】）</h2><ol start="30"><li>Minimum Size Subarray Sum N</li></ol><p>首先先规定滑动窗口的范围[j,k]。假设滑动窗口内部的和是p。现在遍历这个数组，下标为i</p><p>（1）如果p + a[i] &lt; target，让k &#x3D; i</p><p>（2）p + a[i] &#x3D; target，这是一个可能的结果，记录一下。</p><p>（3）p + a[i] &gt; target。这时候要吐出滑动窗口的元素了。做p -&#x3D; a[j++]一直到p + a[i] &lt;&#x3D; target为止。</p><p>对所有的可能的结果找最小值。</p><ol start="31"><li>Longest Substring Without Repeating Characters N</li></ol><p>首先先规定滑动窗口的范围[j,k]，然后构造一个Hash表来维护不重复性。遍历字符串，下标为i</p><p>（1）s[i]不重复，可以扩展k &#x3D; i。记录一下当前滑动窗口长度。维护滑动窗口长度的最大值。</p><p>（2）s[i]重复，j++到不重复为止。</p><ol start="32"><li>Substring with Concatenation of All Words H</li></ol><p>首先先规定滑动窗口的范围[j,k]，然后构造一个Hash表来维护不重复性。首先我们直到滑动窗口的移动是按照单词表的元素为基准的。也就是说我们的初始滑动窗口是不同的，假设单词表元素的长度为k，那么从0,1,2…k-1开始都可以。所以说要遍历（0,k-1）。</p><p>之后和之前的滑动窗口操作一样。但是每次取字符串都是k个k个去取。</p><p>（1）不在单词表里。那么滑动窗口从[i+单词表长度,i+单词表长度]开始。</p><p>（2）在单词表里，而且在滑动窗口内没出现过（用std::map来维护）。k+&#x3D;单词表长度。</p><p>（3）在单词表里，而且在滑动窗口内出现过，那就移动j一直到滑动窗口内部没出现过。</p><ol start="33"><li>Minimum Window Substring H</li></ol><p>滑动窗口的范围[j,k]，首先遍历一下要判别的串K。看看串内部字母的数量。构建一个hash表记录滑动窗口内部每个字母的数量。然后遍历字符串</p><p>（1）没达到要求，滑动窗口向右拓展。</p><p>（2）达到要求了，滑动窗口往左尽量收缩，尽量的含义是，收缩到i以致于滑动窗口[i+1,k]不满足要求而[i,k]满足要求，记录答案，维护答案的最小值。</p><h2 id="矩阵（大部分就是做模拟）"><a href="#矩阵（大部分就是做模拟）" class="headerlink" title="矩阵（大部分就是做模拟）"></a>矩阵（大部分就是做模拟）</h2><ol start="34"><li>Valid Sudoku N</li></ol><p>模拟，首先先把数独构造出来，然后按行按列去检查有无重复项（哈希表）</p><ol start="35"><li>Spiral Matrix N</li></ol><p>这道题也是模拟。就是模拟矩阵旋转的过程。旋转可以分为四个部分，左下右上。做几次旋转可以通过min(m,n) + 1这个式子算出。左下右上每次怎么放元素的也可以算出。</p><ol start="36"><li>Rotate Image N</li></ol><p>旋转矩阵，其实可以拆成四块去做的。左上到右上，右上到右下，右下到左下，左下到左上。每一次都是四个四个做的，而且可以写出映射。那么矩阵一块有多大呢，一块就是(n&#x2F;2) * (n+1&#x2F;2)大，四块的具体的划分也可以说出来。那么就做那么多次的循环交换就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int temp = matrix[i][j];</span><br><span class="line">matrix[i][j] = matrix[n - j - 1][i];</span><br><span class="line">matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];</span><br><span class="line">matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];</span><br><span class="line">matrix[j][n - i - 1] = temp;</span><br></pre></td></tr></table></figure><ol start="37"><li>Set Matrix Zeroes N</li></ol><p>维护一个表b，记录哪些元素要设置为0。遍历一遍矩阵，对0元素，其所在行和所在列上所有位置，在表b中设置为1。矩阵遍历完了就统一设置为0。这样做是防止新生成出来的0会干扰操作。</p><ol start="38"><li>Game of Life N</li></ol><p>暂时略过。</p><h2 id="HashMap（哈希表）"><a href="#HashMap（哈希表）" class="headerlink" title="HashMap（哈希表）"></a>HashMap（哈希表）</h2><ol start="39"><li>Ransom Note E</li></ol><p>首先遍历magazine，记录magazine每个元素出现的次数，记录在哈希表中。然后遍历ransomNote，记录ransomNote每个元素出现的次数，出现比magazine多就判定false，没有的话就判定true。</p><ol start="40"><li>Isomorphic Strings E</li></ol><p>将两个串进行字数统计，记录在哈希表1和2中，然后排序哈希表1和2，比较哈希表中元素数量是否相同。（当然也可以对哈希表进行再哈希）</p><ol start="41"><li>Word Pattern E</li></ol><p>感觉这题并不像E的难度。将句子拆成若干个单词组，然后尝试构建一个字符串对字符的哈希映射，如果出现了哈希冲突，就是false，反之就是true。比如说dog cat cat dog和abba，就可以成功建立 dog-a cat-b的映射，dog cat cat dog和abbc，那么dog可以对a或者c，就产生了冲突，dog cat cat fog和abba，a可以对dog或者fog，也是出现了冲突。（查冲突的方法就是查哈希表的元素是否为空或者是否为不空）</p><ol start="42"><li>Valid Anagram E</li></ol><p>构建两个字符串的哈希表，看哈希表是否完全相等。</p><ol start="43"><li>Group Anagrams N</li></ol><p>这里本来是想让每组单词之间两两调用42题的API，结果TLE。上网看题解发现可以对字符串做sort，这样互为Anagrams的单词就是一样的。</p><ol start="44"><li>Two Sum E</li></ol><p>这里本来可以使用暴力方式，搜索一遍就可以过。但是可以用哈希表。首先构建一个哈希表，然后。遍历数组，对于数组的元素x，希望能找到target-x的存在性，就搜索哈希表即可。</p><ol start="45"><li>Happy Number E</li></ol><p>首先我们模拟上述的操作，然后我们用一个哈希表记录操作的结果的循环性，如果结果循环出现，我们知道时遇到了循环，就要返回false。遇到了1就返回true（我们知道如果不是快乐数就是一定遇到了循环，因为在做操作的时候，对于高位数，会单调递减，对于三位数以内的值，最多最多只能到243，所以一定会出现循环）只不过我们知道当遇到4的时候就代表遇到了循环，可以以此为着手进行优化。</p><ol start="46"><li>Contains Duplicate II E</li></ol><p>在这里依然使用哈希，但是我哈希表的值记录上一次出现在数组的下标。然后每次出现就使用哈希表的值进行判断。</p><ol start="47"><li>Longest Consecutive Sequence N</li></ol><p>做哈希然后找哈希表上连续元素的个数。</p><h2 id="Intervals"><a href="#Intervals" class="headerlink" title="Intervals"></a>Intervals</h2><ol start="48"><li>Summary Ranges E</li></ol><p>遍历数组。记录连续的区间，记录的方法就是比较当前元素和之前元素的关系，如果满足+1，就不管，不满足+1，就意味着新的区间已经出现了。然后把记录的结果转化成字符串。</p><ol start="49"><li>Merge Intervals N</li></ol><p>将区间按照左端递增的方式进行排序，然后每次比较都是比较上一个区间的右端和下一个区间的左端，观察可合并性。如果可合并，就更改右端的值作为一个新的区间。如果不可合并就重新构建新的待合并区间。（最重要的还是排序这一步）</p><ol start="50"><li>Insert Interval N</li></ol><p>其实就是把新区间加进去，然后调用一次49。当然还可以直接遍历一遍所有区间，找到合适的位置进行合并。（找位置其实就是插入排序，因为左端的值是递增的，按照左端递增的规律进行插入就好）</p><ol start="51"><li>Minimum Number of Arrows to Burst Balloons N</li></ol><p>按照右端递增进行排序。然后取一个p&#x3D;第一个元素的右端。如果下一个元素的左端比上一个元素的右端要大，就说明不能在一起射了，就只能ans++，p&#x3D;下一个元素的右端。如果不大，说明可以一起射，就可以不用做任何操作。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol start="52"><li>Valid Parentheses E</li></ol><p>非常典型的Stack问题，括号匹配，如果是左括号，入栈，右括号就和栈顶匹配。</p><ol start="53"><li>Simplify Path N</li></ol><p>非常搞人心态的模拟题。首先用一个栈模拟文件夹路径。首先如果遇到了&#x2F;，就代表该往下或者往上走一步了，如果是一个dot，就啥也不用做，两个dot就退栈，如果都不是，就往栈里push一个新的文件夹名字。其实本题的难dot在dot的处理上，有量个变量k和p（只有dot和不是只有dot）来记录上一级的名字里面是不是只有dot，如果不是只有dot就一律按照普通的名字来。如果遇到了..word.，在遇到第一个dot的时候k++，第二个也是k++，在遇到w的时候就把k&#x3D;0，p&#x3D;1。当p&#x3D;1的时候，再遇到dot都不会k++了。而是保存起来。 反正是一个很折磨的模拟题。</p><ol start="54"><li>Min Stack N</li></ol><p>维护最小值的栈。那就维护两个栈，一个是原始的栈，一个是到目前为止最小值的栈。在push的时候，就把要push的值push到原始栈中，要push的值和最小值栈的最小值push到最小值栈中。</p><ol start="55"><li>Evaluate Reverse Polish Notation N</li></ol><p>暂时略过。</p><ol start="56"><li>Basic Calculator</li></ol><p>力扣的链表数据结构定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><ol start="57"><li>Linked List Cycle</li></ol><p>双指针。设置一个快指针和慢指针。快指针一次性走两次，慢指针一次性走一次。如果有环，那么快慢指针会碰面，如果没有环，那么快指针马上会指向NULL。（当然要注意边界条件，因为当链表为空或者链表根本只有一个元素不可能有环。）</p><ol start="58"><li>Add Two Numbers</li></ol><p>用链表模拟加，很折磨。用数组模拟竖式加法本来就很折磨，更何况链表。构建result表，首先先判断l1和l2指针是不是为空，如果为空的话就默认这是0，不为空的话该是什么是什么（后面移动l1和l2指针也是判断是否为空，为空的话就不用做操作）。然后两个指针对应内容和上一级进位相加。得到这一级加数和进位。加数插入进result表。以此类推，一直到l1和l2都是空。都是空了之后，在result表的队尾加上carry对应的节点。</p><p>这题和一般的模拟一样，首先要考虑两个加数不是同一个位的情况。然后还要考虑result表要构造头指针和尾指针。</p><ol start="59"><li>Merge Two Sorted Lists</li></ol><p>构建一个res表，然后构建三个指针。i，j，k。i指向链表1，j指向链表2。k指向res表。i比j小，k后面补个i，i往后移。反之k后面补个j，j往后移，一直到i或者j到了尾部，把剩下那个没到尾部的那个表补到k后面</p><ol start="60"><li>Copy List with Random Pointer</li></ol><p>深拷贝复制一个链表。那就构建一个老链表结点到新链表结点的映射，新链表构建完了需要完善random指针和next指针。所以之后遍历老链表。假设现在老链表遍历到了k，那么新链表为Hash(k)，那么可以写出Hash(k)-&gt;next &#x3D; Hash(k-&gt;next[老链表])[新链表]，巧妙构建了新链表之间的联系。</p><ol start="61"><li>Reverse Linked List II N</li></ol><p>详见62，62就是用了61的代码：</p><ol start="62"><li>Reverse Nodes in k-Group H</li></ol><p>这一题就是折磨，狠狠地模拟了。这里Sukuna用了一个取巧的方法，用了一个Hash，把链表结点和结点所在的位置做了一次Hash。然后写了一个调换结点的代码。说白了就是对所有的next节点进行了狠狠地替换，代码非常长，算法很好懂，就是代码非常不好写：（注意一下首部的处理）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void reverseBetween(ListNode* head, int left, int right) &#123;</span><br><span class="line">    if(!head) return;</span><br><span class="line">    if(left &gt; 1) &#123;</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[left-1]-&gt;val,maps[right]-&gt;val);</span><br><span class="line">        maps[left-1]-&gt;next = maps[right];</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[left]-&gt;val,maps[right+1]-&gt;val);</span><br><span class="line">        maps[left]-&gt;next = maps[right+1];</span><br><span class="line">        for(int i = right;i &gt; left;i--)&#123;</span><br><span class="line">            //printf(&quot;Let %d to %d\n&quot;,maps[i]-&gt;val,maps[i-1]-&gt;val);</span><br><span class="line">            maps[i]-&gt;next = maps[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //return maps[1];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[1]-&gt;val,maps[right + 1]-&gt;val);</span><br><span class="line">        maps[1]-&gt;next = maps[right + 1];</span><br><span class="line">        for(int i = right;i &gt; left;i--)&#123;</span><br><span class="line">            //printf(&quot;Let %d to %d\n&quot;,maps[i]-&gt;val,maps[i-1]-&gt;val);</span><br><span class="line">            maps[i]-&gt;next = maps[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //return maps[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后以k个为一组进行替换。最后不足k个的就直接复制过去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">       if(k==1)return head;</span><br><span class="line">       int i = 1;</span><br><span class="line">       ListNode* res = head;</span><br><span class="line">       while(res)&#123;</span><br><span class="line">           maps[i] = res;</span><br><span class="line">           res = res-&gt;next; </span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       maps[i]=nullptr;</span><br><span class="line">       i--;</span><br><span class="line">       int total = i;</span><br><span class="line">       int flag = 0;</span><br><span class="line">       for(int j = 1;j + k - 1 &lt;= total;j+=k)&#123;</span><br><span class="line">           </span><br><span class="line">           //printf(&quot;Do %d %d\n&quot;,j,j+k-1);</span><br><span class="line">           reverseBetween(head,j,j+k-1);</span><br><span class="line">           ListNode* head = maps[k];</span><br><span class="line">           while(head)&#123;</span><br><span class="line">               //printf(&quot;%d &quot;,head-&gt;val);</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode* res = flag?maps[1]:maps[k];</span><br><span class="line">           flag = 1;</span><br><span class="line">           i = 1;</span><br><span class="line">           while(res)&#123;</span><br><span class="line">               maps[i] = res;</span><br><span class="line">               res = res-&gt;next; </span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           i--;</span><br><span class="line">           //printf(&quot;\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return maps[1];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="63"><li>Remove Nth Node From End of List N</li></ol><p>链表的删除。首先计算链表的长度l，然后删除掉l - n + 1上的节点。删除的办法在C语言课上讲过了。首先找到l - n + 2上的节点，然后让l - n + 2指向l - n即可（第l个默认是NULL）这样有个好处就是，不用对空指针进行处理。</p><p>但是如果要删除第一个的话，可以直接让head &#x3D; head-&gt;next，就不能找到前一个了。</p><ol start="64"><li>Remove Duplicates from Sorted List II N</li></ol><p>构造hash表，然后构造一个新表，把hash表里所有出现次数为1的数插到新表里。</p><ol start="65"><li>Rotate List N</li></ol><p>首先要明确一点，rotate的次数 &#x3D; k % 链表的长度。然后找到最后第k个元素，记作a，第k-1个元素为a-1。然后原链表的头head和尾tail。tail-&gt;next &#x3D; head。a-1-&gt;next &#x3D; NULL。（这里要考虑边界条件，如果k&#x3D;0，就什么都不用做）</p><ol start="66"><li>Partition List N</li></ol><p>构建两个表1和2，小于x的放入1，否则放入2.如果表1或者2是空表，就直接返回表2或者表1.如果不是的话表1末尾-&gt;next&#x3D;表二开头。</p><ol start="67"><li>LRU Cache N</li></ol><p>暂且不表。</p><h2 id="Binariy-Tree"><a href="#Binariy-Tree" class="headerlink" title="Binariy Tree"></a>Binariy Tree</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ol start="68"><li>Maximum Depth of Binary Tree E</li></ol><p>求二叉树最大深度。那就是求左子树和右子树深度最大值+1。（如果是空树的话返回0）</p><ol start="69"><li>Same Tree E</li></ol><p>先判空，如果两方有一个是空，返回false，如果两方都是空，返回true。如果都不是空，就看本节点值，左子树和右子树的一致性。(p-&gt;val &#x3D;&#x3D; q-&gt;val) &amp;&amp; (isSameTree(p-&gt;left,q-&gt;left)) &amp;&amp; (isSameTree(p-&gt;right,q-&gt;right))</p><ol start="70"><li>Invert Binary Tree E</li></ol><p>如果该树为空，那就什么都不用做。如果不空，那就交换左右子树，然后对左右子树递归调用交换函数。</p><ol start="71"><li>Symmetric Tree E</li></ol><p>调用一下70，把右子树进行一次调转。然后看左子树和右子树是不是一个树（69）</p><ol start="72"><li>Construct Binary Tree from Preorder and Inorder Traversal N</li></ol><p>给定前序排列和中序排列，构建一个树。非常经典的数据结构题。如果排列只有一个，那么就直接返回即可。如果有两个及以上，那首先要知道前序排列的第一个元素，在中序排列的位置，假设为i，那么中序遍历的[0,i-1]就是左子树[i+1,n]是右子树。然后递归构造就好。</p><ol start="73"><li>Construct Binary Tree from Inorder and Postorder Traversal N</li></ol><p>还是经典，只不过从前序改成后序，还是一样的做法。只不过是后序排列的最后一个元素，在中序的位置。</p><ol start="74"><li>Populating Next Right Pointers in Each Node II N</li></ol><p>这个可以首先构造一个层次的链表数组L。然后假设一个节点r的层数为n，那么L[n]-&gt;next &#x3D; r，L[n] &#x3D; r。这样子就可以巧妙地构造一个层次表了。</p><ol start="75"><li>Flatten Binary Tree to Linked List N</li></ol><p>这个可以用一个很笨的方法，就是先前序遍历，把前序遍历的结果放在一个vector内部，然后遍历vector以分配左右子树指针的朝向。</p><ol start="76"><li>Path Sum E</li></ol><p>递归计算。假设target&#x3D;k，那就计算 左子树存在路径使路径和 &#x3D;&#x3D; k - val || 右子树存在路径使路径和 &#x3D;&#x3D; k - val。在递归的时候，有一个函数参数保留k - val的值。</p><ol start="77"><li>Sum Root to Leaf Numbers N</li></ol><p>假设root的值是k，那么这个root对应的值可以这么表示，假设父亲传来了两个数，k和p（p是引用）【这相当于编译原理里面的综合变量和传递变量】，如果没有子树了，那么就让p +&#x3D; 10k + val。如果有子树，那么令k &#x3D; 10k + val。（这样子可以把之前几层的信息传递给最后的叶节点，让叶节点做加法有依据）。可以这么理解：就是有儿子，奖池还在继续，没有儿子了，那么就把奖池兑现。</p><ol start="78"><li>Binary Tree Maximum Path Sum H</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxs = -1000000000;</span><br><span class="line">    int dfs(TreeNode* root,int isroot)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int res1 = dfs(root-&gt;left,0);</span><br><span class="line">        int res2 = dfs(root-&gt;right,0);</span><br><span class="line">        if(res1 + root-&gt;val + res2 &gt; maxs) maxs = res1 + root-&gt;val + res2;</span><br><span class="line">        if(max(res1,res2) + root-&gt;val &gt; maxs) maxs = max(res1,res2) + root-&gt;val;</span><br><span class="line">        if(root-&gt;val &gt; maxs) maxs = root-&gt;val;</span><br><span class="line">        return max(max(res1,res2),0) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        int k = dfs(root,1);</span><br><span class="line">        return max(maxs,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这个代码用得挺笨，我也不知道我搞了个isroot有啥用。不过在这里解释一下代码是怎么做的。我们假设路径是I型和V型。I型就是直勾勾往下走，V型是在某处拐了个弯。首先先记录一下左子树和右子树的I型路径的最大值，假设为l，r。那么算上本路径的I型路径最大值是$max(l,r)+val$。</p><p>那么在考虑V型路径（V型路径就是左右子树两部分构成的I型路径+自己，这样可以组成一个V型路径）：if(res1 + root-&gt;val + res2 &gt; maxs) maxs &#x3D; res1 + root-&gt;val + res2;</p><p>那么维护一个最大值来记录答案。</p><ol start="79"><li>Binary Search Tree Iterator N</li></ol><p>写一个基于二叉树的迭代器。这个非常简单，把二叉树做一次搜索，搜索结果放到stack里。</p><ol start="80"><li>Count Complete Tree Nodes E</li></ol><p>左子树节点数 + 右子树节点数 + 1</p><ol start="81"><li>Lowest Common Ancestor of a Binary Tree</li></ol><p>最近公共祖先（LCA）。首先维护一个dfs(k)，这个值代表k内部是否存在p和q（我们找公共祖先的节点）。</p><p>如果左儿子的dfs和右儿子的dfs都是true，就说明本节点是一个公共祖先。或者本节点就是p或者q，然后左儿子的dfs和右儿子的dfs有一个是true，那也可以说明本节点是一个公共祖先。</p><h2 id="Binariy-Tree-BFS"><a href="#Binariy-Tree-BFS" class="headerlink" title="Binariy Tree BFS"></a>Binariy Tree BFS</h2><ol start="82"><li>Binary Tree Right Side View N</li></ol><p>到了二叉树的层次遍历了。其实还是可以和之前一样，构造一个层次表L，然后做一次dfs(k,n)【代表第k个元素再第n层】然后令L[n] &#x3D; k即可。</p><ol start="83"><li>Average of Levels in Binary Tree E</li></ol><p>计算每一层的平均值。dfs一下，计算每一层的总和和结点数。除一下就好。</p><ol start="84"><li>Binary Tree Level Order Traversal</li></ol><p>其实还是可以和之前一样，构造一个层次表L，然后做一次dfs(k,n)【代表第k个元素再第n层】然后令L[n].push_back(k)即可。当然还可以用队列模拟层次遍历（广度优先搜索），这样做不仅要维护一个搜索队列，还要维护一个搜索队列对应的层次队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getDepth(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return max(getDepth(root-&gt;left),getDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        int p = getDepth(root);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res = *new vector&lt;vector&lt;int&gt;&gt;(p);</span><br><span class="line">        queue&lt;int&gt; l;</span><br><span class="line">        queue&lt;TreeNode*&gt; t;</span><br><span class="line">        l.push(1);</span><br><span class="line">        if(root) t.push(root);</span><br><span class="line">        while(!t.empty())&#123;</span><br><span class="line">            TreeNode* k = t.front();</span><br><span class="line">            int i = l.front();</span><br><span class="line">            t.pop();</span><br><span class="line">            l.pop();</span><br><span class="line">            res[i-1].push_back(k-&gt;val);</span><br><span class="line">            if(k-&gt;left) &#123;t.push(k-&gt;left); l.push(i+1);&#125;</span><br><span class="line">            if(k-&gt;right)&#123;t.push(k-&gt;right);l.push(i+1);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="85"><li>Binary Tree Zigzag Level Order Traversal N</li></ol><p>暂不讨论</p><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><ol start="86"><li>Minimum Absolute Difference in BST E</li></ol><p>BST的前序遍历是按照升序排序的。那就先前序遍历，存一下遍历的结果，然后遍历比较即可。</p><ol start="87"><li>Kth Smallest Element in a BST N</li></ol><p>第K小元素，那就还是存前序遍历的结果，然后取第k个元素就好。</p><ol start="88"><li>Validate Binary Search Tree N</li></ol><p>验证BST的性质，存前序遍历的结果，看是不是前面的比后面的小。</p><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><ol start="89"><li>Number of Islands N</li></ol><p>求连通分量的题目。首先找到一个1，把所有和这个连通分量一起的1全部改成0（这需要上下左右搜索，搜索的时候要注意边界条件）。再继续找1，以此循环往复。然后答案就是循环往复的次数。</p><ol start="90"><li>Surrounded Regions N</li></ol><p>这里是将被围住的O变成X，那么标记和边界的O相同连通分量的O，没被标记的O就说明被围住了，变成X。</p><ol start="91"><li>Clone Graph N</li></ol><p>深拷贝一个图。做一个老结点到新节点的Hash。然后对图做一次dfs。假设dfs(k)，那么先查询Hash(k)存在否，不存在的话赋新值，对k每一个链接的节点，做一次dfs。然后把dfs的结果加入到链接表中。如果存在，就什么也不做。最后直接返回Hash(k)。其实还是和之前链表深拷贝一样，做一个老结点到新节点的Hash。</p><ol start="92"><li>Evaluate Division N</li></ol><p>暂时不表</p><ol start="93"><li>Course Schedule N</li></ol><p>建图。节点是课程号，边是上x课之前要上y课。这里使用邻接表。用E[x]表示所有y-&gt;x。这样很好计算入度了，那就是E[x].length。取出一个入度为0的元素，从图中删掉，更新一下邻接表。如果找不到入度为0的元素，但是还是有元素存在，说明有环，返回false。所有元素都可以被处理，返回true。</p><ol start="94"><li>Course Schedule II N</li></ol><p>和之前一样，只不过把每一个入度为0的元素从图中删除的顺序记录下来而已。</p><h2 id="Graph-BFS"><a href="#Graph-BFS" class="headerlink" title="Graph BFS"></a>Graph BFS</h2><ol start="95"><li>Snakes and Ladders N</li></ol><p>暂且不表</p><ol start="96"><li>Minimum Genetic Mutation</li></ol><p>建图，顶点是可能出现的基因序列。边x-&gt;y，代表x可以变到y。建图之后然后求步数。求步数的方法可以使用bfs。构建一个结点队列和结点对应的步数队列，做dfs。把初始结点和0加入队列中做搜索，搜索到了返回答案，搜索不到（队列空了）就返回-1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; cnt;</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        char keys[4] = &#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;&#125;;        </span><br><span class="line">        for (auto &amp; w : bank) &#123;</span><br><span class="line">            cnt.emplace(w);</span><br><span class="line">        &#125;</span><br><span class="line">        if (start == end) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!cnt.count(end)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;string&gt; qu;</span><br><span class="line">        qu.emplace(start);</span><br><span class="line">        visited.emplace(start);</span><br><span class="line">        int step = 1;</span><br><span class="line">        while (!qu.empty()) &#123;</span><br><span class="line">            int sz = qu.size();</span><br><span class="line">            for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">                string curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                for (int j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">                    for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                        if (keys[k] != curr[j]) &#123;</span><br><span class="line">                            string next = curr;</span><br><span class="line">                            next[j] = keys[k];</span><br><span class="line">                            if (!visited.count(next) &amp;&amp; cnt.count(next)) &#123;</span><br><span class="line">                                if (next == end) &#123;</span><br><span class="line">                                    return step;</span><br><span class="line">                                &#125;</span><br><span class="line">                                qu.emplace(next);</span><br><span class="line">                                visited.emplace(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="97"><li>Word Ladder</li></ol><p>和96一样的bfs。暂且不表。</p><h2 id="Trie（字典树）"><a href="#Trie（字典树）" class="headerlink" title="Trie（字典树）"></a>Trie（字典树）</h2><ol start="98"><li>Implement Trie (Prefix Tree)</li></ol><p>字典树就是前缀树，通过查前缀来判断是不是有。那就构建下面的26叉树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">public:</span><br><span class="line">    char c;</span><br><span class="line">    vector&lt;TrieNode*&gt; list;</span><br><span class="line">    bool end;</span><br><span class="line">    TrieNode(char c) &#123;</span><br><span class="line">        this-&gt;c = c;</span><br><span class="line">        list = vector&lt;TrieNode*&gt;(26);</span><br><span class="line">        end = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // for root</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        list = vector&lt;TrieNode*&gt;(26);</span><br><span class="line">        end = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如说插入了单词cat，那么从字典树头开始在头的list[3]建立一个新的结点，c&#x3D;’c’，然后再在这个结点的list[1]建立一个新的结点，c&#x3D;’a’。最后在这个新的结点的list[‘t’-‘a’]建立一个新的结点，标记end&#x3D;true，就是说有一个单词在这里结束了。</p><p>然后查cat的存在性就是按照上面的逻辑去查。如果走到某一步节点为空，说明肯定不对，如果走完了前缀存在。（如果end&#x3D;true，说明这个单词也存在）这就是字典树，一个26叉树，树中有一个end标记代表有一个完整的单词的存在。</p><ol start="99"><li>Design Add and Search Words Data Structure N</li></ol><p>是98的字典树的应用。</p><ol start="100"><li>Word Search II H</li></ol><p>暂且不表。</p><h2 id="Backtracking（回溯，其实也是一种搜索）"><a href="#Backtracking（回溯，其实也是一种搜索）" class="headerlink" title="Backtracking（回溯，其实也是一种搜索）"></a>Backtracking（回溯，其实也是一种搜索）</h2><ol start="101"><li>Letter Combinations of a Phone Number N</li></ol><p>构建dfs(stage,target,str)。如果stage &#x3D;&#x3D; target，说明结束了，可以写入到res数组。如果是stage &lt; target，说明还要继续往下搜索。那么str +&#x3D; 所有有可出现的字母，然后搜索k次 dfs(stage+1,target,str’)（k&#x3D;所有可能出现的字母数量）</p><ol start="102"><li>Combination N</li></ol><p>还是构建dfs(cur,n,k,temp)cur是当前所选的位置，n是个数，k是组合的个数。如果temp.size() &#x3D;&#x3D; k，那么temp是一个正确的答案，return。然后在考虑选择cur和不选择cur，两个问题上做搜索。一个是temp.push(cur)之后在做dfs(cur+1,n,k,temp)，做完这一部分搜索回溯之后 ，然后temp.pop()在做dfs(cur+1,n,k,temp)。</p><p>这里涉及到n的问题，这里就要对不满足n的要求的做一次剪枝。如果当前temp.size()+n-cur+1 &lt; k，也就是说剩下的所有元素全放进去都不够k个的，那就趁早结束，不做了。</p><ol start="103"><li>Permutations N</li></ol><p>涉及选不选的问题。还是构建dfs(p,n,temp,tag)，用tag数组标记访问的情况。如果p &#x3D;&#x3D; n，说明搜索到了终点。如果p &lt; n，那么就在把所有tag&#x3D;0的元素放入搜索中。首先找一个tag&#x3D;0的数据，然后令tag&#x3D;1，temp加入这个数，做dfs(p+1,n,temp,tag)，结束搜索，也就是回溯后tag&#x3D;0，temp丢出来。</p><ol start="104"><li>Combination Sum N</li></ol><p>还是搜索。dfs(now,target,index)。搜索是对数组的每一项进行选取（dfs(now.push(x),target-x,index+1)）和不选取（dfs(now,target,index+1)）的搜索。搜索到的话就是target&#x3D;0。</p><p>然后可以进行剪枝，就是index &#x3D; nums.size()的话，就没必要继续做了，还有target&lt;0，也没必要继续做了。</p><ol start="105"><li>N-Queens II H</li></ol><p>太经典了，暂且不表。</p><ol start="106"><li>Generate Parentheses N</li></ol><p>还是搜索，dfs(l,r,str,n)。对l和r构成的空间组进行搜索，要么加一个(，要么加一个)。dfs(l+1,r,str+’(‘),dfs(l,r+1,str+’)’)。搜索到了就是l&#x3D;r&#x3D;n。</p><p>还可以进行剪枝。如果l &gt; n，r &gt; n，l &gt; r，都是不可以的。</p><ol start="107"><li>Word Search N</li></ol><p>找存不存在word。dfs(pos,l,n)。上下左右搜索没有被搜索过的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m;</span><br><span class="line">    int n;</span><br><span class="line">    int w;</span><br><span class="line">    int hashset[130];</span><br><span class="line">    int b(int i,int j)&#123;</span><br><span class="line">        return i*n + j;</span><br><span class="line">    &#125;</span><br><span class="line">    void p(int k,int&amp; i,int&amp; j)&#123;</span><br><span class="line">        i = k / n;</span><br><span class="line">        j = k % n;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(int k,int q,string word,vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;int&gt; tag)&#123;</span><br><span class="line">        if(q == w - 1) return true;</span><br><span class="line">        int i,j;</span><br><span class="line">        p(k,i,j);</span><br><span class="line">        if(i &gt; 0 &amp;&amp; tag[b(i-1,j)] == 0 &amp;&amp; board[i-1][j] == word[q+1])&#123;</span><br><span class="line">            tag[b(i-1,j)] = 1;</span><br><span class="line">            if(dfs(b(i-1,j),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i-1,j)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; m - 1 &amp;&amp; tag[b(i+1,j)] == 0 &amp;&amp; board[i+1][j] == word[q+1])&#123;</span><br><span class="line">            tag[b(i+1,j)] = 1;</span><br><span class="line">            if(dfs(b(i+1,j),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i+1,j)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &gt; 0 &amp;&amp; tag[b(i,j-1)] == 0 &amp;&amp; board[i][j-1] == word[q+1])&#123;</span><br><span class="line">            tag[b(i,j-1)] = 1;</span><br><span class="line">            if(dfs(b(i,j-1),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i,j-1)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &lt; n - 1 &amp;&amp; tag[b(i,j+1)] == 0 &amp;&amp; board[i][j+1] == word[q+1])&#123;</span><br><span class="line">            tag[b(i,j+1)] = 1;</span><br><span class="line">            if(dfs(b(i,j+1),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i,j+1)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        m = board.size();</span><br><span class="line">        n = board[0].size();</span><br><span class="line">        w = word.size();</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                hashset[board[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; w;i++)&#123;</span><br><span class="line">            if(--hashset[word[i]] &lt; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tag(m*n);</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                if(board[i][j] == word[0])&#123;</span><br><span class="line">                    tag[b(i,j)] = 1;</span><br><span class="line">                    if(dfs(b(i,j),0,word,board,tag)) return true;</span><br><span class="line">                    tag[b(i,j)] = 0;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样子会超时，要加一个hash的判断。比如说单词出现了N，但是matrix里一个N都没有，就可以直接剪枝了。</p><h2 id="Divide-Conquer（分治）"><a href="#Divide-Conquer（分治）" class="headerlink" title="Divide &amp; Conquer（分治）"></a>Divide &amp; Conquer（分治）</h2><ol start="108"><li>Convert Sorted Array to Binary Search Tree E</li></ol><p>有序数组转化成BST。那就做分治。设置一个constructor，输入一个有序数组返回一个BST。那就c[0,n] &#x3D; {val &#x3D; c[n &#x2F; 2],left &#x3D; c[0, n &#x2F; 2 - 1],right &#x3D; [n &#x2F; 2 + 1,n]}</p><ol start="109"><li>Sort List N</li></ol><p>为链表排序。那就先用快慢指针找到链表的中间，然后做一次分支排序。l1 &#x3D; sort(head),l2 &#x3D; sort(slow).l &#x3D; merge(l1,l2)。merge的办法是构建一个新的链表，方法参考题59。</p><ol start="110"><li>Construct Quad Tree N</li></ol><p>暂且不表</p><ol start="111"><li>Merge k Sorted Lists H</li></ol><p>假设有k个list。（力扣的测试集很弱，你按照顺序merge k次也可以过）</p><p>可以只用merge logk 级的次数。就是做分治。把merge k次的任务分解成。merge[0,k&#x2F;2]和merge[k&#x2F;2+1,k]两个子问题+对于子问题的结果进行一次merge。</p><h2 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h2><ol start="112"><li>Maximum Subarray N</li></ol><p>动态规划。dp[n] &#x3D; max[a[n],dp[n-1] + a[n]] 要么接着拿，要么重开。</p><ol start="113"><li>Maximum Sum Circular Subarray N</li></ol><p>动态规划，正常操作：dp[n] &#x3D; max[a[n],dp[n-1] + a[n]]。现在有不涉及到循环的一个最大值max(dp[n])</p><p>现在考虑涉及到循环的最大值。固定最右边的元素，找到左边的元素。首先记最大前缀和l[k] &#x3D; max(l[k-1],l1+l2+…lk)</p><p>假设右边的元素选了k个。那么左边的元素是n-k个，假设dp1[k] &#x3D; (ln+ln-1+…l_k + l[n-k])</p><p>那么答案是max(max(dp[n]),max(dp1[n]))</p><h2 id="Binary-Search（二分搜索）"><a href="#Binary-Search（二分搜索）" class="headerlink" title="Binary Search（二分搜索）"></a>Binary Search（二分搜索）</h2><ol start="114"><li>Search Insert Position E</li></ol><p>二分搜索。b(0,n-1,target). <code>if a[mid] &lt; target,l = mid + 1,ans = mid. else r = mid - 1.</code></p><ol start="115"><li>Search a 2D Matrix N</li></ol><p>把矩阵展开成向量形式进行二分搜索。</p><ol start="116"><li>Find Peak Element N</li></ol><p>如果mid比mid+1位置的元素小，说明答案很有可能是在右边。反之，说明答案很有可能在左边。然后以此为逻辑二分查找即可。</p><ol start="117"><li>Search in Rotated Sorted Array N</li></ol><p>二分查找，但是这个查找相较于其他查找不同的是，数组分成两部分[A][B]。如果nums[mid] &gt;&#x3D; nums[0]。就说明mid在A区。如果target &gt;&#x3D; nums[0] 并且 target &lt; nums[mid]。就说明target在A区mid左侧。否则target在A区mid右侧或者B区。</p><p>如果mid在B区。那么需要保证target &gt; nums[mid]并且target &lt;&#x3D; nums[n-1]才能保证target在B区mid右侧。</p><ol start="118"><li>Find First and Last Position of Element in Sorted Array N</li></ol><p>先二分查找，找到一个位置k，然后再往左往右遍历。</p><ol start="119"><li>Find Minimum in Rotated Sorted Array N</li></ol><p>在这样的旋转表里找最小值。还是一样分成两部分[A][B]，我们找B区第一个。如果nums[mid] &lt; nums[r]，则说明mid在B区。那就应该在左边找。那就令r &#x3D; mid（因为mid可能是B区第一个）。的否则l &#x3D; mid + 1.</p><ol start="120"><li>Median of Two Sorted Arrays H</li></ol><p>想不到特别好的办法，我这里用的是朴素思考。</p><h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h2><p>堆是一种有序队列。在C++的STL里有一个数据结构满足堆的要求，这里不需要我们搓轮子了。（下面叫优先队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    第三个参数是自己写的cmp函数。</span><br><span class="line">    剩下的用法就是和队列一样</span><br><span class="line">*/</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="121"><li>Kth Largest Element in an Array N</li></ol><p>放进所有元素，pop K-1个元素，取队列的top</p><ol start="122"><li>IPO H</li></ol><p>这一题就是贪心。因为确保了最小投入资本capital是递增的。所以可以先找到所有满足的最小资本数 &lt;&#x3D; 持有资本数的项目。然后按照净利润递减的顺序放入优先队列里，每一次取出优先队列的最大值作为净利润，更新持有资本 &#x3D; 之前持有资本 + 净利润。</p><ol start="123"><li>Find K Pairs with Smallest Sums</li></ol><p>找到K个最小的pair。下面给一个使用这个STL，自定义比较函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct lis &#123;</span><br><span class="line">    vector&lt;int&gt; p; // 存储的值</span><br><span class="line">    vector&lt;int&gt; w; // 相对数组的位置</span><br><span class="line">&#125;;</span><br><span class="line">struct compare &#123;</span><br><span class="line">    bool operator()(lis a, lis b) &#123; return a.p[0] + a.p[1] &gt; b.p[0] + b.p[1]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2,</span><br><span class="line">                                       int k) &#123;</span><br><span class="line">        priority_queue&lt;lis, vector&lt;lis&gt;, compare&gt; que;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        // 先把第1行的处理好</span><br><span class="line">        for (int i = 0; i &lt; min(m, k); i++) &#123;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            vector&lt;int&gt; temp1;</span><br><span class="line">            temp.push_back(nums1[i]);</span><br><span class="line">            temp.push_back(nums2[0]);</span><br><span class="line">            // printf(&quot;1 push %d %d %d %d\n&quot;, i, 0, nums1[i], nums2[0]);</span><br><span class="line">            temp1.push_back(i);</span><br><span class="line">            temp1.push_back(0);</span><br><span class="line">            lis l;</span><br><span class="line">            l.p = temp;</span><br><span class="line">            l.w = temp1;</span><br><span class="line">            que.push(l);</span><br><span class="line">        &#125;</span><br><span class="line">        // 取一个放一个。 取一个x，y。放一个x，y + 1</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p;</span><br><span class="line">        while (k-- &amp;&amp; !que.empty()) &#123;</span><br><span class="line"></span><br><span class="line">            lis r = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            vector&lt;int&gt; temp1;</span><br><span class="line">            p.push_back(r.p);</span><br><span class="line">            if (r.w[1] + 1 &lt; n) &#123;</span><br><span class="line">                temp.push_back(nums1[r.w[0]]);</span><br><span class="line">                temp.push_back(nums2[r.w[1] + 1]);</span><br><span class="line">                temp1.push_back(r.w[0]);</span><br><span class="line">                temp1.push_back(r.w[1] + 1);</span><br><span class="line">                lis l;</span><br><span class="line">                l.p = temp;</span><br><span class="line">                l.w = temp1;</span><br><span class="line">                que.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="124"><li>Find Median from Data Stream H</li></ol><p>找中位数。那就构建一个递增的优先队列和一个递减的优先队列。这两个优先队列分别记录大于中位数的数和小于中位数的数。还要保证小于中位数的数量和大于中位数的数量差不多一致。</p><h2 id="Bit-Manipulation（位运算）"><a href="#Bit-Manipulation（位运算）" class="headerlink" title="Bit Manipulation（位运算）"></a>Bit Manipulation（位运算）</h2><ol start="125"><li>Add Binary E</li></ol><p>位运算没有任何算法，就是纯模拟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        string ans;</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        reverse(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">        int n = max(a.size(), b.size()), carry = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.size() ? (a.at(i) == &#x27;1&#x27;) : 0;</span><br><span class="line">            carry += i &lt; b.size() ? (b.at(i) == &#x27;1&#x27;) : 0;</span><br><span class="line">            ans.push_back((carry % 2) ? &#x27;1&#x27; : &#x27;0&#x27;);</span><br><span class="line">            carry /= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (carry) &#123;</span><br><span class="line">            ans.push_back(&#x27;1&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="126"><li>Reverse Bits E</li></ol><p>先转化成二进制，在reverse一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        for(int i = 0;i &lt; 32;i++)&#123;</span><br><span class="line">            //printf(&quot;Push back %d\n&quot;,n%2);</span><br><span class="line">            temp.push_back(n % 2);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        uint32_t res = 0;</span><br><span class="line">        uint32_t j = 1;</span><br><span class="line">        for(int i = 31;i &gt;= 0;i--)&#123;</span><br><span class="line">            res += (j * temp[i]);</span><br><span class="line">            //printf(&quot;get %d\n&quot;,temp[i]);</span><br><span class="line">            j *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="127"><li>Number of 1 Bits E</li></ol><p>一直÷2，然后找÷2的余数为1的次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            res += (n % 2);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="128"><li>Single Number E</li></ol><p>根据a ^ a &#x3D; 0的定律。对所有数异或在一起。剩下的那个数就是唯一一个。</p><ol start="129"><li>Single Number II N</li></ol><p>这个比较搞。可以计算每一位出现1的次数。如果这一位出现1的次数 mod 3不为0，说明只出现1次的那个元素这一位为1.（看力扣题解好像可以用状态机来表示，感觉很酷）</p><ol start="130"><li>Bitwise AND of Numbers Range N</li></ol><p>脑筋急转弯。对于按位与，我们知道，与里面出现一次0，那最终的答案就一定是0了。所以我们就可以推出，答案是m和n的二进制形态的公共前缀。</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ol start="131"><li>Palindrome Number E</li></ol><p>回文数字。如果是负数就一定是错的。如果是正数的话可以构造逆数字，看看逆数字是不是和正数字一样。假设x的最后一位是k，那么令逆数字 &#x3D; 逆数字 * 10 + k。</p><ol start="132"><li>Plus One E</li></ol><p>模拟加。这里需要注意万一全部为9的情况。</p><ol start="133"><li>Factorial Trailing Zeroes N</li></ol><p>0的个数，大家知道0 是由 2 和 5构成的。2明显很充裕，那就是看项目中5因数的个数。（25算两个，125算三个，625算四个）</p><ol start="134"><li>Sqrt(x) E</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        for(int i = 1;i &lt; 46341;i++)&#123;</span><br><span class="line">            if(i * i &gt; x) return i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 46340;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="135"><li>Pow(x, n) N</li></ol><p>快速幂算法。这里直接搬题解的。基于x^n + x^n &#x3D; x^{2n}的道理快速算出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><ol start="136"><li>Max Points on a Line H</li></ol><p>暂且不表</p><h2 id="1D-DP（一维动态规划）"><a href="#1D-DP（一维动态规划）" class="headerlink" title="1D DP（一维动态规划）"></a>1D DP（一维动态规划）</h2><p>动态规划就需要把dp递推方程给出来。给出dp递推方程就好办了。</p><ol start="137"><li>Climbing Stairs E</li></ol><p>dp[n] &#x3D; dp[n-1] + dp[n-2] dp[1] &#x3D; 1,dp[2] &#x3D; 2</p><ol start="138"><li>House Robber N</li></ol><p>对于第n个要么偷，要么不偷（那就算上第n-1个）。可以写出</p><p>dp[n] &#x3D; max(dp[n-2]+a[n],dp[n-1])<br>dp[1] &#x3D; a[1]<br>dp[2] &#x3D; max(a[1],a[2])</p><ol start="139"><li>Word Break N</li></ol><p>dp[0] &#x3D; true. 如果有个单词，长度为k，单词的最后一位刚好到n处，那么dp[n] &#x3D; dp[n-k]。（这个的做法就是遍历n，然后从n往后推1，2，3….，k个字母，看构不构成单词，如果一个都构成不了，那就是false）</p><ol start="140"><li>Coin Change N</li></ol><p>首先令dp[i] &#x3D; 114514。那么dp[i] &#x3D; min(dp[i],dp[i-coin[i]]+1)</p><ol start="141"><li>Longest Increasing Subsequence N</li></ol><p>dp[0] &#x3D; 1. 对于所有a[n] &gt; a[k] dp[n] &#x3D; max(dp[n],dp[k] + 1)，然后找到最大的dp</p><p>对于dp，其递推方程的数据来源可以是一个数据（之前一个，之前两个）；也可以一组数据中最大的或者是最小的。</p><h2 id="多维DP"><a href="#多维DP" class="headerlink" title="多维DP"></a>多维DP</h2><ol start="142"><li>Triangle N</li></ol><p>dp[0][0] &#x3D; a[0][0]<br>dp[i][0] &#x3D; dp[i-1][0] + a[i][0]<br>dp[i][i] &#x3D; dp[i-1][i-1] + a[i][i]<br>dp[i][k] &#x3D; min(dp[i-1][k-1],dp[i-1][k]) + a[i][k]</p><ol start="143"><li>Minimum Path Sum N</li></ol><p>dp[0][0] &#x3D; a[0][0]<br>dp[i][0] &#x3D; a[i][0] + dp[i-1][0]<br>dp[0][i] &#x3D; a[0][i] + dp[0][i-1]<br>dp[i][j] &#x3D; min(dp[i-1][j],dp[i][j-1]) + a[i][j]</p><ol start="144"><li>Unique Paths II N</li></ol><p>dp[0][0] &#x3D; 1<br>dp[i][0] &#x3D; 有阻碍？0 : (上一个有无阻碍？0：dp[i-1][0])<br>dp[0][i] &#x3D; 有阻碍？0 : (左一个有无阻碍？0：dp[0][i-1])<br>dp[i][j] &#x3D; 有阻碍？0 : (上一个有无阻碍？0：dp[i-1][j]) + (左一个有无阻碍？0：dp[i][j-1])</p><ol start="145"><li>Longest Palindromic Substring N</li></ol><p>暂时不表</p><ol start="146"><li>Interleaving String N</li></ol><p>首先看两个字符串的长度，长度不等是不可能成立的。</p><p>dp[0][0] &#x3D; T<br>dp[i][j] &#x3D; (dp[i-1][j] &amp; s1[i-1] &#x3D; s3[i+j-1]) | (dp[i][j-1] &amp; s2[j-1] &#x3D; s3[i+j-1])</p><p>解释：dp[i][j]解释了s3[i+j-1]可以被s1[0…i-1]和s2[0…j-1]构造。</p><ol start="147"><li>Edit Distance N</li></ol><p>D[i][j]&#x3D;min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])&#x3D;1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)<br>​D[i][j]&#x3D;1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])</p><p>解释：D[i][j]是A[0..i]到B[0…j]的编辑距离。</p><ol start="148"><li>Best Time to Buy and Sell Stock III H</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p[0] = -prices[0]; // buy once</span><br><span class="line">p[1] = 0; // buy 1 sell 1</span><br><span class="line">p[2] = -prices[0]; // buy 2 sell 1</span><br><span class="line">p[3] = 0; // buy 2 sell 2</span><br><span class="line">for(int i = 1;i &lt; s;i++)&#123;</span><br><span class="line">    p[0] = max(p[0],-prices[i]); // for buy 1 when buy once?</span><br><span class="line">    p[1] = max(p[1],p[0]+prices[i]);</span><br><span class="line">    p[2] = max(p[2],p[1]-prices[i]);</span><br><span class="line">    p[3] = max(p[3],p[2]+prices[i]);</span><br><span class="line">    //printf(&quot;%d %d %d %d %d\n&quot;,prices[i],p[0],p[1],p[2],p[3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="149"><li>Best Time to Buy and Sell Stock IV H</li></ol><p>从2次到k次，很快能能找到关系，从4个状态到2k个状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1;i &lt;= k;i++)&#123;</span><br><span class="line">    p[2 * i - 1] = -prices[0];</span><br><span class="line">    p[2 * i + 0] = 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 1;j &lt; s;j++)&#123;</span><br><span class="line">    for(int i = 1;i &lt;= k;i++)&#123;</span><br><span class="line">        p[2 * i - 1] = max(p[2 * i - 1],p[2 * i - 2] - prices[j]);</span><br><span class="line">        p[2 * i + 0] = max(p[2 * i + 0],p[2 * i - 1] + prices[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="150"><li>Maximal Square</li></ol><p>dp(i,j)&#x3D;min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1（dp为为1的边长）</p><p>这里我做了个很复杂的写法，贴在这里算了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        int dp[305][305];</span><br><span class="line">        dp[0][0] = matrix[0][0] - &#x27;0&#x27;;</span><br><span class="line">        for(int i = 1;i &lt; n;i++)&#123;</span><br><span class="line">            dp[0][i] =matrix[0][i] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt; m;i++)&#123;</span><br><span class="line">            dp[i][0] = matrix[i][0] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 1;j &lt; n;j++)&#123;</span><br><span class="line">                if(matrix[i][j] == &#x27;0&#x27;)&#123;</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    int flag = 1;</span><br><span class="line">                    int n = dp[i-1][j-1];</span><br><span class="line">                    int p = 0,q = 0;</span><br><span class="line">                    for(int k = 0;k &lt; n;k++)&#123;</span><br><span class="line">                        if(matrix[i][j-1-k] == &#x27;0&#x27;)&#123;</span><br><span class="line">                            flag = 0;</span><br><span class="line">                            </span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = k + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //p = min(p+1,n);</span><br><span class="line">                    for(int k = 0;k &lt; n;k++)&#123;</span><br><span class="line">                        if(matrix[i-1-k][j] == &#x27;0&#x27;)&#123;</span><br><span class="line">                            flag = 0;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q = k + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //q = min(q+1,n);</span><br><span class="line">                    if(flag) dp[i][j] = dp[i-1][j-1] + flag;</span><br><span class="line">                    else dp[i][j] = min(p,q) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                printf(&quot;%d &quot;,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int ma = 0;</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                ma = max(ma,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ma*ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;E 是Easy N 是 Normal，也就是Medium，H 是 Hard&lt;/p&gt;
&lt;h2 id=&quot;Array-String&quot;&gt;&lt;a href=&quot;#Array-String&quot; class=&quot;headerlink&quot; title=&quot;Array &amp;#x2F; String&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="算法题" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Sukuna出的几道语文高考题</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/11/19/chinese/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/11/19/chinese/</id>
    <published>2024-11-19T04:21:34.000Z</published>
    <updated>2024-11-21T06:43:32.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="（一）史记左传杂记"><a href="#（一）史记左传杂记" class="headerlink" title="（一）史记左传杂记"></a>（一）史记左传杂记</h3><p><strong>材料一</strong>: 昔有夏之方衰也，后羿自鉏迁于穷石，因夏民以代夏政。恃其射也，不修民事而淫于原兽。弃武罗、伯困、熊髡、龙圉而用寒浞。寒浞，伯明氏之谗子弟也。伯明后寒弃之，夷羿收之，信而使之，以为己相。浞行媚于内而施赂于外，愚弄其民而虞羿于田，树之诈慝以取其国家，外内咸服。羿犹不悛，将归自田，家众杀而亨之，以食其子。其子不忍食诸，死于穷门。靡奔有鬲氏。浞因羿室，生浇及豷，恃其谗慝诈伪而不德于民。使浇用师，灭斟灌及斟寻氏。处浇于过，处豷于戈。靡自有鬲氏，收二国之烬，以灭浞而立少康。少康灭浇于过，后杼灭豷于戈。有穷由是遂亡，失人故也。  《左传·襄公·襄公四年》<br><strong>材料二</strong>：夏后帝启崩，子帝太康立。帝太康失国，昆弟五人，须于洛汭，作五子之歌。太康崩，弟中康立，是为帝中康。帝中康时，羲、和湎淫，废时乱日。胤往征之，作《胤征》。中康崩，子帝相立。帝相崩，子帝少康立。魏庄子曰：“昔有夏之衰也，后羿自鉏迁于穷石，因夏人而代夏政。恃其射也，不修人事，而信用伯明氏之谗子寒浞。浞杀羿，烹之，以食其子，子不忍食，杀于穷门。浞因羿室，生浇及豷。  《史记·夏本纪第二》<br><strong>材料三</strong>：昔有过浇杀斟灌以伐斟鄩灭夏后相后缗方娠逃出自窦归于有仍生少康焉为仍牧正惎浇能戒之浇使椒求之逃奔有虞为之庖正以除其害。虞思于是妻之以二姚，而邑诸纶，有田一成，有众一旅。能布其德，而兆其谋，以收夏众，抚其官职；使女艾谍浇，使季杼诱豷，遂灭过、戈，复禹之绩。祀夏配天，不失旧物。今吴不如过，而越大于少康，或将丰之，不亦难乎？勾践能亲而务施，施不失人，亲不弃劳，与我同壤而世为仇雠。于是乎克而弗取，将又存之，违天而长寇雠，后虽悔之，不可食已。姬之衰也，日可俟也。介在蛮夷，而长寇雠，以是求伯，必不行矣。   《左传·哀公·哀公元年》<br><strong>材料四</strong>：帝降夷羿，革孽夏民。胡射夫河伯，而妻彼雒嫔？冯珧利决，封豨是射。何献蒸肉之膏，而后帝不若？浞娶纯狐，眩妻爰谋。何羿之射革，而交吞揆之？ 《楚辞·天问》<br><strong>材料五</strong>：惟浇在户，何求于嫂？何少康逐犬，而颠陨厥首？女歧缝裳，而馆同爰止。何颠易厥首，而亲以逢殆？《楚辞·天问》</p><p>1、对文中划线部分的断句，正确的是（    ）(3分)<br>A、昔有过浇杀斟灌以伐斟鄩&#x2F;灭夏后&#x2F;相后缗方娠&#x2F;逃出自窦&#x2F;归于有仍&#x2F;生少康焉&#x2F;为仍牧正惎&#x2F;浇能戒之&#x2F;浇使椒求之&#x2F;逃奔有虞&#x2F;为之庖正&#x2F;以除其害<br>B、昔有过浇杀斟灌以伐斟鄩&#x2F;灭夏后相&#x2F;后缗方娠&#x2F;逃出自窦&#x2F;归于有仍&#x2F;生少康焉&#x2F;为仍牧正惎&#x2F;浇能戒之&#x2F;浇使椒求之&#x2F;逃奔有虞&#x2F;为之庖正&#x2F;以除其害<br>C、昔有过浇杀斟灌以伐斟鄩&#x2F;灭夏后&#x2F;相后缗方娠&#x2F;逃出自窦&#x2F;归于有仍&#x2F;生少康焉&#x2F;为仍牧正&#x2F;惎浇能戒之&#x2F;浇使椒求之&#x2F;逃奔有虞&#x2F;为之庖正&#x2F;以除其害<br>D、昔有过浇杀斟灌以伐斟鄩&#x2F;灭夏后相&#x2F;后缗方娠&#x2F;逃出自窦&#x2F;归于有仍&#x2F;生少康焉&#x2F;为仍牧正&#x2F;惎浇能戒之&#x2F;浇使椒求之&#x2F;逃奔有虞&#x2F;为之庖正&#x2F;以除其害<br>2、对文中文化常识的解释，正确的是（     ）（3分）<br>A、材料二出自于《史记·夏本纪》，史记是由西汉史学家司马迁所著，是中国古代历史上第一部纪传体断代史。<br>B、材料一和材料三选自《左传》，左传别名左氏春秋，是战国时期史学家左丘明所著的编年体史书，汉朝以后多称《左传》。与《公羊传》《谷梁传》合称“春秋三传”。<br>C、寇雠指仇视，不和谐的见解，最早出自于《孟子·离娄下》：“君之视臣如土芥，则臣视君如寇雠。”雠本来的意思是回答，应答，雠祚指的是在酒宴上宾主互相敬酒。<br>D、楚辞是由楚国文学家屈原所作的诗歌，全诗充满了现实主义的味道，讲述了屈原对世事不公的叹惋。<br>3、结合诗歌内容分析一下,夷羿是怎么被消灭的?（3分）<br>A、被寒浞杀死了.<br>B、自然死亡.<br>C、被流放然后被饿死了.<br>D、被有穷国的使节杀死了.<br>4、将下面句子翻译成现代汉语。（8分）<br>（1）寒浞，伯明氏之谗子弟也。<br>（2）勾践能亲而务施，施不失人，亲不弃劳，与我同壤而世为仇雠。<br>5、《楚辞·天问》通篇是对天地、自然和人世等一切事物现象的发问，内容奇绝，显示出作者沉潜多思、思想活跃、想象丰富的个性，表现出超卓非凡的学识和惊人的艺术才华，被誉为是“千古万古至奇之作”。可以结合屈原生平和材料思考一下为什么屈原要描述这一段夏朝历史?（3分）</p><p>答案：DCA</p><h3 id="（二）数字计算机的历史介绍"><a href="#（二）数字计算机的历史介绍" class="headerlink" title="（二）数字计算机的历史介绍"></a>（二）数字计算机的历史介绍</h3><p><strong>材料一</strong>:数字计算机产生后，计算技术（即计算机设计技术与程序设计技术）和有关计算机的理论研究开始得到发展。这方面构成了所说的理论计算机科学。至于图灵机理论，则可以看作是这一学科形成前的阶段。至于“计算机科学”一词则到60年代初才出现，此后各国始在大学中设置计算机科学系。计算机科学是一门年轻的科学，它究竟包括哪些内容,还没有一致公认的看法。一般认为,计算机科学主要包括理论计算机科学、计算机系统结构、软件工程的一部分和人工智能。理论计算机科学是在20世纪30年代发展起来的。40年代机电的与电子的计算机出现后，关于现实计算机及其程序的数学模型性质的研究以及计算复杂性(早期称作计算难度)的研究迅速发展起来，形成自动机论、形式语言理论、程序设计理论、算法设计与分析和计算复杂性理论几个领域。<br>50年代以来，计算机的性能在计算速度和编址空间方面已提高了几个数量级。但大部分是通过元件更新而获得的。在系统结构方面基本上仍是属于40年代后期形成的存储程序型，即所谓诺伊曼型机器。这种结构的主要特点是它属于控制流型。在这种结构中，一项计算先做什么后做什么是事先确定了的，程序中指令的顺序是事先确定了的。为了在计算机的性能方面取得大的进展，需要突破这种旧的形式。计算机系统结构方面的重要课题之一，是探索非诺伊曼型机器的设计思想。在非诺伊曼型机器中，有一种是70年代初提出的数据流机器（又名数据驱动机器）。美国、苏联和英国都已制成这种机器。这种机器的特点是，在一项计算中先做什么后做什么不是事先确定，所执行的指令是动态排序的。排序的原则是操作数已准备就绪的先做，因而称作数据驱动机器。这种类型的机器更便于实现并行计算。软件工程 程序设计在相当长的时间内是一种类似“手艺”而不是类似现代工程的技术。<br><strong>材料二</strong>:上世纪六十年代，基于超大规模集成电路的微处理器还未出现，计算机系统就是一个大型的中央处理器，体积大，计算速度慢。当时，我国使用的计算机系统都是自主设计，且同国际水平差距不大，标志性产品包括晶体管109 机（1965 年 6月研制）、小规模集成电路 106 机（1968年研制）等。上世纪70年代以后，美国大规模集成电路尤 其是超大规模集成电路快速发展起来，以英特尔 4004 为标志，美国真正意义上的微处理器面世， CPU 正式进入商用时代，此后按照摩尔定律持续快速演进，英特尔此后也一直统治着全球桌面和高 性能计算市场。相反我国受限于国内经济条件、国际技术封锁等原因，期间虽然研制出了基于大规模集成电路的第三代计算机系统——专用 77 型微机，但丧失了第四代计算机系统（基于超大规模集成电路）的研究能力。从“七五”开始，一直到“九五”，国家对国产 CPU 的支持力度明显下降， 主要科研支持计划都未将其列入。直接的后果是，上世纪 90 年代中期，国内大量处理器研究单位关闭，人员大批流失，大学也很少设置硬件专业，计算机公司变成组装厂，CPU 设计能力基本丧失。<br><strong>材料三</strong>:处理器是计算机系统的核心和大脑，也是国家大宗战略物资，系统复杂研发难度高。我国 CPU研发起步较晚，并且在某些企业造假的骗科研资金的情况下，发展较为坎坷，步入正轨是在“十二五”之后。在国家集成电路产业政策和大基金投资等多重措施支持下，一大批国产 CPU 设计单位成长起来，产品覆盖了高性能计算、桌面、移动和嵌入式等主要应用场景。但高端芯片确实无法与美国相抗衡，不过好在产品线相对丰富，该有的产品种类应用具有，只是性能上还略有差距。<br>全球 CPU 指令集架构有两类——复杂指令集（X86）和精简指令集（以 ARM、MIPS、POWER等为代表）。其中，复杂指令集（CISC）通过增加可实现复杂功能的指令和多种灵活的编址方式，来提高程序的运行速度。但直接后果就是需要对不等长的指令进行分割处理，造成一些不必要的等待，效率较低，对硬件集成度、工艺、功耗均非常高。精简指令集（RISC）采用的等长的指令，可以将一条指令分割成若干个进程或者线程，交给不同的处理器并行处理，效率高，硬件集成度要求不高，工艺简单而且成本低。<br>对于CPU设计有80%的时间运行20%的指令这一说,根据软硬协同的系统观念,我们可以用另外一种手法解决另外80%的指令<br><strong>材料四</strong>:操作系统(Operating System,简称OS)是承载各种信息设备和软件应用运行的基础平台,是配置在计算机硬件上的第一层软件。它是一组控制和管理计算机硬件和软件资源,合理地对各类作业进行调度以及方便用户的程序集合。操作系统是用来对整个计算机系统的硬件和软件资源进行配置和管理,控制所有应用程序运行,提供人机交互的平台,是计算机工作的灵魂,CPU、数据库、办公软件、中间件、应用软件等需要与操作系统深度适配。<br>从产业格局上看,通用型OS已被国际巨头占据先发优势,加快构建壁垒。在桌面OS领域,微软依旧占据着全球领先地位。截至2017年12月,全球桌面OS市场的绝大多数份额都被微软Windows所占据,非Windows产品市场份额总和仅为11.12%。在移动终端OS领域,截至2017年第一季度,谷歌主导的安卓的全球市场份额已经达到了85%,谷歌和苹果两家总市场份额达到99.79%,移动OS市场已经呈现出“一大一小”的基本格局,相较于2010年,市场的集中度大幅提升。此外,微软、谷歌等国际巨头在OS领域的研发投入力度持续加大,通过不断的推进新产品的研发来确保自身在市场竞争中的优势地位,旧产品市场份额下降的同时新产品的市场份额会快速上升,从而使企业系列产品的市场份额总和保持稳定,持续的技术研发和产品更新构建了较为厚实的市场竞争壁垒,市场新进者基本无法撼动原有的市场格局。<br>从创新模式上看,开源社区建设受到普遍重视,基于开源模式的产业生态系统渐成气候。开源模式一直以来都是OS领域技术创新的重要途径,微软的WindowsOS和苹果的MacOS其前身都是开源OS。当前,在桌面操作系统领域,基于开源Linux的操作系统还占据了约3%的全球市场份额,在工控OS和服务器OS领域,这一比例更高。在全球Top500的超级计算机上,有99%的计算机使用的是Linux操作系统,主要有Ubuntu,Arch,Debian等都是属于Linux操作系统,同时,在大型商业企业如谷歌、IBM、Facebook以及国家安全相关的服务器上,Linux操作系统也是主流选择。此外,开源Linux也极大推动了新型操作系统的研发和应用,例如谷歌的安卓OS就是以Linux为核心的,全球当前主要的物理网操作系统也都选用了Linux内核。<br>1、关于处理器设计的相关说法中,错误的是:（3分）<br>A、处理器的规模并不是一成不变的,根据摩尔定律,电子工艺的进步会影响处理器的工艺和性能.<br>B、复杂指令集比精简指令集难实现,具体来说CISC指令长度是不固定的,RISC指令长度是固定的.<br>C、我国在早期还能跟上世界发展的步伐,但是在第三代计算机系统中已经完全丧失了设计的能力,眼睁睁看着美国公司发展.<br>D、RISC指令集通过增加指令集并行程度降低指令的设计难度,可以把一条CISC复杂指令进行切割交付给多个CPU核执行.<br>2、关于操作系统的相关说法中,错误的是:（3分）<br>A、操作系统本质上还是一款软件,是一款极其贴合硬件的软件,操作系统有很多直接控制和管理硬件资源的功能.<br>B、操作系统最重要的就是用户接口,操作系统要尽力地去满足用户的需求,对于用户的需求,操作系统要安排与分配硬件.<br>C、Linux操作系统是一类操作系统的集合,这种操作系统的源代码是开放在开源平台上的,因此Linux操作系统并不安全.<br>D、Windows操作系统占据了PC机的操作系统的市场份额.谷歌和苹果瓜分了移动应用的市场份额,国产操作系统进入市场任重而道远.<br>3、关于文章的相关说法中,错误的是:（3分）<br>A、对于剩下的80%指令,我们可以使用软件的方法来完善剩下的指令,用硬件可能成本太高.所以说可以用软件或者是微指令的方法设计.<br>B、计算机主要是由控制流和数据流组成,一般来说控制流机器比数据流机器更加难制造.数据流的计算机更改了冯诺伊曼的结构,更加先进.<br>C、计算机的领域可以由理论部分和实践部分,对于计算机理论的研究同样重要.包括程序设计思想,算法复杂性理论等等.<br>D、计算机体系结构也是计算机科学需要讨论的重要内容,在硬件红利结束之后,对于体系结构的研究尤为重要,最大的体系结构的变革就是数据流型计算机.<br>4、（5分）综合全文,请分析一下当前体系结构研究两大方面的市场现状.<br>5、（5分）面对美国等西方国家对我国卡脖子的现象,我们可以从哪些方面冲破对我国的体系结构的限制?</p><p>答案：<br>1、C 是第四代计算机开始丧失了自主的能力.<br>2、C 文章有提到Linux系统能为国家安全领域提供服务.而且只通过开源就判断安全性属于逻辑牵强.<br>3、B 数据流机器比控制流更难造.<br>4、首先第一点、我们得知道两大市场是什么.材料一到三介绍CPU的情况,材料四介绍操作系统的情况,答对这一点可以获得2分.<br>总体市场现状:CPU的情况就是我国的低端芯片的设计卓有成就,但是高端芯片设计出现问题,在第四代计算机过后,CPU的设计落后国际水平,对于国际的大趋势,总体有两个大类,一个是RISC,一个是CISC.操作系统的现状:一大一小的格局,开源市场的崛起(3分)<br>5、材料一揭示我们可以发展理论的计算机科学与技术.材料二揭示我们需要国家给予支持.材料三揭示科研人员要守规矩,不能骗补贴,还要发展高端的芯片.材料四揭示我们还需要大力发展操作系统,尤其参加开源的开发.(上面的4点答对2点可以获得3分)<br>自己再补充可以酌情给2分.</p><h3 id="（三）计算机网络探索"><a href="#（三）计算机网络探索" class="headerlink" title="（三）计算机网络探索"></a>（三）计算机网络探索</h3><p>Definition(定义):计算机网络也称计算机通信网。关于计算机网络的最简单定义是：一些相互连接的、以共享资源为目的的、自治的计算机的集合。若按此定义，则早期的面向终端的网络都不能算是计算机网络，而只能称为联机系统（因为那时的许多终端不能算是自治的计算机）。但随着硬件价格的下降，许多终端都具有一定的智能，因而“终端”和“自治的计算机”逐渐失去了严格的界限。若用微型计算机作为终端使用，按上述定义，则早期的那种面向终端的网络也可称为计算机网络。<br>另外，从逻辑功能上看，计算机网络是以传输信息为基础目的，用通信线路将多个计算机连接起来的计算机系统的集合，一个计算机网络组成包括传输介质和通信设备。<br>从用户角度看，计算机网络是这样定义的：存在着一个能为用户自动管理的网络操作系统。由它调用完成用户所调用的资源，而整个网络像一个大的计算机系统一样，对用户是透明的。<br>Development(发展):自从计算机网络出现以后，它的发展速度与应用的广泛程度十分惊人。纵观计算机网络的发展，其大致经历了以下四个阶段：<br>诞生阶段:20世纪60年代中期之前的第一代计算机网络是以单个计算机为中心的远程联机系统，典型应用是由一台计算机和全美范围内2000多个终端组成的飞机订票系统，终端是一台计算机的外围设备，包括显示器和键盘，无CPU和内存。随着远程终端的增多，在主机前增加了前端机(FEP)。当时，人们把计算机网络定义为“以传输信息为目的而连接起来，实现远程信息处理或进一步达到资源共享的系统”，这样的通信系统已具备网络的雏形。<br>形成阶段:20世纪60年代中期至70年代的第二代计算机网络是以多个主机通过通信线路互联起来，为用户提供服务，兴起于60年代后期，典型代表是美国国防部高级研究计划局协助开发的ARPANET。主机之间不是直接用线路相连，而是由接口报文处理机(IMP)转接后互联的。IMP和它们之间互联的通信线路一起负责主机间的通信任务，构成了通信子网。通信子网互联的主机负责运行程序，提供资源共享，组成资源子网。这个时期，网络概念为“以能够相互共享资源为目的互联起来的具有独立功能的计算机之集合体”，形成了计算机网络的基本概念。<br>互联互通阶段:20世纪70年代末至90年代的第三代计算机网络是具有统一的网络体系结构并遵守国际标准的开放式和标准化的网络。ARPANET兴起后，计算机网络发展迅猛，各大计算机公司相继推出自己的网络体系结构及实现这些结构的软硬件产品。由于没有统一的标准，不同厂商的产品之间互联很困难，人们迫切需要一种开放性的标准化实用网络环境，这样应运而生了两种国际通用的最重要的体系结构，即TCP&#x2F;IP体系结构和国际标准化组织的OSI体系结构。<br>高速网络技术阶段:20世纪90年代至今的第四代计算机网络，由于局域网技术发展成熟，出现光纤及高速网络技术，整个网络就像一个对用户透明的大的计算机系统，发展为以因特网( Internet)为代表的互联网。<br>Ability(功能):数据通信:数据通信是计算机网络的最主要的功能之一。数据通信是依照一定的通信协议，利用数据传输技术在两个终端之间传递数据信息的一种通信方式和通信业务。它可实现计算机和计算机、计算机和终端以及终端与终端之间的数据信息传递，是继电报、电话业务之后的第三种最大的通信业务。数据通信中传递的信息均以二进制数据形式来表现，数据通信的另一个特点是总是与远程信息处理相联系，是包括科学计算、过程控制、信息检索等内容的广义的信息处理。<br>资源共享:资源共享是人们建立计算机网络的主要目的之一。计算机资源包括硬件资源、软件资源和数据资源。硬件资源的共享可以提高设备的利用率，避免设备的重复投资，如利用计算机网络建立网络打印机；软件资源和数据资源的共享可以充分利用已有的信息资源，减少软件开发过程中的劳动，避免大型数据库的重复建设。<br>集中管理:计算机网络技术的发展和应用，已使得现代的办公手段、经营管理等发生了变化。目前，已经有了许多管理信息系统、办公自动化系统等，通过这些系统可以实现日常工作的集中管理，提高工作效率，增加经济效益。<br>实现分布式处理:网络技术的发展，使得分布式计算成为可能。对于大型的课题，可以分为许许多多小题目，由不同的计算机分别完成，然后再集中起来，解决问题。<br>负荷均衡:负荷均衡是指工作被均匀的分配给网络上的各台计算机系统。网络控制中心负责分配和检测，当某台计算机负荷过重时，系统会自动转移负荷到较轻的计算机系统去处理。<br>1、关于文章内容,下面说法正确的是:(3分)<br>A、微型计算机可以当作终端看待,所以终端和自治的计算机的差异随着时代的变迁变得越来越少.<br>B、第一代计算机网络系统主要为全美国的订票系统提供服务,由一个主要的计算机和2000个次要的计算机组成的系统.<br>C、第三代计算机网络系统中,由于科技和技术的飞速发展,网络的软硬件条件变得越来越好,因为软硬件的发展导致统一的TCP&#x2F;IP模型出现.<br>D、计算机网络的数据通信要求永远是和远程信息处理相关,这些数据会以“二进制”的形式进行传输.<br>2、关于文章内容,下面说法错误的是(3分)<br>A、对于不同的角度,计算机网络的定义呈现出不同的特征,对于逻辑构成,计算机网络由传输介质和通讯主体组成.<br>B、在第二代网络之后,由美国国防部研发的ARPANET兴起之后,逐渐出现了“子网”的说法,这个技术为数据共享和安全性提供了土壤.<br>C、计算机网络对用户是“透明”的,透明的意思就是用户不需要了解计算机网络的内部构造就可以使用计算机网络,这在一定程度上为用户提供了便捷.<br>D、计算机网络可以充当一个叫做调解员的身份,当一个计算机的任务比较少,它可以主动从任务比较多的计算机转移任务.<br>3、对于计算机网络的“分布式处理系统”,合理的推测有几个?(3分)<br>I、分布式处理有一个主机,这个主机可以负责调度不同的计算机执行不同的子任务.<br>II、分布式处理的计算机网络系统可以完成数据通信、负载均衡的功能.<br>III、分布式处理的计算机需要网络作为纽带,这些计算机往往在物理上是分离的.<br>A、I、II、III            B、I、II               C、I                  D、II、III<br>4、请用你自己的话解释一下计算机网络发展的4个流程的特点.(5分)<br>5、请结合计算机网络的逻辑层面和用户层面定义分析为什么局域网是一个计算机网络.(5分)<br>局域网:通常我们常见的“LAN”就是指局域网，这是我们最常见、应用最广的一种网络。局域网随着整个计算机网络技术的发展和提高得到充分的应用和普及，几乎每个单位都有自己的局域网，有的甚至家庭中都有自己的小型局域网。很明显，所谓局域网，那就是在局部地区范围内的网络，它所覆盖的地区范围较小。局域网在计算机数量配置上没有太多的限制，少的可以只有两台，多的可达几百台。一般来说在企业局域网中，工作站的数量在几十到两百台次左右。在网络所涉及的地理距离上一般来说可以是几米至10公里以内。局域网一般位于一个建筑物或一个单位内，不存在寻径问题，不包括网络层的应用。</p><p>答案：</p><p>1、D A选项因果反了,B选项“次要的计算机”错误,C选项,原文的推理是,软硬件的条件变好导致出现了标准不匹配的问题才导致TCP&#x2F;IP的出现,漏了一个推导.<br>2、D 文章只说多的可以转移到少的,没说少的可以主动转移到多的.<br>3、B 物理上是分离的不一定对.</p><h3 id="（四）史记-孝文本纪"><a href="#（四）史记-孝文本纪" class="headerlink" title="（四）史记-孝文本纪"></a>（四）史记-孝文本纪</h3><p>孝文帝从代来，即位二十三年，宫室苑囿狗马服御无所增益，有不便，辄弛以利民。 尝欲作露台，召匠计之，直百金。上曰：“百金中民十家之产，吾奉先帝宫室。常恐羞之，何以台为!”上常衣绨衣①，所幸慎夫人，今衣不得曳地，帏帐不得文绣，以示敦朴，为天下先。治霸陵皆以瓦器，不得以金银铜锡为饰，不治坟，欲为省，毋烦民。南越王尉佗自立为武帝，然上召贵尉佗兄弟，以德报之，佗遂去帝称臣。与匈奴和亲，匈奴背约入盗，然令边备守，不发兵深入，恶烦苦百姓。吴王诈病不朝，就赐几杖。群臣如袁盎等称说虽切。常假借用之。群臣如张武等受赂遗金钱，觉，上乃发御府金钱赐之，以愧其心，弗下吏。专务以德化民，是以海内殷富，兴于礼义。<br>　　后七年六月己亥，帝崩于未央宫。遗诏曰：“朕闻盖天下万物之萌生，糜不有死。死者天地之理。物之自然者，奚可甚哀。当今之时，世咸嘉生而恶死，厚葬以破业，重服以伤生，吾甚不取。且朕既不德，无以佐百姓;今崩，又使重服久临，以离寒暑之数，哀人之父子。伤长幼之志，损其饮食，绝鬼神之祭祀，以重吾不德也，谓天下何!朕获保宗庙，以眇眇之身托于天下君王之上，二十有余年矣。赖天地之灵，社稷之福，方内安宁，靡有兵革。朕既不敏，常畏过行，以羞先帝之遗德;维年之久长，惧于不终。今乃幸以天年，得复供养于高庙，朕之不明与。嘉之，其奚哀悲之有!”<br>　　孝景皇帝元年十月，制诏御史：“孝文皇帝临天下，通关梁，不异远方。除诽谤，去肉刑，赏赐长老，收恤孤独，以育群生。减嗜欲，不受献，不私其利也。罪人不帑，不诛无罪。除宫刑，出美人，重绝人之世。朕既不敏，不能识。此皆上古之所不及，而孝文皇帝亲行之。德厚侔天地，利泽施四海，靡不获福焉。”<br>　　太史公曰：孔子言“必世②然后仁。善人之治国百年，亦可胜残去杀”。诚哉是言汉兴至孝文四十有余载德至盛也廪廪③乡改④正服⑤封禅矣谦让未成于今。呜呼，岂不仁哉!<br>　　(选自《史记·孝文帝本纪》，有删改)<br>　　【注】①绨衣：质地粗厚的丝织衣服。②世：古代以十年为一世。③廪廪：犹庶几，渐进。④乡改：更改历法。⑤正服：更改服色。<br>1、（3分）对文中画波浪线部分的断句，正确的一项是<br>A、诚哉&#x2F;是言汉兴&#x2F;至孝文四十有余&#x2F;载德至盛也&#x2F;廪廪乡改正服封禅矣&#x2F;谦让未成于今<br>B、诚哉是言&#x2F;汉兴&#x2F;至孝文四十有余载&#x2F;德至盛也&#x2F;廪廪乡改正服封禅矣&#x2F;谦让未成于今<br>C、诚哉是言&#x2F;汉兴至孝文四十有余&#x2F;载德至盛也&#x2F;廪廪乡改正服&#x2F;封禅矣谦让&#x2F;未成于今<br>D、诚哉是言&#x2F;汉兴&#x2F;至孝文四十有余载&#x2F;德至盛也&#x2F;廪廪乡改正服&#x2F;封禅矣谦让&#x2F;未成于今<br>2、（3分）下面对原文有关内容的分析和概括，不正确的一项是<br>A、文帝注重休养生息，反对大兴土木。他打算建造一座高台，召来工匠一计算，造价要上百斤黄金，就自动停止了。<br>B、文帝率先垂范，以身作则。他平时穿的是质地粗厚的丝织衣服，甚至严格限制慎夫人穿衣用度，为民做节俭的榜样。<br>C、孝文皇帝有着比较进步的生死观，他认为死是事物的自然归宿;对侍丧葬也主张节俭，反对厚葬等奢侈攀比的习俗。<br>D、孝文皇帝功德显赫，恩惠遍及四海。他去世后，后人给予他很高的历史评价，没有哪个皇帝堪与他比，无溢美之词。<br>3、（3分）下面对文化常识的说法中，不正确的是<br>A、孝文帝自“代”来的代指的是政变之后孝文帝把持朝政的意思.<br>B、帝崩于未央宫,皇帝死亡往往使用“崩”这个字,对于皇后的死亡,我们可以使用“薨”.<br>C、朕获保宗庙,这句话可以代表汉孝文帝获得了庙号,在汉朝不是所有皇帝都有庙号,汉文帝是“太宗”.<br>D、制诏御史,御史是汉朝的监察官,自秦朝开始,御史专门作为监察性质的官职,负责监察朝廷官吏.<br>4、把文言文阅读材料中画横线的句子翻译成现代汉语。(8分)<br>(1)百金中民十家之产，吾奉先帝宫室，常恐羞之，何以台为! (4分)<br>(2)今乃幸以天年，得复供养于高庙，朕之不明与，嘉之，其奚哀悲之有!(4分)<br>5、（3分）太史公评价这位帝王呜呼，岂不仁哉,那么这个帝王有哪些仁的事迹?</p><p>答案：<br>1、B<br>2、D（D项中“没有哪个皇帝堪与他比”错，应为“没有哪个人不曾得到他的好处”。）<br>3、A 代不是代替的意思.<br>4、（1）百斤黄金相当于十户中等人家的产业，我承受了先帝留下来的宫室，时常担心有辱于先帝，还建造高台干什么呢？（判断句、奉、羞、“何以台为”，每点1分）（2）如今没想到能侥幸享尽天年，被供奉在高庙里享受祭祀，我如此不贤明，却能有这样的结果，我认为就很好，还有什么可悲哀的呢！<br>5、1)从政 23 年,奢侈品没有变多 2)和平解决南越王的叛乱 3)和平解决匈奴问题 4) 善待吴王 5) 善待犯错的官员 6) 在遗诏中要求丧失从简.(回答3点得3分)</p><h3 id="（五）恐怖（莫泊桑）"><a href="#（五）恐怖（莫泊桑）" class="headerlink" title="（五）恐怖（莫泊桑）"></a>（五）恐怖（莫泊桑）</h3><p>那是在一八七○年战争期间①。我们穿过鲁昂，向奥德梅尔桥后撒。我们的部队有两千人，这两千人溃不成军，士气低落，精疲力竭，正赶赴勒阿弗尔整编。<br>白雪覆盖着大地。黑夜来临。我们从头天起就没有吃东西。普鲁士人离我们不远，所以我们迅速逃跑。<br>诺曼底的田野一片惨白，偶尔露出农庄四周的树影；田野在黑色天空下伸向远方，显得沉重而阴森。<br>在晦暗的暮色中，只听见一片含混不清的、拖沓而嘈杂的声音，仿佛是畜群在迁徙；在这片无穷无尽的踏步声中还夹杂着饭盒和军刀模糊的碰撞声。士兵们弯着腰，弓着背，肮脏不堪,甚至衣衫褴褛；他们在雪地上拖着疲惫的步子，艰难地往前走，往前赶。<br>那天夜里严寒刺骨。我们的手与钢枪托粘到了一起。我常常看见一个士兵脱下使他难受的靴子赤脚赶路，于是每个脚印都带着血。他走了一会儿便坐下休息几分钟，可再也没有站起来。每个坐着的人都是死人。<br>我们后面留下了多少可怜的士兵呀！他们精疲力竭，想让僵硬的两腿歇一歇再继续赶路，可是，等他们一停下来，等他们那几乎停滞的血液不再在冻僵的肉体内流动，一种无法抗拒的麻痹便使他们动弹不了，将他们钉在地上，合上他们的眼晴，不出一秒钟便使这个超负荷的人体机器完全瘫痪。他们的前额垂向膝盖，慢慢下沉，但并没有完全倒下，因为他们的腰和四肢一动不动，像木头一样硬，无法弯曲也无法挺直。<br>在黑夜，在雪地，在这片寒冷和致命的田野上，我们这些比较强壮的人仍然继续走着；我们连骨髓都冻僵了，凭着运动惯性往前走；我们感到悲伤、气馁、绝望，特别可怕的是，我们感到被遗弃，感到世界末日来临，感到死亡，感到虚无。<br>我看见两名宪兵抓着一个小个子的古怪男人的胳膊，他年岁很大，没有胡子，模样确实古怪。<br>宪兵认为抓住了一名间谍，便来找军官。<br>“间谍”这个词很快便在掉队的士兵中间传开了，他们在间谍四周围拢来。一个声音喊道：“枪毙他！”于是那些疲惫至极、勉强倚着步枪站立的士兵们突然感到一阵疯狂的、兽性的愤怒，这种愤怒往往驱使群众进行屠杀。我想说话，当时我是营长，可是谁也不承认长官，连我也可能被他们枪毙。<br>一个宪兵说：“他跟踪我们三天了。他到处打听炮兵的情况。”<br>我试着盘问这个人：“你是什么人？你想干什么？你为什么要跟着部队？”<br>那人用无法听懂的土话嘟囔了几个字。<br>这的确是个怪人，肩膀窄窄的，眼神狡猾，在我面前惶惑不安，以致我对他是间谍不再怀疑。他看上去年龄很大，身体虚弱。他偷偷打量我，神色谦卑、愚蠢和狡诈。<br>人们在我周围喊道：“让他靠墙站！靠墙站！”<br>我对宪兵说：“你们负责俘虏？……”<br>话还没有说完,士兵们便一拥而上，将我推倒,顷刻之间愤怒的人群抓住那个人，将他打翻在地，拖到路边，扔到树旁。他摔在雪地上奄奄一息。<br>他立刻被枪毙了。士兵们朝他射击，重新装上了子弹，再次射击，像野人一样疯狂。他们拥挤着轮流从尸体前走过，向尸体射击，就像人们列队从棺材前面走过抛洒圣水一样。<br>突然一声呼喊：“普鲁士人！普鲁士人！”<br>于是士兵们狂乱地溃逃，巨大的喧嚣声响彻四野。<br>流浪汉的枪击声引起了恐慌，就连开枪者本人也吓坏了，他们不知道恐慌来源于自己，慌忙逃走，消失在黑暗中。<br>我独自呆在尸体前，那两个宪兵也恪尽职守地呆在那里。<br>他们抬起这个被打得稀烂的、血肉模糊的身体。<br>“搜搜他。”我说。<br>我掏出衣袋里的那盒火柴递过去。一个宪兵为另一个宪兵照明，我站在他们两人中间。<br>摆弄尸体的宪兵说：“他穿蓝罩衣、白衬衫、长裤、鞋。”<br>第一根火柴——熄灭了，又点燃第二根。宪兵在翻死者的衣袋，继续说：“一把角质小刀、一条方格手帕、一个鼻烟盒、一小截细绳、一块面包。”<br>第二根火柴也熄灭了，又点燃第三根。宪兵在尸体上摸了很久，大声说：“就是这些。”<br>我说：“把他的衣服脱光。在贴肉的地方也许能找到什么。”<br>为了让两个宪兵同时行动，我亲自划火柴为他们照明。在转瞬即逝的急速的微光下，他们从他身上脱下一件件衣服，将这个还有热气的血肉模糊的身体脱得精光。<br>突然，一个宪兵喃喃地说：“真见鬼，指挥官，这是个女人！”<br>我无法描述我当时感到多么恐慌，一种奇异的、钻心的恐慌。我不相信，便在雪地上跪下来，看着这堆不成人形的血肉。这是个女人！<br>两个宪兵目瞪口呆，十分气馁，等着我发表意见。<br>可是我不知道该怎么想，该作何假设。<br>于是宪兵班长慢慢地说：“也许她是来找孩子的。她孩子在炮兵部队，一直没有消息。”<br>另一个宪兵接着说：“可能是这样吧。”<br>我曾经历过许多可怕的事，但当时我哭了起来。在那个冰冷的夜晚，在那片黑色平原上，我而对死尸，面对着这个奥秘，而对着这个横遭残杀的陌生女人，体验到“恐怖”的含义。<br>（有删改）<br>【注】①一八七○年战争：又称普法战争。战争由法国发动，最后以普售士大获全胜、建立德意志帝国告终。<br>1、下列对本文相关内容的理解，不正确的一项是(   )（3分）<br>A.士兵坐下休息后，“再也没有站起来”，由此可看出“我”的悲悯之情；枪毙“间谍”时，士兵“像野人一样疯狂”，流露出士兵愤怒的情绪。<br>B.“古怪男人”被乱兵射杀后，“我独自呆在尸体前，那两个宪兵恪尽职守也呆在那里”，他们的目的是要从死者身上找到有价值的军事情报。<br>C.当得知死者是女人后，“我不相信，便在雪地上跪下来”。“跪下来”不只是为了验证宪兵的说法是否正确，也包含着一种对死者的负罪感。<br>D.“古怪男人”目睹法军溃败，担心在炮兵部队服役的儿子的安危，竟然在无法忍受的严寒中“跟踪我们三天”，让人不能不为伟大的母爱而感叹。<br>2、下列对本文艺术特色的分析鉴赏，不正确的一项是(   )（3分）<br>A.文中环境描写笔力精湛，如“诺曼底的田野一片惨白”“显得沉重而阴森”。这些描写渲染了冬夜凄凉的气氛，烘托了士兵惊恐的心情。<br>B.文中细节描写真实细腻，如“每个脚印都带着血”，“他们的前额垂向膝盖，慢慢下沉”。这些细节触目惊心，能让读者感受到战争的残酷。<br>C.文中运用比喻、拟人、夸张、排比等多种修辞手法，对天气的寒冷、军队的情状、士兵的心情作了生动的描写，给人留下了深刻的印象。<br>D.文中的“我”是故事的参与者、讲述者，第一人称叙事视角有利于真实再现战争情景，有利于表现“我”强烈的主观感受和复杂情绪。<br>3、莫泊桑的小说叙述技巧圆熟，擅长铺垫、伏笔、照应。请从文中各找一例，并简要分析其作用。（5分）<br>4、本文结尾说：“而对着……体验到‘恐怖’的含义。”“恐怖”在文中有哪些含义？请简要分析。（5分）</p><p>1、答案：D“‘古怪男人’目睹法军溃败，担心在炮兵部队服役的儿子的安危”不对。从小说结尾部分来看，“古怪男人”来找孩子，“孩子在炮兵部队，一直没有消息”只是宪兵作出的猜测，不一定是事实。<br>2、答案：C “拟人”不对。文中没有运用拟人的修辞手法。<br>3、答案：①铺垫：小说前半部分细致描写了士兵在严寒、饥饿、死亡的威胁下溃逃的情景，这为下文写他们怀疑“古怪男人”是敌军间谍，失去理智将其无情射杀做了铺垫，使情节显得真实可信。②伏笔：“间谍”个子很小，“没有胡子”，“肩膀窄窄的”，与女性体貌特征较为符合，这使故事结局虽然令人震惊，但并不十分突兀。③照应：小说开头部分交代“普鲁士人离我们不远，所以我们迅速逃跑”，中间部分又写到“突然一声呼喊：‘普鲁士人！普鲁士人！’”，于是士兵狂乱溃逃。二者相互照应，使小说结构更为紧凑。<br>4、答案：①事件的恐怖。被众多士兵射杀的“间谍”，竟然是一名无辜的老妇，而这名老妇很可能是一个炮兵的母亲，她惨死在本国士兵的枪下。②人心的恐怖。在溃败的耻辱前，在严寒、饥饿、死亡的威胁下，人心扭曲变态，完全失去理性，可以肆意枪杀他们怀疑的每一个人。③战争的恐怖。战争带来死亡，带来猜忌，带来暴乱，带走生命，带走信任，带走和平，可谓恐怖至极。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;（一）史记左传杂记&quot;&gt;&lt;a href=&quot;#（一）史记左传杂记&quot; class=&quot;headerlink&quot; title=&quot;（一）史记左传杂记&quot;&gt;&lt;/a&gt;（一）史记左传杂记&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;材料一&lt;/strong&gt;: 昔有夏之方衰也，后羿自鉏迁于穷石，因夏民</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>边缘智能应用论文阅读</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/10/31/edgecompute/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/10/31/edgecompute/</id>
    <published>2024-10-31T13:10:37.000Z</published>
    <updated>2024-10-31T08:37:03.403Z</updated>
    
    <content type="html"><![CDATA[<p>[4] Smart Traffic Monitoring System using Computer Vision and Edge Computing</p><p>Background：交通堵塞检测和超速检测。</p><p>Motivation：I、交通管理系统可捕获大量视频数据，并利用视频处理技术的进步来检测和监控交通事故。传统上，收集的数据会转发到流量管理中心 （TMC） 进行深入分析，因此可能会加剧到 TMC 的网络时延。（数据量大导致时延增大）。II、我们建议利用边缘通过为靠近摄像头的边缘节点配备计算资源（例如 Cloudlet）进行计算。与 TMC 相比，Cloudlet 的计算资源有限，提供的视频处理能力有限。</p><p>所以，一种在边缘实现，另一种在 TMC 实现，它们在设计时考虑了不同的计算资源。虽然 TMC 提供了强大的计算能力，但它接收的视频质量取决于底层网络条件。另一方面，边缘处理非常高质量的视频，但计算资源有限。</p><p>Approach：混合边缘云解决方案优于纯云和纯边缘解决方案。</p><p>[5] Edge-Based and Privacy-Preserving Multi-Modal Monitoring of Student Engagement in Online Learning Environments</p><p>Bakground：网课场景</p><p>Motivation：参与度是学生学习成绩的早期预测指标，因此教师可以观察听众的行为以保持他们的参与度。所以说检测学生的参与度。</p><p>Approach：提供了一种基于边缘的多模式参与分析解决方案，以维护其所有受众的参与度概览。这使得CPU占用率显著变低。</p><p>[6] Sleep Monitoring Systems based on Edge Computing and Microservices Caching[C]</p><p>Background：睡眠检测问题</p><p>Motivation：传统上，运行状况监测系统受到云中集中处理和存储的限制，从而导致延迟问题和潜在的数据丢失。</p><p>Approach：一种基于边缘计算的智能睡眠监测系统，利用微服务架构和缓存技术。拟议的系统采用边缘计算，使数据处理更接近源头，从而减少延迟并提高实时监控能力。缓存用于减少数据库负载并优化随机存取存储器 （RAM） 的使用。主要是缓存的出现。</p><p>[7] Joint Deployment of Fixed-Site and UAV Mounted Edge Servers Based on Traffic Prediction[C]</p><p>Background：预测车流量</p><p>Motivation：随着移动边缘计算 （MEC） 的快速发展，如何及时响应和高效利用计算资源已成为一项挑战。然而，传统的静态边缘计算资源缺乏灵活性，无法适应车联网 （IoV） 用户所经历的动态时空变化。</p><p>Approach：I、将固定站点边缘服务器 （FES） 与无人机安装的边缘服务器 （UAVE） 一起部署，以向车联网用户 （UE） 提供卸载服务。II、动态分配计算任务以优化资源利用率。（动态边）</p><p>[8] Machine learning based IoT system for secure traffic management and accident detection in smart cities</p><p>Backgrounds: 拥堵预测</p><p>Motivation：在智慧城市中，汽车的快速增长导致了拥堵、污染和商品运输中断。每年，由于日常道路事故而导致的死亡人数和永久性损伤病例都更多。</p><p>Approach：使用基于物联网的交通管理系统检测事故。为了识别、收集和发送数据，自动驾驶汽车和智能小工具配备了带有一组传感器的基于 IoT 的 ITM 系统。运输系统正在通过机器学习得到改进。</p><p>[9] A YOLOv7 Forest Fire Detection System with Edge Computing</p><p>Backgrounds: 火灾检测</p><p>Motivation：传统的火灾检测方法的实时性和检测能力较弱。新一代深度学习技术，尤其是卷积神经网络，为火灾探测提供了新的手段和方法。基于深度学习的火灾探测方法具有较高的准确率和鲁棒性。但是，由于其参数数量众多，计算量大，很难实际应用。随着边缘计算的发展，现在可以使用边缘而不是云进行计算，这将大大降低延迟。</p><p>Approach：基于 YOLOv7 网络训练了一个能够识别森林火灾的模型，并将训练后的模型进一步部署到边缘服务器 RK3588 上。最后，使用 Pyqt5 构建了能够显示火灾识别结果的前端可视化界面。该方法中的模型具有良好的鲁棒性和泛化能力，边缘计算在火灾森林检测中的应用进一步提高了火灾检测的速度，为森林火灾检测提供了新的途径。</p><p>[10] Lightweight Person Re-Identification for Edge Computing</p><p>Backgrounds: 行人检测</p><p>Motivation：大多数流行的模型主要是为云计算环境设计的，这带来了复杂性，限制了它们在边缘计算场景中的有效性。</p><p>Approach：本文提出了注意力知识辅助蒸馏轻量级网络 （ADLN），这是一种专为边缘计算而设计的网络架构。</p><p>共同目的：提高实时性和准确度。提高实时性的途径有资源占用量、时延等，提高准确度的就是提升AP。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[4] Smart Traffic Monitoring System using Computer Vision and Edge Computing&lt;/p&gt;
&lt;p&gt;Background：交通堵塞检测和超速检测。&lt;/p&gt;
&lt;p&gt;Motivation：I、交通管理系统可捕获</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>目标检测概论</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/10/17/NN/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/10/17/NN/</id>
    <published>2024-10-17T06:38:17.000Z</published>
    <updated>2024-10-31T06:53:04.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标检测概论"><a href="#目标检测概论" class="headerlink" title="目标检测概论"></a>目标检测概论</h3><p>目标检测，通俗点说就是给定一个图像，在图像中框出符合要求的区域。</p><p>用数学语言表达，就是：</p><p>训练集的输入是$(x_1,b_1),\dots,(x_n,b_n)$（其中$x_i&#x3D;(x_{i1},x_{i2},…,x_{ik})\in R^{m<em>n}$ 是原始$m</em>n$，k通道的图片，$b_i &#x3D; {b_{i1},b_{i2},…,b_{ij},c_{i1},c_{i2},…,c_{ij}}$是若干个符合要求的区域$b_{ik}\in R^4$和它们的id$c_{ik}$），也就是说在神经网络的推理中，我们需要输入一个$x$得到一个$b$</p><h3 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h3><p>传统目标检测方法包含预处理、窗口滑动、特征提取、特征选择、特征分类、后处理等步骤，而卷积神经网络本身具有特征提取、特征选择和特征分类的功能。那么，可以直接利用卷积神经网络对每个滑动窗口产生的候选区进行二分类，判断其是否为待检测目标。R-CNN因此而生。</p><p>R-CNN就是在CNN的基础上加了一层滑动窗口的选择。它有几点创新点：</p><ul><li>确定了two stage网络的设计范式。two stage网络的基本思想是把网络拆分成分类（类别判断）和回归（位置判断）两个任务进行处理。</li><li>形成日后主流的目标检测模型范式：input（输入）、backbone（主干）、neck（转化）、head（预测）。</li></ul><h4 id="R-CNN的Input部分"><a href="#R-CNN的Input部分" class="headerlink" title="R-CNN的Input部分"></a>R-CNN的Input部分</h4><p>这一部分是相较于CNN的关键区别，这一部分针对输入的图像，生成一系列可能有目标的识别框。对于每张输入的图片，采用Selective Search 方法，生成1K~2K个候选区域（region proposals&#x2F;region of interest，Rol）。</p><p>首先先对图像做一次图像分割：这里使用Massachusetts Institute of Technology基于图计算的图像分割方法。首先建图$G(V,E)$。点集就是图像上的每一个像素。边集是相邻的像素集合。每条边上有一个非负的权重表示像素之间的相似度，图每条边的权值是基于像素点之间的关系，可以是像素点之间的灰度值差，也可以是像素点之间的距离。在图论中，图的分割是$S &#x3D; (C_1,C_2,..,C_n) when C &#x3D; G’(V’,E’) ,\sum V’ &#x3D; V$，其中$V’$是$V$的一个子集，$E’$是$E$的一个子集，问题就转化成了求一个最优的图分割。本算法过程就相当于先将图分割成一个个顶点，然后通过合并策略，将它们合并，最后得到一个既不”太精细“也不”太粗糙“的分割。那是怎么进行合并的呢？论文中提出了一个叫做$MInt(C_1,C_2) &#x3D; min(Int(C_1) + \tau(C_1),Int(C_2) + \tau(C_2))$的定义。这个定义基于$Int(C) &#x3D; \max w(e)$（e是C中的边）。如果$MInt(C_1,C_2) &gt; Dif(C_1,C_2)$，那么$C_1,C_2$就可以合并。（其中$Dif(C_1,C_2) &#x3D; \min w(v_i,v_j)$，$v_i$和$v_j$是$C_1$和$C_2$中的点）。做多次合并，可以得到一个合理的图的分割。</p><p>原文地址：<a href="https://cs.brown.edu/people/pfelzens/papers/seg-ijcv.pdf%EF%BC%89">https://cs.brown.edu/people/pfelzens/papers/seg-ijcv.pdf）</a></p><p>得到了图的分割后，再对这个基础的分割进行一次聚类。根据之前计算好的$S$，计算S中每一个部分之间的相似度。在这里相似度可以表示成$s(r_i,r_j) &#x3D; a_1s_{color}(r_i,r_j) + a_2s_{texture}(r_i,r_j)+ a_3s_{size}(r_i,r_j) + a_4s_{fill}$，其中每个相似度表示颜色相似度，纹理相似度，大小相似度和填充相似度。计算好相似度后对挑选相似度最高的两个区域进行合并。合并的方法是构建一个新的大框。</p><p>原文地址：<a href="https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf">https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf</a></p><h4 id="R-CNN的BackBone部分"><a href="#R-CNN的BackBone部分" class="headerlink" title="R-CNN的BackBone部分"></a>R-CNN的BackBone部分</h4><p>R-CNN使用了非常传统的AlexNet进行分析。</p><p>第1层输入层： 输入为224×224×3 三通道的图像。</p><p>第2层Conv层： 输入为224×224×3，经过96个kernel size为11×11×3的filter, stride &#x3D; 4，卷积后得到shape为55×55×96的卷积层。</p><p>这里有2点值得注意的细节：(224-11)&#x2F;4 + 1 &#x3D; 54.25，</p><p>（1）按照论文中filter size和stride的设计，输入的图片尺寸应该为227×227×3。</p><p>（2）加上padding&#x3D;2，则(224-11+2*2)&#x2F;4 + 1 &#x3D; 55.25，步长会略去小数，得到55.</p><p>第3层Max-pooling层： 输入为55×55×96，经Overlapping pooling(重叠池化)pool size &#x3D; 3,stride &#x3D; 2后得到尺寸为27×27×96 的池化层</p><p>第4层Conv层： 输入尺寸为27×27×96，经256个5×5×96的filter卷积，padding&#x3D;same得到尺寸为27×27×256的卷积层。</p><p>第5层池化层： 输入为27×27×256，，经pool size &#x3D; 3,stride &#x3D; 2的重叠池化，得到尺寸为13×13×256的池化层。</p><p>第6～8层Conv层： 第6层输入为13×13×256，经384个3×3×256的filter卷积得到13×13×384的卷积层。 第7层输入为13×13×384，经384个3×3×384的filter卷积得到13×13×384的卷积层。 第8层输入为13×13×384，经256个3×3×384的filter卷积得到13×13×256的卷积层。 这里可见，这三层卷积层使用的kernel前两个维度都是3×3，只是通道维不同。</p><p>第9层Max-pooling层： 输入尺寸为13×13×256，经pool size &#x3D; 3,stride &#x3D; 2的重叠池化得到尺寸为6×6×256的池化层。该层后面还隐藏了flatten操作，通过展平得到6×6×256&#x3D;9216个参数后与之后的全连接层相连。</p><p>第10～12层Dense（全连接）层： 第10~12层神经元个数分别为4096，4096,1000。其中前两层在使用relu后还使用了Dropout对神经元随机失活，最后一层全连接层用softmax输出1000个分类。（分类数量根据具体应用的数量变化，比如数据集中有10个类别，则最后输出10）</p><h4 id="R-CNN的Head部分"><a href="#R-CNN的Head部分" class="headerlink" title="R-CNN的Head部分"></a>R-CNN的Head部分</h4><p>R-CNN使用一个SVM分类器来判别图片的类别（一个one-hot向量），使用一个回归器来预测目标的位置坐标（一个坐标四元组）。到了最终的预测结果输出阶段，还需要使用非极大值抑制（NMS）算法去除多余的候选区域。非极大值抑制（Non-maximal suppression，NMS）合并相似的预测。原来的NMS是用于锚框的情况，这里用于网格的情况。先从所有锚框中选取一个置信度高的锚框并对其进行标记，然后去掉（抑制）与其IOU值大于$\epsilon$的锚框；重复上面步骤，直至所有的锚框都被标记。</p><h3 id="SPPNet（Spatial-Pyramid-Pooling-Networks）"><a href="#SPPNet（Spatial-Pyramid-Pooling-Networks）" class="headerlink" title="SPPNet（Spatial Pyramid Pooling Networks）"></a>SPPNet（Spatial Pyramid Pooling Networks）</h3><ul><li><p>卷积神经网络的全连接层需要固定输入的尺寸，而Selective search所得到的候选区域存在尺寸上的差异，无法直接输入到卷积神经网络中实现区域的特征提取，因此RCNN先将候选区缩放至指定大小随后再输入到模型中进行特征提取。</p></li><li><p>RCNN使用Selective Search从图像中获取候选区域，然后依次将候选区域输入到卷积神经网络中进行图像特征提取，如果有2000个候选区域，则需要进行2000次独立的特征提取过程。然后，这2000个候选区域是存在一定程度的重叠的，所以如此设计会导致大量的冗余计算。</p></li></ul><p>SPP-Net究竟做了什么呢？CNN网络需要固定尺寸的图像输入，SPPNet将任意大小的图像池化生成固定长度的图像表示。SPPNet在最后一个卷积层后，接入了金字塔池化层，保证传到下一层全连接层的输入固定。</p><p>其次呢，SPPNet先做一次卷积，在卷积好的图像中进行Selective Search。由于做卷积操作不影响图像的位置，所以这样做是没问题的。</p><p>原文地址：<a href="http://arxiv.org/pdf/1406.4729">http://arxiv.org/pdf/1406.4729</a></p><h3 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h3><p>Fast R-CNN最重要的改进就是利用SPPNet，与R-CNN一样，利用Selective Search算法通过图像分割的方法得到一些原始区域，然后使用一些合并策略将这些区域合并，得到一个层次化的区域结构，而这些结构就包含着可能需要的物体。</p><p>但是，Fast R-CNN与R-CNN不同的是，这些生成出来的候选区域不需要每一个都丢到卷积神经网络里面提取特征，而且只需要在特征图上映射便可。</p><p>这样做的好处就是对于每一个框出来的区间，不需要都做一次卷积操作，而是直接可以进行池化和全连接了。在这里所有的图像都会池化成$7 \times 7$的特征矩阵。最后全连接层中有一个概率分配器和位置回归器。和R-CNN同理。Loss函数也分成分类loss（一般来说就是引入一个softmax层做交叉熵）和回归loss（smooth-L1损失）两部分</p><p>$$L(p,u,t^u,v) &#x3D; L_{cls}(p,u)+\lambda u(u&lt;1)L_{rgs}(t^u,v)$$</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/394c30ee399375d92dc9ec14ab4c0de9.png"></p><h3 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h3><p>相较于Fast R-CNN，做的优化就是引入了区域建议网络（Region Proposal Network，RPN）代替Selective Search算法。其核心思想就是利用锚点进行运算。</p><p>原文地址：<a href="https://arxiv.org/pdf/1504.08083">https://arxiv.org/pdf/1504.08083</a></p><h3 id="Yolo"><a href="#Yolo" class="headerlink" title="Yolo"></a>Yolo</h3><p>Yolo是You only look once的简写。采用单阶段网络（one-stage）。预测（物体位置和类别）由一个网络进行。可以进行端到端（end-to-end）训练以提高准确性。所以叫Look Once（）</p><p>YOLO将输入的图片resize成448 x 448，并且为 S x S（S &#x3D; 7）个grid，如果物体的中心落入该grid中，那么该grid就需要负责检测该物体。一次性输出所检测到的目标信息，包括类别和位置。综上，S×S 个网格，每个网格要预测 B个bounding box ，还要预测 C 个类。网络输出就是一个 S × S × (5×B+C)。（S x S个网格，每个网格都有B个预测框，每个框又有5个参数，再加上每个网格都有C个预测类）</p><p>YOLOv1采用的是“分而治之”的策略，将一张图片平均分成7×7个网格，每个网格分别负责预测中心点落在该网格内的目标。回忆一下，在Faster R-CNN中，是通过一个RPN来获得目标的感兴趣区域，这种方法精度高，但是需要额外再训练一个RPN网络，这无疑增加了训练的负担。在YOLOv1中，通过划分得到了7×7个网格，这49个网格就相当于是目标的感兴趣区域。通过这种方式，我们就不需要再额外设计一个RPN网络，这正是YOLOv1作为单阶段网络的简单快捷之处！</p><p>在Yolov1中是7 × 7 × 30（30等于两个框的xywh和置信度+所属类别的概率【20个】）。YOLO 有 24 个卷积层，后面是 2 个全连接层（FC）。一些卷积层交替使用 1×1 减少层来减少特征图的深度。在网络中，我们规定损失函数由分类预测损失、坐标预测损失（预测的bounding box和ground truth之间的差距）和置信度预测损失（框的客观真实性）组成，具体的损失函数的表示不表。</p><h3 id="Yolov5"><a href="#Yolov5" class="headerlink" title="Yolov5"></a>Yolov5</h3><p>Yolo是基于R-CNN的一种神经网络框架，如图所示：</p><p><img src="https://pic4.zhimg.com/v2-c006bfdf549bd811fcbcf8a6260f1c05_r.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目标检测概论&quot;&gt;&lt;a href=&quot;#目标检测概论&quot; class=&quot;headerlink&quot; title=&quot;目标检测概论&quot;&gt;&lt;/a&gt;目标检测概论&lt;/h3&gt;&lt;p&gt;目标检测，通俗点说就是给定一个图像，在图像中框出符合要求的区域。&lt;/p&gt;
&lt;p&gt;用数学语言表达，就是：&lt;/p</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Python异步编程说明</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/10/12/asycn/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/10/12/asycn/</id>
    <published>2024-10-12T15:56:31.000Z</published>
    <updated>2024-10-12T07:20:32.766Z</updated>
    
    <content type="html"><![CDATA[<p>Python异步编程使用<code>asycn</code>和<code>await</code>两个关键词进行修饰。其中<code>asycn</code>关键词修饰过程，而<code>await</code>修饰操作本身。</p><h3 id="EventLoop（事件循环）"><a href="#EventLoop（事件循环）" class="headerlink" title="EventLoop（事件循环）"></a>EventLoop（事件循环）</h3><p>Python异步编程的核心是维护若干个事件循环，学过操作系统的可以把事件简单地认为是“进程”。Python的事件循环维护若干个Task（协程），当Task被阻塞或者Task完成了，就从Task池（我起的名字）中获取下一个可以用的Task来执行。你可以通过<code>get_running_loop()</code>和<code>get_event_loop()</code>来获取当前的事件循环。区别是前者如果没有正在运行的事件循环则会引发 RuntimeError并且只能由协程或回调来调用。后者如果没有正在运行的事件循环择新建一个事件循环。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>事件循环本质就是管理Task。Task是一次协程的一次执行。协程使用<code>asycn</code>关键词进行修饰。这种函数最大特点是执行可以暂停，交出执行权。在<code>asycn</code>修饰的函数里面可以加上<code>await</code>修饰的<code>asycn</code>函数，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def get_data()</span><br><span class="line">return 11</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line"># get_data()</span><br><span class="line">d = await get_data()</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>当执行到await这一步的时候，就暂停当前Task命令的执行，反而去执行别的命令（就相当于阻塞）。这个时候会有人问，await修饰的那段任务执行情况是怎么样的呢，是作为一个新的Task放入事件循环中？其实不是，await代表异步执行，你可以简单地理解成开一个新的协程去做这件事情。这个协程首先把当前Task给暂停了，换一个新的Task。等那个新的协程把事情做完了，把之前那个被暂停的Task抓到Task池里面。其核心就是把IO密集型的任务进行重组，在IO等待的时候做点别的。</p><p>那至于Python如何平衡这个协程和新协程，就是内核做的事情，程序员不需要思考这件事。你可以认为，在程序员的角度中，就是做到需要等待的任务，就交给别人先占用CPU，我等完了我再来占用CPU。异步的目的就是并发执行。并发执行计算和IO，并发执行若干个任务。（这里我猜有一种机制，可以让计算，也就是CPU操作和IO一起执行，其实硬件上是可以实现的，有一种叫做DMA的机器可以实现IO和计算分离，具体的实现可以去学学，但是我目前就只知道用法）</p><h3 id="Push-task-to-eventloop"><a href="#Push-task-to-eventloop" class="headerlink" title="Push task to eventloop"></a>Push task to eventloop</h3><p>我们可以使用<code>asyncio.run()</code>来执行一个异步任务，也可以使用<code>asyncio.gather()</code>打包若干个Task进行执行。</p><h3 id="Get-the-return-value-from-task"><a href="#Get-the-return-value-from-task" class="headerlink" title="Get the return value from task"></a>Get the return value from task</h3><p>我们可以使用<code>task.result()</code>来统一返回，可以配合barrier一起使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    start_time = time.time()#程序启动时间</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()#获取本机事件循环</span><br><span class="line">    tasks = [loop.create_task(get_data(i)) for i in range(4)]</span><br><span class="line"> </span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print()</span><br><span class="line">    for task in tasks:</span><br><span class="line">        print(task.result())</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python异步编程使用&lt;code&gt;asycn&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;两个关键词进行修饰。其中&lt;code&gt;asycn&lt;/code&gt;关键词修饰过程，而&lt;code&gt;await&lt;/code&gt;修饰操作本身。&lt;/p&gt;
&lt;h3 id=&quot;EventLoop（事</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>In Search of an Understandable Consensus Algorithm (Extended Version)</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/04/28/mit-6-824-raft/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/04/28/mit-6-824-raft/</id>
    <published>2024-04-28T02:15:32.000Z</published>
    <updated>2024-05-31T00:29:28.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft究竟做什么？"><a href="#Raft究竟做什么？" class="headerlink" title="Raft究竟做什么？"></a>Raft究竟做什么？</h1><p>众所周知，一个可靠的分布式系统需要冗余。因为一个人是很容易出错的，这时候需要一群人来帮忙纠错。这就是分布式系统的可靠性。当一个机器出现故障或者错误，那么其他机器需要帮助这个机器进行恢复。那么阅读实验文档，Raft也干这么一件事。Raft是一个用于分布式系统的状态机协议，这个协议维护一个数据的完整副本，也就是说每一个机器，都拥有一组数据或者叫状态。Raft将客户端请求组织成一个序列，称为日志，并确保所有副本服务器看到相同的日志。每个副本按日志顺序执行客户端请求，将其应用于服务状态的本地副本。由于所有实时副本都看到相同的日志内容，它们都以相同的顺序执行相同的请求，因此继续具有相同的服务状态。如果服务器出现故障但后来恢复，Raft会将其日志更新到最新状态。具体来说，就是Raft负责维护每一个副本服务器所拥有的“副本”是一致的。</p><h1 id="6-824实验要求"><a href="#6-824实验要求" class="headerlink" title="6.824实验要求"></a>6.824实验要求</h1><ul><li>A：领导人选举：在众多个peer中选举出一个peer，这个peer作为领导者维护日志。当旧的领导者出现问题了，就换新的领导者。</li><li>B：日志记录：当一个新的请求来的时候，领导者和追随者需要记录日志信息。</li><li>C：持久状态：Raft重新启动服务的时候，要判断怎么重新启动最好。</li><li>D：对数压实：因为需要传递日志，传递一个完整的日志是很困难的，这时候需要对日志进行压缩。</li></ul><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Raft具有下面的性质：</p><ul><li>更强大的leader：所有访问Raft的请求都是由leader转发给其他成员的</li><li>leader选举：使用随机的时钟来选择领导人</li><li>成员更改：保证在配置文件更改的时候，Raft仍然正常运行</li></ul><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>对于一个分布式系统，若干个机器计算相同的状态的相同副本，当有一个服务器掉线了，服务也可以继续进行。复制状态机使用差错检测的方法。当客户访问分布式系统，提交一个新的请求的时候，首先先访问leader，leader记录客户的请求，生成日志，并把日志复制给其他的服务器中。最后更新状态，把最后的消息传递给客户端。</p><p>首先一个复制状态机需要推选出一个leader，然后存储在leader崩溃后的信息。然后leader需要对日志进行复制，日志本身就是一组命令的记录。然后状态机根据日志的记录按照顺序进行执行（状态的维护），每个服务器的每个日志都保存了相同命令。尽管每个服务器的状态机是不一致的，但是由于日志的存在，状态是一致的。</p><p>维护这个日志的一致性是共识算法的核心，共识模块从客户端获取信息然后加入进自己的日志中。然后定时的和其他服务器上的共识模块进行通信。只要命令被合理的复制保存了，那么每个服务器的状态机都会更改状态，然后输出会传递回客户端。执行的过程必须安全，可靠和高效。</p><h1 id="Raft的共识算法"><a href="#Raft的共识算法" class="headerlink" title="Raft的共识算法"></a>Raft的共识算法</h1><p>首先先选举出一个leader，然后给leader有一个维护日志的责任。所有的客户端请求都和leader进行交互，然后leader把复制log的请求给其他服务器，并且通知其他服务器执行状态机更新的合适时间。一个leader可能会断线，那么新的leader会被选举出来。</p><p>一个Raft集群会包括若干个服务器，一般来说是5个，它能让系统容忍两次失败。每个服务器都会有三个状态：leader（领导者），follower（追随者）和candidate（参与者）。follower什么都不干，只负责接受leader来的数据并且回应。candidate负责选举一个新的leader。leader拥有对日志完全的管理权限。leader接受客户的请求，然后把客户的请求复制给其他的服务器。然后告知其他服务器什么时候可以更新状态机（执行客户的操作）。指定一个leader会极大程度地减轻设计的难度。因为leader可以自己决定把日志写到哪个服务器上。leader可以掉线，如果lLeader掉线了，就重新选一个就好了。</p><p>Raft将时间分解成下面的若干个terms，这个terms有各种各样的长度，每个terms分成两个部分，第一个部分是选举，第二个部分是处理。每次terms结束了之后就重新进行选举，如果在一个terms中没能选举出一个合适的leader，那么这个terms提前终止</p><h2 id="leader选举（lab2A）"><a href="#leader选举（lab2A）" class="headerlink" title="leader选举（lab2A）"></a>leader选举（lab2A）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Raft究竟做什么？&quot;&gt;&lt;a href=&quot;#Raft究竟做什么？&quot; class=&quot;headerlink&quot; title=&quot;Raft究竟做什么？&quot;&gt;&lt;/a&gt;Raft究竟做什么？&lt;/h1&gt;&lt;p&gt;众所周知，一个可靠的分布式系统需要冗余。因为一个人是很容易出错的，这时候需要</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>MIT_6.824:PA1-MapReduce</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/04/19/mit-6-824-mr/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/04/19/mit-6-824-mr/</id>
    <published>2024-04-19T02:15:32.000Z</published>
    <updated>2024-04-19T08:41:47.089Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近事情比较多，但是又想刷一下6.824的实验，慕名已久了，于是就看了一下实验手册和大佬分享的代码。在这里写了一点自己的个人感悟。</p><h1 id="什么是MapReduce"><a href="#什么是MapReduce" class="headerlink" title="什么是MapReduce"></a>什么是MapReduce</h1><p>分布式计算的核心就是有一个主节点，驱动若干个副节点进行计算。MapReduce是一种非常特殊的分布式计算策略，因为所有的副节点都会执行相同的map操作和reduce操作。map操作和reduce操作之间是有一个barrier，做完map才能做reduce。map和reduce操作都可以自己人为定义的。但是需要满足一个条件。map操作需要收集若干条数据，生成若干条key-value对，reduce操作负责合并这些key-value对。对于若干个key-value对，合并成一个key-value对。</p><h1 id="RPC连接"><a href="#RPC连接" class="headerlink" title="RPC连接"></a>RPC连接</h1><p>master节点和worker节点之间的通信会根据socket协议进行传输。这期间会用到RPC的服务，go语言提供了RPC的服务。这里定义了WorkerArgs和WorkerReply两种信息。客户端执行<code>call</code>操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)</span></span><br><span class="line">sockname := coordinatorSock()</span><br><span class="line">c, err := rpc.DialHTTP(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">err = c.Call(rpcname, args, reply)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>call操作收取要调用服务端的接口名称（类.函数名）args提供传递的参数，reply提供接受的信息。这是分布式系统能实现的网络基础</p><h1 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h1><p>Worker并不需要思考什么问题，它只需要像一个牛马一样完成任务就好了。所以说对于Worker来说，只要做这么一件事。“等待派活-做活”之间循环就好。</p><p>等待派活就是向Master（或者叫Coordinator）发送一个请求，Master经过分析后就给Worker派活。派活的形式就如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Tasktype <span class="type">int</span> <span class="comment">// 0: map task, 1: reduce task, 2: waiting, 3: job finished</span></span><br><span class="line">NMap     <span class="type">int</span> <span class="comment">// number of map task</span></span><br><span class="line">NReduce  <span class="type">int</span> <span class="comment">// number of reduce task</span></span><br><span class="line"></span><br><span class="line">MapTaskNumber <span class="type">int</span>    <span class="comment">// map task only</span></span><br><span class="line">Filename      <span class="type">string</span> <span class="comment">// maptask only</span></span><br><span class="line"></span><br><span class="line">ReduceTaskNumber <span class="type">int</span> <span class="comment">// reducetask only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskType代表活的形式，下面的两个参数告诉Worker同事的数量。</p><p>Worker获得了派活的信息之后，就开始执行Master分发下的活。活的形式只有两种。一种是map，一种是reduce</p><p>先说map：</p><ul><li>获取要分析的文件名</li><li>进行分析，得到一组key-value对（按照文件数进行分配）</li><li>把这些key-value对按照Reduce任务的数量大小分到若干个Hash桶中。</li><li>把Hash桶中的元素记录到中间文件中（文件名是 i-k ，i代表是哪个Map对应做的，应该由第k个Reduce来做）</li><li>告知Master任务结束</li></ul><p>中间文件的记录是按照json文件的形式的，json包会提供Encoder和Decoder进行抽象的文件操作</p><p>接着说reduce：</p><ul><li>从中间文件中获取数据</li><li>对数据进行排序，排序之后相同key的元素就会在一起</li><li>获取相同的key组成的元素，做reduce操作</li><li>写结果</li><li>告知Master任务结束</li></ul><p>再说Master。Master的构建是简化过的，它维护了一个Map池和Reduce池。Map池一共有m个任务，Reduce池一共有n个任务。（m是根据文件数量给定的，n是自己给定的）</p><p>当有Worker需要请求任务时：首先判断map是不是已经分配完了，如果分配完了但是还没做完，告知Worker等待，如果没分配完，找到一个没分配的任务，告知其要做这个任务，然后等待任务完成。但是有个问题就是Worker可能自己会退出执行，这就需要Master去“督工”，督工的方式很简单，新建一个匿名线程，然后过10s检查是不是做完了，没做完默认它G了。重新分配给下一个有缘人。</p><p>当Map执行完了之后，map任务完成数+1，当完成数&#x3D;总量的时候，就可以分配Reduce了。这就是简单的MapReduce服务的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于最近事情比较多，但是又想刷一下6.824的实验，慕名已久了，于是就看了一下实验手册和大佬分享的代码。在这里写了一点自己的个人感悟。&lt;/p&gt;
&lt;h1 id=&quot;什么是MapReduce&quot;&gt;&lt;a href=&quot;#什么是MapReduce&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Stanford CS143 PA</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2024/04/17/stanford-cs143-PA/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2024/04/17/stanford-cs143-PA/</id>
    <published>2024-04-17T01:11:55.000Z</published>
    <updated>2024-04-17T03:12:46.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="flex用法"><a href="#flex用法" class="headerlink" title="flex用法"></a>flex用法</h2><p>flex可以用于词法分析。一个flex文件可以分成2个部分：引导区和规则区（我起的名）</p><p>引导区的内容会原封不动地放到.c文件中。规则区是由若干个规则组成的区域，flex的目的就是为了把规则区的内容进行解释，变成词法分析的.c文件中。（理论：正则表达式转化为NFA，然后再转化为DFA）。规则区的每一个规则由三部分组成<code>&lt;执行状态&gt;&lt;正则式&gt;&lt;匹配规则&gt;</code>。在规则区内部可以执行两种特殊的操作，一种是正则式的宏定义，例如<code>[0-9] DIGIT</code>是将0-9的数字定义成DIGIT。一种是状态声明<code>%START STATE</code>，表示声明了一个新的状态，叫做STATE。最开始的时候的状态叫做INITIAL。</p><p>flex执行的逻辑是规则匹配。规则的含义是，在某个执行状态下满足正则式就执行对应的匹配规则。规则匹配的顺序是从上到下的。也就是同时满足AB两种规则，先执行A规则对应的操作，再执行B规则对应的操作。</p><p>flex生成的c文件是没有main函数的，main函数需要我们自己实现（本实验已经写好了），flex提供了接口给main函数调用，<code>yylex()</code>负责从文件流中进行读取分析，告诉main函数程序的下一个词是什么类型的。其内容保存在<code>yylval</code>类型的变量中。</p><p>再flex内部中，我们可以讲<code>yylval</code>的成员进行赋值以保存相关信息，最原始的匹配信息（比如”abc\n”匹配到了STRING，那么最原始的匹配信息就是”abc\n”）保存在yytext中，yymore的用途是，本次匹配的yytext会保存在下次匹配的yytext前面。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>CS143的实验要在cool语言上作为基础。对于一个语言来说，注释是必要的，但是对于编译器来说，注释是没必要去理解的。作为编译器的第一环，就需要略掉。cool语言的多行注释的语法是（**），单行注释的语法是–。</p><p>首先处理多行注释，按照实验文档中所示，当处于INITIAL状态的时候，遇到了（*，就代表遇到了注释，就要进入注释状态。（这个注释可能是嵌套的，还要保存这是第几层），遇到了*）就是代表推出注释。注释内部所有字符全部忽略。接着处理单行注释，当处于INITIAL状态的时候，遇到了–，就代表遇到了单行注释，就要进入单行注释状态。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>cool语言也支持字符串，对于字符串的定义是从”开始的，当遇到”的符号，就代表进入了字符串状态。</p><ul><li>对于一个字符串，首先字符串是不能包含’\\‘ ‘&quot;‘ ‘\n’ </li><li>字符串的定义是可以换行的，但是换行的时候一定要加\\</li><li>最后编译器要对转译字符进行翻译</li></ul><p>cool语言要求，类型名大写，类型对应的实例是小写的。</p><h2 id="flex编译出来的C语言文件"><a href="#flex编译出来的C语言文件" class="headerlink" title="flex编译出来的C语言文件"></a>flex编译出来的C语言文件</h2><p>对flex编译出来的C语言文件进行简单的分析：最前面的一部分是flex自带的东西，对于每个flex文件都有的。还有一部分是flex中引导区的内容，编译的时候会原封不动地放进新生成的.c文件里面。下面是规则区，众所周知，词法分析是用DFA表示的，对于flex文件里面的每一个规则，都对应DFA的一个终止状态，当DFA进入到终止状态之后，就执行我们之前flex文件定义好的动作。下面的一部分是执行DFA操作的代码。</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><h2 id="复习一下！移进和规约"><a href="#复习一下！移进和规约" class="headerlink" title="复习一下！移进和规约"></a>复习一下！移进和规约</h2><p>bison使用LR文法进行分析，分析的基础就基于移进和规约。比如说一个规则S-&gt;abc，当遇到a的时候就移进，遇到b的时候再移进，遇到c的时候再移进，这个时候移进到规则的尾部了。就可以规约成S。移进规约的基础是基于一个状态机的，状态机的每一个状态记录了可能被规约到的规则的集合，移进一个字母就会前往一个新的状态。比如说S-&gt;abc和T-&gt;abd，当遇到a的时候，这两个规则都可能被归约到，这个状态就是S-&gt;a.bc，T-&gt;a.bd。当进入了一个空状态（也就是说一个可能被归约到的规则都没有），就意味着，程序有语法错误。</p><h2 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h2><p>经过了flex的词法分析，现在进入文法分析的部分。flex将程序分解成了若干个token。这些token被称为终结符。当然与之相对应的是非终结符。这个在编译原理中学过。终结符是以%token定义的，非终结符是以%type定义的。在抽象语法树中，非终结符是语法树的非叶节点，终结符是语法树的叶结点。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对于一个非终止符，需要有属性这一个概念来记录非终止符的相关信息。属性一般可以分为两种，一种叫做继承属性，这种属性一般是抽象语法树的上层结点直接赋予的属性；另外一种是综合属性，综合属性是抽象语法树下面的节点综合计算得来的属性。</p><p>对于bison，当执行S-&gt;abc的规约的时候，可以规定一个规约动作，当执行规约操作的时候，规约动作也就一起执行了。在bison的实际应用中，规约动作一般是对S进行综合属性的赋值，和对a，b，c的继承属性的赋值。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="$$是什么"></a>$$是什么</h2><p>在bison的规约操作中，一定会遇到对属性的操作，但是对属性的操作怎么体现在代码上呢？这里使用$开头的元素代指终结符或者非终结符。比如说$$就代替被规约的那个，$1就代表规约的元素的第一个，以此类推。所有元素都代指一个数据类型，在前面的union中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    Boolean boolean;</span><br><span class="line">    Symbol symbol;</span><br><span class="line">    Program program;</span><br><span class="line">    Class_ class_;</span><br><span class="line">    Classes classes;</span><br><span class="line">    Feature feature;</span><br><span class="line">    Features features;</span><br><span class="line">    Formal formal;</span><br><span class="line">    Formals formals;</span><br><span class="line">    Case case_;</span><br><span class="line">    Cases cases;</span><br><span class="line">    Expression expression;</span><br><span class="line">    Expressions expressions;</span><br><span class="line">    <span class="type">char</span> *error_msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中二元组中，前面的具体类型名，后面是代指。比如说定义<code>%type &lt;classes&gt; class_list</code>就代表class_list对应的非终止符，其$类型的变量就是Classes。</p><h2 id="规约冲突的化解"><a href="#规约冲突的化解" class="headerlink" title="规约冲突的化解"></a>规约冲突的化解</h2><p>有可能会出现移进-规约和规约-规约的冲突，比如说S-&gt;ab和T-&gt;abc，那读入了ab，是规约呢还是移进呢？这种冲突一般是由语法的二义性所导致的。有一种解决办法是定义结合性。比如说 x op y op z。那么我们可以定义<code>%left op</code>或者<code>%right op</code>。%left指定左相关性（将x与y优先分组）<br>%right指定右相关性（将y与z优先分组）。还有优先级的问题，后定义的要比前面定义的优先级要高。比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27;</span><br></pre></td></tr></table></figure><p>就代表乘除的优先级要比加减高。</p><h2 id="迭代定义的文法"><a href="#迭代定义的文法" class="headerlink" title="迭代定义的文法"></a>迭代定义的文法</h2><p>如果要写一个一种文法，由0个或者若干个1组成的句子，那怎么写呢？一般的方法就是这样：s-&gt;1S|空。在这里也是一样，对于若干个class组成的cool文件，就是classes-&gt;class classes | </p><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><h2 id="前端的review"><a href="#前端的review" class="headerlink" title="前端的review"></a>前端的review</h2><p>编译器设计可以分成两个部分，第一个部分是前端，另外一个部分是后端。前端的部分主要处理和语言相关的操作，比如说C语言，Java或者本课程所提到的cool语言。后端的部分主要处理和目的机有关的内容，比如说把代码生成到x86_linux上等等。现在对前端进行一个preview。</p><ul><li>词法分析，将源代码分解成若干个token。</li><li>语法分析，将若干个token组成一个语法分析树。通过定义好的<code>yyparse</code>读取。</li><li>语义分析，分析语法树上的语义单元是否出现语义逻辑错误。通过定义好的<code>yyparse</code>读取。</li></ul><p>语法分析主要分析语法结构，并不对语义逻辑进行分析，比如说鸡肉吃我，这明显是符合汉语言语法的，但是并不符合标准的语义。</p><h2 id="类表"><a href="#类表" class="headerlink" title="类表"></a>类表</h2><p>cool语言是面向对象的语言，代码是由一组类组成的，首先最重要的就是维护类的性质。这里有一个数据结构叫做类表，可以维护类。类表的核心是一张map，这张map记录了类名和类结构体的关系。所有关于类的语义错误都可以被记录下来。</p><p>在构建的时候可以进行两方面的检查：</p><ul><li>名字不能定义成SELF_TYPE（比如说Int之类的）</li><li>不能重复定义一个类</li><li>必须存在一个叫做Main的类。</li></ul><p>类表构建完了之后，所有的类的名字都是合法的了，现在要检查类的继承是不是合法的。因为类的继承是不能构成环的，比如说A继承B，那么B不能继承A。完成这种检查的方式很简单，从Main类做一次拓扑排序就好。判断完了这一部分，剩下的只需要检查两个：</p><ul><li>不能继承整数 String等类</li><li>不能继承一个不存在的类</li></ul><p>当然不会做拓扑排序的话还有一种方法，就是遍历每个类，对每个类进行溯源，直到Object，如果遇到和这个类一样的就报错。</p><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>现在把视角往下放，进入到方法表中，现在我们对每一个类构建一个方法表，<code>static std::map&lt;Symbol, MethodTable&gt; methodtables;</code>其中一个MethodTable是一个<code>typedef SymbolTable&lt;Symbol, method_class&gt; MethodTable;</code>我们发现这就是一个符号表！</p><p>正确的，对语义操作到这里我们发现，其实所有的表都是符号表！符号表记录了每一个区域的所有定义的符号的信息。编译原理课上其实学过，一个作用域就会有一个符号表，当编译器想要搜索一个符号究竟是啥意思的时候，就会从符号表上进行搜索。这里又提到了作用域，其实在编译器的实践中，作用域会体现在符号表上的层数上，比如说一个类是第一层，类里面的方法定义是第二层，等等。当语义分析来到了这一层之后，就要新建一个这一层的符号表。当语义分析脱离了这一层之后，这一层定义的符号表就没有用了。其实这就像个stack。</p><p>简单介绍以下本项目的符号表，本符号表通过一个叫做<code>Scope</code>的东东来进行作用域管理，当来一个新的作用域的时候，新建一个，当离开一个作用的时候，销毁一个，当要在该作用域加一个元素的时候，就可以使用<code>Scope(scope,new_element)</code>来添加。原理和栈一样！</p><p>现在已经对每个类都组织好了符号表，每个类都记录好所含的成员或者方法。组织的方法就是对类的Feature进行读取，这个Feature已经在语法分析的时候已经做好了，和上面的一样，还是对这个符号表进行检查。检查需要检查重载的性质。父类定义了个方法，子类的同名方法必须要和父类同名方法一致。</p><p>首先第一个问题，就是怎么获取到父类？这里使用之前构建好的类表的<code>EetInheritance</code>，代码浅显易懂，就是回溯！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::list&lt;Symbol&gt; <span class="title">ClassTable::GetInheritancePath</span><span class="params">(Symbol type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == SELF_TYPE) &#123;</span><br><span class="line">        type = curr_class-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::list&lt;Symbol&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that Object&#x27;s father is No_class</span></span><br><span class="line">    <span class="keyword">for</span> (; type != No_class; type = m_classes[type]-&gt;<span class="built_in">GetParent</span>()) &#123;</span><br><span class="line">        path.<span class="built_in">push_front</span>(type);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个问题，就是知道了父类，怎么指导父类有没有这个元素呢？可以自己实现一个<code>lookup</code>函数，因为父类也已经构建好了一组方法表，找就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DAT * <span class="title">lookup</span><span class="params">(SYM s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(ScopeList *i = tbl; i != <span class="literal">NULL</span>; i=i-&gt;<span class="built_in">tl</span>()) &#123;</span><br><span class="line"><span class="keyword">for</span>( Scope *j = i-&gt;<span class="built_in">hd</span>(); j != <span class="literal">NULL</span>; j = j-&gt;<span class="built_in">tl</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == j-&gt;<span class="built_in">hd</span>()-&gt;<span class="built_in">get_id</span>()) &#123;</span><br><span class="line"> <span class="keyword">return</span> (j-&gt;<span class="built_in">hd</span>()-&gt;<span class="built_in">get_info</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面贴出来的是人家写好的lookup，照着用就好了。其实也只是遍历而已。</p><p>最后一个问题就是怎么判断函数参数的个数，其实早在语法分析的时候已经把所有的参数信息全部放到<code>Formal</code>这里面去了。</p><h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>本项目维护了一个属性表，这个属性表就是一个符号表，全局，仅此一个。这个符号表帮助我们进行最后的语义检查。</p><p>程序的总的框架还是类，对每个类进行分析。这里我们首先引入一个问题。类的继承构成Scope的迭代吗？其实构成的。首先想一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can I get the value of a here? which a? What about b?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一层括号是访问不到第二层的a的内容的。父类的作用域中无法访问到子类的元素，但是子类的作用域可以访问父类的元素，还可以重写。那么子类的作用域是不是像第二层的，父类的作用域是不是像第一层的！能理解这一点可以加深对作用域的思考。</p><p>好话说回属性表，组织好一个属性表之后，就需要依据属性表的元素进行分析了对类里面每个元素进行分析了！</p><p>check分成两部分，一部分是方法，一部分是属性。</p><p>首先谈谈方法吧，首先，方法内部也会存在大量的作用域嵌套！所以更新作用域表是很有必要的。因为进入了一个新方法的分析，就需要打开一个作用域。其次，方法的分析分为两部分，一个是对参数的分析，一个是对内容的分析。参数是一个参数表，需要对参数表的名字和类型进行分析。内容本质上，就是一个表达式。我们需要分析表达式的返回类型是不是和方法定义的匹配。</p><p>接着谈谈属性吧，一般来说，属性后面需要添加一个初始化语句，我们还需要对这个初始化语句进行分析，看看其类型。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>无论是上面的方法表达式和初始化语句，都是表达式，对表达式的类型分析是非常有必要的，因为语言都是由一组组的表达式构成的，表达式的类型非常丰富，需要考虑到各种各样的表达式的构成。这一部分不表。</p><h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><p>终于结束了前端的工作，来到了后端的工作，在前端的时候，我们构建了一个语法树，根据语法树的信息判断了语义信息，验证了语义信息的正确性，现在我们根据这个语法树和相关的语义信息，进行代码生成。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>堆和栈是从大一学习C语言开始就老生长谈的一个话题了，简单的说，堆和栈是存放数据的两个区域。堆呢，一般负责存放静态的，不咋变化的数据。栈呢，一般存放动态的，一直在变的数据。针对数据的相关性质，可以对数据分配不同的存放模式。对于堆中的数据，我们一般可以进行简单的管理，对于栈中的数据，我们可以临时使用一个sp寄存器当作指针进行访存。</p><h2 id="代码生成的总体步骤"><a href="#代码生成的总体步骤" class="headerlink" title="代码生成的总体步骤"></a>代码生成的总体步骤</h2><ul><li>类表构建：还是和PA4一样的思路，对于类，首先构建一个类表来记录相关的信息。这个类表记录了系统已有的标准类和用户自己定义的类的一切信息。</li><li>全局变量：构建好了类的信息之后，第一步是构建全局变量。这一部分的操作是固定的，根据MIPS的定义，首先要建立基本类的定义，比如说Str，Int等类。以标签的形式存在于汇编语句中。</li><li>定义GC：方便内存管理</li><li>常量：记录各种各样的常量值，放在最前面。因为常量的值是不可以更改的。</li><li>类名：记录每个类及其子类。初始化相关的类。</li><li>构建虚表：将每个类的方法的入口地址记录下来。</li><li>原型对象构建：所有的类都会从一个原型对象继承属性和方法。</li><li>类的构造函数构建：</li><li>类的方法构建:</li></ul><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>这个Environment其实就是各种变量存放的位置，对于一个变量a，我们可以在编译的时候对其进行空间的分配。由于MIPS（RISC-V）也一样的访存是以寄存器+偏移的形式进行间接访问管理的。所以说就在这里记录变量的地址了。那函数的入口地址怎么记录呢？</p><h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><p>学过C++的应该知道虚函数，在这里，每一个method可以认为是一个虚函数。在调用虚函数的入口地址的时候，是需要调用晚期绑定类型对应的入口地址，这时候需要查找虚函数的入口地址，然后构造汇编指令。函只在C++中，如果要有virtual，我们就需要把它添加进vTable。并且每个类(而不是类实例)都有自己的虚表，因此vTable就变成了vTables。虚表存放的位置一般存放在模块的常量段中，从始至终都只有一份。</p><p>对于cool语言来说，也是需要虚表，我们默认所有函数，都是虚函数。所以说构建一个虚表是很有必要的。在实践中，我们使用<code>code_dispatchTabs</code>函数来记录虚函数的地址，每一个表项由类名，方法名和地址构成</p><h2 id="表达式生成"><a href="#表达式生成" class="headerlink" title="表达式生成"></a>表达式生成</h2><p>分配了数据的位置，那可以进行代码的生成了。</p><p>在CS143的课程中，提到了表达式的生成。比如说有个表达式，a+b，那么我们可以递归的来计算，首先将a的值放到a0寄存器中，然后把a0寄存器的值放到栈顶，更新栈。接着把b的值计算出来放到a0，取栈顶的值放到t1，最后计算a0+t1。这是一个简单的表达式计算的方法。</p><p>这里体验了CT和RT的联动，CT指的是编译时所做的操作，RT指的是运行时所做的操作。上面说明的是CT的操作，而RT的操作就被抽象成了a的值的计算了！这样可以实现多态。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>在讲函数的调用之前，首先要明确一个概念，叫做caller和callee，假如说在main函数调用了用户自己写的函数a，那么main就是caller，callee就是a。Caller-saved register（又名易失性寄存器AKA volatile registers, or call-clobbered）用于保存不需要在各个调用之间保留的临时数据。Callee-saved register（又称非易失性寄存器AKA non-volatile registers, or call-preserved）用于保存应在每次调用中保留的长寿命值。当调用者进行过程调用时，可以期望这些寄存器在被调用者返回后将保持相同的值，这使被调用者有责任在返回调用者之前保存它们并恢复它们。</p><p>学过汇编的都知道，在进行函数调用的时候，执行过程是这样的：</p><ul><li>caller将所有参数进行入栈</li><li>调用函数（j指令）</li><li>callee保存caller的fp</li><li>callee设置fp为sp</li><li>callee保存其他callee-save寄存器</li><li>callee将a0保存在s0中</li><li>callee执行函数体</li><li>callee回复之前保存的寄存器</li><li>恢复栈帧为调用前的状态</li><li>跳转ra保存的返回地址</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;词法分析&quot;&gt;&lt;a href=&quot;#词法分析&quot; class=&quot;headerlink&quot; title=&quot;词法分析&quot;&gt;&lt;/a&gt;词法分析&lt;/h1&gt;&lt;h2 id=&quot;flex用法&quot;&gt;&lt;a href=&quot;#flex用法&quot; class=&quot;headerlink&quot; title=&quot;flex用</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>南大pa</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/09/13/nju-pa/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/09/13/nju-pa/</id>
    <published>2023-09-13T03:07:52.000Z</published>
    <updated>2024-04-17T03:14:29.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><p>南大pa是一个设计非常巧妙而且指引非常足的一个实验，由于其指引已经很足了，我在这里不会写实验具体是怎么做的，具体写一下我的思考。</p><h3 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h3><p>程序的执行可以看成是一个有限状态机，每一个时刻可能对应一个状态。状态可以用程序计数器的值来进行表述，在不同的状态下，执行的指令和存储器的值也是不一样的，每一个状态可以指令一个访存或者计算指令。不同的程序是不同的状态机。</p><h3 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h3><p>pa的实验分成三个部分，一个是基础的nemu，nemu本质上是一个硬件模拟，它并不承担软件的部分，它为其他的部份提供硬件层面上的支持。对于其他的部份来说，他们会天真的认为自己是在一个真实的计算机进行执行，但是这一切都是nemu假扮的。nemu并不完善，它只能假扮CPU的执行和部分IO。</p><p>还有一个是am，am是抽象计算机，它可以称为静态链接库，这个本质上属于软件，它为其他运行程序提供基础的IO服务，在编译的时候它会和其他的用户程序一起编译在一起。所以说软件部份&#x3D;am+用户程序，在实验的不同部分中，用户程序是不同的。</p><p>这个实验的运行逻辑其实可以知道了。nemu充当硬件的成份，am+用户程序充当软件，在编译后写入进nemu的假想的存储内，由nemu模拟运行。</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>一般来说一个成熟的系统会使用make来自动化构建。pa使用了下面这条make语句进行构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(OBJ_DIR)/%.o: %.c</span><br><span class="line">  @echo + CC $&lt;</span><br><span class="line">  @mkdir -p $(dir $@)</span><br><span class="line">  @$(CC) $(CFLAGS) -c -o $@ $&lt;</span><br><span class="line">  $(call call_fixdep, $(@:.o=.d), $@)</span><br></pre></td></tr></table></figure><p>其中%.表示对于任何一个.o文件，这个是什么意思呢，我们看下面的这个make文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"> </span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CC) -c -o $@ $&lt;</span><br><span class="line">main: main.o fun.o</span><br><span class="line">$(CC) -o main main.o fun.o</span><br></pre></td></tr></table></figure><p>其中系统的输出是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.cpp</span><br><span class="line">gcc -c -o fun.o fun.cpp</span><br><span class="line">gcc -o main main.o fun.o</span><br></pre></td></tr></table></figure><p>%.保证在依赖链中所有依赖相似的依赖都会被构建，我们可以将%.的替换称为一次“展开”，在一次展开中，$&lt;表示第一个依赖文件，$^表示所有依赖文件，$@指代所有目标文件。当然这个指代仅指代一次展开。这是一个省力的好办法。</p><h3 id="客户程序载入"><a href="#客户程序载入" class="headerlink" title="客户程序载入"></a>客户程序载入</h3><p>众所周知，nemu是一个硬件模拟器，硬件需要运行软件，软件是以操作码储存在内存中的，nemu提供了一个默认的客户程序，这个客户程序很小，只有4B，在启动的时候首先把这个客户程序放在指定的位置中，然后让pc寄存器指向这个客户程序的第一个字节码。当然，这个客户程序执行完之后是nemu_trap命令。执行中断操作，这个后面会讲为什么。</p><p>当然我们可以定义一个自选的默认程序来执行相关操作。这个程序的读取在parse_arg已经做好了。如果有自选的程序，会覆盖掉之前的默认的客户程序。</p><h3 id="客户程序运行"><a href="#客户程序运行" class="headerlink" title="客户程序运行"></a>客户程序运行</h3><p>当代码初始化了之后就会进入sdb_mainloop中，sdb_mainloop是nemu自带的一个控制台小程序，它可以接收控制台的命令然后控制客户程序的执行。</p><p>执行的核心逻辑是cpu_exec()，括号内可以传一个整数，表示执行多少条指令，如果传的数是-1就一直循环执行下去。</p><p>什么东西可以打断cpu的执行呢，那就是中断，当遇到中断的时候，执行结束，nemu会根据中断的类型判断：</p><ul><li><code>HIT GOOD TRAP</code> - 客户程序正确地结束执行</li><li><code>HIT BAD TRAP</code> - 客户程序错误地结束执行</li><li><code>ABORT</code> - 客户程序意外终止, 并未结束执行</li></ul><p>对于nemu来说，我们可以简单地认为，遇到BAD TRAP&#x2F;GOOD TRAP就算是一次程序运行的结束。复杂点说就是对于nemu这一个硬件平台，可以运行很多次软件，一次TRAP就是一次软件的运行。实际上对于C语言或者别的，程序运行的结束有另外的表示，nemu本身也是一个大型的C语言项目，nemu运行的结束也需要有表示。</p><h3 id="优雅地退出"><a href="#优雅地退出" class="headerlink" title="优雅地退出"></a>优雅地退出</h3><p>作为一个C语言代码，我们可以认为main是C语言的核心框架，当main执行完了之后，整个C语言代码就执行完了，一般OS需要在这个时候回收一个信号，这个信号提示刚刚的C语言代码运行情况。这就是return 0的作用，return 0就是告诉上层（或者叫调用该C语言代码的模块），我运行地挺好。</p><p>我们注意到nemu退出的时候输出了一堆奇怪的东西，其实是return的结果不是0而是-1，如果return的结果是-1，一般就是运行出现了问题。RTFSC之后可以很快更改。</p><h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><h3 id="暂停一下！"><a href="#暂停一下！" class="headerlink" title="暂停一下！"></a>暂停一下！</h3><p>在做pa2的时候，你可以简单的认为，nemu是模拟硬件的执行，而am-kernel（abstract-machine）模拟最基础的软件的执行。abstract-machine里面模拟了最简单的运行时环境（你可以理解为是“头文件”）</p><p>那首先，我们先尝试理解一下nemu的运行机理。nemu尝试去实现了一个简单的硬件，这个简单的硬件完成了一个简单的图灵机，就是设置一个PC，取指令，执行指令，设置下一次执行的PC。对于所有的软件，包括am和用户程序，它是一个二进制字节码。nemu阅读这个二进制字节码，然后执行字节码对应的指令。</p><p>现在RTFSC。了解一下程序的运行。首先程序执行<code>am_init_monitor()</code>，然后执行若干个初始化的操作：</p><ul><li>rand</li><li>mem 初始化内存，将0-0x8000000的位置随机给一个数据，就算初始化好了。也就是说存储器其实是一个比较大的数组。</li><li>isa 初始化cpu的执行，将cpu的pc寄存器指向前面提到的开始执行的一段代码的第一条指令的位置。这一段开始执行的代码根据指令集的不同进行执行（这一段特殊的内置的代码很像操作系统的bios，实际上的功能其实也差不多）</li><li>load_img 将一个镜像文件覆盖上述的那段特殊的内置代码，这个镜像文件是运行NEMU的一个可选参数, 在运行NEMU的命令中指定。如果运行NEMU的时候没有给出这个参数，NEMU将会运行内置客户程序。</li><li>device 初始化各种设备</li></ul><p>有疑问！这个用户的二进制文件大小是怎么确定的？我们可以看到am-bin.S这个文件中，这个文件巧妙地确定了大小</p><p>这就是完成了各种初始化的操作，然后跳转到engine_start()。engine_start根据不同的情况进行执行。</p><ul><li>如果指定了客户程序，就一直执行下去。</li><li>没有指定客户程序，就执行sdb，也就是内置的一个调试器。调试器的实现不去讨论。</li></ul><p>到这里其实我们可以知道一点，其实nemu也是一个程序！这个程序在我们的cpu上执行，它的职责，其实是模拟一个cpu！这个程序分为两个部分，一个是代码部分，用于模拟cpu上的执行，一个是数据部分，用于模拟内存，这个数据部分，存储了要被模拟器模拟的程序，和要被模拟器模拟的程序所用的内存！</p><h3 id="一次模拟执行"><a href="#一次模拟执行" class="headerlink" title="一次模拟执行"></a>一次模拟执行</h3><p>上文中说到，nemu执行完初始化的操作之后就开始执行用户程序的代码，那究竟是怎样执行的呢？具体的执行可以推导<code>execute()-&gt;execute_once()-&gt;isa_exectue()</code>，这是isa_execute()的执行，和五段流水线的操作一模一样。</p><h3 id="IOE的实现"><a href="#IOE的实现" class="headerlink" title="IOE的实现"></a>IOE的实现</h3><p>上述实现了一个非常简单的图灵机（TRM），当时只有图灵机的实现是不足以解决问题的。只会计算的计算机，是没有人机交互的能力的，于是实现IO是迫在眉睫的问题。</p><p>IO设备有两种模式，一种是中断的模式，一种是内存映射。这里使用内存映射的模式，举个例子吧！比如说你想在命令行窗口里面输出一个字母A，那么你只需要往一个特殊的地方输入”A”这个字母，那么设备从这个特殊的地方获取A这个数据，然后输出字母A。那么特殊的地方在哪里呢？在init_device()</p><p>设备是沟通外界物理世界（模拟信号）和逻辑世界（数字信号）的桥梁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态机模型            |           状态机模型之外</span><br><span class="line">  S = &lt;R, M&gt;         |        D</span><br><span class="line">  计算机/程序  &lt;----I/O指令----&gt; 设备 &lt;----模拟电路----&gt; 物理世界</span><br><span class="line">                     |</span><br><span class="line">                     |</span><br></pre></td></tr></table></figure><h3 id="“内存”读写"><a href="#“内存”读写" class="headerlink" title="“内存”读写"></a>“内存”读写</h3><p>为什么要给内存打上引号？是因为内存的读写不再是内存本身了，为什么这样说呢？RTFSC（当执行L类指令和S类指令的时候）</p><p>内存的读写要分为两部分，第一部分是设备，第二部分是内存本体。对于内存本体的读写很简单，由于这部分的实验没有页表，那么就很简单的移动处理，虚拟地址+offset&#x3D;物理地址。如果是设备读写，就要调用专门的设备读写函数。</p><h3 id="在AM中加上设备读写的支持"><a href="#在AM中加上设备读写的支持" class="headerlink" title="在AM中加上设备读写的支持"></a>在AM中加上设备读写的支持</h3><p>这下知道驱动是怎么写的了吧？（应该叫驱动）比如说你要输出一个图片，经过驱动程序的转化，会变成一组S指令和L指令。本次实验的所有IOE完成全部都是这么来的，具体不表。</p><h1 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h1><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断是每个系统都需要思考的一个问题。在nemu系统中，你可以从软件和硬件的两方面完成中断操作。</p><ul><li>硬件处理：中断相关寄存器的实现和中断相关指令的实现</li><li>软件处理：中断向量和中断处理程序</li></ul><p>再梳理一遍中断相关的操作。</p><ul><li>nemu程序执行ecall指令。</li><li>跳转到mtvec所保存的中断向量处。<code>s-&gt;npc = mtvec</code>，保存epc（硬件处理） nemu还在执行指令，但是和普通的TRM没啥区别了</li><li>执行中断向量，经典保存栈帧</li><li>跳转到am提供的中断处理程序，判断是中断类型，这里默认由用户主动引发的中断是11。（这里是am模块提供的运行时环境支持，和操作系统集成）</li><li>跳转到nano的代码，执行系统调用处理。</li><li>返回，返回的时候执行特定的返回操作。</li></ul><p>这里<code>mcause</code>保存中断处理的原因，<code>c-&gt;GPR1</code>保存系统调用号。</p><h3 id="带操作系统大应用"><a href="#带操作系统大应用" class="headerlink" title="带操作系统大应用"></a>带操作系统大应用</h3><p>上面我们提到，nemu是硬件，am集成了软件的运行时环境为应用程序提供了执行环境。这里的应用程序换成了一个操作系统，这个操作系统包含了代码区域和数据区域，代码区域存储了一系列操作系统执行的代码，数据区域作为ramdisk存放了要被操作系统规划执行的代码。所以本质上是三部分代码。这就是大应用。也就是AM+OS规划application执行。</p><h3 id="操作系统下的IOE"><a href="#操作系统下的IOE" class="headerlink" title="操作系统下的IOE"></a>操作系统下的IOE</h3><p>所有的IO操作，全部都使用am提供的底层借口。下面举个例子展示一下IO操作是如何逐层抽象的。</p><ul><li>navy（应用程序） 访问抽象文件<code>\dev\fb</code></li><li>访问文件的操作被转化为了系统调用（详见<code>syscall.c</code>）</li><li>中断，和上面一样</li><li>进入了系统调用处理，处理发现是read系统调用，进入文件系统处理</li><li>文件系统通过文件标识符号获取read的处理函数，从read的这个抽象接口中获取了内容。返回。</li></ul><p>这一部分是操作系统为应用程序提供的逻辑读写服务。操作系统的read函数调用了AM提供了抽象读写函数<code>io_read()</code>，这就是AM为操作系统提供的抽象读写服务。AM再具体的实现物理设备的读写，和上面一样。</p><h3 id="驱动？"><a href="#驱动？" class="headerlink" title="驱动？"></a>驱动？</h3><p>这大概就是驱动的概念，驱动是可以随意安装和卸载的。在这里我们也可以安装和卸载驱动。</p><p>AM为上文提供了一个抽象接口<code>io_read() or io_write()</code>，这个抽象接口传递一个变长参数。比如<code>io_read(A,B,C,D)</code>，这个时候编译器会根据klib库的一个宏，生成一个新的数据类型<code>A_T</code>包含三个成员分别叫B，C，D三个，和一个新的宏<code>A</code>。并且调用<code>ioe_read(int A,A_T buf)</code>然后执行你已经注册好的底层驱动函数。</p><p>注册的逻辑实在函数指针数组<code>lut</code>里面添加你这个宏的支持，具体看代码也可以懂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PA1&quot;&gt;&lt;a href=&quot;#PA1&quot; class=&quot;headerlink&quot; title=&quot;PA1&quot;&gt;&lt;/a&gt;PA1&lt;/h1&gt;&lt;p&gt;南大pa是一个设计非常巧妙而且指引非常足的一个实验，由于其指引已经很足了，我在这里不会写实验具体是怎么做的，具体写一下我的思考。&lt;/</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>MIT_6.S081_xv6.Information 集合</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/</id>
    <published>2023-02-09T02:57:19.000Z</published>
    <updated>2024-03-25T01:34:52.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Operating-System-Overview"><a href="#1-Operating-System-Overview" class="headerlink" title="1:Operating System Overview"></a>1:Operating System Overview</h1><h2 id="1-xv6系统的启动过程"><a href="#1-xv6系统的启动过程" class="headerlink" title="1 xv6系统的启动过程:"></a>1 xv6系统的启动过程:</h2><h3 id="1-1xv6引导器"><a href="#1-1xv6引导器" class="headerlink" title="1.1xv6引导器"></a>1.1xv6引导器</h3><p>当x86系列的PC机启动的时候,首先会执行BIOS程序,BIOS程序一般会存放在固定的ROM中,一般在磁盘固定扇区中.BIOS 的作用是在启动时进行硬件的准备工作,接着BIOS程序会把控制权递交给操作系统.具体来说,BIOS会把控制权递交给从引导扇区中的固定的代码中(BIOS会把引导扇区存储的代码加载到内存0x7c00处),接着引导程序会把操作系统内核载入到内存中,控制权递交给内核,程序是M态的.</p><p>在xv6系统,引导程序由汇编引导程序和代码引导程序.</p><h3 id="1-2-内核态进入用户态"><a href="#1-2-内核态进入用户态" class="headerlink" title="1.2 内核态进入用户态"></a>1.2 内核态进入用户态</h3><p>阅读kernel.asm(内核整体的代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000080000000 &lt;_entry&gt;:</span><br><span class="line">    80000000:00009117          auipcsp,0x9</span><br><span class="line">    80000004:86013103          ldsp,-1952(sp) # 80008860 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line">    80000008:6505                luia0,0x1</span><br><span class="line">    8000000a:f14025f3          csrra1,mhartid</span><br><span class="line">    8000000e:0585                addia1,a1,1</span><br><span class="line">    80000010:02b50533          mula0,a0,a1</span><br><span class="line">    80000014:912a                addsp,sp,a0</span><br><span class="line">    80000016:652050ef          jalra,80005668 &lt;start&gt;</span><br></pre></td></tr></table></figure><p>我们看到了_entry这个标签,也就是说内核是从_entry开始运行的,那我们首先查看一下entry.S的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\# qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each CPU to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line"># set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid \* 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024\*4</span><br><span class="line">csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line"># jump to start() in start.c</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure><p>引导程序会把内存载入到0x80000000这个地址是因为在0~0x80000000这个地址范围内还有I&#x2F;O设备等(还有程序的逻辑地址)</p><p>entry.S开始设置了一个栈,栈的带下是1024*4&#x3D;4KB,其中mhartid是运行当前程序的CPU核的ID,那么第i个核的栈地址空间就分配到stack+(hartid)*4096~stack+(hartid+1)*4096这个范围内.</p><p>因为这个操作系统是运行在多核的RISC-V操作系统上,由多个核同时访问一个内存空间,所以说每个核的CPU只在允许的内存空间中执行代码.其中每个核的寄存器又是不一样的,所以说可以修改每个核的sp寄存器来区分不同的核的代码运行空间.</p><p>在entry.S执行完操作之后,根据汇编代码,程序会跳转到start的这个函数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// entry.S jumps here in machine mode on stack0.</span><br><span class="line">void start()</span><br><span class="line">&#123;</span><br><span class="line">  // set M Previous Privilege mode to Supervisor, for mret.</span><br><span class="line">  unsigned long x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x = MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  // set M Exception Program Counter to main, for mret.</span><br><span class="line">  // requires gcc -mcmodel=medany</span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  // disable paging for now.</span><br><span class="line">  w_satp(0);</span><br><span class="line"></span><br><span class="line">  // delegate all interrupts and exceptions to supervisor mode.</span><br><span class="line">  w_medeleg(0xffff);</span><br><span class="line">  w_mideleg(0xffff);</span><br><span class="line">  w_sie(r_sie()  SIE_SEIE  SIE_STIE  SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  // configure Physical Memory Protection to give supervisor mode</span><br><span class="line">  // access to all of physical memory.</span><br><span class="line">  w_pmpaddr0(0x3fffffffffffffull);</span><br><span class="line">  w_pmpcfg0(0xf);</span><br><span class="line"></span><br><span class="line">  // ask for clock interrupts.</span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  // keep each CPU&#x27;s hartid in its tp register, for cpuid().</span><br><span class="line">  int id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  // switch to supervisor mode and jump to main().</span><br><span class="line">  asm volatile(&quot;mret&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在start函数中我们还是会执行在M态执行的操作:</p><p>首先会执行mepc寄存器的操作,改变了mepc寄存器就相当于改变了断点值.这个寄存器相当于S态中断进入到M态的时候,触发中断的PC,当M态回到S态的时候,就继续从断点处执行.当然这个操作还制定了M态比S态更加接近于内核.</p><p>接着下一步就是取消分页,在这一部分,虚拟地址是和实际的物理地址是一一对应的.</p><p>再下一步,将所有的中断委托给S态进行处理.</p><p>再下一步,指定程序允许的物理地址,在S态我们允许访问所有的物理地址</p><p>在下一步,对时钟芯片编程以产生计时器中断.</p><p>再下一步,取CPU的核id</p><p>最后一步,返回到main()函数,执行mret指令.</p><p>操作系统接着就会进入main函数,main函数主要初始化设备和一些子系统,然后调用userinit()函数来生成第一个进程,第一个进程只会运行很基础的程序,这个程序再initcode.S中已经声明.(这个时候已经进入U态了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\# Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br></pre></td></tr></table></figure><p>系统调用的参数是a0<del>a7,其中a0</del>a6代表argv等,a7代表具体执行什么系统调用.</p><p>这个时候系统会执行init程序,init程序这个时候就会加载sh程序,并且会初始化一个新的文件描述器(你可以认为是标准的I&#x2F;O输入输出,控制台输出,因为Unix类型的系统会把设备当成文件来看),然后执行Shell程序,系统开始执行</p><h2 id="2-操作系统接口与系统调用"><a href="#2-操作系统接口与系统调用" class="headerlink" title="2 操作系统接口与系统调用"></a>2 操作系统接口与系统调用</h2><p>这个操作系统没有图形化界面,目前只能执行基本的键盘命令.</p><p>操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很难的。一方面我们希望接口设计得简单和精准，使其易于正确地实现；另一方面，我们可能忍不住想为应用提供一些更加复杂的功能。解决这种矛盾的办法是让接口的设计依赖于少量的_机制_ （<em>mechanism</em>)，而通过这些机制的组合提供强大、通用的功能。</p><p>xv6提供 Unix 操作系统中的基本接口（由 Ken Thompson 和 Dennis Ritchie 引入），同时模仿 Unix 的内部设计。Unix 里机制结合良好的窄接口提供了令人吃惊的通用性。这样的接口设计非常成功，使得包括 BSD，Linux，Mac OS X，Solaris （甚至 Microsoft Windows 在某种程度上）都有类似 Unix 的接口。理解 xv6 是理解这些操作系统的一个良好起点。</p><p>xv6 使用了传统的<strong>内核</strong>概念 – 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为<strong>进程</strong>）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。</p><p>听上去很绕是吧,我们可以简单地理解,就是操作系统类似于高速公路的服务区,程序就是司机,司机在高速公路上开车相当于程序的正常执行,进入高速公路服务区司机就不会继续开车了,程序暂停执行.所以说程序获得操作系统提供的服务是通过中断的方式获得的.这个中断可以简称访管中断.</p><p>程序想获得操作系统的服务,先通过访管中断进入中断处理程序,这个时候就进入到了S态,在中断处理程序中根据某种特殊寄存器的值跳转到特殊的地址执行特殊的程序,这种特殊的程序叫做系统调用.因为用户态的程序权限有限,所以说要向操作系统提获取给更高的权限.只能通过中断的方式获取.</p><p>总得来说,进程通过<strong>系统调用</strong>使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p><h2 id="3-更多的基础知识"><a href="#3-更多的基础知识" class="headerlink" title="3 更多的基础知识"></a>3 更多的基础知识</h2><h3 id="3-1-内核的组成"><a href="#3-1-内核的组成" class="headerlink" title="3.1 内核的组成"></a>3.1 内核的组成</h3><p>RISC-V的CPU主要分成三个态,操作系统会在三个态中穿插进行.</p><p>其中M态是机器态,在M态的操作系统有最高的权限,最高的优先级,可以执行所有指令,但是操作系统一般只在刚开始启动的时候是M态,在执行了一段初始化代码后就会降低到S态.</p><p>操作系统的内核一般是在S态进行运行,在S态,我们可以执行所有的指令,包括一部分特权指令,特权指令不知道的回去翻一下操作系统书.</p><p>在操作系统的空间划分中,我们一般划分内核态和用户态空间,在S态的时候,所有的程序和堆栈都是在内核态空间的,在U态的时候,所有的程序和堆栈都是在用户态空间的.</p><p>综上所述,内核主要由内核态空间和一些系统调用组成.这种内核一般称为monolithic kernel.</p><p>对于另外一种microkernel的操作系统,它们会把一部分应该在S态运行的代码下放到U态防止出现问题,这个叫做微内核.</p><h3 id="3-2-程序的逻辑地址"><a href="#3-2-程序的逻辑地址" class="headerlink" title="3.2 程序的逻辑地址"></a>3.2 程序的逻辑地址</h3><p>程序空间主要由基本的代码和数据,栈,堆,栈帧组成.其中栈帧保存了当前程序执行的时候一些基本的寄存器、断点信息、页表信息和CPU信息.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">  /\*   0 \*/ uint64 kernel_satp;   // kernel page table</span><br><span class="line">  /\*   8 \*/ uint64 kernel_sp;     // top of process&#x27;s kernel stack</span><br><span class="line">  /\*  16 \*/ uint64 kernel_trap;   // usertrap()</span><br><span class="line">  /\*  24 \*/ uint64 epc;           // saved user program counter</span><br><span class="line">  /\*  32 \*/ uint64 kernel_hartid; // saved kernel tp</span><br><span class="line">  /\*  40 \*/ uint64 ra;</span><br><span class="line">  /\*  48 \*/ uint64 sp;</span><br><span class="line">  /\*  56 \*/ uint64 gp;</span><br><span class="line">  /\*  64 \*/ uint64 tp;</span><br><span class="line">  /\*  72 \*/ uint64 t0;</span><br><span class="line">  /\*  80 \*/ uint64 t1;</span><br><span class="line">  /\*  88 \*/ uint64 t2;</span><br><span class="line">  /\*  96 \*/ uint64 s0;</span><br><span class="line">  /\* 104 \*/ uint64 s1;</span><br><span class="line">  /\* 112 \*/ uint64 a0;</span><br><span class="line">  /\* 120 \*/ uint64 a1;</span><br><span class="line">  /\* 128 \*/ uint64 a2;</span><br><span class="line">  /\* 136 \*/ uint64 a3;</span><br><span class="line">  /\* 144 \*/ uint64 a4;</span><br><span class="line">  /\* 152 \*/ uint64 a5;</span><br><span class="line">  /\* 160 \*/ uint64 a6;</span><br><span class="line">  /\* 168 \*/ uint64 a7;</span><br><span class="line">  /\* 176 \*/ uint64 s2;</span><br><span class="line">  /\* 184 \*/ uint64 s3;</span><br><span class="line">  /\* 192 \*/ uint64 s4;</span><br><span class="line">  /\* 200 \*/ uint64 s5;</span><br><span class="line">  /\* 208 \*/ uint64 s6;</span><br><span class="line">  /\* 216 \*/ uint64 s7;</span><br><span class="line">  /\* 224 \*/ uint64 s8;</span><br><span class="line">  /\* 232 \*/ uint64 s9;</span><br><span class="line">  /\* 240 \*/ uint64 s10;</span><br><span class="line">  /\* 248 \*/ uint64 s11;</span><br><span class="line">  /\* 256 \*/ uint64 t3;</span><br><span class="line">  /\* 264 \*/ uint64 t4;</span><br><span class="line">  /\* 272 \*/ uint64 t5;</span><br><span class="line">  /\* 280 \*/ uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-进程"><a href="#3-3-进程" class="headerlink" title="3.3 进程"></a>3.3 进程</h3><p>进程就是运行的代码,进程可以通过调用ecall指令来进入到S态.其中进入到S态的何处就是有S态进行定义的.S态也可以调用sret指令回到断点处继续执行指令.</p><p>下面给顶了进程的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct proc &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line"></span><br><span class="line">  // p-&gt;lock must be held when using these:</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  void \*chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class="line">  int pid;                     // Process ID</span><br><span class="line"></span><br><span class="line">  // wait_lock must be held when using this:</span><br><span class="line">  struct proc \*parent;         // Parent process</span><br><span class="line"></span><br><span class="line">  // these are private to the process, so p-&gt;lock need not be held.</span><br><span class="line">  uint64 kstack;               // Virtual address of kernel stack</span><br><span class="line">  uint64 sz;                   // Size of process memory (bytes)</span><br><span class="line">  pagetable_t pagetable;       // User page table</span><br><span class="line">  struct trapframe \*trapframe; // data page for trampoline.S</span><br><span class="line">  struct context context;      // swtch() here to run process</span><br><span class="line">  struct file \*ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode \*cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中trapframe就是栈帧,pagetable就是页表.(可以复习一下OS关于内存的论述),state用于描述进程的状态.然后chan我猜测是进程等待队列的下一个元素.file就是打开的文件,cwd就是当前的目录,kstack是内核栈的位置,parent就是父进程.</p><p>进程之间是用数组来进行组合的.</p><p>在这一节你需要知道的是:</p><p>每一个进程都有一个页表来标记va和pa,不同的进程靠不同的页表来物理地相互阻隔,由于页表不同,不同的进程访问相同的虚拟地址,却是访问不同的物理地址,达到了物理的阻塞.</p><p>每一个进程再一定的时间会被其他的进程打断,这个时候CPU停止对于这个进程的执行,转而执行其他的进程.</p><p>每个进程都有两个栈,在U态处理的时候访问用户栈,在S态处理的时候访问内核栈.当进程被打断的时候信息会存储在用户态栈中.</p><p>总之,一个进程有控制流,什么时候控制CPU,还有数据流,对于内存和栈的访问.</p><h1 id="2-Trap-Syscall"><a href="#2-Trap-Syscall" class="headerlink" title="2:Trap&amp;Syscall"></a>2:Trap&amp;Syscall</h1><h2 id="中断和系统调用"><a href="#中断和系统调用" class="headerlink" title="中断和系统调用"></a>中断和系统调用</h2><p>在RISC-V中有三种事件会使得CPU放弃对当前执行的程序的运行转而去处理这些事件.</p><ul><li>系统调用,当当前程序执行ecall指令的时候</li><li>异常:指令的执行出现问题,比如说除0等.内部</li><li>中断:当设备传来需要中断的信号.外部</li></ul><p>我们首先先注意到一点就是CPU进入到中断然后从中断中恢复,程序本身是不可查的,也就是说程序并不知道它被中断了,犹如做了一个梦一样,这是非常重要的,就是怎么进入中断,怎么样从中断回来.</p><p>有了这么一个基本的要求,我们可以得到大概的处理思路,基本上来说就是中断首先要进入内核的状态进行处理.并且可以分成4步:RISC-V的CPU首先在硬件层面上作出一些反应,接着就是执行一段汇编代码来进入到内核状态.进入到内核状态后就是一段中断例程,这个程序是所有中断共享的,然后再根据中断的类型不同再进入到不同的中断处理的程序.</p><p>对于中断我们又可以分成三类,对于这三类有不同的做法,分别是内核态中断,用户态中断和时钟中断.对于处理中断的程序,我们一般称为handler.</p><h2 id="RISC-V硬件"><a href="#RISC-V硬件" class="headerlink" title="RISC-V硬件"></a>RISC-V硬件</h2><p>首先RISC-V有几个处理中断的硬件结构:</p><ul><li><code>stvec</code>寄存器:存储中断处理程序(例程)的第一条指令,当中断发生的时候RISC-V的CPU会跳转到<code>stvec</code>寄存器对应的地址.这个寄存器也叫中断入口寄存器</li><li><code>sepc</code>寄存器:当中断发生的时候RISC-V CPU会保存当前PC寄存器的值在sepc中.</li><li><code>scause</code>寄存器:表示中断的原因和来源,为什么会发生此中断.</li><li><code>sscratch</code>寄存器:内核会放一个值在这里,这一个值对于中断程序的开始很有用.</li><li><code>sstatus</code>寄存器:设置中断屏蔽的寄存器.</li></ul><p>上述寄存器在U状态下不可读写.并且上述的寄存器还有一个M开头的版本,用于处理M模式下的中断.对于每一个CPU都有一套寄存器来管理程序运行.</p><p>那么硬件具体会做什么呢;</p><ol><li>如果当前中断是设备中断,并且sstatus寄存器内设置了屏蔽,就不做任何事.</li><li>设置sstatus寄存器的值,屏蔽中断.</li><li>把当前PC寄存器的值copy给sepc寄存器.</li><li>保存当前的模式,在sstatus寄存器.</li><li>设置scause,保存中断的原因.</li><li>设置当前状态为S态.</li><li>把stvec寄存器的值给PC.</li><li>转而执行PC寄存器对应的指令.</li></ol><h2 id="用户态的中断"><a href="#用户态的中断" class="headerlink" title="用户态的中断"></a>用户态的中断</h2><p>这里讲述了当执行用户态的代码的时候会发生什么.</p><p>当用户段代码出现了中断现象的时候,首先就会执行<code>uservec</code>-&gt;<code>usertrap</code>-&gt;中断处理 -&gt;<code>usertrapret</code>-&gt;<code>userret</code>.</p><p>对于RISC-V的处理中,主要是内核态空间和用户态空间都维持了页表,但是RISC-V的硬件并没有在中断发生的时候在硬件的层面上更换页表,所以说xv6操作系统需要在处理中断的时候把页表替换成内核的页表,并且这个内核的页表可以与stvec寄存器的值对应,不会发生缺页中断.</p><p>xv6的解决之道就是添加一个trampoline页,trampoline就是以个特殊的页,这个页包含了uservec和userret两部分,并且这个页存在于所有进程的页表,自然也存在于内核态空间下的页表.并且这个页是分配在虚拟地址空间的最后一个部分,所以说很难与用户进程发生冲突.</p><p>这个trampoline页存在于任何一个进程和内核的页表,并且映射的虚拟地址都是一样的,定义在<code>TRAMPOLINE</code>这个C语言宏中.并且stvec这个寄存器存储的地址,就指向trampoline这个页的uservec这个部分,所以说当用户态发生中断的时候,RISC-V硬件处理完之后就可以立刻转化成内核态然后接着运行.因为U态和S态的页表是部分一样的,起码对于trampoline的记录是一样的</p><p>由于stvec寄存器存储了userret的地址,所以中断一开始的时候会进入uservec这个部分执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">      # swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><p>对于中断操作,我们知道我们得把所有的寄存器存放到内存中,但是对于RISC-V的汇编语言,我们还得有一个寄存器来存储应该访问的内存的地址.但是通用寄存器都已经失去了作用了,所以说RISC-V提供一个寄存器叫做sscratch寄存器,这个时候就可以把a0先暂时存储到<code>sscratch</code>寄存器中,然后再把a0从<code>sscratch</code>寄存器中取出.<em>在这里这个寄存器主要是存放了栈帧的首地址,新的栈帧就会存放在<code>sscratch</code>表示的地址中,在原文中提到,在返回到U态时,内核通过设置<code>sscratch</code>寄存器来制定下一次中断时栈帧的地址</em>.</p><p>对于栈帧的处理同样需要页表,在xv6系统中,对于每一个进程我们都会申请一个trapframe页,这个页的虚拟地址永远指定在TRAPFRAME这个地方上.栈帧元素的一系列初始化都是在进程创建的时候都已经保存好了.其实所有进程都会有一个栈帧,并且栈帧的虚拟地址是一样的,但是虚拟地址是一样的由于每个进程的页表又不是一样的,所以说对应的物理地址是不一样的.</p><p>那对于内核态的代码,我们不能通过TRAPFRAME这个虚拟地址来访问进程的栈帧结构,那么我们应该怎么办呢?</p><p>我们看到p-&gt;trapframe的构造过程.首先就是<code>p-&gt;trapframe</code>保存的是kalloc直接分配的物理地址,<code>p-&gt;trapframe = (struct **trapframe** \*)**kalloc**()</code>,直接保存的物理地址.</p><p>对于每一个进程,首先要申请一个页面,然后把这个页面的物理地址保存到p-&gt;trapframe这个结构中,接着每个进程都要调用proc_pagetable函数,执行&#96;<strong>mappages</strong>(pagetable, <strong>TRAPFRAME</strong>, <strong>PGSIZE</strong>, (<strong>uint64</strong>)(p-&gt;trapframe), <strong>PTE_R</strong>  <strong>PTE_W</strong>),把这个物理地址映射到TRAPFRAME这个va中.</p><p>所以说对于每个进程,在用户态访问trapframe都是访问TRAPFRAME这个va,由于每个进程的页表映射不同导致最后的实际物理地址不同.</p><p>综上所述:内核使用p-&gt;trapframe保存的物理地址访问栈帧结构,所有的用户态程序使用TRAPFRAME这个同样的虚拟地址访问栈帧结构,但是由于页表不同导致访问的实际物理地址不一样.</p><p>最后就是进程进入到内核态,访问p-&gt;trapframe就是物理地址,就不会访问TRAPFRAME这个虚拟地址</p><p>由于栈帧已经保存好了内核栈的地址,内核页表的地址,以及CPU的核号,所以说接下来的操作就是读取栈帧,读取内核栈地址,内核页表的地址以及下一个trap函数的入口地址.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">usertrap(void)</span><br><span class="line">&#123;</span><br><span class="line">  int which_dev = 0;</span><br><span class="line"></span><br><span class="line">  if((r_sstatus() &amp; SSTATUS_SPP) != 0)</span><br><span class="line">    panic(&quot;usertrap: not from user mode&quot;);</span><br><span class="line"></span><br><span class="line">  // send interrupts and exceptions to kerneltrap(),</span><br><span class="line">  // since we&#x27;re now in the kernel.</span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line">  </span><br><span class="line">  // save user program counter.</span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  if(r_scause() == 8)&#123;</span><br><span class="line">    // system call</span><br><span class="line"></span><br><span class="line">    if(p-&gt;killed)</span><br><span class="line">      exit(-1);</span><br><span class="line"></span><br><span class="line">    // sepc points to the ecall instruction,</span><br><span class="line">    // but we want to return to the next instruction.</span><br><span class="line">    p-&gt;trapframe-&gt;epc += 4;</span><br><span class="line"></span><br><span class="line">    // an interrupt will change sstatus &amp;c registers,</span><br><span class="line">    // so don&#x27;t enable until done with those registers.</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; else if((which_dev = devintr()) != 0)&#123;</span><br><span class="line">    // ok</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;usertrap(): unexpected scause %p pid=%d\\n&quot;, r_scause(), p-&gt;pid);</span><br><span class="line">    printf(&quot;            sepc=%p stval=%p\\n&quot;, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(p-&gt;killed)</span><br><span class="line">    exit(-1);</span><br><span class="line"></span><br><span class="line">  // give up the CPU if this is a timer interrupt.</span><br><span class="line">  if(which_dev == 2)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>trap.c()</code>中的<code>usertrap</code>函数,这个时候就已经进入内核态了,首先第一步就是对<code>stvec</code>寄存器进行修改,因为对于用户态和内核态发生中断,进入的中断程序还是不一样的,然后接着在<code>trapframe</code>里面保存<code>sepc</code>寄存器(就是中断的断点),因为有可能调用yield(),所以说保存断点非常有必要.如果trap是<code>syscall</code>的话,接着就调用syscall函数即可,如果是设备故障的话,就先保存设备的编号,如果不是设备中断的话就是指令的异常这个时候就退出就可以了.如果是时钟中断<code>(which_dev==2)</code>就处理一下.</p><p>这个就是中断处理,对于不同类型的中断有不同的处理,处理完之后就要返回U态了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">usertrapret(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  // we&#x27;re about to switch the destination of traps from</span><br><span class="line">  // kerneltrap() to usertrap(), so turn off interrupts until</span><br><span class="line">  // we&#x27;re back in user space, where usertrap() is correct.</span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  // send syscalls, interrupts, and exceptions to trampoline.S</span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  // set up trapframe values that uservec will need when</span><br><span class="line">  // the process next re-enters the kernel.</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process&#x27;s kernel stack</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()</span><br><span class="line"></span><br><span class="line">  // set up the registers that trampoline.S&#x27;s sret will use</span><br><span class="line">  // to get to user space.</span><br><span class="line">  </span><br><span class="line">  // set S Previous Privilege mode to User.</span><br><span class="line">  unsigned long x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode</span><br><span class="line">  x = SSTATUS_SPIE; // enable interrupts in user mode</span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  // set S Exception Program Counter to the saved user pc.</span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  // tell trampoline.S the user page table to switch to.</span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  // jump to trampoline.S at the top of memory, which </span><br><span class="line">  // switches to the user page table, restores user registers,</span><br><span class="line">  // and switches to user mode with sret.</span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((void (\*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先第一步就是调用usertrapret函数,这个函数首先第一步就是做stvec寄存器的写入,回忆一下:一开始在进入内核的时候为了防止内核出现中断就把stvec寄存器改成<code>kerbelvec</code>,现在要返回U态了就把中断入口改成uservec即可.然后就是处理栈帧了,把内核页表地址,内核栈和usertrap地址,CPU核号保存进去.接着就是改变status寄存器的数值,改成用户态的寄存器,然后调取断点地址,把断点地址写到sepc寄存器里面(<em>这样子就是进入内核态保存用户态断点,退出内核态的时候把断点进行加载,防止内核态也出现中断</em>),接着切换页表,切换到用户态的页表,然后接着跳转到userret函数中.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p>这个时候会进行函数调用,进入userret这个函数之前,TRAPFRAME作为第一个参数,第二个参数就是用户态页表的地址,首先第一步就是加载用户态页表(<em>处理逻辑:先获得satp,再加载到a1寄存器,接着取出来</em>),接着就是把栈帧中存储的寄存器值全部加载到真实的寄存器中,最后一步就是把栈帧头部的虚拟地址保存到sscratch寄存器,下一次执行中断操作的时候就可以直接读取sscratch寄存器的内容确定栈帧的地址.</p><p>最后执行sret,把sepc寄存器的内容给pc,转换为U态,中断结束</p><p>总结下来: 导出保存在寄存器的栈帧首虚拟地址-&gt;把寄存器保存到trapframe中-&gt;加载内核态页表-&gt;存储断点-&gt;执行中断处理-&gt;加载断点-&gt;加载用户态页表-&gt;把trapframe的内容加载到真实的寄存器-&gt;把栈帧首地址放入寄存器中.</p><p>其实内核可以修改trapframe中的寄存器值,在中断结束后再把栈帧的值加载到真实的寄存器中.</p><h2 id="调用系统函数"><a href="#调用系统函数" class="headerlink" title="调用系统函数."></a>调用系统函数.</h2><p>我们接着第二章来说,在执行userinit函数之后,就执行initcode.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\\0&quot;</span><br><span class="line"></span><br><span class="line"># char \*argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>这是一个标准的调用系统调用的样本,a0~a6存储系统调用需要的参数,a7传递了系统调用号,表示执行何种系统调用,传递完参数后就执行ecall.ecall是一个硬件指令,会把状态调整为S态然后执行uservec函数,接着就是我们熟知的trap处理函数.</p><p>在syscall()函数中,我们可以知道这个函数根据a7寄存器表示的系统调用号来找到函数指针然后进行调用,这里构思很巧妙,就是构建系统调用函数指针来进行跳转.</p><p>接着返回的时候就把返回值传递给a0寄存器.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static uint64 (\*syscalls[])(void) = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line">//系统调用号,系统调用函数</span><br><span class="line">void</span><br><span class="line">syscall(void)</span><br><span class="line">&#123;</span><br><span class="line">  int num;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;%d %s: unknown sys call %d\\n&quot;,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统调用的参数"><a href="#系统调用的参数" class="headerlink" title="系统调用的参数."></a>系统调用的参数.</h2><p>系统调用会传递参数进入,对于RISC-V来说,朴素的思想就是把参数传递到寄存器中,然后系统调用函数读取存储在寄存器中的数据,比如说argint和atgaddr,argfd等.</p><p>对于直接传递的参数,我们可以直接读取没有大问题,但是对于传递指针的参数,我们就需要进行额外的处理,第一个问题呢就是我们不知道程序是不是友好的,有可能用户程序通过传递地址来修改内核的内存,这样就导致了不安全的情况的发生.第二个问题就是xv6的内核态和用户态页表是不一样的.</p><p>所以说xv6的做法就是对于获得字符串的函数argstr(),去构建一个新的函数fetchstr去安全地获得数据,这个函数就会调用copyinstr()函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">copyinstr(pagetable_t pagetable, char \*dst, uint64 srcva, uint64 max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  int got_null = 0;</span><br><span class="line"></span><br><span class="line">  while(got_null == 0 &amp;&amp; max &gt; 0)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    if(pa0 == 0)</span><br><span class="line">      return -1;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    if(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line"></span><br><span class="line">    char \*p = (char \*) (pa0 + (srcva - va0));</span><br><span class="line">    while(n &gt; 0)&#123;</span><br><span class="line">      if(\*p == &#x27;\\0&#x27;)&#123;</span><br><span class="line">        \*dst = &#x27;\\0&#x27;;</span><br><span class="line">        got_null = 1;</span><br><span class="line">        break;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        \*dst = \*p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  if(got_null)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会从pagetable这个页表对应的虚拟地址srcva处copy max字节的元素到内核页表的dst处.做法就是调用walkaddr来找到pagetable中srcva对应的物理地址,然后从这个物理地址中拷贝字节到dst中,由于现在是S态,所以说页表是内核态对应的页表,所以说提取用户态地址上的数据要查找用户态页表,然后把数据存放到内核态的地址就直接查询内核态页表就可以了.</p><p>总体的思路就是,找到这个用户态虚拟地址对应的物理地址,取出这个物理地址上的元素,给到dst(内核态虚拟地址).</p><h2 id="内核态引发的中断"><a href="#内核态引发的中断" class="headerlink" title="内核态引发的中断"></a>内核态引发的中断</h2><p>在内核态引发中断,由于stvec寄存器已经发生了改变,所以进入的中断程序已经是kernelvec这个程序了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br></pre></td></tr></table></figure><p>但是由于已经在内核态了,所以说就不需要切换堆栈,也不需要切换页表,也不需要构建trapframe了,直接把寄存器的数值存到堆栈,调用处理内核中断的函数kerneltrap.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">kerneltrap()</span><br><span class="line">&#123;</span><br><span class="line">  int which_dev = 0;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  if((sstatus &amp; SSTATUS_SPP) == 0)</span><br><span class="line">    panic(&quot;kerneltrap: not from supervisor mode&quot;);</span><br><span class="line">  if(intr_get() != 0)</span><br><span class="line">    panic(&quot;kerneltrap: interrupts enabled&quot;);</span><br><span class="line"></span><br><span class="line">  if((which_dev = devintr()) == 0)&#123;</span><br><span class="line">    printf(&quot;scause %p\\n&quot;, scause);</span><br><span class="line">    printf(&quot;sepc=%p stval=%p\\n&quot;, r_sepc(), r_stval());</span><br><span class="line">    panic(&quot;kerneltrap&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // give up the CPU if this is a timer interrupt.</span><br><span class="line">  if(which_dev == 2 &amp;&amp; myproc() != 0 &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  // the yield() may have caused some traps to occur,</span><br><span class="line">  // so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kerneltrap就只用处理两种类型的中断了,分别是设备I&#x2F;O和指令执行错误.在这里和usertrap其实是一样的,先获得设备号,如果设备号没有,那就是指令执行错误,打出错误信息</p><p>当然也是一样yiled()执行完了之后会导致其他进程执行,其他进程的时候会继续引发中断,所以说朴素的思想就是把sepc保存下来,再最后中断返回的时候把保存的sepc写入即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        // not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p>最后返回的时候也是只需要把寄存器取出来即可.</p><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>当访问一个va,但是页表中没有对应的pa的时候,就会引发缺页中断,系统会处理这个缺页中断或者退出执行,或者分配一个新的页给这个进程.</p><h1 id="3-Memory-Pagetable"><a href="#3-Memory-Pagetable" class="headerlink" title="3: Memory&amp;Pagetable"></a>3: Memory&amp;Pagetable</h1><h2 id="分页的硬件"><a href="#分页的硬件" class="headerlink" title="分页的硬件"></a>分页的硬件</h2><p>RISC-V的指令(包括用户态下的或者内核态下的)里面的地址操作数其实代表了虚拟地址.但是对应地,RAM或者叫做物理内存,自然也有物理地址,物理地址真实唯一地标记实际内存空间,可能RAM的第10006个区块地址就是0x10006.所以说就有页表这个东西,把指令提供的逻辑地址转化到实际内存的物理地址.</p><p>xv6会运行RISC-V支持的Sv39架构,页表是一个连接虚拟地址和实际的物理地址的一个桥梁,CPU给页表一个虚拟地址,页表会返回一个物理地址.</p><p>其中虚拟地址分成两部分,低12位就是offset,代表一个页有​大,中间的27位是index值,负责寻找到对应的表项位置,比如说如果index&#x3D;5就代表要找到第五个表项.后面的25位不需要.页表的每一项对应44位的PPN和10位的flags.其中flags标记这一项的一些控制信息,PPN则和offset一块组成物理地址.虚拟地址是​的空间,而物理地址是​.</p><p>总的来说是分三步走.</p><ul><li>虚拟地址分成index和Offset两部分.</li><li>找到页表中的第index项.获取其中的PPN和flags</li><li>PPN和虚拟地址的Offset组成物理地址.</li></ul><p>页表给OS给操作系统提供了va和pa互换的途径,其中内存被划分成4KB的块,我们称之为页.</p><p>实际的操作可能更加复杂,SV39维护的是一个多级页表.虚拟地址转化为物理地址需要分三步走.</p><p>首先我们发现页表是三级结构,第一层页表的首地址保存在satp寄存器中,有512个表项,其中表项存储着下一级页表(第二层)的首地址.第二级页表也是由512个表项组成,其中每一个表项存着下一级页表(第三层)的首地址.第三级页表里面存储的就是对应的物理地址的PPN.</p><p>所以说va分成L2,L1,L0和Offset分成四部分.</p><ul><li>首先在第一级页表中找到第L2个表项,这样就找到第二级页表的首地址.</li><li>然后在第二级页表中找到第L1个表项,这样就找到第三级页表的首地址.</li><li>最后在第三级页表中找到第L0个表项,这样就能获取到PPN,然后拿PPN和offset组合在一起就可以了.</li><li>如果在任何一次寻找的时候Flags显示这个页表项不可用,那么就引发缺页中断.</li></ul><p>三级页表非常好用而别比较高效,因为一开始的时候我们不需要要那么大的空间存放页表,我们可以边运行程序遍扩充页表的大小.</p><p>但是CPU这样去访问页表需要3次访存指令.这样子访问就很慢,所以说CPU设计了一个类似于cache的东西来保存页表信息,这个表叫做TLB.CPU首先会在TLB中查找页表元素.如果TLB miss了才会调用访存操作来获取页表元素.</p><p>每一个页表都都存储了flag位,其中PTE_V存着这个页表项究竟是不是可用的.PTE_W表示指令是否可以往这个页是否可写,PTE_X表示这个页是否可执行,PTE_U表示在用户态下是否可以访问这一页.</p><p>在硬件层面上我们必须指定第一级页表的首地址,这个页表首地址存放在<code>satp</code>寄存器中,由于这个是CPU,所以说不同CPU的satp寄存器的值都是不一样的.我们还知道每个进程的第一级页表的首地址也是不一样的(每个进程都有不同的页表记录地址).这为每个CPU运行不同的进程提供了一句.</p><p>我们的用户程序在虚拟内存上进行读写,提供的地址也是虚拟地址,虚拟内存其实就是由许多的实际的DRAM(存储器件)组成的虚拟化而已.</p><h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p>xv6对每个进程都维护了一份页表(<strong>每个进程都有一个页表</strong>),来表示不同进程的虚拟地址空间.当然xv6也会给内核态地址空间维护一个页表,也就是说xv6的地址空间&#x3D;若干个用户态进程的地址空间+内核地址空间.</p><p>QEMU会模拟一个RAM(物理存储器),这个存储器的地址空间是0x80000000~0x86400000.在xv6系统中称为PHYSTOP.QEMU还把各种I&#x2F;O设备,比如说磁盘等的地址映射到0x80000000的地址之下,xv6操作系统可以通过直接访问这些物理地址来操控这些设备(比如说访问0x10001000来访问VIRTIO disk),而不是通过访问RAM来间接地访问设备.</p><p>内核通过直接访问映射来访问RAM和上文提到的设备,也就是说程序提到的虚拟地址&#x3D;物理地址.(也就是说,xv6访问内存和设备是bare linking的,物理地址就是虚拟地址,同样地,在页表中,对应的虚拟地址&#x3D;物理地址).</p><p>当然内核用户状态下也有不是直接链接的比如说<code>trampoline</code>页(看syscall&amp;trap一章)和内核态栈(若干个内核态栈之间有一个Guard页)不是直接连的.</p><h2 id="如何创建一个地址空间"><a href="#如何创建一个地址空间" class="headerlink" title="如何创建一个地址空间?"></a>如何创建一个地址空间?</h2><p>所有的xv6关于地址的处理全部放在<code>vm.c</code>这个文件中.</p><p>最关键的就是数据结构就是<code>pagetable_t</code>这个数据结构,这个数据结构本质上就是一个<code>uint64*</code>类型的一个指针,这个代表了第一级页表的首地址.可以是用户进程页表的首地址,也可以是内核页表的首地址.</p><p>最重要的函数有<code>walk</code>,这个函数负责给定一个va,然后找到对应的PTE.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">pte_t \*  </span><br><span class="line">walk(pagetable_t pagetable, uint64 va, int alloc)  </span><br><span class="line">&#123;  </span><br><span class="line"> if(va &gt;= MAXVA)  </span><br><span class="line">   panic(&quot;walk&quot;);  </span><br><span class="line">​  </span><br><span class="line"> for(int level = 2; level &gt; 0; level--) &#123;  </span><br><span class="line">   pte_t \*pte = &amp;pagetable[PX(level, va)];  </span><br><span class="line">   if(\*pte &amp; PTE_V) &#123;  </span><br><span class="line">     pagetable = (pagetable_t)PTE2PA(\*pte);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">     if(!alloc  (pagetable = (pde_t\*)kalloc()) == 0)  </span><br><span class="line">       return 0;  </span><br><span class="line">     memset(pagetable, 0, PGSIZE);  </span><br><span class="line">     \*pte = PA2PTE(pagetable)  PTE_V;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> return &amp;pagetable[PX(0, va)];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int  </span><br><span class="line">mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)  </span><br><span class="line">&#123;  </span><br><span class="line"> uint64 a, last;  </span><br><span class="line"> pte_t \*pte;  </span><br><span class="line">​  </span><br><span class="line"> if(size == 0)  </span><br><span class="line">   panic(&quot;mappages: size&quot;);  </span><br><span class="line">   </span><br><span class="line"> a = PGROUNDDOWN(va);  </span><br><span class="line"> last = PGROUNDDOWN(va + size - 1);  </span><br><span class="line"> for(;;)&#123;  </span><br><span class="line">   if((pte = walk(pagetable, a, 1)) == 0)  </span><br><span class="line">     return -1;  </span><br><span class="line">   if(\*pte &amp; PTE_V)  </span><br><span class="line">     panic(&quot;mappages: remap&quot;);  </span><br><span class="line">   \*pte = PA2PTE(pa)  perm  PTE_V;  </span><br><span class="line">   if(a == last)  </span><br><span class="line">     break;  </span><br><span class="line">   a += PGSIZE;  </span><br><span class="line">   pa += PGSIZE;  </span><br><span class="line">&#125;  </span><br><span class="line"> return 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)  </span><br><span class="line">&#123;  </span><br><span class="line"> if(mappages(kpgtbl, va, sz, pa, perm) != 0)  </span><br><span class="line">   panic(&quot;kvmmap&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line">pagetable_t  </span><br><span class="line">kvmmake(void)  </span><br><span class="line">&#123;  </span><br><span class="line"> pagetable_t kpgtbl;  </span><br><span class="line">​  </span><br><span class="line"> kpgtbl = (pagetable_t) kalloc();  </span><br><span class="line"> memset(kpgtbl, 0, PGSIZE);  </span><br><span class="line">​  </span><br><span class="line"> // uart registers  </span><br><span class="line"> kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R  PTE_W);  </span><br><span class="line">​  </span><br><span class="line"> // virtio mmio disk interface  </span><br><span class="line"> kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R  PTE_W);  </span><br><span class="line">​  </span><br><span class="line"> // PLIC  </span><br><span class="line"> kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R  PTE_W);  </span><br><span class="line">​  </span><br><span class="line"> // map kernel text executable and read-only.  </span><br><span class="line"> kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R  PTE_X);  </span><br><span class="line">​  </span><br><span class="line"> // map kernel data and the physical RAM we&#x27;ll make use of.  </span><br><span class="line"> kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R  PTE_W);  </span><br><span class="line">​  </span><br><span class="line"> // map the trampoline for trap entry/exit to  </span><br><span class="line"> // the highest virtual address in the kernel.  </span><br><span class="line"> kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R  PTE_X);  </span><br><span class="line">​  </span><br><span class="line"> // map kernel stacks  </span><br><span class="line"> proc_mapstacks(kpgtbl);  </span><br><span class="line">   </span><br><span class="line"> return kpgtbl;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">kvminithart()  </span><br><span class="line">&#123;  </span><br><span class="line"> w_satp(MAKE_SATP(kernel_pagetable));  </span><br><span class="line"> sfence_vma();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">kinit()  </span><br><span class="line">&#123;  </span><br><span class="line"> initlock(&amp;kmem.lock, &quot;kmem&quot;);  </span><br><span class="line"> freerange(end, (void\*)PHYSTOP);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line">void \*  </span><br><span class="line">kalloc(void)  </span><br><span class="line">&#123;  </span><br><span class="line"> struct run \*r;  </span><br><span class="line">​  </span><br><span class="line"> acquire(&amp;kmem.lock);  </span><br><span class="line"> r = kmem.freelist;  </span><br><span class="line"> if(r)  </span><br><span class="line">   kmem.freelist = r-&gt;next;  </span><br><span class="line"> release(&amp;kmem.lock);  </span><br><span class="line">​  </span><br><span class="line"> if(r)  </span><br><span class="line">   memset((char\*)r, 5, PGSIZE); // fill with junk  </span><br><span class="line"> return (void\*)r;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">kfree(void \*pa)  </span><br><span class="line">&#123;  </span><br><span class="line"> struct run \*r;  </span><br><span class="line">​  </span><br><span class="line"> if(((uint64)pa % PGSIZE) != 0  (char\*)pa &lt; end  (uint64)pa &gt;= PHYSTOP)  </span><br><span class="line">   panic(&quot;kfree&quot;);  </span><br><span class="line">​  </span><br><span class="line"> // Fill with junk to catch dangling refs.  </span><br><span class="line"> memset(pa, 1, PGSIZE);  </span><br><span class="line">​  </span><br><span class="line"> r = (struct run\*)pa;  </span><br><span class="line">​  </span><br><span class="line"> acquire(&amp;kmem.lock);  </span><br><span class="line"> r-&gt;next = kmem.freelist;  </span><br><span class="line"> kmem.freelist = r;  </span><br><span class="line"> release(&amp;kmem.lock);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int  </span><br><span class="line">growproc(int n)  </span><br><span class="line">&#123;  </span><br><span class="line"> uint sz;  </span><br><span class="line"> struct proc \*p = myproc();  </span><br><span class="line">​  </span><br><span class="line"> sz = p-&gt;sz;  </span><br><span class="line"> if(n &gt; 0)&#123;  </span><br><span class="line">   if((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == 0) &#123;  </span><br><span class="line">     return -1;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; else if(n &lt; 0)&#123;  </span><br><span class="line">   sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);  </span><br><span class="line">&#125;  </span><br><span class="line"> p-&gt;sz = sz;  </span><br><span class="line"> return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sbrk是一个系统调用,这个调用帮助我们实现进程内存空间的增长和消亡.</p><h2 id="sbrk系统调用"><a href="#sbrk系统调用" class="headerlink" title="sbrk系统调用?"></a>sbrk系统调用?</h2><p>同样,为了防止栈溢出,我们有一个guard page来保护.</p><p>stack页是一个页,然后里面的参数是由exec程序创建的,有各种参数以及参数的地址.还有main执行完PC的返回值.</p><p>其中trapframe这个页是映射到可用物理空间的,在kernel态是直接映射的,所以说不用担心kernel态访问不了用户态的kernel.</p><p>第一:一个用户进程只使用一张页表,不同的用户进程的物理地址是相互隔离的不会被打扰的.第二,用户看见的虚拟地址是连续的但其实物理地址不是连续的,这样加大了分配的灵活性.第三,trampoline页是所有用户通用的,也就是说每个用户的页表一定有一个MAXVA-PGSIZE-&gt;trampoline的映射.</p><p>用户地址空间是从0~MAXVA的.然后当用户程序需要更多的内存的时候,xv6就会使用kalloc来获取新的页,然后接着建立pa和va的关系(和内核是一样的).对于虚拟地址,如果用户进程暂时不需要使用,就可以把页表的PTE_V置0表示不需要使用.</p><h2 id="用户进程地址空间"><a href="#用户进程地址空间" class="headerlink" title="用户进程地址空间."></a>用户进程地址空间.</h2><p>同样,在释放的时候,也是获得这个释放的物理块地址,把它放到freelist的队首中.</p><p>在<code>kalloc.c</code>中我们知道,每次申请都会调用一次kalloc函数.kalloc函数每一次从freelist中取出一块来进行返回.这个freelist已经在kinit函数中初始化好了,就是从end(内核态空间的占用的最后一个地址)到PHYSTOP这个区域内.</p><h2 id="如何申请物理块"><a href="#如何申请物理块" class="headerlink" title="如何申请物理块?"></a>如何申请物理块?</h2><p>我们知道TLB会存储一些页表信息,CPU同样也会切换进程,切换进程的时候我们不想让下一个进程知道我们的页表信息,这个时候就会调用sfence_vma()函数来对TLB的内容进行一次部分刷新.</p><p>这个时候这个函数会把<code>kernel_pagetable</code>写进satp寄存器中,这个时候页表正式进入工作,之后的地址就是需要页表一级的转化,并且当前页表的第一级首地址就是<code>kernel_pagetable</code>.</p><p>在S态的main函数执行了<code>kvminithart</code>函数来初始化了内核态页表.</p><p>上面的所有函数实现的基础就是在bare linking上面的,也就是说执行的情况中虚拟地址&#x3D;物理地址,我们才可以方便地访问和处理.</p><p>进行了若干次的虚拟地址和物理地址的映射,这个时候最后一步就是调用<code>proc_mapstacks</code>.对每一个进程都分配了一个内核栈.然后也调用了<code>kvmmap</code>来进行地址的映射.最后返回一个内核态页表.</p><p>在操作系统初始化的时候,就调用<code>kvminit</code>函数对内存空间进行初始化,<code>kvminit</code>调用了<code>kvmmake</code>函数.<code>kvmmake</code>又调用了若干个<code>kvmmap</code>函数.在调用这一段函数的时候,xv6还没有开启份页功能,所以说在这一部分执行的指令可以直接访问物理内存.<code>kvmmake</code>函数首先申请物理内存的一页作为内核态页表的一页.然后接着调用<code>kvmmap</code>函数在kernel态的页表中添加对于若干个虚拟地址的映射.</p><p>然后又copyout和copyin,这个函数可以从用户态的虚拟地址中获取信息传递给内核态.</p><p>给定va和pa,然后添加va和pa的连接,放入页表中,这个时候va和pa正式有了联系.</p><p>还有一个就是mappages.这个函数负责添加页表项,就是给页表添加一项,让一段虚拟地址和一段物理地址进行匹配.</p><p>这个函数是不是跟我们之前说的读法是一样的,三层的页表就需要我们去读三次,有哪一次发现Valid位(PTE_V不对)就返回为0,然后申请一个新页即可.</p><h1 id="4-Interrupt-Device-Manage"><a href="#4-Interrupt-Device-Manage" class="headerlink" title="4:Interrupt&amp;Device Manage"></a>4:Interrupt&amp;Device Manage</h1><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>一个设备驱动程序就是操作系统对特定的设备进行管理的程序,这些程序让设备执行操作,并且处理设备引起的中断,并且与因为设备I&#x2F;O而被阻塞的进程.设备驱动程序往往非常难设计,因为设备和设备驱动程序是一起工作的,而且编写设备驱动程序需要对硬件接口有着深入的了解,这一点往往非常难.</p><p>设备会通过引发中断来通知操作系统进行处理,在中断的那一部分我们说过,操作系统通过识别中断来源来判断这是个设备中断,然后调用设备中断处理程序.其中函数会调用<code>devintr</code>这个函数来获取究竟是什么设备发生了中断.</p><p>许多设备中断的程序一般分成两个部分,第一个部分在进程的内核态执行,一般来说用户程序会执行read和write调用以希望从设备中获取一些信息.这一部分的内容可能负责把用户的请求传送给设备,让设备执行用户的请求.第二个部分就是设备中断处理,这一部分一般是设备处理完用户的请求,处理完之后设备会向操作系统发送一个中断请求,这一部分的代码就是用来处理设备的中断请求的,把结果传递给用户程序并唤醒相关的进程.</p><h2 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h2><p>关于控制台,关于控制台的一些代码存放到了<code>console.c</code>这个文件中,控制台驱动程序可以接受用户输入的字符,通过UART这个特殊的硬件.控制台驱动程序一次性获得一行输入,用户进程,比如说shell程序会通过read这个系统调用来获得控制台输入.综合起来就是</p><p>QEMU模拟的UART硬件-&gt;操作系统的内核-&gt;用户程序的read系统调用.</p><p>在实际的电脑中,16550芯片会管理RS232这个串行链路来连接到其他终端,在QEMU中,这个模拟的芯片连接你的键盘和屏幕.</p><p>对于操作系统(软件)来说:我们可以像访问内存一样来访问UART硬件,在之前内存管理的时候我们已经提到了,我们可以通过访问UART0这个地址来像访问内存一样来访问设备.在UART设备中存储了许多寄存器数据,操作系统可以通过UART0地址+偏移来访问寄存器数据.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define RHR 0                 // receive holding register (for input bytes)</span><br><span class="line">#define THR 0                 // transmit holding register (for output bytes)</span><br><span class="line">#define IER 1                 // interrupt enable register</span><br><span class="line">#define IER_RX_ENABLE (1&lt;&lt;0)</span><br><span class="line">#define IER_TX_ENABLE (1&lt;&lt;1)</span><br><span class="line">#define FCR 2                 // FIFO control register</span><br><span class="line">#define FCR_FIFO_ENABLE (1&lt;&lt;0)</span><br><span class="line">#define FCR_FIFO_CLEAR (3&lt;&lt;1) // clear the content of the two FIFOs</span><br><span class="line">#define ISR 2                 // interrupt status register</span><br><span class="line">#define LCR 3                 // line control register</span><br><span class="line">#define LCR_EIGHT_BITS (3&lt;&lt;0)</span><br><span class="line">#define LCR_BAUD_LATCH (1&lt;&lt;7) // special mode to set baud rate</span><br><span class="line">#define LSR 5                 // line status register</span><br><span class="line">#define LSR_RX_READY (1&lt;&lt;0)   // input is waiting to be read from RHR</span><br><span class="line">#define LSR_TX_IDLE (1&lt;&lt;5)    // THR can accept another character to send</span><br></pre></td></tr></table></figure><p>首先xv6的S态的main函数会调用<code>consoleinit</code>函数.这个函数会初始化UART硬件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">consoleinit(void)</span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, &quot;cons&quot;);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  // connect read and write system calls</span><br><span class="line">  // to consoleread and consolewrite.</span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uartinit()的代码保证了UART在收到每一次键盘输入的时候都会引发中断,然后每一次传输完一整个字符还会送出一个trasmit complete中断.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteReg(IER, IER_TX_ENABLE  IER_RX_ENABLE);</span><br></pre></td></tr></table></figure><p>接着UART硬件也会引发一个中断,trap函数会判断这是什么类型中断,发现是设备引起的中断,就转而调用处理设备中断的函数<code>devintr</code>,接着这个函数通过调用<code>PLIC</code>判断是什么设备引起的中断,发现是UART设备,转而调用<code>uartintr</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">devintr()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  if((scause &amp; 0x8000000000000000L) &amp;&amp;</span><br><span class="line">     (scause &amp; 0xff) == 9)&#123;</span><br><span class="line">    // this is a supervisor external interrupt, via PLIC.</span><br><span class="line"></span><br><span class="line">    // irq indicates which device interrupted.</span><br><span class="line">    int irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    if(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; else if(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; else if(irq)&#123;</span><br><span class="line">      printf(&quot;unexpected interrupt irq=%d\\n&quot;, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // the PLIC allows each device to raise at most one</span><br><span class="line">    // interrupt at a time; tell the PLIC the device is</span><br><span class="line">    // now allowed to interrupt again.</span><br><span class="line">    if(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else if(scause == 0x8000000000000001L)&#123;</span><br><span class="line">    // software interrupt from a machine-mode timer interrupt,</span><br><span class="line">    // forwarded by timervec in kernelvec.S.</span><br><span class="line"></span><br><span class="line">    if(cpuid() == 0)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // acknowledge the software interrupt by clearing</span><br><span class="line">    // the SSIP bit in sip.</span><br><span class="line">    w_sip(r_sip() &amp; ~2);</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//中断处理分成两个部分,前面部分把存储在UART寄存器的键盘输入发送.</span><br><span class="line">void</span><br><span class="line">uartintr(void)</span><br><span class="line">&#123;</span><br><span class="line">  //keyborad-&gt;RHR</span><br><span class="line">  // read and process incoming characters.(处理控制台输入)</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    int c = uartgetc();</span><br><span class="line">    if(c == -1)</span><br><span class="line">      break;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // send buffered characters.(处理控制台输出)</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从uartintr函数中从UART寄存器中获取一个字符,再把字符递交给consoleintr函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">uartgetc(void)</span><br><span class="line">&#123;</span><br><span class="line">  if(ReadReg(LSR) &amp; 0x01)&#123;</span><br><span class="line">    // input data is ready.</span><br><span class="line">    return ReadReg(RHR);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是从LSR寄存器判断,然后从RHR寄存器获得数据.</p><p><code>consoleintr</code>负责把所有UART输入的元素存储起来,存储到<code>cons.buf</code>这个数组中,然后当输入的是换行,就可以唤醒一个正在运行<code>consoleread</code>的进程.这个进程会执行<code>consoleread</code>函数,<code>consoleread</code>函数会读取缓冲区内的数据,然后返回给用户态.</p><p>每一次唤醒,<code>consoleread</code>就是读取一行的元素,然后把数据传递给用户态.</p><p>总结:用户键盘输入-&gt;中断一次-&gt;UART把中断的输入读取出来送到consoleintr-&gt;consointr调用consoleread函数</p><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>read()系统调用能获得用户的键盘输入,write()系统调用可以在控制器中进行输出.</p><p>UART设备每一次从THR寄存器中输出一字节的数据,它就会产生一个中断,和之前一样,<code>uartintr</code>会调用<code>uartstart</code>函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">uartstart()</span><br><span class="line">&#123;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    if(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      // transmit buffer is empty.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if((ReadReg(LSR) &amp; LSR_TX_IDLE) == 0)&#123;</span><br><span class="line">      // the UART transmit holding register is full,</span><br><span class="line">      // so we cannot give it another byte.</span><br><span class="line">      // it will interrupt when it&#x27;s ready for a new byte.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += 1;</span><br><span class="line">    </span><br><span class="line">    // maybe uartputc() is waiting for space in the buffer.</span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次输出一字节的数据都需要看看在缓冲区内有没有其他的数据需要去输出.这个函数就是检查缓冲区内还有没有数据要写,如果要写,就放到THR寄存器中等待去写.</p><p>然后机器就会从THR寄存器中读取要输出的内容,输出成功就触发中断,看看还有没有要要写的内容,有的话就接着放入THR寄存器中.</p><p>特别地,第一个字节会在<code>uartputc</code>这个系统调用中进行输出.其他的字节是通过字节</p><h2 id="设备驱动的并行性"><a href="#设备驱动的并行性" class="headerlink" title="设备驱动的并行性"></a>设备驱动的并行性</h2><p>你会发现,每一次进入<code>consoleread</code>和<code>consoleintr</code>都会获取一个锁,这个锁会保证不可能同时有两个进程执行这个函数,当两个进程同时执行<code>consoleread</code>的时候,有可能会把一整句话分成两部分交付给两个进程,这个是不对的.加上锁可以保证同时只有一个进程进入这个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd abab</span><br><span class="line">process1 :c a</span><br><span class="line">process2 :dabb</span><br></pre></td></tr></table></figure><p>还有一个可能就是一个进程在等待<code>consoleread</code>的结束,另外一个进程正在运行,这个时候执行中断操作可能会把console输入传递给另外一个进程,这个时候我们也需要上一个锁.</p><p>Another way in which concurrency requires care in drivers is that one process may be waiting for input from a device, but the interrupt signaling arrival of the input may arrive when a different process (or no process at all) is running. Thus interrupt handlers are not allowed to think about the process or code that they have interrupted. For example, an interrupt handler cannot safely call copyout with the current process’s page table. Interrupt handlers typically do relatively little work (e.g., just copy the input data to a buffer), and wake up top-half code to do the rest.</p><h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><p>RISC-V的CPU在一定的时间段就会触发一次时钟中断,RISC-V希望时钟中断能在M态处理而不是在S态处理.xv6选择在一个特殊的方法来处理时钟中断.</p><p>在start.c中,我们设置了把所有中断都放在S态进行处理.但是我们在<code>timeinit</code>函数中创建了一个专属于时钟中断的处理模式.主要有几点:</p><ul><li>配置了CLINT硬件,这个硬件会在一定间隔时间触发一次中断.</li><li>配置trapframe,这样可以把通用寄存器的数据放到CLINT寄存器中</li><li>由于M态的中断只有时钟中断,中断向量配置为timevec.</li></ul><p>在M态下的时钟中断处理函数在是<code>timervec</code>:这个保存了一部分寄存器,然后告诉CLINT硬件什么时候产生下一次时钟中断,然后引发一个S态的软件中断.</p><p>在执行用户态或者是内核态的代码的时候都会引发时钟中断,时钟中断尽量不要打扰正在执行关键任务的进程.所以说RISC-V允许引起一个软件中断,这个中断是S态引起的.</p><p>当中断被关闭的时候,说明正在执行很关键的任务,代码可以选择拒绝时钟中断的执行,如果没有关中断,这个软件中断就会打断正在执行的代码,执行时钟中断的操作,放弃对CPU的占用.</p><p>总结:进入M态处理中断-&gt;引发一个S态的中断-&gt;如果执行关键任务,先不管中断,如果不执行关键任务,就放弃对于CPU的占用-&gt;调度给其他进程.</p><h1 id="5-MultiPlexing"><a href="#5-MultiPlexing" class="headerlink" title="5:MultiPlexing"></a>5:MultiPlexing</h1><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在xv6中,我们拥有的进程数往往要比CPU核要多.那么我们通过多路复用来进行调度.我们这个时候多路复用来进行调度.所有的进程共用几个多路复用器,使用的方法一般是时分复用.</p><p>首先xv6当等待设备完成I&#x2F;O或者等待子进程退出的时候,就会使用<code>sleep</code>和<code>wakeup</code>系统调用来切换进程的状态.同时xv6操作系统并不会允许一个进程占用CPU太多时间,当一个进程连续占用CPU一段时间这个进程也会强制改变状态.这个对于进程来说,它被唤醒和打断是无法侦查的.所以说对于一个进程来说相当于占用了属于自己的CPU.</p><p>完成多路复用有一定的挑战,第一点就是如何进行进程的切换,切换CPU的运行状态以及其他部件的状态.第二点,对于用户进程,怎么处理可以让用户进程无法觉察到自己失去了CPU的控制权.这里xv6使用时钟中断来进行切换,(每段时间暂停一遍,进入内核态执行进程切换函数,这样子对于用户进程是透明的).第三点,所有CPU核都会执行一组进程,我们需要设计一个锁结构来防止race的出现.第四点,一个进程的所有内存和其他的资源在进程退出的时候都必须得释放,但是在释放的时候我们很难释放内核态栈.第五点,每一个核都需要知道自己运行进程的序号,否则我们进入内核态的时候不知道使用哪个栈.最后一点,就是sleep和wakeup的系统调用让进程放弃CPU.但是我们需要的注意是在唤醒进程的时候的race现象.</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>在切换进程的时候首先用户态先进入内核态,然后会把上下文信息放入到内核栈,切换到新的进程,然后新的进程的上下文信息会从内核栈中取出,再切换到用户态.每个进程会拥有一个内核态栈,因为多个进程共用一个内核栈是非常危险的.</p><p>保存的信息就是CPU的寄存器的值,同时,恢复也是恢复保存在内核态栈的寄存器值.swtch函数会执行寄存器的保存和提取.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br><span class="line">        </span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br></pre></td></tr></table></figure><p>在这里swtch首先把当前的寄存器信息存放到a0对应的内核栈中,再从a1对应的内核栈中取出数据放到寄存器中.对于这个函数,它并不知道这是什么进程在执行stwch调用.</p><p>现在我们知道context(上下文)的内容了,对于每一个进程和CPU的数据结构都有一部分保存上下文.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Saved registers for kernel context switches.</span><br><span class="line">struct context &#123;</span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  // callee-saved</span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C语言中,a0分别是老进程的context字段的地址,a1是新的进程的context字段的地址.我们发现这里只保存了callee-saved寄存器.但是你会发现,ra寄存器的值被改变了,所以说我知道当函数返回的时候,返回地址改变了,所以说这下pc就变成之前调用swtch的进程调用swtch的PC.这听上去很绕,简单的说就是反悔的PC不是这个进程调用之前的那个PC,而是上个进程调用之前的PC.</p><p>Swtch takes two arguments: struct context *old and struct context *new. It saves the current registers in old, loads registers from new, and returns.</p><p>我们回到之前的代码,在trap中最后调用了yield函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">yield(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先yield函数讲当前进程的状态改成“可执行”,接着又调用sched()函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">sched(void)</span><br><span class="line">&#123;</span><br><span class="line">  int intena;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  if(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(&quot;sched p-&gt;lock&quot;);</span><br><span class="line">  if(mycpu()-&gt;noff != 1)</span><br><span class="line">    panic(&quot;sched locks&quot;);</span><br><span class="line">  if(p-&gt;state == RUNNING)</span><br><span class="line">    panic(&quot;sched running&quot;);</span><br><span class="line">  if(intr_get())</span><br><span class="line">    panic(&quot;sched interruptible&quot;);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断各种情况,这个不是特别重要,重要的是我执行了swtch函数,这个函数会把当前进程的上下文保存,然后把scheduler()的上下文拿出来开始执行中间的调度过程.这个调度过程是每个CPU都特有的调度过程,其上下文存放在cpu的context里面,这个context区间每个CPU核都有一个.这下返回的地址不是sched()函数而是scheduler()函数了.也就是说这个地方很巧妙地改变ra寄存器让程序的返回地址改变,返回的是调度函数.这种思路只改变了部分上下文就可以改变运行的程序,非常妙.(最重要的是每个CPU一个防止race现象)</p><h2 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h2><p>现在完成了第一步,从原进程到调度程序,对于第一步,都是先获得进程的锁,然后更改进程的状态然后调用sched,这个对于sleep还是yiled还是exit都是一样.sched函数会进行一定的检查,然后最后sched会调用swtch转移到scheduler函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">scheduler(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p;</span><br><span class="line">  struct cpu \*c = mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = 0;</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    // Avoid deadlock by ensuring that devices can interrupt.</span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      if(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        // Switch to chosen process.  It is the process&#x27;s job</span><br><span class="line">        // to release its lock and then reacquire it</span><br><span class="line">        // before jumping back to us.</span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        // Process is done running for now.</span><br><span class="line">        // It should have changed its p-&gt;state before coming back.</span><br><span class="line">        c-&gt;proc = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着根据scheduler的返回地址开始执行,首先这个函数是一个永远循环下去的循环,接着把上一次调用swtch进程的锁给释放了.你会发现这个十分巧妙,因为进程之间的解锁和上锁是通过swtch实现的,swtch的调用者已经有了锁,接着这个锁传递给scheduler.</p><p>由于scheduler是<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>开始执行的,所以说第一步就是标记CPU正在运行的进程,把这个进程改成0(NULL),然后再来释放这个锁.(因为当前上锁的进程一定是上一次进入的进程.)这个时候在sched()上的锁,在scheduler()释放.在scheduler()获得的锁,在sched()释放因为这是一个回环.这个时候你可以认为scheduler和sched是一个回环.当然也不绝对,因为当新的进程第一次运行的时候,返回是从forkret函数返回的,这个是在frok函数一开始就已经设定好的.第一次运行执行forkret函数,然后通过usertrapret返回到用户态.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">forkret(void)</span><br><span class="line">&#123;</span><br><span class="line">  static int first = 1;</span><br><span class="line"></span><br><span class="line">  // Still holding p-&gt;lock from scheduler.</span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line"></span><br><span class="line">  if (first) &#123;</span><br><span class="line">    // File system initialization must be run in the context of a</span><br><span class="line">    // regular process (e.g., because it calls sleep), and thus cannot</span><br><span class="line">    // be run from main().</span><br><span class="line">    first = 0;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduler运行一个永远运行的循环,首先找到一个可以运行的进程,一直运行直到调用yield()函数,这个可以运行的定义就是p-&gt;state&#x3D;&#x3D;RUNNABLE.每一次找到可以运行的进程,都会把这个进程的进程信息放到当前cpu的结构体里面,标记为RUNNING.</p><p>首先我们知道,当一个进程的状态是RUNNING,我们可以安全地保存这个进程的上下文,因为现在这个CPU的寄存器是属于某个进成的寄存器,还有一个就是挑选属于RUNNABLE的进程它也是为了防止出现问题.</p><p>由于要保存进程的状态,所以说这就是为什么xv6需要给处理进程的代码上锁了,就是因为进程状态这个变量就是临界变量,这块代码是临界区</p><h2 id="当前的CPU和进程信息"><a href="#当前的CPU和进程信息" class="headerlink" title="当前的CPU和进程信息."></a>当前的CPU和进程信息.</h2><p>我们需要记录当前的进程指针来获取信息,一般来说,如果你的机器是一个核的,我们可以设置一个全局变量,但是我们的机器是多核的,每个核执行不同的进程,这个方案就有一定的问题.</p><p>所以说xv6维护一个结构体叫做CPU,这个CPU存储着当前CPU核正在运行什么核.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Per-CPU state.</span><br><span class="line">struct cpu &#123;</span><br><span class="line">  struct proc \*proc;          // The process running on this cpu, or null.</span><br><span class="line">  struct context context;     // swtch() here to enter scheduler().</span><br><span class="line">  int noff;                   // Depth of push_off() nesting.</span><br><span class="line">  int intena;                 // Were interrupts enabled before push_off()?</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体存放着scheduler的上下文,以及当前运行的进程.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct cpu\*</span><br><span class="line">mycpu(void) &#123;</span><br><span class="line">  int id = cpuid();</span><br><span class="line">  struct cpu \*c = &amp;cpus[id];</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">cpuid()</span><br><span class="line">&#123;</span><br><span class="line">  int id = r_tp();</span><br><span class="line">  return id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候可以获得cpuid以及对应的结构体.因为CPU的核号是存放在tp寄存器的.在mstart中,就是在启动的时候已经把CPU的核号已经送入到tp寄存器中了,在M-mode的时候,usertrapret把tp寄存器保存在trapoline寄存器中.并且编译器永远不会把tp寄存器改变,所以说我们可以很方便地获得cpu核的id值.</p><p>当然,为了保证CPU返回不会被时钟中断打扰,调用这个函数要求使用cpu结构体的时候关闭中断,当使用完毕之后再来开启中断.</p><p>当然我们还可以使用<code>myproc()</code>函数来获得当前cpu运行的进程结构体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Return the current struct proc \*, or zero if none.</span><br><span class="line">struct proc\*</span><br><span class="line">myproc(void) &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  struct cpu \*c = mycpu();</span><br><span class="line">  struct proc \*p = c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><p>sleep和wakeup调用给底层提供了一个同步接口,我们可以根据这个同步接口构建一个叫做信号量的顶层接口,信号量的定义和P-V操作我们都在操作系统课上学过了,我们就不需要解释究竟什么是P-V操作.贴个代码吧:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">100 struct semaphore &#123;</span><br><span class="line">101 struct spinlock lock;</span><br><span class="line">102 int count;</span><br><span class="line">103 &#125;;</span><br><span class="line">104</span><br><span class="line">  </span><br><span class="line">400 void</span><br><span class="line">401 V(struct semaphore \*s)</span><br><span class="line">402 &#123;</span><br><span class="line">403 acquire(&amp;s-&gt;lock);</span><br><span class="line">404 s-&gt;count += 1;</span><br><span class="line">405 wakeup(s);</span><br><span class="line">406 release(&amp;s-&gt;lock);</span><br><span class="line">407 &#125;</span><br><span class="line">408</span><br><span class="line">409 void</span><br><span class="line">410 P(struct semaphore \*s)</span><br><span class="line">411 &#123;</span><br><span class="line">412 acquire(&amp;s-&gt;lock);</span><br><span class="line">413 while(s-&gt;count == 0)</span><br><span class="line">414 sleep(s, &amp;s-&gt;lock);</span><br><span class="line">415 s-&gt;count -= 1;</span><br><span class="line">416 release(&amp;s-&gt;lock);</span><br><span class="line">417 &#125;</span><br></pre></td></tr></table></figure><p>P-V操作需要获得锁,因为对于信号量,同时可以有多个进程对信号量进行操作.</p><p>总而言之,P-V操作要求我们sleep(s,s-&gt;lock),要求这个进程为了s信号灯而等待,放弃当前CPU的占用,wakeup(s)要求通知所有为s信号灯而等待的进程,有位占了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Atomically release lock and sleep on chan.</span><br><span class="line">// Reacquires lock when awakened.</span><br><span class="line">void</span><br><span class="line">sleep(void \*chan, struct spinlock \*lk)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line">  </span><br><span class="line">  // Must acquire p-&gt;lock in order to</span><br><span class="line">  // change p-&gt;state and then call sched.</span><br><span class="line">  // Once we hold p-&gt;lock, we can be</span><br><span class="line">  // guaranteed that we won&#x27;t miss any wakeup</span><br><span class="line">  // (wakeup locks p-&gt;lock),</span><br><span class="line">  // so it&#x27;s okay to release lk.</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);  //DOC: sleeplock1</span><br><span class="line">  release(lk);</span><br><span class="line"></span><br><span class="line">  // Go to sleep.</span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  // Tidy up.</span><br><span class="line">  p-&gt;chan = 0;</span><br><span class="line"></span><br><span class="line">  // Reacquire original lock.</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先标记一下,这个目前是睡眠状态.还标记一下睡眠的理由,就是proc的chan元素.然后进行进程调度,因为这个程序在返回的时候还是需要对信号灯进行更改,所以说在返回的时候还是需要信号灯的锁.但是当进程进入睡眠状态就可以不需要信号灯的锁了.记录进程是为了谁而睡眠的十分重要.</p><p>对应的,在wakeup()函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Wake up all processes sleeping on chan.</span><br><span class="line">// Must be called without any p-&gt;lock.</span><br><span class="line">void</span><br><span class="line">wakeup(void \*chan)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p;</span><br><span class="line"></span><br><span class="line">  for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    if(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就寻找一个正在睡眠的并且因为chan这个原因睡眠的进程,表示你要的资源已经到达,这个时候就可以提醒这些进程现在可以执行了.(为什么要一次性全部通知,这样会错吗?其实不会,因为是执行while循环的,如果发现s-&gt;count还是小于0,那我还是接着睡吧zzz)</p><p>由于我们对很多临界变量,比如说信号灯,进程控制块进行了修改,所以说锁结构是必要的.</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>xv6的管道使用sleep和wakeup的操作来进行复杂的同步通讯.我们在之前已经了解过Linux的管道系统.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct pipe &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  char data[PIPESIZE];</span><br><span class="line">  uint nread;     // number of bytes read</span><br><span class="line">  uint nwrite;    // number of bytes written</span><br><span class="line">  int readopen;   // read fd is still open</span><br><span class="line">  int writeopen;  // write fd is still open</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在xv6,我们使用pipe这个数据结构,首先我们看到一个锁结构,还有一个数据buffer.还有nread和nwrite来表示目前管道的两端已经读出了几个元素,已经写入几个元素.这个数据buffer还是一个循环队列,也就是第PIPELINE-1项之后就是第0项.循环队列的判空和判满非常容易.由于在这里我们使用了类似于TCP id的模式处理,所以说我们读区元素使用%运算来进行读取.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">pipewrite(struct pipe \*pi, uint64 addr, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  struct proc \*pr = myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  while(i &lt; n)&#123;</span><br><span class="line">    if(pi-&gt;readopen == 0  pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; //DOC: pipewrite-full</span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      char ch;</span><br><span class="line">      if(copyin(pr-&gt;pagetable, &amp;ch, addr + i, 1) == -1)</span><br><span class="line">        break;</span><br><span class="line">      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line"></span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是pipewrite,在对管道这个临界资源修改之前我们先上锁,所以说读的时候不能写,写的时候不能读,也不能同时读也不能同时写,这个就是锁的魅力.</p><p>首先就是各种异常情况,这个不说了,接着就是满的情况,那么只能让暂时让写的进程休眠,顺便让那群没字节可读的进程醒过来.如果没有满,那就一个一个字节地往buffer里面写,写的操作就是普通的循环队列,只不过这里巧妙地使用了wakeup和sleep调节满和空之间的平衡.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">piperead(struct pipe \*pi, uint64 addr, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  struct proc \*pr = myproc();</span><br><span class="line">  char ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  while(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  //DOC: pipe-empty</span><br><span class="line">    if(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); //DOC: piperead-sleep</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; n; i++)&#123;  //DOC: piperead-copy</span><br><span class="line">    if(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      break;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    if(copyout(pr-&gt;pagetable, addr + i, &amp;ch, 1) == -1)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  //DOC: piperead-wakeup</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于读也是一样,如果管道是空的,那么没字节可读,那就让自己休眠.顺便通知写的进程抓紧来写,如果不是空的,那就慢慢来读.一个字一个字地读.</p><p>由于读写区间都上了锁,所以说这样可以保证只有一个进程能对一个管道进行处理,防止乱套.</p><h2 id="等待-退出和杀死的系统调用"><a href="#等待-退出和杀死的系统调用" class="headerlink" title="等待,退出和杀死的系统调用"></a>等待,退出和杀死的系统调用</h2><p>首先就是wait的系统调用:wait调用就是等待子进程退出,退出了之后父进程就可以继续执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">wait(uint64 addr)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*np;</span><br><span class="line">  int havekids, pid;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    // Scan through table looking for exited children.</span><br><span class="line">    havekids = 0;</span><br><span class="line">    for(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      if(np-&gt;parent == p)&#123;</span><br><span class="line">        // make sure the child isn&#x27;t still in exit() or swtch().</span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">        havekids = 1;</span><br><span class="line">        if(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          // Found one.</span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          if(addr != 0 &amp;&amp; copyout(p-&gt;pagetable, addr, (char \*)&amp;np-&gt;xstate,</span><br><span class="line">                                  sizeof(np-&gt;xstate)) &lt; 0) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;wait_lock);</span><br><span class="line">            return -1;</span><br><span class="line">          &#125;</span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;wait_lock);</span><br><span class="line">          return pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // No point waiting if we don&#x27;t have any children.</span><br><span class="line">    if(!havekids  p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;wait_lock);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Wait for a child to exit.</span><br><span class="line">    sleep(p, &amp;wait_lock);  //DOC: wait-sleep</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的代码非常好懂,由于这个wait比较菜,只需要任何一个子进程退出就可以了,所以说实现起来不难.首先判断这个进程有没有一个儿子,并且这个儿子就是僵尸状态的,如果有的话就太好了,我就不用wait了,我就把这个儿子给释放了.并且把信息传递给用户那边.如果没有找到,那还是乖乖等着吧.我们获得这些锁,第一是为了保护进程,第二个是为了防止多线程访问..导致这个pid和havekids出现问题.</p><p>接着就是exit了,由于wait调用要等待有没有儿子退出,所以说sleep和wakeup是要配套的,wakeup就是在exit里面实现的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">exit(int status)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  if(p == initproc)</span><br><span class="line">    panic(&quot;init exiting&quot;);</span><br><span class="line"></span><br><span class="line">  // Close all open files.</span><br><span class="line">  for(int fd = 0; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    if(p-&gt;ofile[fd])&#123;</span><br><span class="line">      struct file \*f = p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = 0;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  // Give any children to init.</span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  // Parent might be sleeping in wait().</span><br><span class="line">  wakeup(p-&gt;parent);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  // Jump into the scheduler, never to return.</span><br><span class="line">  sched();</span><br><span class="line">  panic(&quot;zombie exit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看是不是init的守护进程要退出,不是就还好.第一步就是解决打开的文件问题,一一关闭文件即可.接着就是reparent,就是如果它的父进程要被exit掉,但是子进程还在存活,就需要使用reparent来处理父进程.如果这个进程有父进程,顺便叫醒正在沉睡的,等待它的儿子调用exit()的爸爸.接着由于这个已经退出了,所以说转进程调度吧.</p><p>exit是自己退场,那么kill是勒令让别人退场.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">kill(int pid)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p;</span><br><span class="line"></span><br><span class="line">  for(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    if(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = 1;</span><br><span class="line">      if(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        // Wake process from sleep().</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//usertrapret()</span><br><span class="line">if(p-&gt;killed)</span><br><span class="line">    exit(-1);</span><br></pre></td></tr></table></figure><p>这个就像注射了慢性毒药,我在kill函数什么都不做,我只是设定一个killed为1,然后这个进程在执行usertrapret的时候由于killed值为1,这个时候就它会自己调用exit()然后退场.</p><h1 id="6-File-System"><a href="#6-File-System" class="headerlink" title="6:File System"></a>6:File System</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>xv6的文件系统由7层组成,首先就是最下面的硬件层,<strong>cache层</strong>在上面通过缓存硬件块来实现操作系统同步地访问硬盘块(这样可以降低操作系统访问硬盘块的时间),并且可以进行简单的同步管理,这样子可以保证只有一个进程同时访问一个硬盘块.<strong>记录层</strong>让更高层次的程序在在一次处理中能够处理多个硬件块,保证这些硬件块是同步处理的(要么都不处理,要么都处理).<strong>inode层</strong>负责描述文件,其中一个文件对应着一个inode,这个inode存储着许多文件的信息.其中inode层负责存储文件的控制信息,其中有一个索引负责带领文件找到索引本身.<strong>文件目录层</strong>负责实现具体的文件目录.<strong>路经名层</strong>负责完善文件树.这样可以根据文件的路径取访问文件了.文件描述器层负责完善许多UNIX抽象文件接口,负责给用户程序提供文件系统相关的系统调用.</p><p>硬盘把数据按照硬盘扇区为单位连续地存放在磁盘中,每一个磁盘扇区大小是512字节.其中第0块是第一个512字节.第1块是第513-1024字节,以此类推.xv6操作系统维护一个buf结构体.存储在这个结构体的数据可能和磁盘实际存储的数据不一样.<strong>有一种可能就是数据写进buf结构体,但还是没有写进磁盘块</strong>.(类似于cache,cache也有脏数据嘛)</p><p>还需要注意的是,在操作系统中,磁盘块的大小一般是磁盘扇区大小的两倍.所以说在xv6中我们认为一块就是两个扇区,就是1024字节.<strong>到后面我们逻辑上认为一块就是两个扇区,1024字节.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define BSIZE 1024  // block size</span><br><span class="line">struct buf &#123;</span><br><span class="line">  int valid;   // has data been read from disk?</span><br><span class="line">  int disk;    // does disk &quot;own&quot; buf?</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  struct buf \*prev; // LRU cache list</span><br><span class="line">  struct buf \*next;</span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个文件系统必须有一个计划,就是哪些磁盘块存放控制文件总体信息的inode,哪些磁盘块存放具体的文件.在这里,xv6把磁盘分成了几个部分,第0块是boot块,这里面存放着引导操作系统的代码.第1块又被称为“超级块”,超级块中存放了关于整个文件系统的原数据(包括文件系统所有块的数量,inode的数量,还有文件块的数量).从2后面就是记录,接着就是inode,接着就是bit map(这个bitmap可以帮助我们确定哪些块已经被使用了),最后就是存放的文件块.</p><h2 id="2-buffer-cache层"><a href="#2-buffer-cache层" class="headerlink" title="2.buffer cache层."></a>2.buffer cache层.</h2><p>buffer cache层有两个作用,第一个是同步,在内存中只有一个磁盘块的拷贝,还有就是只有一个进程能够访问这个磁盘块的拷贝.第二个作用就是可以把比较常用的磁盘块放入缓存区里面,这样可以加快进程读写磁盘的速度.</p><p>buffer cache层主要提供了两个API,分别是bread()和bwrite().</p><p>bread()负责获取一个块的存储在内存中的副本,我们之后的读写操作就是在内存中的副本进行的.bwirte()就负责把内存中副本写入到磁盘中.总的来说是read()操作把磁盘中信息读取到内存,write就是把内存中的信息写入到磁盘.在最后我们要调用brelease来释放这个内存块的锁.总之bread()返回了一个带锁的buffer,brelease就负责把这个锁释放掉.</p><p>因为这个本质上也是一个cache.当操作系统要求访问一个不再buffer的磁盘块,它就需要淘汰,淘汰就选用最久未使用算法即可.</p><h3 id="Cache层重要数据结构定义"><a href="#Cache层重要数据结构定义" class="headerlink" title="Cache层重要数据结构定义"></a>Cache层重要数据结构定义</h3><p><code>buf</code>数据结构定义。<code>valid</code>字段表示该buf中是否存储了有效内容；字段<code>disk</code>的意思是缓冲区的内容已经被提交到了磁盘，这可能会改变缓冲区(如，把磁盘中的数据写到<code>data</code>,这个类似于cache的脏位,代表这个是不是在cache中写过)；<code>dev</code>、<code>blockno</code>标识该buf存储的磁盘块设备和扇区号；<code>data</code>则是<code>buf</code>实际缓存的内容；而<code>prev</code>和<code>next</code>就代表一个双向链表.其中<code>refcnt</code>代表这个块是不是可用的,或者代表这个buf链接了多少个磁盘块.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct buf &#123;</span><br><span class="line">  int valid;   // has data been read from disk?</span><br><span class="line">  int disk;    // does disk &quot;own&quot; buf?</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  struct buf \*prev; // LRU cache list</span><br><span class="line">  struct buf \*next;</span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bcache</code>数据结构定义。bcache用于管理所有的buffer，将所有的<code>buf</code>用双链表进行连接，<code>head</code>是链表头，不存储实际的buf。所有的代码访问bcache是访问head,并不会访问buf数组.我们了解过用硬件实现的cache,但是这是第一次遇见用软件实现的cache.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  // Linked list of all buffers, through prev/next.</span><br><span class="line">  // Sorted by how recently the buffer was used.</span><br><span class="line">  // head.next is most recent, head.prev is least.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><h3 id="Cache层的函数定义"><a href="#Cache层的函数定义" class="headerlink" title="Cache层的函数定义"></a>Cache层的函数定义</h3><blockquote><p><code>binit()</code>函数：初始化<code>bcache</code>，把所有的buf使用双链表进行连接。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">binit(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*b;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, &quot;bcache&quot;);</span><br><span class="line"></span><br><span class="line">  // Create linked list of buffers</span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  for(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, &quot;buffer&quot;);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>bget()</code>函数：</p><p>bget函数首先获取<code>bcache.lock</code>，至多扫描两遍双链表，第一遍从前到后，如果磁盘块已经缓存至buf中，则在第一遍循环之后就会返回该buf；否则执行第二次反向扫描，寻找目前未使用的buf，将buf的必要字段进行标记之后返回该buf。</p><p>注意：在将buf返回之前，需要获取该buf的锁<code>(buf.lock)</code>；赋值语句<code>b-&gt;valid = 0</code>，它确保了<code>bread</code>将从磁盘读取块数据，而不是错误地使用缓冲区里之前的数据。获取锁的目标是,现在只有一个进程能够访问这段cache,这是为了方便各进程进行同步.当然我们获得了我们需要的元素之后我们就可以释放<code>bcache.lock</code>了.</p><p>如果所有的块都是忙的,只能返回busy的信息了.我们不需要考虑同步的问题,我们设计的锁能保证同时只有一个进程访问bcache和buf结构体.同样,非零的refcnt保证了只有一个dev number.</p><p>睡眠锁保证了就算有许多个进程要访问这个块,仅仅是睡眠而已,因为有多个进程要访问这个文件是很正常的.这样子也可以保证在只有一个进程同时读写这个cache.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Look through buffer cache for block on device dev.</span><br><span class="line">// If not found, allocate a buffer.</span><br><span class="line">// In either case, return locked buffer.</span><br><span class="line">static struct buf\*</span><br><span class="line">bget(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*b;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  // Is the block already cached?</span><br><span class="line">  for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      return b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Not cached.</span><br><span class="line">  // Recycle the least recently used (LRU) unused buffer.</span><br><span class="line">  for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    if(b-&gt;refcnt == 0) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = 0;</span><br><span class="line">      b-&gt;refcnt = 1;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      return b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(&quot;bget: no buffers&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bread()</code>函数：</p><ul><li><p>内部调用了<code>bget</code>函数，该函数保证了返回的已经获取了<code>buf.lock</code>的<code>buf</code></p></li><li><p>如果buf还没有获取有效的数据内容，则需要通过<code>virtio_disk_rw()</code>这个函数接口载入数据并将buf的有效位置为1.<code>virtio_disk_rw()</code>函数可以读取磁盘里面的信息,然后把信息传递给</p></li><li><p>返回这个buf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Return a locked buf with the contents of the indicated block.</span><br><span class="line">struct buf\*</span><br><span class="line">bread(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*b;</span><br><span class="line"></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  if(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, 0);</span><br><span class="line">    b-&gt;valid = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; `bwrite()`函数把buf中的数据写回磁盘，要求持有`buf.lock`锁</span><br><span class="line"></span><br><span class="line">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="line">void</span><br><span class="line">bwrite(struct buf \*b)</span><br><span class="line">&#123;</span><br><span class="line">  if(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(&quot;bwrite&quot;);</span><br><span class="line">  virtio_disk_rw(b, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>brelse()</code>函数：如果调用者完成了对缓冲区的操作，它必须调用<code>brelse</code>来释放它。</p></li><li><p>首先需要判断是否持有参数<code>buf</code>的锁；</p></li><li><p>如果持有锁则释放该<code>buf</code> 的锁；这样子其他进程就可以访问这个cache了.所以说综上就是一个进程获取了锁并成功进入之后,执行完brelse就可以让下一个进程接着执行.</p></li><li><p>获取<code>bcache.lock</code>之后，将buf的引用计数<code>refcnt</code>减1，根据<code>buf</code>的引用计数是否为0来决定是否将<code>buf</code>调整到双链表的表头。</p></li><li><p>对缓冲区的移动使得列表按照最近使用(释放)进行排序：列表里的第一个缓冲区是最近被使用的，最后一个则是最近最少被使用的。<code>bget</code>里的两个循环利用了这点：在最坏的情况下，扫描一个已经存在的缓冲区必须处理整个列表，当引用处于良好的位置的时候，先检查最近使用的缓冲区将减少扫描时间。通过反向扫描(跟随<code>prev</code>指针)，对要重新使用的缓冲区的扫描查找到了最少使用的缓冲区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Release a locked buffer.</span><br><span class="line">// Move to the head of the most-recently-used list.</span><br><span class="line">void</span><br><span class="line">brelse(struct buf \*b)</span><br><span class="line">&#123;</span><br><span class="line">  if(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(&quot;brelse&quot;);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  if (b-&gt;refcnt == 0) &#123;</span><br><span class="line">    // no one is waiting for it.</span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; `bpin`和`bunpin`用于调整引用计数`refcnt`.pin就是+1,unpin就是-1.</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bpin(struct buf \*b) &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bunpin(struct buf \*b) &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Log层"><a href="#Log层" class="headerlink" title="Log层"></a>Log层</h2><p><strong>前言</strong></p><p>在文件系统的设计里最有趣的问题之一是故障恢复。许多文件系统的操作包含了多次写磁盘的操作，在一串写操作之后的崩溃使得磁盘上的文件系统处于不一致的状态。</p><p>xv6系统调用不直接写入硬盘上文件系统的数据结构。相反，它把一个描述放在磁盘上，这个描述是它在一个<code>log</code>里所期望的所有磁盘写操作。一旦系统调用日志记录了所有的写操作，它往磁盘上写入一个特殊的<code>commit</code>记录用来表示那个日志包含了一个完整的操作。那时系统调用才会把所有的写操作写入到磁盘文件系统里的数据结构中。当那些写操作都完成后，系统调用删除磁盘上的日志。</p><p>如果系统崩溃并重启，在运行任何进程之前，文件系统代码按如下描述从崩溃中恢复：如果日志被标记为包含一个完整的操作，则恢复代码把写操作复制到磁盘文件系统。如果日志不是标记为包含完整的操作，恢复代码忽略这个日志。恢复代码最后删除日志完成所有的操作。</p><p><strong>超级块结构体定义以及磁盘布局</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Disk layout:</span><br><span class="line">// [ boot block  super block  log  inode blocks </span><br><span class="line">//                                          free bit map  data blocks]</span><br><span class="line">//</span><br><span class="line">// mkfs computes the super block and builds an initial file system. The</span><br><span class="line">// super block describes the disk layout:</span><br><span class="line">struct superblock &#123;</span><br><span class="line">  uint magic;        // Must be FSMAGIC</span><br><span class="line">  uint size;         // Size of file system image (blocks)</span><br><span class="line">  uint nblocks;      // Number of data blocks</span><br><span class="line">  uint ninodes;      // Number of inodes.</span><br><span class="line">  uint nlog;         // Number of log blocks</span><br><span class="line">  uint logstart;     // Block number of first log block</span><br><span class="line">  uint inodestart;   // Block number of first inode block</span><br><span class="line">  uint bmapstart;    // Block number of first free map block</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Log层结构体定义"><a href="#Log层结构体定义" class="headerlink" title="Log层结构体定义"></a>Log层结构体定义</h3><blockquote><p>这个数据结构和磁盘上的<code>log</code>区域一一对应的。磁盘上的<code>log</code>区域由<code>log.start</code>开始的连续<code>log.size</code>个<code>block</code>组成。第一个<code>block</code>即为<code>logheader</code>，待写磁盘块的个数记录在<code>logheader.n</code>中，待写磁盘块号记录在<code>block</code>数组中。<code>log.dev</code>表示该<code>log</code>位于哪一个磁盘（xv6实际上只有一个）。<code>log.outstanding</code>记录了目前有多少个进程正在并行地对磁盘进行写。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Contents of the header block, used for both the on-disk header block</span><br><span class="line">// and to keep track in memory of logged block# before commit.</span><br><span class="line">struct logheader &#123;</span><br><span class="line">  int n;</span><br><span class="line">  int block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct log &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  int start;</span><br><span class="line">  int size;</span><br><span class="line">  int outstanding; // how many FS sys calls are executing.</span><br><span class="line">  int committing;  // in commit(), please wait.</span><br><span class="line">  int dev;</span><br><span class="line">  struct logheader lh;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Log层函数的定义"><a href="#Log层函数的定义" class="headerlink" title="Log层函数的定义"></a>Log层函数的定义</h3><blockquote><p><code>initlog</code>函数：使用超级块中的字段初始化log。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">initlog(int dev, struct superblock \*sb)</span><br><span class="line">&#123;</span><br><span class="line">  if (sizeof(struct logheader) &gt;= BSIZE)</span><br><span class="line">    panic(&quot;initlog: too big logheader&quot;);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;log.lock, &quot;log&quot;);</span><br><span class="line">  log.start = sb-&gt;logstart;</span><br><span class="line">  log.size = sb-&gt;nlog;</span><br><span class="line">  log.dev = dev;</span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recover_from_log</code>函数，根据函数名称应该是根据之前写入磁盘的日志信息恢复磁盘数据的操作</p><ul><li><p>从磁盘读取log header</p></li><li><p>将提交的日志写入磁盘</p></li><li><p>清空日志记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">recover_from_log(void)</span><br><span class="line">&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(1); // if committed, copy from log to disk</span><br><span class="line">  log.lh.n = 0;</span><br><span class="line">  write_head(); // clear the log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从磁盘的读取<code>log header</code>到内存中，位于log所在磁盘块的第一个磁盘块</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Read the log header from disk into the in-memory log header</span><br><span class="line">static void</span><br><span class="line">read_head(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*buf = bread(log.dev, log.start);</span><br><span class="line">  struct logheader \*lh = (struct logheader \*) (buf-&gt;data);</span><br><span class="line">  int i;</span><br><span class="line">  log.lh.n = lh-&gt;n;</span><br><span class="line">  for (i = 0; i &lt; log.lh.n; i++) &#123;</span><br><span class="line">    log.lh.block[i] = lh-&gt;block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>recovering的作用是啥？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Copy committed blocks from log to their home location</span><br><span class="line">static void</span><br><span class="line">install_trans(int recovering)</span><br><span class="line">&#123;</span><br><span class="line">  int tail;</span><br><span class="line"></span><br><span class="line">  for (tail = 0; tail &lt; log.lh.n; tail++) &#123;</span><br><span class="line">    struct buf \*lbuf = bread(log.dev, log.start+tail+1); // read log block</span><br><span class="line">    struct buf \*dbuf = bread(log.dev, log.lh.block[tail]); // read dst</span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  // copy block to dst</span><br><span class="line">    bwrite(dbuf);  // write dst to disk</span><br><span class="line">    if(recovering == 0)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>begin_op()</code>函数：发起写请求，任何对bcache中的block进行写操作之前都需要调用这个函数。</p></li><li><p>如果日志处于commit状态，则需要等待；</p></li><li><p>否则判断本次写操作是否会使得transaction需要写的磁盘块超出LOGSIZE；</p></li><li><p>如果没有超过则将<code>log.outstanding</code>字段加1；</p></li><li><p>如果超过则需要等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// called at the start of each FS system call.</span><br><span class="line">void</span><br><span class="line">begin_op(void)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;log.lock);</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    if(log.committing)&#123;</span><br><span class="line">      sleep(&amp;log, &amp;log.lock);</span><br><span class="line">    &#125; else if(log.lh.n + (log.outstanding+1)\*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      // this op might exhaust log space; wait for commit.</span><br><span class="line">      sleep(&amp;log, &amp;log.lock);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      log.outstanding += 1;</span><br><span class="line">      release(&amp;log.lock);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在结束写请求的时候调用<code>end_op()</code>函数，将<code>log.outstanding</code>字段减1；</p></li><li><p>如果<code>log.committing</code>字段为1，表面日志处于提交状态，抛出异常；</p></li><li><p>如果所有的进程都结束了写请求，则将<code>log.committing</code>字段以及<code>do_commit</code>置为1；</p></li><li><p>如果<code>do_commit</code>为1则调用commit函数，将本轮进程写的结果写回磁盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// called at the end of each FS system call.</span><br><span class="line">// commits if this was the last outstanding operation.</span><br><span class="line">void</span><br><span class="line">end_op(void)</span><br><span class="line">&#123;</span><br><span class="line">  int do_commit = 0;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;log.lock);</span><br><span class="line">  log.outstanding -= 1;</span><br><span class="line">  if(log.committing)</span><br><span class="line">    panic(&quot;log.committing&quot;);</span><br><span class="line">  if(log.outstanding == 0)&#123;</span><br><span class="line">    do_commit = 1;</span><br><span class="line">    log.committing = 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // begin_op() may be waiting for log space,</span><br><span class="line">    // and decrementing log.outstanding has decreased</span><br><span class="line">    // the amount of reserved space.</span><br><span class="line">    wakeup(&amp;log);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;log.lock);</span><br><span class="line"></span><br><span class="line">  if(do_commit)&#123;</span><br><span class="line">    // call commit w/o holding locks, since not allowed</span><br><span class="line">    // to sleep with locks.</span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;log.lock);</span><br><span class="line">    log.committing = 0;</span><br><span class="line">    wakeup(&amp;log);</span><br><span class="line">    release(&amp;log.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>log_write</code>函数用于把块修改写入内存中的log</p></li></ul><p>通常情况下，我们调用<code>bread</code>函数读取一个块，然后对块的内容进行了修改，然后调用<code>brelse</code>释放这个块。**问题在于log怎么知道哪些块需要写回呢？得用<code>logheader</code>来记录，所以必须有个函数来写<code>logheader</code>记录块的修改，这个函数就是<code>log_write</code>**。</p><ul><li><p>如果是第一次修改这个块，那么执行<code>log.lh.n++</code>操作；</p></li><li><p>当一个块在单个事务中被多次写入时，<code>log_write</code>会发现它，并在日志里为那个块分配相同的位置。这个优化被称为<strong>合并</strong>(absorption)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">log_write(struct buf \*b)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;log.lock);</span><br><span class="line">  if (log.lh.n &gt;= LOGSIZE  log.lh.n &gt;= log.size - 1)</span><br><span class="line">    panic(&quot;too big a transaction&quot;);</span><br><span class="line">  if (log.outstanding &lt; 1)</span><br><span class="line">    panic(&quot;log_write outside of trans&quot;);</span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; log.lh.n; i++) &#123;</span><br><span class="line">    if (log.lh.block[i] == b-&gt;blockno)   // log absorption</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  log.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  if (i == log.lh.n) &#123;  // Add new block to log?</span><br><span class="line">    bpin(b);</span><br><span class="line">    log.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;log.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commit</code>函数可以分为几个阶段：</p></li><li><p>把内存中需要修改的block写回磁盘的log区域<code>(write_log)</code></p></li><li><p>把内存中<code>logheader</code>写回磁盘的log区域头<code>(write_head)</code></p></li><li><p>把log区域的磁盘块写回到磁盘的相应位置<code>(install_trans)</code></p></li><li><p>把磁盘<code>log</code>区域头标记需要写回的<code>block</code>数目的位置清零<code>log.lh.n = 0 &amp; write_head</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">commit()</span><br><span class="line">&#123;</span><br><span class="line">  if (log.lh.n &gt; 0) &#123;</span><br><span class="line">    write_log();     // Write modified blocks from cache to log</span><br><span class="line">    write_head();    // Write header to disk -- the real commit</span><br><span class="line">    install_trans(0); // Now install writes to home locations</span><br><span class="line">    log.lh.n = 0;</span><br><span class="line">    write_head();    // Erase the transaction from the log</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Copy modified blocks from cache to log.</span><br><span class="line">static void</span><br><span class="line">write_log(void)</span><br><span class="line">&#123;</span><br><span class="line">  int tail;</span><br><span class="line"></span><br><span class="line">  for (tail = 0; tail &lt; log.lh.n; tail++) &#123;</span><br><span class="line">    struct buf \*to = bread(log.dev, log.start+tail+1); // log block</span><br><span class="line">    struct buf \*from = bread(log.dev, log.lh.block[tail]); // cache block</span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  // write the log</span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="inode层"><a href="#inode层" class="headerlink" title="inode层"></a>inode层</h2><blockquote><p>磁盘上的inode被填充在一个被称为inode块的连续磁盘区域上。每个inode都是一样大小，所以给定一个编号n，很容易就找到磁盘上的第n个inode</p></blockquote><h3 id="两个分配和回收磁盘块的函数"><a href="#两个分配和回收磁盘块的函数" class="headerlink" title="两个分配和回收磁盘块的函数"></a>两个分配和回收磁盘块的函数</h3><blockquote><p>遍历bitmap，分配或者回收block</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a zeroed disk block.</span><br><span class="line">static uint</span><br><span class="line">balloc(uint dev)</span><br><span class="line">&#123;</span><br><span class="line">  int b, bi, m;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line"></span><br><span class="line">  bp = 0;</span><br><span class="line">  for(b = 0; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    for(bi = 0; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = 1 &lt;&lt; (bi % 8);</span><br><span class="line">      if((bp-&gt;data[bi/8] &amp; m) == 0)&#123;  // Is block free?</span><br><span class="line">        bp-&gt;data[bi/8] = m;  // Mark block in use.</span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        return b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(&quot;balloc: out of blocks&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Free a disk block.</span><br><span class="line">static void</span><br><span class="line">bfree(int dev, uint b)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line">  int bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = 1 &lt;&lt; (bi % 8);</span><br><span class="line">  if((bp-&gt;data[bi/8] &amp; m) == 0)</span><br><span class="line">    panic(&quot;freeing free block&quot;);</span><br><span class="line">  bp-&gt;data[bi/8] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inode层的数据结构定义"><a href="#inode层的数据结构定义" class="headerlink" title="inode层的数据结构定义"></a>inode层的数据结构定义</h3><blockquote><p><strong>磁盘上 i 结点结构定义</strong></p><p>磁盘上的inode通过<code>struct dinode</code>来定义。<code>type</code>字段区分了文件、目录、和特殊文件(设备)。如类型值为0则表示磁盘inode是空闲的。字段<code>nlink</code>记录了引用当前inode的目录条目的数量，用以识别这个磁盘inode和它的数据块何时应该被释放。<code>size</code>字段记录了文件内容的字节数。<code>addrs</code>数组记录了保存了文件内容的磁盘块的块号，<code>addrs</code>里的前<code>NDIRECT</code>个块被称为<strong>直接块</strong>(direct blocks)；第<code>NDIRECT+1</code>个块记录了<code>NINDIRECT</code>个块的数据，它被称为<strong>间接块</strong>(indirect block)。</p><p>对数据结构中 <code>major</code>、<code>minor</code> 字段的解释：</p><p>在Unix系系统中，一切皆是文件。所有硬盘，键盘，网卡等设备都有文件来代表，对应着<code>/dev/</code>下面的文件。对于应用程序来说，可以像对待普通文件一样打开、关闭、读写这些设备文件。但是，这种文件名比如：<code>/dev/sda</code> 、<code>/dev/raw/raw1</code>都是用户空间名称，OS <code>Kernel</code>根本不知道这个名称代指什么。在内核空间是通过<code>major</code>、<code>minor``device number</code>来区分设备的。</p><p>**<code>major device number</code>**：可以看做是设备驱动程序，被同一设备驱动程序管理的设备有相同的<code>major device number</code>。这个数字实际是Kernel 中<code>device driver table</code>的索引。这个表保存着不同的设备驱动程序。</p><p>**<code>minor device number</code>**：代表被访问的具体设备。也就是说，Kernel根据<code>major device number</code>找到设备驱动程序，然后再从<code>minor device number</code>获得设备位置等属性。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 下面的宏定义用于type字段，type = 0表示该dinode尚未分配</span><br><span class="line">#define T_DIR     1</span><br><span class="line">#define T_FILE    2</span><br><span class="line">#define T_DEVICE  3</span><br><span class="line">// On-disk inode structure</span><br><span class="line">struct dinode &#123;</span><br><span class="line">  short type;           // File type</span><br><span class="line">  short major;          // Major device number (T_DEVICE only)</span><br><span class="line">  short minor;          // Minor device number (T_DEVICE only)</span><br><span class="line">  short nlink;          // Number of links to inode in file system</span><br><span class="line">  uint size;            // Size of file (bytes)</span><br><span class="line">  uint addrs[NDIRECT+1];   // Data block addresses</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>内存中需保存的i结点信息数据结构定义，除了从磁盘读取的inode信息，还定义了一些其他的字段。内核把活动inode的集合保存在内存中，即<code>struct inode</code>。<code>ref</code>字段记录了C指针引用内存里inode的次数，当那个计数降为0的时候内核就会从内存中丢弃这个inode。<code>iget</code>和<code>iput</code>函数请求和释放到一个inode的指针，这会修改这个引用计数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// in-memory copy of an inode</span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  struct sleeplock lock; // protects everything below here</span><br><span class="line">  int valid;          // inode has been read from disk?</span><br><span class="line"></span><br><span class="line">  short type;         // copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-inode层函数定义"><a href="#4-3-inode层函数定义" class="headerlink" title="4.3 inode层函数定义"></a>4.3 inode层函数定义</h3><blockquote><p><code>iget()</code>函数</p><p>遍历<code>itable</code>寻找 i 结点是否已经被加载至内存中，如是则将该 i 结点的<code>ref</code>引用计数加1；在遍历的过程中使用empty对空的 i 结点进行保存；如果 i 结点还未被加载至内存则使用空 i 结点对需要获取的 i 结点进行保存。最后返回对应的 i 结点。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct inode inode[NINODE];</span><br><span class="line">&#125; itable;</span><br><span class="line">// Find the inode with number inum on device dev</span><br><span class="line">// and return the in-memory copy. Does not lock</span><br><span class="line">// the inode and does not read it from disk.</span><br><span class="line">static struct inode\*</span><br><span class="line">iget(uint dev, uint inum)</span><br><span class="line">&#123;</span><br><span class="line">  struct inode \*ip, \*empty;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  // Is the inode already in the table?</span><br><span class="line">  empty = 0;</span><br><span class="line">  for(ip = &amp;itable.inode[0]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;</span><br><span class="line">    if(ip-&gt;ref &gt; 0 &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;itable.lock);</span><br><span class="line">      return ip;</span><br><span class="line">    &#125;</span><br><span class="line">    if(empty == 0 &amp;&amp; ip-&gt;ref == 0)    // Remember empty slot.</span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Recycle an inode entry.</span><br><span class="line">  if(empty == 0)</span><br><span class="line">    panic(&quot;iget: no inodes&quot;);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = 1;</span><br><span class="line">  ip-&gt;valid = 0;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  return ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ilock</code>函数用于获取ip所☞的 i 结点的锁，同时如果该 i 结点的内容处于无效状态时，需要从磁盘中读取对应设备和结点号的 i 结点，把相关字段拷贝至内存 i 结点中，将该 i 结点的有效位置为1，保证 i 结点的内容是有效的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Inodes per block.</span><br><span class="line">#define IPB           (BSIZE / sizeof(struct dinode))</span><br><span class="line"></span><br><span class="line">// Block containing inode i</span><br><span class="line">#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span><br><span class="line"></span><br><span class="line">// Lock the given inode.</span><br><span class="line">// Reads the inode from disk if necessary.</span><br><span class="line">void</span><br><span class="line">ilock(struct inode \*ip)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line">  struct dinode \*dip;</span><br><span class="line"></span><br><span class="line">  if(ip == 0  ip-&gt;ref &lt; 1)</span><br><span class="line">    panic(&quot;ilock&quot;);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">  if(ip-&gt;valid == 0)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (struct dinode\*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, sizeof(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = 1;</span><br><span class="line">    if(ip-&gt;type == 0)</span><br><span class="line">      panic(&quot;ilock: no type&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>iunlock()</code> 函数：释放<code>ip</code>所☞的 i 结点的锁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// Unlock the given inode.</span><br><span class="line">void</span><br><span class="line">iunlock(struct inode \*ip)</span><br><span class="line">&#123;</span><br><span class="line">  if(ip == 0  !holdingsleep(&amp;ip-&gt;lock)  ip-&gt;ref &lt; 1)</span><br><span class="line">    panic(&quot;iunlock&quot;);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; `idup()`函数类似于`bpin` ，`iput()`函数类似于`brelse`函数。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 当`iput`函数判断自己是最后一个持有该inode指针、该inode的内容是有效的、该inode的引用链接数为0时，会将该inode进行删除。</span><br><span class="line"></span><br><span class="line">// Increment reference count for ip.</span><br><span class="line">// Returns ip to enable ip = idup(ip1) idiom.</span><br><span class="line">struct inode\*</span><br><span class="line">idup(struct inode \*ip)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line">  ip-&gt;ref++;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">  return ip;</span><br><span class="line">&#125;</span><br><span class="line">// Drop a reference to an in-memory inode.</span><br><span class="line">// If that was the last reference, the inode table entry can</span><br><span class="line">// be recycled.</span><br><span class="line">// If that was the last reference and the inode has no links</span><br><span class="line">// to it, free the inode (and its content) on disk.</span><br><span class="line">// All calls to iput() must be inside a transaction in</span><br><span class="line">// case it has to free the inode.</span><br><span class="line">void</span><br><span class="line">iput(struct inode \*ip)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">  if(ip-&gt;ref == 1 &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == 0)&#123;</span><br><span class="line">    // inode has no links and no other references: truncate and free.</span><br><span class="line"></span><br><span class="line">    // ip-&gt;ref == 1 means no other process can have ip locked,</span><br><span class="line">    // so this acquiresleep() won&#x27;t block (or deadlock).</span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    release(&amp;itable.lock);</span><br><span class="line"></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    ip-&gt;type = 0;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = 0;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;itable.lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;itable.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; `itrunc()`函数先释放直接块，再释放间接块里所列出的那些块，最后再释放间接块自身。</span><br><span class="line"></span><br><span class="line">// Truncate(截断) inode (discard contents).</span><br><span class="line">// Caller must hold ip-&gt;lock.</span><br><span class="line">void</span><br><span class="line">itrunc(struct inode \*ip)</span><br><span class="line">&#123;</span><br><span class="line">  int i, j;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line">  uint \*a;</span><br><span class="line">  // 遍历前面NDIRECT个直接块，并进行释放块操作</span><br><span class="line">  for(i = 0; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    if(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint\*)bp-&gt;data;</span><br><span class="line">    // 遍历后面NINDIRECT个间接块，进行释放操作</span><br><span class="line">    for(j = 0; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      if(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = 0;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>bmap()</code>函数用于返回第<code>bn</code>个数据块的硬盘块号，参数<code>ip</code>用于表示inode的指针。如果<code>ip</code>里没有那个块，<code>bmap</code>会给它分配一个。</p><p>(注：由于一个块的大小<code>BSIZE</code>是1024字节且<code>NDIRECT</code>是12，所以一个文件可以直接载入的内容为12k字节。由于<code>NINDIRECT</code>是256，所以读取间接块后可以载入的内容是256k字节。)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static uint</span><br><span class="line">bmap(struct inode \*ip, uint bn)</span><br><span class="line">&#123;</span><br><span class="line">  uint addr, \*a;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line">  // 判断是否为直接块</span><br><span class="line">  if(bn &lt; NDIRECT)&#123;</span><br><span class="line">    if((addr = ip-&gt;addrs[bn]) == 0)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">  // 判断是否是间接块</span><br><span class="line">  if(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    // Load indirect block, allocating if necessary.</span><br><span class="line">    if((addr = ip-&gt;addrs[NDIRECT]) == 0)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint\*)bp-&gt;data;</span><br><span class="line">    if((addr = a[bn]) == 0)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(&quot;bmap: out of range&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>writei()</code>函数和<code>readi()</code>函数</p><p>比较简单，首先检查文件偏移和写入&#x2F;读取字节大小是否合法，合法后对数据进行循环拷贝.写入时，读取块，将源数据拷贝至缓冲区；读出时，读取块，将块数据拷贝至对应的区域。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// Write data to inode.</span><br><span class="line">// Caller must hold ip-&gt;lock.</span><br><span class="line">// If user_src==1, then src is a user virtual address;</span><br><span class="line">// otherwise, src is a kernel address.</span><br><span class="line">// Returns the number of bytes successfully written.</span><br><span class="line">// If the return value is less than the requested n,</span><br><span class="line">// there was an error of some kind.</span><br><span class="line">int</span><br><span class="line">writei(struct inode \*ip, int user_src, uint64 src, uint off, uint n)</span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line"></span><br><span class="line">  if(off &gt; ip-&gt;size  off + n &lt; off)</span><br><span class="line">    return -1;</span><br><span class="line">  if(off + n &gt; MAXFILE\*BSIZE)</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  for(tot=0; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    if(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == -1) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(off &gt; ip-&gt;size)</span><br><span class="line">    ip-&gt;size = off;</span><br><span class="line"></span><br><span class="line">  // write the i-node back to disk even if the size didn&#x27;t change</span><br><span class="line">  // because the loop above might have called bmap() and added a new</span><br><span class="line">  // block to ip-&gt;addrs[].</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  return tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">readi(struct inode \*ip, int user_dst, uint64 dst, uint off, uint n)</span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  struct buf \*bp;</span><br><span class="line"></span><br><span class="line">  if(off &gt; ip-&gt;size  off + n &lt; off)</span><br><span class="line">    return 0;</span><br><span class="line">  if(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  for(tot=0; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    if(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == -1) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      tot = -1;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  return tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Directory层"><a href="#Directory层" class="headerlink" title="Directory层"></a>Directory层</h2><h3 id="directory层结构体定义"><a href="#directory层结构体定义" class="headerlink" title="directory层结构体定义"></a>directory层结构体定义</h3><blockquote><p><code>inum</code>：该目录项对应的inode号</p><p><code>name</code>：该目录项的名称</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct dirent &#123;</span><br><span class="line">  ushort inum;</span><br><span class="line">  char name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="directory层函数定义"><a href="#directory层函数定义" class="headerlink" title="directory层函数定义"></a>directory层函数定义</h3><blockquote><p>函数<code>dirloopup()</code>在目录 i 结点所包含的下一层的所有文件中找到名称为name的文件目录项，首先判断inode的type是否为T_DIR (目录) ，如果不是则抛出异常；接着循环读取inode所☞的目录文件，读取每一个目录项，如果找到名字为name的目录项，则查找 该目录项指向的inode并返回该inode。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Look for a directory entry in a directory.</span><br><span class="line">// If found, set \*poff to byte offset of entry.</span><br><span class="line">struct inode\*</span><br><span class="line">dirlookup(struct inode \*dp, char \*name, uint \*poff)</span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  struct dirent de;</span><br><span class="line"></span><br><span class="line">  if(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(&quot;dirlookup not DIR&quot;);</span><br><span class="line"></span><br><span class="line">  for(off = 0; off &lt; dp-&gt;size; off += sizeof(de))&#123;</span><br><span class="line">    if(readi(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span><br><span class="line">      panic(&quot;dirlookup read&quot;);</span><br><span class="line">    if(de.inum == 0)</span><br><span class="line">      continue;</span><br><span class="line">    if(namecmp(name, de.name) == 0)&#123;</span><br><span class="line">      // entry matches path element</span><br><span class="line">      if(poff)</span><br><span class="line">        \*poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      return iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>namex()</code>函数</p><ul><li><code>namex</code>首先决定路径计算从哪里开始。如果路径是从斜杠开始的，计算从根目录开始；否则，就从当前目录开始；</li><li>用<code>skipelem</code>来依次得到路径里的每个元素；</li><li>每次循环都必须在当前inode(<code>ip</code>)查找<code>name</code>；</li><li>循环首先锁定<code>ip</code>并检查它是否是一个目录，如果不是，查找失败；</li><li>如果这个调用是<code>nameiparent</code>并且这是最后一个路径元素，按照<code>nameiparent</code>的定义，循环终止；</li><li>最后，使用<code>dirlookup</code>查找路径元素，并通过设置<code>ip = next</code>为下一次循环做好准备。当循环遍历完所有的路径元素退出后，<code>namex</code>返回<code>ip</code>；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">// Look up and return the inode for a path name.</span><br><span class="line">// If parent != 0, return the inode for the parent and copy the final</span><br><span class="line">// path element into name, which must have room for DIRSIZ bytes.</span><br><span class="line">// Must be called inside a transaction since it calls iput().</span><br><span class="line">static struct inode\*</span><br><span class="line">namex(char \*path, int nameiparent, char \*name)</span><br><span class="line">&#123;</span><br><span class="line">  struct inode \*ip, \*next;</span><br><span class="line"></span><br><span class="line">  if(\*path == &#x27;/&#x27;)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  else</span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  while((path = skipelem(path, name)) != 0)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    if(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(nameiparent &amp;&amp; \*path == &#x27;\\0&#x27;)&#123;</span><br><span class="line">      // Stop one level early.</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      return ip;</span><br><span class="line">    &#125;</span><br><span class="line">    if((next = dirlookup(ip, name, 0)) == 0)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  if(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return ip;</span><br><span class="line">&#125;</span><br><span class="line">// Paths</span><br><span class="line"></span><br><span class="line">// Copy the next path element from path into name.</span><br><span class="line">// Return a pointer to the element following the copied one.</span><br><span class="line">// The returned path has no leading slashes,</span><br><span class="line">// so the caller can check \*path==&#x27;\\0&#x27; to see if the name is the last one.</span><br><span class="line">// If no name to remove, return 0.</span><br><span class="line">//</span><br><span class="line">// Examples:</span><br><span class="line">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span><br><span class="line">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span><br><span class="line">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span><br><span class="line">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span><br><span class="line">//</span><br><span class="line">static char\*</span><br><span class="line">skipelem(char \*path, char \*name)</span><br><span class="line">&#123;</span><br><span class="line">  char \*s;</span><br><span class="line">  int len;</span><br><span class="line">  // 过滤路径字符串开头所有的&#x27;/&#x27;</span><br><span class="line">  while(\*path == &#x27;/&#x27;)</span><br><span class="line">    path++;</span><br><span class="line">  if(\*path == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  s = path;</span><br><span class="line">  while(\*path != &#x27;/&#x27; &amp;&amp; \*path != 0)</span><br><span class="line">    path++;</span><br><span class="line">  len = path - s;</span><br><span class="line">  if(len &gt;= DIRSIZ)</span><br><span class="line">    memmove(name, s, DIRSIZ);</span><br><span class="line">  else &#123;</span><br><span class="line">    memmove(name, s, len);</span><br><span class="line">    name[len] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  while(\*path == &#x27;/&#x27;)</span><br><span class="line">    path++;</span><br><span class="line">  return path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; `dirlink()`函数</span><br><span class="line">&gt; </span><br><span class="line">&gt; 在目录 i 结点dp中添加一个新的名字为name的目录项</span><br><span class="line"></span><br><span class="line">// Write a new directory entry (name, inum) into the directory dp.</span><br><span class="line">int</span><br><span class="line">dirlink(struct inode \*dp, char \*name, uint inum)</span><br><span class="line">&#123;</span><br><span class="line">  int off;</span><br><span class="line">  struct dirent de;</span><br><span class="line">  struct inode \*ip;</span><br><span class="line"></span><br><span class="line">  // Check that name is not present.</span><br><span class="line">  if((ip = dirlookup(dp, name, 0)) != 0)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Look for an empty dirent.</span><br><span class="line">  for(off = 0; off &lt; dp-&gt;size; off += sizeof(de))&#123;</span><br><span class="line">    if(readi(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span><br><span class="line">      panic(&quot;dirlink read&quot;);</span><br><span class="line">    if(de.inum == 0)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  strncpy(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  if(writei(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span><br><span class="line">    panic(&quot;dirlink&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="file-descriptor层"><a href="#file-descriptor层" class="headerlink" title="file descriptor层"></a>file descriptor层</h2><h3 id="file-descriptor层的数据结构定义"><a href="#file-descriptor层的数据结构定义" class="headerlink" title="file descriptor层的数据结构定义"></a>file descriptor层的数据结构定义</h3><blockquote><p><code>readable</code>、<code>writable</code>刻画文件的读写权限，<code>off</code>表示文件读写偏移；</p><p><code>ftable</code>管理所有打开的文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">  enum &#123; FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  int ref; // reference count</span><br><span class="line">  char readable;</span><br><span class="line">  char writable;</span><br><span class="line">  struct pipe \*pipe; // FD_PIPE</span><br><span class="line">  struct inode \*ip;  // FD_INODE and FD_DEVICE</span><br><span class="line">  uint off;          // FD_INODE</span><br><span class="line">  short major;       // FD_DEVICE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct file file[NFILE];</span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure><h3 id="file-descriptor层函数定义"><a href="#file-descriptor层函数定义" class="headerlink" title="file descriptor层函数定义"></a>file descriptor层函数定义</h3><blockquote><p><code>filealloc</code>扫描文件表查找未引用的文件(<code>f-&gt;ref == 0</code>)并返回一个新的引用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a file structure.</span><br><span class="line">struct file\*</span><br><span class="line">filealloc(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct file \*f;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  for(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    if(f-&gt;ref == 0)&#123;</span><br><span class="line">      f-&gt;ref = 1;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      return f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>filedup</code>递增引用计数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Increment ref count for file f.</span><br><span class="line">struct file\*</span><br><span class="line">filedup(struct file \*f)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  if(f-&gt;ref &lt; 1)</span><br><span class="line">    panic(&quot;filedup&quot;);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fileclose</code>递减引用计数。当引用计数降为0，释放底层对应的管道或inode。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Close file f.  (Decrement ref count, close when reaches 0.)</span><br><span class="line">void</span><br><span class="line">fileclose(struct file \*f)</span><br><span class="line">&#123;</span><br><span class="line">  struct file ff;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  if(f-&gt;ref &lt; 1)</span><br><span class="line">    panic(&quot;fileclose&quot;);</span><br><span class="line">  if(--f-&gt;ref &gt; 0)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = \*f;</span><br><span class="line">  f-&gt;ref = 0;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  if(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; else if(ff.type == FD_INODE  ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>filestat</code>实现了对文件的<code>stat</code>操作（<code>stat操作是文件/文件系统的详细信息显示</code>）。它只允许操作inode，然后调用<code>stati</code>；最后将数据从内核拷贝至用户。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Get metadata about file f.</span><br><span class="line">// addr is a user virtual address, pointing to a struct stat.</span><br><span class="line">int</span><br><span class="line">filestat(struct file \*f, uint64 addr)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line">  struct stat st;</span><br><span class="line">  </span><br><span class="line">  if(f-&gt;type == FD_INODE  f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    if(copyout(p-&gt;pagetable, addr, (char \*)&amp;st, sizeof(st)) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fileread</code>实现了对文件的<code>read</code>操作。首先检查是否允许<code>readable</code>模式，然后把调用传递给管道或inode的实现。如果文件是一个inode，它使用I&#x2F;O位移作为读操作的位移，然后增加这个位移。管道没有位移的概念。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Read from file f.</span><br><span class="line">// addr is a user virtual address.</span><br><span class="line">int</span><br><span class="line">fileread(struct file \*f, uint64 addr, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int r = 0;</span><br><span class="line"></span><br><span class="line">  if(f-&gt;readable == 0)</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  if(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; else if(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    if(f-&gt;major &lt; 0  f-&gt;major &gt;= NDEV  !devsw[f-&gt;major].read)</span><br><span class="line">      return -1;</span><br><span class="line">    r = devsw[f-&gt;major].read(1, addr, n);</span><br><span class="line">  &#125; else if(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    if((r = readi(f-&gt;ip, 1, addr, f-&gt;off, n)) &gt; 0)</span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    panic(&quot;fileread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>filewrite</code>实现了对文件的<code>write</code>操作。首先检查是否允许<code>writeable</code>模式，然后把调用传递给管道或inode的实现。如果文件是一个inode，它使用I&#x2F;O位移作为写操作的位移，然后增加这个位移。管道没有位移的概念。要记得inode函数需要调用者管理锁定。inode的锁定有一个方便的附加效果，即读写位移是自动更新的，因此同时对一个文件的多个写操作不会覆盖彼此的数据，但这些写操作可能会交错在一起。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// Write to file f.</span><br><span class="line">// addr is a user virtual address.</span><br><span class="line">int</span><br><span class="line">filewrite(struct file \*f, uint64 addr, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int r, ret = 0;</span><br><span class="line"></span><br><span class="line">  if(f-&gt;writable == 0)</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  if(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; else if(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    if(f-&gt;major &lt; 0  f-&gt;major &gt;= NDEV  !devsw[f-&gt;major].write)</span><br><span class="line">      return -1;</span><br><span class="line">    ret = devsw[f-&gt;major].write(1, addr, n);</span><br><span class="line">  &#125; else if(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    // write a few blocks at a time to avoid exceeding</span><br><span class="line">    // the maximum log transaction size, including</span><br><span class="line">    // i-node, indirect block, allocation blocks,</span><br><span class="line">    // and 2 blocks of slop for non-aligned writes.</span><br><span class="line">    // this really belongs lower down, since writei()</span><br><span class="line">    // might be writing a device like the console.</span><br><span class="line">    int max = ((MAXOPBLOCKS-1-1-2) / 2) \* BSIZE;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i &lt; n)&#123;</span><br><span class="line">      int n1 = n - i;</span><br><span class="line">      if(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      if ((r = writei(f-&gt;ip, 1, addr + i, f-&gt;off, n1)) &gt; 0)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      if(r != n1)&#123;</span><br><span class="line">        // error from writei</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : -1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    panic(&quot;filewrite&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>sys_link</code>从获取它的两个字符串参数<code>old</code>和<code>new</code>开始。如果<code>old</code>存在且不是目录，递增它的<code>ip-&gt;nlink</code>计数。然后调用<code>nameiparent</code>来找到<code>new</code>的父目录和最终的路径元素，并创建一个新的目录条目来指向<code>old</code>的inode。新的上级目录必须存在且和inode在同一设备上：inode号在单独的磁盘上有唯一的意义。如果发生了这样的错误，<code>sys_link</code>必须回退且递减<code>ip-&gt;nlink</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Create the path new as a link to the same inode as old.</span><br><span class="line">uint64</span><br><span class="line">sys_link(void)</span><br><span class="line">&#123;</span><br><span class="line">  char name[DIRSIZ], new[MAXPATH], old[MAXPATH];</span><br><span class="line">  struct inode \*dp, \*ip;</span><br><span class="line"></span><br><span class="line">  if(argstr(0, old, MAXPATH) &lt; 0  argstr(1, new, MAXPATH) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  if((ip = namei(old)) == 0)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ilock(ip);</span><br><span class="line">  if(ip-&gt;type == T_DIR)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line"></span><br><span class="line">  if((dp = nameiparent(new, name)) == 0)</span><br><span class="line">    goto bad;</span><br><span class="line">  ilock(dp);</span><br><span class="line">  if(dp-&gt;dev != ip-&gt;dev  dirlink(dp, name, ip-&gt;inum) &lt; 0)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    goto bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;nlink--;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……还有很多与文件相关的系统调用，不一一列举了</p><h2 id="读写操作和设备文件"><a href="#读写操作和设备文件" class="headerlink" title="读写操作和设备文件"></a>读写操作和设备文件</h2><blockquote><p><code>file.c</code>和<code>file.h</code>文件中记录了xv6的驱动</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// map major device number to device functions.</span><br><span class="line">struct devsw &#123;</span><br><span class="line">  int (\*read)(int, uint64, int);</span><br><span class="line">  int (\*write)(int, uint64, int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct devsw devsw[NDEV];&#x2F;&#x2F; 其中NDEV &#x3D; 10，xv6最多支持10种不同的驱动<br>#define CONSOLE 1&#x2F;&#x2F; xv6只实现了Console的读写</p><blockquote><p>在<code>console.c</code>种，console的读写绑定到devsw上了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">consoleinit(void)</span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, &quot;cons&quot;);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  // connect read and write system calls</span><br><span class="line">  // to consoleread and consolewrite.</span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init.c</code>中的一段代码</p><ul><li>创建设备文件console；</li><li>将<code>CONSOLE(major号)</code>绑定到console文件上；</li><li>打开console。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(open(&quot;console&quot;, O_RDWR) &lt; 0)&#123;</span><br><span class="line">  mknod(&quot;console&quot;, CONSOLE, 0);</span><br><span class="line">  open(&quot;console&quot;, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line">dup(0);  // stdout</span><br><span class="line">dup(0);  // stderr</span><br></pre></td></tr></table></figure><strong>一个设备文件总是绑定了一个驱动函数，打开设备文件后的读写，就相当于调用相应的驱动程序</strong>。</li></ul><h1 id="7-Lock"><a href="#7-Lock" class="headerlink" title="7:Lock"></a>7:Lock</h1><p>许多操作系统内核,包括xv6都保持着多线程多进程执行,首先是因为这个xv6有许多个微处理器,这些处理器(CPU)是独立地执行一段代码,共享物理内存,这个时候就会有问题,就是在一个CPU读取数据的时候,另外一个CPU会写数据,或者说多个CPU同时写数据.这些都会出现问题.所以说多进程多线程的同步问题是非常重要的,我们需要一系列同步的手段来保证同步.所以这个词“并发性”代表多个指令同时执行的情况,由于中断操作,线程切换以及多核并行执行,我们不得不考虑并发性的问题.</p><p>这一章我们会举出一些由于并发性导致的程序执行错误的例子,并着重介绍一个使用广泛的并发操作:锁.</p><h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><p>首先我们举一个简单的例子来解释什么叫做race现象.假设有两个进程同时调用wait.wait需要free掉子进程的内存,所以说在每个CPU,这个内核会调用kfree来执行操作,kalloc()会从空闲页链表中取出链表首部,kfree()就是从空闲页链表中放一个页进入首部.这个时候两个进程都会进入到wait调用中,这个时候程序的结果是不确定的!</p><p>因为你不知道程序执行的顺序,因为CPU的调度我们具体也无法得知.假设这两个进程分别是A和B,这个时候有一种可能就是,A先取了链表的头,B随后取链表的头,A改完之后放进去,B改完之后放进去.这个时候B的修改<strong>覆盖</strong>了A的修改,导致了执行的错误.</p><p>这个叫做race现象,具体的来说就是,对于内存区域的同一块区域有多个进程同时访问,往往,出现race现象就代表着离出现bug也不远了.对于争用现象,最重要的问题就是我们对与并行程序的控制不是很够,我们不知道并行程序的执行顺序,所以说我们要加上一点控制手段来控制执行程序.</p><h2 id="spinlocks"><a href="#spinlocks" class="headerlink" title="spinlocks"></a>spinlocks</h2><p>xv6自旋锁(<code>spinlock</code>)用于内核临界区访问的同步和互斥。自旋锁最大的特征是当进程拿不到锁时会进入无限循环，直到拿到锁退出循环。Xv6使用100ms一次的时钟中断和Round-Robin调度算法来避免陷入自旋锁的进程一直无限循环下去。Xv6允许同时运行多个CPU核，多核CPU上的等待队列实现相当复杂，因此使用自旋锁是相对比较简单且能正确执行的实现方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Mutual exclusion lock.</span><br><span class="line">struct spinlock &#123;</span><br><span class="line">  uint locked;       // Is the lock held?</span><br><span class="line"></span><br><span class="line">  // For debugging:</span><br><span class="line">  char \*name;        // Name of lock.</span><br><span class="line">  struct cpu \*cpu;   // The cpu holding the lock.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最重要的就是一个int类型的变量,这个变量帮助我们记录一下锁有没有被使用.</p><p>首先调用锁之前我们要对锁进行初始化,初始化的操作就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">initlock(struct spinlock \*lk, char \*name)</span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = 0;</span><br><span class="line">  lk-&gt;cpu = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个锁结构,还有一个名字,把名字存进去,其他的元素赋值0即可.</p><p>RISC-V会给定一个指令,这个指令叫做<code>amoswap</code>,这是一个原子指令,使用方法是这个<code>amoswap r, a</code>.本质上就是lw指令,把地址a的内存元素放进r对应的寄存器,但是有一点比较特殊的是:这个操作可以保证在执行操作的时候r和a都不会被其他CPU访问到.保证了同步控制.(不给其他CPU访问相当于规定了对于这个内存的访问顺序).</p><p>xv6使用acquire来获取锁的控制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">acquire(struct spinlock \*lk)</span><br><span class="line">&#123;</span><br><span class="line">  push_off(); // disable interrupts to avoid deadlock.</span><br><span class="line">  if(holding(lk))</span><br><span class="line">    panic(&quot;acquire&quot;);</span><br><span class="line"></span><br><span class="line">  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span><br><span class="line">  //   a5 = 1</span><br><span class="line">  //   s1 = &amp;lk-&gt;locked</span><br><span class="line">  //   amoswap.w.aq a5, a5, (s1)</span><br><span class="line">  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  // Tell the C compiler and the processor to not move loads or stores</span><br><span class="line">  // past this point, to ensure that the critical section&#x27;s memory</span><br><span class="line">  // references happen strictly after the lock is acquired.</span><br><span class="line">  // On RISC-V, this emits a fence instruction.</span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  // Record info about lock acquisition for holding() and debugging.</span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会一直调用一个C的库函数,这个库函数会按照注释的方法调用来获取数据,如果这个锁一直都没有释放,就让它一直这么循环下去,直到锁被释放了为止.一释放这个进程就获得锁,在获得的第一瞬间把lock值赋值1.然后获取之后为了调试需要顺便记录一下CPU的值.</p><p>下面是锁的释放:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">release(struct spinlock \*lk)</span><br><span class="line">&#123;</span><br><span class="line">  if(!holding(lk))</span><br><span class="line">    panic(&quot;release&quot;);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = 0;</span><br><span class="line"></span><br><span class="line">  // Tell the C compiler and the CPU to not move loads or stores</span><br><span class="line">  // past this point, to ensure that all the stores in the critical</span><br><span class="line">  // section are visible to other CPUs before the lock is released,</span><br><span class="line">  // and that loads in the critical section occur strictly before</span><br><span class="line">  // the lock is released.</span><br><span class="line">  // On RISC-V, this emits a fence instruction.</span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  // Release the lock, equivalent to lk-&gt;locked = 0.</span><br><span class="line">  // This code doesn&#x27;t use a C assignment, since the C standard</span><br><span class="line">  // implies that an assignment might be implemented with</span><br><span class="line">  // multiple store instructions.</span><br><span class="line">  // On RISC-V, sync_lock_release turns into an atomic swap:</span><br><span class="line">  //   s1 = &amp;lk-&gt;locked</span><br><span class="line">  //   amoswap.w zero, zero, (s1)</span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先把cpu的值设置为0,然后通过同步的赋值指令把值赋值,这个就代表这个进程结束了对临界区的访问,现在可以让其他进程访问了.</p><h2 id="自旋锁的使用"><a href="#自旋锁的使用" class="headerlink" title="自旋锁的使用."></a>自旋锁的使用.</h2><p>xv6使用锁来防止race现象的发生.对于使用锁,下面有几个基本的准则:</p><p>第一个就是如果有一个变量,一个CPU写的时候另外一个CPU可以去读,这个时候我们需要保护这个变量.第二,记住锁要保护不变量(不变量指的是在某些时候不能被其他程序改变的变量).总的来说就是,如果有可能有多个进程会对一个数据结构进行更改的话,那么我们必须得采取一定的措施来让进程有序地访问数据结构.</p><p>当然过分地使用锁也是不应该的,如果这个程序只可能有一个进程访问,那么就没必要使用锁.</p><p>使用锁的一个特征就是,我们把访问和修改数据结构的代码称为临界区,当进入临界区的时候获得锁,当离开临界区的时候释放锁.</p><p>获得锁</p><p>临界区</p><p>释放锁</p><h2 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h2><p>我们首先得知道,对于不同锁,我们要保证锁的获取顺序是一定的,如果有一段代码要求先获得A锁,再获得B锁.另外一段代码要求获得B锁,在获得A锁,这个时候就会造成卡死.因为一段代码等待B锁,另外一段代码等待A锁.就互相等待,卡死了.</p><p>在xv6里面也有很多这样的锁链,比如说在console.c中,首先获取了<code>cons.lock</code>,接着调用wakeup函数,这个又获得<code>p.lock</code>.在文件系统中也是首先获取<code>vdisk.lock</code>再获取<code>p-&gt;lock</code>.xv6里面的锁都有着巧妙的安排,这样可以避免死锁的发生.</p><p>死锁有可能是程序的逻辑结构出现了问题,有时锁的特征事先不知道，可能是因为必须持有一个锁才能发现下一个要获取的锁的特征。最后,死锁发生与否取决于你怎么规划和使用锁,使用的锁越多就越容易死锁.</p><p>一个比较朴素的方法就是使用“重入锁”.重入锁的设计就是如果一一个锁是被一个进程拥有的,我们还是允许这个进程再获得这个锁.而不是执行panic指令.然而，事实证明，重入锁使并发性更难推理：重入锁打破了锁导致关键部分相对于其他关键部分是原子的直觉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct spinlock lock;</span><br><span class="line">int data = 0; // protected by lock</span><br><span class="line">f() &#123;</span><br><span class="line">acquire(&amp;lock);</span><br><span class="line">if(data == 0)&#123;</span><br><span class="line">call_once();</span><br><span class="line">h();</span><br><span class="line">data = 1;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">g() &#123;</span><br><span class="line">aquire(&amp;lock);</span><br><span class="line">if(data == 0)&#123;</span><br><span class="line">call_once();</span><br><span class="line">data = 1;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面,假设h函数就是执行g函数的调用,如果饮用了重入锁的话,这个call_once就会执行两遍.但是不引入重入锁的话就会导致死锁.出于这个问题,我们还是放弃了可重入锁,所以说对于程序的编写者来说,我们尽量确定好锁的申请顺序,防止A进程拥有a锁等待b锁,B进程拥有b锁等待a锁的存在.</p><p>获取锁之后进入临界区的时候,由于防止被中断打断进入中断处理程序从而导致死锁,所以说获得锁的死后就会打断中断.举个例子,比如说处理时钟中断的时候,clockintr会获得tickslock.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">clockintr()</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此同时,在执行中断操作的<code>sys_sleep</code>函数也会访问tickslock:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sleep(void)</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  if(argint(0, &amp;n) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  while(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    if(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说为了避免中断打断之后的死锁现象,一个CPU运行的代码获得了锁之后,这个CPU的中断就会被禁止.所以说这个时候就要禁用中断,但是禁用中断的时候要改变中断使能寄存器:我们就用一个栈来存储之,这个存储中断使能寄存器的函数就是<code>push_pff</code>和<code>pop_off</code>.当然一个CPU对应上的进程能开启多个锁,所以说我们用一个intena来代表这个进程拥有多少锁.所以说我们在acquire中申请一遍,在release中再申请一遍.</p><p>为了避免死锁，xv6中规定若一个进程持有<code>spinlock</code>，则必须要禁用中断。如果此时中断开启，那么可能会出现以下死锁情况：</p><ol><li>进程A在内核态运行并拿下了p锁时，触发中断进入中断处理程序。</li><li>中断处理程序也在内核态中请求p锁，由于锁在A进程手里，且只有A进程执行时才能释放p锁，因此中断处理程序必须返回，p锁才能被释放。</li><li>那么此时中断处理程序会永远拿不到锁，陷入无限循环，进入死锁。</li></ol><p>因此调用<code>push_off</code>和<code>pop_off</code>来禁用和开启中断。</p><p>获取锁的过程可能嵌套：一个进程获取了锁A，然后再获取锁B，释放锁B时，由于A还未释放，因此不能开启中断。注：<code>struct cpu</code>中的<code>noff</code>记录目前的深度，<code>intena</code>记录在获取第一把锁之前的中断使能状态，当深度为0且<code>intena</code>为1（所有锁都被释放且最初的使能状态为1）时，才开启中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span><br><span class="line">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span><br><span class="line">// are initially off, then push_off, pop_off leaves them off.</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">push_off(void)</span><br><span class="line">&#123;</span><br><span class="line">  // 获取之前的中断使能状态</span><br><span class="line">  int old = intr_get();</span><br><span class="line">  // 关闭中断使能</span><br><span class="line">  intr_off();</span><br><span class="line">  if(mycpu()-&gt;noff == 0)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">pop_off(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct cpu \*c = mycpu();</span><br><span class="line">  if(intr_get())</span><br><span class="line">    panic(&quot;pop_off - interruptible&quot;);</span><br><span class="line">  if(c-&gt;noff &lt; 1)</span><br><span class="line">    panic(&quot;pop_off&quot;);</span><br><span class="line">  c-&gt;noff -= 1;</span><br><span class="line">  if(c-&gt;noff == 0 &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指令和内存顺序"><a href="#指令和内存顺序" class="headerlink" title="指令和内存顺序"></a>指令和内存顺序</h2><p>我们一般会认为指令的执行顺序和我们代码的编辑顺序是一样的,但是其实这个并不绝对.CPU为了执行的速度,往往会做一些修改.假如说A和B一组指令,CPU可能会先让B执行,可能因为<strong>B的输入比A的输入</strong>先准备好,也有可能是因为执行B的时间比A长,我们不如先执行B,,这样B和A可以同步执行,增加CPU的效率,当然对于编译器,编译器也可能会把后面的指令移动到前面.当然CPU和编译器这么做的前提就是我不会改变输出的结果.但是,这样的特性对于锁来说是不好的,<strong>这对多处理器的情况下,有可能会出现与时间有关的问题</strong>.总而言之,CPU和编译器可能会提高效率改变指令执行的顺序.</p><p>比如说下面的这个例子:假如说第4行的语句移动到第6行之后就会引起严重的后果.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1  l = malloc(sizeof \*l);</span><br><span class="line">2  l-&gt;data = data;</span><br><span class="line">3  acquire(&amp;listlock);</span><br><span class="line">4  l-&gt;next = list;</span><br><span class="line">5  list = l;</span><br><span class="line">6  release(&amp;listlock);</span><br></pre></td></tr></table></figure><p>这个时候对于其他的进程来说看到了被更新的list,但是看到了没有被初始化的list-&gt;next.这样是不好的.</p><p>去告诉CPU和编译器不要执行这样的重新编排,我们在acquire和release中执行了 <code>__sync_synchronize()</code>函数,这个函数类似于一个<code>memery barrier</code>.之前的指令不可以跨过这个memeory_barrier执行.</p><h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><p>自旋锁是这个进程一直等待别的进程把锁释放,这个进程在一直执行一个循环等待释放,这个锁适用于获得锁到释放锁用不了多久的时间的那种,等待的一方执行执行不了不久循环.但是万一这个锁要使用很久呢,一直等待别人,等一会儿还行,等很久我不如先睡一会儿,等别人用完了再叫醒我就好了.</p><p>所以说xv6提供一个睡眠锁.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">acquiresleep(struct sleeplock \*lk)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  while (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = 1;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得锁的时候,自旋锁就是一直查询,查询到可以使用锁了就接着往下走,但是这个睡眠锁就不一样了,当锁被占用的时候,它就直接引入睡眠模式,当有进程release这个锁的时候这个进程就会被唤醒,然后再查询一遍锁是否是可用的即可.如果是可用的,就往下执行和spinlock一样的操作.</p><p>总结:自旋锁就是一直查,睡眠锁就是被叫醒一次查一次.</p><p>对于release操作也是一样:首先清空标记,然后把所有为了lk而等待的进程全部唤醒.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">releasesleep(struct sleeplock \*lk)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = 0;</span><br><span class="line">  lk-&gt;pid = 0;</span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Operating-System-Overview&quot;&gt;&lt;a href=&quot;#1-Operating-System-Overview&quot; class=&quot;headerlink&quot; title=&quot;1:Operating System Overview&quot;&gt;&lt;/a&gt;1:Ope</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>MIT_6.s081_Lab</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/02/08/mit-6-s081-lab/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/02/08/mit-6-s081-lab/</id>
    <published>2023-02-08T03:02:54.000Z</published>
    <updated>2024-03-25T01:34:55.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Xv6-and-Unix-utilities"><a href="#1-Xv6-and-Unix-utilities" class="headerlink" title="1:Xv6 and Unix utilities"></a>1:Xv6 and Unix utilities</h1><p>运行环境:Ubuntu 20.04 qemu</p><p>在做6.s081的实验之前我们首先要先下载Xv6操作系统以及qemu虚拟机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure><h2 id="Lab1-1-Boot-xv6"><a href="#Lab1-1-Boot-xv6" class="headerlink" title="Lab1_1:Boot xv6"></a>Lab1_1:Boot xv6</h2><p>运行并安全退出xv6系统:</p><p>运行的方法很简单:cd进xv6的文件夹里面,然后输入`make qemu`即可,输入完之后就是进入了xv6的系统里面了</p><p>退出的方法就是,先Ctrl+A,再输入x即可.</p><h2 id="Lab1-2-sleep"><a href="#Lab1-2-sleep" class="headerlink" title="Lab1_2 sleep"></a>Lab1_2 sleep</h2><p>本实验要为 xv6 实现 UNIX 程序 sleep； 您的睡眠应暂停用户指定的滴答数。 滴答是 xv6 内核定义的时间概念，即来自定时器芯片的两次中断之间的时间。</p><p>一些提示：</p><ul><li>在开始编码之前，请阅读<a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 书籍</a>第 1 章。（中文版<a href="https://drive.google.com/file/d/1QmK2EgNgYEniHJnn2jidtNsK1uclZ9KM/view?usp=sharing">xv6 书籍</a>)</li><li>查看<code>user/</code>中的其他一些程序 （例如，<code>user/echo.c</code>、<code>user/grep.c</code>和<code>user/rm.c</code>）以了解如何获取传递给程序的命令行参数。</li><li>如果用户忘记传递参数， sleep 应该打印错误消息。</li><li>命令行参数作为字符串传递；您可以使用<code>atoi</code>将其转换为整数（请参阅 user&#x2F;ulib.c）。</li><li>使用系统调用<code>sleep</code>。</li><li>确保<code>main</code>调用<code>exit()</code>以退出您的程序。</li><li>将你的<code>睡眠</code>程序添加到Makefile 中的<code>UPROGS</code>；完成后，<code>make qemu</code>将编译您的程序，您将能够从 xv6 shell 运行它。</li><li>查看 Kernighan 和 Ritchie 的书*The C programming language (second edition)*（K&amp;R）以了解 C。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc,char \*argv[])&#123;</span><br><span class="line">  for(int i=0;!argv[i];i++)&#123;</span><br><span class="line">    if(argv[1][i]&gt;&#x27;9&#x27;argv[1][i]&lt;&#x27;0&#x27;)&#123;</span><br><span class="line">      write(1, &quot;error\\n&quot;, 6);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int times=atoi(argv[1]);</span><br><span class="line">  sleep(times);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>首先我们知道在C语言中argc代表传入的参数数,argv是传入的参数.</li></ul><p>第一个for循环就是判断这个是不是一个正常的数字(什么时候结束循环呢?),第二步用atoi函数转化成数字,最后执行系统调用sleep.</p><h2 id="Lab1-3-pingpong"><a href="#Lab1-3-pingpong" class="headerlink" title="Lab1_3 pingpong"></a>Lab1_3 pingpong</h2><p>编写一个程序，使用 UNIX 系统调用在两个进程之间通过一对管道“乒乓”一个字节，每个管道一个。 父母应该向孩子发送一个字节； 子进程应该打印“: received ping”，其中 是它的进程 ID，将管道上的字节写入父进程，然后退出； 父母应该从孩子那里读取字节，打印“: received pong”，然后退出。</p><p>一些提示：</p><ul><li>使用管道创建管道。</li><li>使用 fork 创建一个孩子。</li><li>使用 read 从管道读取，并使用 write 写入管道。</li><li>使用 getpid 查找调用进程的进程 ID。</li><li>将程序添加到 Makefile 中的 UPROGS。</li><li>xv6 上的用户程序有一组有限的库函数可供它们使用。 可以在 user&#x2F;user.h 中看到列表； 源（系统调用除外）位于 user&#x2F;ulib.c、user&#x2F;printf.c 和 user&#x2F;umalloc.c。</li></ul><p>我们可以认为pipe是一个Linux进程间通讯的一种方式,一个管道以一个两位的int类型数组构成,其中第一个元素是读端的接口编号,第二个元素是写端的接口编号.然后可以使用read和write来进行读取,注意管道的端口有读端口和写端口之分,读的时候只能从读端口读数据,写的时候只能从写的端口写数据.</p><p>有点像我们之前操作系统课上面学到的缓冲区的结构,缓冲区有两端,一端读一端写.</p><p>系统调用:<br>可以使用pipe(一个二位的数组)来初始化一个管道.经过pipe了之后,第一个元素就是一个读取的端口,第二个元素就是对应写入的端口,<br>可以使用read(读端口,读出来的元素写在哪里,长度)来从一个读的端口读出元素<br>可以使用write(写端口,写出来的元素写在哪里,长度)来把元素写进一个端口.</p><p>fork函数就是一次调用,两次返回,调用之后父进程和子进程都从获得函数的返回值开始继续往下运行,就像一条河流,遇到了一个分叉口,河流分成了两叉,这两叉都从分叉口开始继续往下流.在这里分叉口就像fork()调用,调用生成了两个分叉,两个分叉都从fork()调用结束后继续往下走.</p><p><img src="https://img-blog.csdn.net/20161223173958916"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int p_filedes[2],s_filedes[2];</span><br><span class="line">  pipe(p_filedes);</span><br><span class="line">  pipe(s_filedes);</span><br><span class="line">  char buf[4];</span><br><span class="line">  if(fork()==0)&#123;</span><br><span class="line">    read(p_filedes[0],buf,4);</span><br><span class="line">    printf(&quot;%d: received %s\\n&quot;,getpid(),buf);</span><br><span class="line">    write(s_filedes[1],&quot;pong&quot;,4);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    write(p_filedes[1],&quot;ping&quot;,4);</span><br><span class="line">    read(s_filedes[0],buf,4);</span><br><span class="line">    printf(&quot;%d: received %s\\n&quot;,getpid(),buf);</span><br><span class="line">  &#125;</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的思路就是先初始化两根管道,接着父进程先read再写,子进程先写再read.</p><h2 id="Lab1-4-prime"><a href="#Lab1-4-prime" class="headerlink" title="Lab1_4 prime"></a>Lab1_4 prime</h2><p>编写一个程序,完成一个并发版本的prime初筛,第一个进程负责把2-35范围内的素数输入进管道,对于每一个素数,我们都需要fork一个进程来接受管道的数字然后输出出来.</p><ul><li>关闭进程不需要的文件描述符，否则你的程序将在第一个进程达到 35 之前耗尽 xv6 的资源。</li><li>一旦第一个进程达到 35，它应该等到整个管道终止，包括所有子、孙等。因此，主素数进程应该只在所有输出都被打印出来，并且在所有其他素数进程都退出之后才退出。</li><li>当管道的写端关闭时，read 返回零。</li><li>将 32 位（4 字节）整数直接写入管道是最简单的，而不是使用格式化的 ASCII I&#x2F;O。</li><li>您应该仅在需要时在管道中创建流程。</li><li>将程序添加到 Makefile 中的 UPROGS。</li></ul><p>基本的思路在下面,每一个进程对应一个素数,主进程负责传输2-34的数据给子进程们,每个进程对应一个素数,如果这个数%这个素数不为0的话就可以传给下一级的进程,如果没有下一级的进程那么fork一个新的进程,这个数一定是素数,这个进程就会接着处理来自左边邻居的数据,处理的方式.这样子每一个进程就像一个筛子,筛选不可能是素数的数.</p><p>总的来说主进程的数据首先从左到右到第一个子进程,判断能不能被2除,不可以就继续从左到右交给下一个子进程,判断能不能被3除…,如果下一个子进程是不存在的,那么新建一个进程,这个进程就代表对应数.</p><p><img src="https://pic3.zhimg.com/80/v2-cfd5f86fa2495b79eabf8bdaa24925f2_1440w.jpg"></p><h2 id="Lab1-5-find"><a href="#Lab1-5-find" class="headerlink" title="Lab1_5 find"></a>Lab1_5 find</h2><p>编写一个简单版本的 UNIX 查找程序：查找目录树中具有特定名称的所有文件。给定对应的文件名以及文件名在目录,找到文件名的位置.</p><ul><li>查看 user&#x2F;ls.c 以了解如何读取目录。</li><li>使用递归允许 find 访问到子目录。</li><li>不要递归到“.” 和 ”..”。</li><li>对文件系统的更改在 qemu 运行中持续存在； 要获得一个干净的文件系统，请运行 make clean 然后 make qemu。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct dirent &#123;</span><br><span class="line">  ushort inum;</span><br><span class="line">  char name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>上面是文件系统中关于目录文件内容的说明,inum说明这个文件占用了几个inode.该操作系统类似于Linux系统,磁盘分成磁盘块,磁盘块的一些相关控制信息就储存在存放在内存中的inode.文件系统获得文件,先找到文件的file结构,根据file结构找到inode,再根据inode找到磁盘块.</li></ul><p>说白了目录文件存储的就是一堆dirent类型的结构体.</p><p>下面就是stat信息,stat信息存放了文件的一些控制信息,比如说链接信息,大小和类型之类的.在我们利用open打开文件后,open函数会返回一个数字,我们再利用fstat这个调用找到stat控制块.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">  int dev;     // File system&#x27;s disk device</span><br><span class="line">  uint ino;    // Inode number</span><br><span class="line">  short type;  // Type of file</span><br><span class="line">  short nlink; // Number of links to file</span><br><span class="line">  uint64 size; // Size of file in bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先来看看xv6是如何完成对ls指令的支持的?</p><p>首先第一个函数:根据文件的的路径名提取出文件的名字,就是从后往前遍历,找到第一个‘&#x2F;’,这之间的那一部分就是文件的名字.</p><p>接着就是ls函数,ls函数中只需要提供当前的path,找到path里面的所有文件即可.首先先打开当前path对应的文件(Linux内部目录文件和普通的文件都是文件),再利用fstat系统调用找到stat的值.由于目录文件里面就是连续地存储了一堆dirent类型的结构体,那我们可以把目录文件的内容当成一个struct dirent<a href="%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84,%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%8E%BB%E8%AF%BB">MAX</a></p><p>最后就是main函数,就是看看输入的指令罢了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line">#include &quot;kernel/fs.h&quot;</span><br><span class="line"></span><br><span class="line">char\* fmtname(char \*path)</span><br><span class="line">&#123;</span><br><span class="line">  static char buf[DIRSIZ+1];</span><br><span class="line">  char \*p;</span><br><span class="line"></span><br><span class="line">  // Find first character after last slash.</span><br><span class="line">  for(p=path+strlen(path); p &gt;= path &amp;&amp; \*p != &#x27;/&#x27;; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  // Return blank-padded name.</span><br><span class="line">  if(strlen(p) &gt;= DIRSIZ)</span><br><span class="line">    return p;</span><br><span class="line">  memmove(buf, p, strlen(p));</span><br><span class="line">  memset(buf+strlen(p), &#x27; &#x27;, DIRSIZ-strlen(p));</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ls(char \*path)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[512], \*p;</span><br><span class="line">  int fd;</span><br><span class="line">  struct dirent de;</span><br><span class="line">  struct stat st;</span><br><span class="line"></span><br><span class="line">  if((fd = open(path, 0)) &lt; 0)&#123;</span><br><span class="line">    fprintf(2, &quot;ls: cannot open %s\\n&quot;, path);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(fstat(fd, &amp;st) &lt; 0)&#123;</span><br><span class="line">    fprintf(2, &quot;ls: cannot stat %s\\n&quot;, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch(st.type)&#123;</span><br><span class="line">  case T_FILE:</span><br><span class="line">    printf(&quot;%s %d %d %l\\n&quot;, fmtname(path), st.type, st.ino, st.size);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  case T_DIR:</span><br><span class="line">    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;</span><br><span class="line">      printf(&quot;ls: path too long\\n&quot;);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    strcpy(buf, path);</span><br><span class="line">    p = buf+strlen(buf);</span><br><span class="line">    \*p++ = &#x27;/&#x27;;</span><br><span class="line">    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;</span><br><span class="line">      if(de.inum == 0)</span><br><span class="line">        continue;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = 0;</span><br><span class="line">      if(stat(buf, &amp;st) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;ls: cannot stat %s\\n&quot;, buf);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;%s %d %d %d\\n&quot;, fmtname(buf), st.type, st.ino, st.size);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char \*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  if(argc &lt; 2)&#123;</span><br><span class="line">    ls(&quot;.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  for(i=1; i&lt;argc; i++)</span><br><span class="line">    ls(argv[i]);</span><br><span class="line">  exit(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以对ls指令稍微修改修改,ls只用找当前目录第一层的所有文件,那么我们也是找当前目录的所有文件,对于目录文件,我们继续往下搜索这个目录,对于普通文件,我们只用看名字是否匹配即可.</p><h2 id="Lab1-6-xargs"><a href="#Lab1-6-xargs" class="headerlink" title="Lab1_6 xargs"></a>Lab1_6 xargs</h2><p>这个指令就是我们要把若干条指令合并在一块进行执行.其中前面指令的standard out会作为下一条的指令一个输入来进行执行.</p><p>举个例子:前面指令的hello too作为standard out作为下一条指令的输入.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello too  xargs echo bye</span><br><span class="line">$ bye hello too</span><br></pre></td></tr></table></figure><ul><li>使用 fork 和 exec 对每一行输入调用命令。 在父级中使用 wait 等待子级完成命令。</li><li>要读取单行输入，请一次读取一个字符，直到出现换行符 (‘\n’)。</li><li>kernel&#x2F;param.h 声明了 MAXARG，如果您需要声明 argv 数组，这可能很有用。</li><li>对文件系统的更改在 qemu 运行中持续存在； 要获得一个干净的文件系统，请运行 make clean 然后 make qemu。</li><li>将程序添加到 Makefile 中的 UPROGS。</li></ul><p>首先第一步把指令xargs给删除掉:然后把标准输出(来源:0)获取下来,放入最后一个参数中进行执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/param.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char \*argv[])&#123;</span><br><span class="line">    char\* argvs[MAXARG];</span><br><span class="line">    for(int i=1;i&lt;argc;i++)&#123;</span><br><span class="line">        argvs[i-1]=argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[512];</span><br><span class="line">    int index;</span><br><span class="line">    int read_len;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        index = -1;</span><br><span class="line">        do&#123;</span><br><span class="line">            index++;</span><br><span class="line">            read_len=read(0,&amp;buf[index],sizeof(char));</span><br><span class="line">        &#125;while(read_len&gt;0&amp;&amp;buf[index]!=&#x27;\\n&#x27;);</span><br><span class="line">        if(read_len==0&amp;&amp;index==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[index]=&#x27;\\0&#x27;;</span><br><span class="line">        argvs[argc-1]=buf;</span><br><span class="line">         if (fork() == 0) &#123;</span><br><span class="line">            exec(argvs[0], argvs);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Xv6-and-Syscall"><a href="#2-Xv6-and-Syscall" class="headerlink" title="2:Xv6 and Syscall"></a>2:Xv6 and Syscall</h1><h2 id="Lab2-1-Trace"><a href="#Lab2-1-Trace" class="headerlink" title="Lab2_1 Trace."></a>Lab2_1 Trace.</h2><p>实验2_1主要是完成一个新的系统调用,这个系统调用主要的功能就是追踪,主要就是创建一个新的跟踪系统调用来控制跟踪,它应该采用一个参数,一个整数“掩码”,其位指定要跟踪的系统调用.比如说跟踪fork系统调用就会调用trace(1&lt;&lt;SYS_USER_FORK).我们需要修改 xv6 内核以在每个系统调用即将返回时打印出一行.该行应包含进程id、系统调用的名称和返回值,我们还必须对这个进程以及所有子进程进行跟踪.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//trace.c</span><br><span class="line">int main(int argc, char \*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  char \*nargv[MAXARG];</span><br><span class="line"></span><br><span class="line">  if(argc &lt; 3  (argv[1][0] &lt; &#x27;0&#x27;  argv[1][0] &gt; &#x27;9&#x27;))&#123;</span><br><span class="line">    fprintf(2, &quot;Usage: %s mask command\\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (trace(atoi(argv[1])) &lt; 0) &#123;</span><br><span class="line">    fprintf(2, &quot;%s: trace failed\\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">    nargv[i-2] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[0], nargv);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现在调用trace的时候,首先判断输入参数的合法性,然后再进行trace操作,接着再执行剩下的操作.这个时候trace就是一个系统调用,我们需要完成系统调用.</p><p>现在我们开始实验:</p><h5 id="1-在user-h中添加对于trace函数的支持"><a href="#1-在user-h中添加对于trace函数的支持" class="headerlink" title="1) 在user.h中添加对于trace函数的支持."></a>1) 在user.h中添加对于trace函数的支持.</h5><p>这里面存储了所有user函数会调用的系统调用.</p><h5 id="2-添加一个entry在user-pl里面"><a href="#2-添加一个entry在user-pl里面" class="headerlink" title="2) 添加一个entry在user.pl里面"></a>2) 添加一个entry在user.pl里面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># Generate usys.S, the stubs for syscalls.</span><br><span class="line"></span><br><span class="line">print &quot;# generated by usys.pl - do not edit\\n&quot;;</span><br><span class="line"></span><br><span class="line">print &quot;#include \\&quot;kernel/syscall.h\\&quot;\\n&quot;;</span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print &quot;.global $name\\n&quot;;</span><br><span class="line">    print &quot;$&#123;name&#125;:\\n&quot;;</span><br><span class="line">    print &quot; li a7, SYS_$&#123;name&#125;\\n&quot;;</span><br><span class="line">    print &quot; ecall\\n&quot;;</span><br><span class="line">    print &quot; ret\\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry(&quot;fork&quot;);</span><br><span class="line">entry(&quot;exit&quot;);</span><br><span class="line">entry(&quot;wait&quot;);</span><br><span class="line">entry(&quot;pipe&quot;);</span><br><span class="line">entry(&quot;read&quot;);</span><br><span class="line">entry(&quot;write&quot;);</span><br><span class="line">entry(&quot;close&quot;);</span><br><span class="line">entry(&quot;kill&quot;);</span><br><span class="line">entry(&quot;exec&quot;);</span><br><span class="line">entry(&quot;open&quot;);</span><br><span class="line">entry(&quot;mknod&quot;);</span><br><span class="line">entry(&quot;unlink&quot;);</span><br><span class="line">entry(&quot;fstat&quot;);</span><br><span class="line">entry(&quot;link&quot;);</span><br><span class="line">entry(&quot;mkdir&quot;);</span><br><span class="line">entry(&quot;chdir&quot;);</span><br><span class="line">entry(&quot;dup&quot;);</span><br><span class="line">entry(&quot;getpid&quot;);</span><br><span class="line">entry(&quot;sbrk&quot;);</span><br><span class="line">entry(&quot;sleep&quot;);</span><br><span class="line">entry(&quot;uptime&quot;);</span><br><span class="line">entry(&quot;trace&quot;);</span><br></pre></td></tr></table></figure><p>这个user.pl负责输出汇编代码,这个汇编代码就是user文件夹里面的代码调用系统调用之后由U态进入到S态的过渡代码,主要是构建参数的代码和ecall组成.</p><p>执行顺序:调用系统调用-&gt;user.pl生成的代码(U态进入到S态)-&gt;S态的系统调用.</p><h5 id="3-在syscall-h添加系统调用号"><a href="#3-在syscall-h添加系统调用号" class="headerlink" title="3) 在syscall.h添加系统调用号"></a>3) 在syscall.h添加系统调用号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// System call numbers</span><br><span class="line">#define SYS_fork    1</span><br><span class="line">#define SYS_exit    2</span><br><span class="line">#define SYS_wait    3</span><br><span class="line">#define SYS_pipe    4</span><br><span class="line">#define SYS_read    5</span><br><span class="line">#define SYS_kill    6</span><br><span class="line">#define SYS_exec    7</span><br><span class="line">#define SYS_fstat   8</span><br><span class="line">#define SYS_chdir   9</span><br><span class="line">#define SYS_dup    10</span><br><span class="line">#define SYS_getpid 11</span><br><span class="line">#define SYS_sbrk   12</span><br><span class="line">#define SYS_sleep  13</span><br><span class="line">#define SYS_uptime 14</span><br><span class="line">#define SYS_open   15</span><br><span class="line">#define SYS_write  16</span><br><span class="line">#define SYS_mknod  17</span><br><span class="line">#define SYS_unlink 18</span><br><span class="line">#define SYS_link   19</span><br><span class="line">#define SYS_mkdir  20</span><br><span class="line">#define SYS_close  21</span><br><span class="line">#define SYS_trace  22</span><br></pre></td></tr></table></figure><p>这个文件里面存储了系统调用的调用调用号,在后面这些宏就负责替换为编号.</p><h5 id="4-在proc结构体里面添加一个mask成员-用来记录要trace哪种系统调用"><a href="#4-在proc结构体里面添加一个mask成员-用来记录要trace哪种系统调用" class="headerlink" title="4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用."></a>4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用.</h5><h5 id="5-在kernel-sysproc-c里面实现具体的系统调用-在这里你会发现系统调用的实现会保存在这里"><a href="#5-在kernel-sysproc-c里面实现具体的系统调用-在这里你会发现系统调用的实现会保存在这里" class="headerlink" title="5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里."></a>5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_trace(void)</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  if (argint(0, &amp;n) &lt; 0) // get the number of argv[1].</span><br><span class="line">    return -1;</span><br><span class="line">  myproc()-&gt;mask = n;    // save in the mask.</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候可以通过argint系统调用来获得栈帧中保存的寄存器值.然后把寄存器的值保存到mask元素中.</p><h5 id="6-更改fork函数-添加mask的复制-np-mask-p-mask"><a href="#6-更改fork函数-添加mask的复制-np-mask-p-mask" class="headerlink" title="6) 更改fork函数,添加mask的复制.np-&gt;mask = p-&gt;mask;"></a>6) 更改fork函数,添加mask的复制.<code>np-&gt;mask = p-&gt;mask;</code></h5><p>这一步的目的就是为了让子进程执行系统调用也可以完成.</p><h5 id="7-添加syscall-c中关于trace函数的支持"><a href="#7-添加syscall-c中关于trace函数的支持" class="headerlink" title="7) 添加syscall.c中关于trace函数的支持."></a>7) 添加syscall.c中关于trace函数的支持.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在syscall的函数数组中添加即可.</span><br><span class="line">......</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line">//添加函数声明.</span><br><span class="line">extern uint64 sys_trace(void);</span><br></pre></td></tr></table></figure><h5 id="8-更改syscall-c的syscall函数"><a href="#8-更改syscall-c的syscall函数" class="headerlink" title="8) 更改syscall.c的syscall函数"></a>8) 更改syscall.c的syscall函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void)</span><br><span class="line">&#123;</span><br><span class="line">  int num;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    if (p-&gt;mask &amp; (1 &lt;&lt; num))</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;%d %s: unknown sys call %d\\n&quot;,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加关于追踪的函数,追踪的方法很简单,因为要追踪的mask是处于第几位的,只需要求一个与看看是不是0即可.</p><p>全部过关</p><h1 id="Lab2-2-sys-info"><a href="#Lab2-2-sys-info" class="headerlink" title="Lab2_2 sys info"></a>Lab2_2 sys info</h1><p>我们需要完成一个系统调用,给定一个struct sysinfo的指针,然后可以输出当前系统的可用进程数和可用内存数.</p><h5 id="1-在makefile-user-pl和user-h添加对于sysinfo系统调用的支持-不懂的请翻阅上面"><a href="#1-在makefile-user-pl和user-h添加对于sysinfo系统调用的支持-不懂的请翻阅上面" class="headerlink" title="1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)"></a>1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)</h5><h5 id="2-统计当前正在使用进程数-定义新函数proc-size-在proc-h中"><a href="#2-统计当前正在使用进程数-定义新函数proc-size-在proc-h中" class="headerlink" title="2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中"></a>2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//return: the proc that are occupied.</span><br><span class="line">int</span><br><span class="line">proc_size()</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  int n = 0;</span><br><span class="line">  for (i = 0; i &lt; NPROC; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (proc[i].state != UNUSED) n++;</span><br><span class="line">  &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法就是对于所有进程(NPROC)进行一遍遍历,如果不是UNUSED,就代表已经使用了</p><h5 id="3-统计当前的内存数-定义新函数freememory-在kalloc-h中"><a href="#3-统计当前的内存数-定义新函数freememory-在kalloc-h中" class="headerlink" title="3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中."></a>3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line">freememory()</span><br><span class="line">&#123;</span><br><span class="line">  struct run\* p = kmem.freelist;</span><br><span class="line">  uint64 num = 0;</span><br><span class="line">  while (p)</span><br><span class="line">  &#123;</span><br><span class="line">    num ++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return num \* PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得freelist(物理内存中没有分配的块),然后对链表进行一遍遍历,找到有几个块没有分配,乘以一个块的数量即可.</p><h5 id="4-完成sysinfo的操作-注意2-和3-定义的函数要声明在def-h中"><a href="#4-完成sysinfo的操作-注意2-和3-定义的函数要声明在def-h中" class="headerlink" title="4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在def.h中"></a>4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在<code>def.h</code>中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sysinfo(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct sysinfo info;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  // get the the address of the sysinfo structure.</span><br><span class="line">  if (argaddr(0, &amp;addr) &lt; 0) </span><br><span class="line">    return -1;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  //get freemem</span><br><span class="line">  info.freemem = freememory();</span><br><span class="line">  //get the proc</span><br><span class="line">  info.nproc = proc_size();</span><br><span class="line">  // copyto the structure.</span><br><span class="line">  if (copyout(p-&gt;pagetable, addr, (char\*)&amp;info, sizeof(info)) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作主要是,用户会传递指针来,这个指针就指向了sysinfo的结构体,所以说我们需要在内核态获得信息构造一个新的结构体传回去就可以了.</p><h5 id="5-像上个实验一样完成syscall-h-syscall-c的支持即可"><a href="#5-像上个实验一样完成syscall-h-syscall-c的支持即可" class="headerlink" title="5) 像上个实验一样完成syscall.h,syscall.c的支持即可."></a>5) 像上个实验一样完成syscall.h,syscall.c的支持即可.</h5><h3 id="3-Xv6-and-PageTable"><a href="#3-Xv6-and-PageTable" class="headerlink" title="3:Xv6 and PageTable"></a>3:Xv6 and PageTable</h3><h3 id="Lab3-1-Speed-Up-the-system-calls"><a href="#Lab3-1-Speed-Up-the-system-calls" class="headerlink" title="Lab3_1 Speed Up the system calls"></a>Lab3_1 Speed Up the system calls</h3><p>一些操作系统（例如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加速某些系统调用。 这消除了在执行这些系统调用时对内核交叉的需要。</p><p>创建每个进程时，在 USYSCALL（memlayout.h 中定义的 VA）映射一个只读页面。 在这个页面的开始，存储一个struct ussyscall（也在memlayout.h中定义），并初始化它来存储当前进程的PID。</p><ul><li>可以在 kernel&#x2F;proc.c 中的 proc_pagetable() 中执行映射。</li><li>只读的权限位要确保正确</li><li>mappages() 是一个有用的实用程序。</li><li>不要忘记在 allocproc() 中分配和初始化页面。</li><li>确保在 freeproc() 中释放页面。</li></ul><h5 id="1-确认usyscall的结构体是什么-其实存储的就是pid"><a href="#1-确认usyscall的结构体是什么-其实存储的就是pid" class="headerlink" title="1) 确认usyscall的结构体是什么,其实存储的就是pid."></a>1) 确认usyscall的结构体是什么,其实存储的就是pid.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct usyscall &#123;</span><br><span class="line">  int pid;  // Process ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-为每个进程结构添加usyscall的元素-这个结构存储在一个新的页里面"><a href="#2-为每个进程结构添加usyscall的元素-这个结构存储在一个新的页里面" class="headerlink" title="2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面."></a>2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面.</h5><h5 id="3-打开proc-c-依葫芦画瓢给usyscall结构体申请一个页面"><a href="#3-打开proc-c-依葫芦画瓢给usyscall结构体申请一个页面" class="headerlink" title="3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面."></a>3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// alloc a page that store usyscall proc</span><br><span class="line">  if((p-&gt;usyss = (struct usyscall \*)kalloc()) == 0)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="4-依据提示-我们在proc-pagetable中依葫芦画瓢来进行地址的映射-注意-如果映射失败是要把之前俩都给取消掉"><a href="#4-依据提示-我们在proc-pagetable中依葫芦画瓢来进行地址的映射-注意-如果映射失败是要把之前俩都给取消掉" class="headerlink" title="4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉"></a>4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall),</span><br><span class="line">             PTE_R  PTE_U) &lt; 0) &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><br><span class="line">    uvmfree(pagetable, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中mappages(表,虚拟地址,页大小,物理地址,权限)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_V (1L &lt;&lt; 0) // valid</span><br><span class="line">#define PTE_R (1L &lt;&lt; 1)</span><br><span class="line">#define PTE_W (1L &lt;&lt; 2)</span><br><span class="line">#define PTE_X (1L &lt;&lt; 3)</span><br><span class="line">#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br></pre></td></tr></table></figure><p>权限的编码有几种方式,分别用五位0-1表示,从左到右都是可运行,可读,可写,只可以内核用,用户可以用.</p><h5 id="5-在进程初始化的时候添加初始化的代码-初始化usyscall的结构"><a href="#5-在进程初始化的时候添加初始化的代码-初始化usyscall的结构" class="headerlink" title="5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构."></a>5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构.</h5><p>p-&gt;usyscall-&gt;pid &#x3D; p-&gt;pid;</p><h5 id="6-进程结束的时候-free掉进程的时候把这一页也free掉"><a href="#6-进程结束的时候-free掉进程的时候把这一页也free掉" class="headerlink" title="6) 进程结束的时候,free掉进程的时候把这一页也free掉"></a>6) 进程结束的时候,free掉进程的时候把这一页也free掉</h5><p>if (p-&gt;usyss) kfree((void *)p-&gt;usyss);<br>p-&gt;usyss &#x3D; 0;</p><h5 id="7-进程结束的时候-依葫芦画瓢把映射关系给取消掉"><a href="#7-进程结束的时候-依葫芦画瓢把映射关系给取消掉" class="headerlink" title="7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉."></a>7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉.</h5><p>uvmunmap(pagetable, USYSCALL, 1, 0);</p><h2 id="Lab3-2-Print-a-page-table"><a href="#Lab3-2-Print-a-page-table" class="headerlink" title="Lab3_2 Print a page table"></a>Lab3_2 Print a page table</h2><p>在这部分实验中，您将向 xv6 添加一个新功能，该功能通过检查 RISC-V 页表中的访问位来检测并向用户空间报告此信息。定义一个名为 vmprint() 的函数。 它应该接受一个 pagetable_t 参数，并以下面描述的格式打印该页表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000//二级页表</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000//二级页表的表项,进入一级页表</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000//一级页表的表项,进入页表</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure><p>在exec.c中的_return argc;<em>之前插入_if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable)</em> 语句来输出第一个进程的页表.</p><p>首先要确定的第一点就是,这个页表其实实际上是一种多级页表的结构,就是二级页表存储的表项(PPN)其实是一级页表的第一个PTE的地址,一级页表的表项才是pa.具体的多级页表的解释可以参考我其他的博客或者翻阅操作系统或者组员书.</p><p>首先我们知道,PTE是一个长度为64的整数而已.其中存储了各种各样的信息,这些信息可以通过调用宏来实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10</span><br><span class="line">#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span><br><span class="line">#define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span><br></pre></td></tr></table></figure><p>其实本质上来说,就是xv6系统的PTE除去后10位和前12位就是pa.</p><p>所以说这个东西就可以转化为基本的递归.对于二级页表,对于每一个表项就进入到一级页表再遍历.所以说本质上这就是一个树,二级页表作为根,有若干个儿子,也就是一级页表,一级页表也有若干个儿子…那遍历树怎么遍历,一般来说就是用递归的手段</p><p>● 可以将vmprint( )放在kernel&#x2F;vm.c中。<br>● 使用kernel&#x2F;riscv.h文件末尾的宏。<br>● 函数freewalk可能是鼓舞人心的（可以仿照该函数来写vmprint）。<br>● 在kernel&#x2F;defs.h中定义vmprint的原型，以便可以从exec.c调用它。<br>● 在printf调用中使用%p输出完整的64位十六进制PTE和地址，如示例所示。</p><h5 id="1-根据提示-在exec的return-argc之前添加一段"><a href="#1-根据提示-在exec的return-argc之前添加一段" class="headerlink" title="1) 根据提示,在exec的return argc之前添加一段:"></a>1) 根据提示,在exec的return argc之前添加一段:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-pid==1)&#123;</span><br><span class="line">  vmprint(p-&gt;pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-在def-h中添加对于vmprint的定义"><a href="#2-在def-h中添加对于vmprint的定义" class="headerlink" title="2) 在def.h中添加对于vmprint的定义"></a>2) 在def.h中添加对于vmprint的定义</h5><h5 id="3-修改vm-c-仿照freewalk改造函数"><a href="#3-修改vm-c-仿照freewalk改造函数" class="headerlink" title="3) 修改vm.c,仿照freewalk改造函数."></a>3) 修改vm.c,仿照freewalk改造函数.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void vmprintlevel(pagetable_t pt, int level) &#123;</span><br><span class="line">    char \*delim = 0;</span><br><span class="line">    if (level == 2) delim = &quot;..&quot;;</span><br><span class="line">    if (level == 1) delim = &quot;.. ..&quot;;</span><br><span class="line">    if (level == 0) delim = &quot;.. .. ..&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 512; i++) &#123;</span><br><span class="line">        pte_t pte = pt[i];</span><br><span class="line">        if ((pte &amp; PTE_V)) &#123;</span><br><span class="line">            //  this PTE points to a lower level page table.</span><br><span class="line">            printf(&quot;%s%d: pte %p pa %p\\n&quot;, delim, i, pte, PTE2PA(pte));</span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            if ((pte &amp; (PTE_RPTE_WPTE_X)) == 0) &#123;</span><br><span class="line">                vmprintlevel((pagetable_t)child, level - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vmprint(pagetable_t pt) &#123;</span><br><span class="line">    printf(&quot;page table %p\\n&quot;, pt);</span><br><span class="line">    vmprintlevel(pt, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想就是递归,递归获得下一级的地址,本质上是一个DFS.有下一级的页表就进入下一级进行遍历.</p><h2 id="Lab3-3-Detecting-which-pages-have-been-accessed"><a href="#Lab3-3-Detecting-which-pages-have-been-accessed" class="headerlink" title="Lab3_3 Detecting which pages have been accessed"></a>Lab3_3 Detecting which pages have been accessed</h2><p>在本部分的实验中，你将向xv6添加一个新特性，通过检查RISC-V页表中的访问位来获取信息并向用户空间报告这些信息。</p><p>实现pgaccess()函数，它是一个系统调用,会返回哪些页面已经被访问.其中第一个参数就是从哪个虚拟地址开始检查,第二个参数就是检查几个页面,结果传递给第三个参数,第三个参数是位掩码,其中第几位为1表示第几个页面已经被访问了.</p><p>● 首先在kernel&#x2F;sysproc.c中实现sys_pgaccess( )。<br>● 你需要使用argaddr()和argint()解析参数。<br>● 对于输出位掩码，在内核中存储一个临时缓冲区并在填充正确的位后将其复制给用户（通过copyout()）更容易。<br>● 可以设置可扫描页数的上限。<br>● kernel&#x2F;vm.c中的walk()对于查找正确的PTE非常有用。<br>● 你需要在kernel&#x2F;riscv.h中定义PTE_A，即访问位。请参阅RISC-V手册以确定其值。<br>● 如果PTE_A已设置，在检查后务必清除它。否则，将无法确定自上次调用pgaccess()以来是否访问了页面（即，该位将被永久设置）。<br>● 利用vmprint()可方便地调试页表。</p><h5 id="1-参阅RISC-V手册-确定PTE-A是什么"><a href="#1-参阅RISC-V手册-确定PTE-A是什么" class="headerlink" title="1) 参阅RISC-V手册,确定PTE_A是什么."></a>1) 参阅RISC-V手册,确定PTE_A是什么.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_A (1L &lt;&lt; 6)</span><br></pre></td></tr></table></figure><h5 id="2-完成sys-pgaccess-在这里主要是处理参数-利用argaddr和argint处理参数"><a href="#2-完成sys-pgaccess-在这里主要是处理参数-利用argaddr和argint处理参数" class="headerlink" title="2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数."></a>2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_pgaccess(void) &#123;</span><br><span class="line">    // lab pgtbl: your code here.</span><br><span class="line">    // get argument</span><br><span class="line">    uint64 buf;</span><br><span class="line">    int number;</span><br><span class="line">    uint64 ans;</span><br><span class="line">    if (argaddr(0, &amp;buf) &lt; 0) return -1;</span><br><span class="line">    if (argint(1, &amp;number) &lt; 0) return -1;</span><br><span class="line">    if (argaddr(2, &amp;ans) &lt; 0) return -1;</span><br><span class="line">    return pgaccess((void\*)buf, number, (void\*)ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-读取当前虚拟地址-找到对应的页表项目的函数找到-walk"><a href="#3-读取当前虚拟地址-找到对应的页表项目的函数找到-walk" class="headerlink" title="3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk"></a>3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk</h5><p>使用方法:<code>te = (pte_t*)walk(pagetable, ((uint64)pg) + (uint64)PGSIZE * i, 0);</code></p><h5 id="4-读取接着根据pte表项-找到PTE-A位"><a href="#4-读取接着根据pte表项-找到PTE-A位" class="headerlink" title="4) 读取接着根据pte表项,找到PTE_A位."></a>4) 读取接着根据pte表项,找到PTE_A位.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64 pgaccess(void \*pg, int number, void \*store) &#123;</span><br><span class="line">    struct proc \*p = myproc();</span><br><span class="line">    if (p == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    pagetable_t pagetable = p-&gt;pagetable;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; number; i++) &#123;</span><br><span class="line">        pte_t\* pte;</span><br><span class="line">        pte = (pte_t\*)walk(pagetable, ((uint64)pg) + (uint64)PGSIZE \* i, 0);</span><br><span class="line">        if (pte != 0 &amp;&amp; ((\*pte) &amp; PTE_A)) &#123;</span><br><span class="line">            ans = 1 &lt;&lt; i;</span><br><span class="line">            \*pte ^= PTE_A;  // clear PTE_A</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // copyout</span><br><span class="line">    return copyout(pagetable, (uint64)store, (char \*)&amp;ans, sizeof(int));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Xv6-and-Trap"><a href="#4-Xv6-and-Trap" class="headerlink" title="4:Xv6 and Trap"></a>4:Xv6 and Trap</h1><h2 id="Lab4-1-RISC-V-Assembly"><a href="#Lab4-1-RISC-V-Assembly" class="headerlink" title="Lab4_1 RISC-V Assembly"></a>Lab4_1 RISC-V Assembly</h2><p>我们需要运行对call.c这份代码的编译,然后回答一些问题</p><p>make fs.img编译之后我们可以找到下面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:1141                addisp,sp,-16</span><br><span class="line">   2:e422                sds0,8(sp)</span><br><span class="line">   4:0800                addis0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:250d                addiwa0,a0,3</span><br><span class="line">   8:6422                lds0,8(sp)</span><br><span class="line">   a:0141                addisp,sp,16</span><br><span class="line">   c:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:1141                addisp,sp,-16</span><br><span class="line">  10:e422                sds0,8(sp)</span><br><span class="line">  12:0800                addis0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:250d                addiwa0,a0,3</span><br><span class="line">  16:6422                lds0,8(sp)</span><br><span class="line">  18:0141                addisp,sp,16</span><br><span class="line">  1a:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:1141                addisp,sp,-16</span><br><span class="line">  1e:e406                sdra,8(sp)</span><br><span class="line">  20:e022                sds0,0(sp)</span><br><span class="line">  22:0800                addis0,sp,16</span><br><span class="line">  printf(&quot;%d %d\\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:4635                lia2,13</span><br><span class="line">  26:45b1                lia1,12</span><br><span class="line">  28:00000517          auipca0,0x0</span><br><span class="line">  2c:7b050513          addia0,a0,1968 # 7d8 &lt;malloc+0xea&gt;</span><br><span class="line">  30:00000097          auipcra,0x0</span><br><span class="line">  34:600080e7          jalr1536(ra) # 630 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:4501                lia0,0</span><br><span class="line">  3a:00000097          auipcra,0x0</span><br><span class="line">  3e:27e080e7          jalr638(ra) # 2b8 &lt;exit&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.Q:Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<br>哪些寄存器存储了函数的参数?比如说调用printf的时候13存在哪个寄存器里面?</p><p>A:a0~a7共8个参数,其中调用printf的时候13就存在a2这个寄存器里面</p><p>2.Q:Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)<br>汇编代码中哪一部分出现了对函数f的调用,函数g呢?</p><p>A:其实并没有,编译器把g函数内联到f函数里面,再把f函数内联到main里面</p><p>3.Q:At what address is the function printf located?<br>printf的入口地址在哪里?</p><p>A:根据<code>jalr 1536(ra)</code>可以知道printf的地址在0x630这个里面</p><p>4.Q:What value is in the register ra just after the jalr to printf in main?<br>printf执行完返回到main的时候ra寄存器的值是多少?</p><p>显然ra中应是jalr下一条指令的地址，即0x38。</p><p>5.Q:Run the following code.</p><p>unsigned int i &#x3D; 0x00646c72;<br>printf(“H%x Wo%s”, 57616, &amp;i);</p><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change<code>57616</code> to a different value?<br>输出是什么?RISC-V是小端存储的.如果是大端存储的呢?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p><strong>输出”HE110 World”. 57616&#x3D;0xe110。RISC-V 是 little-endian，&amp;i处存储的字节依次为0x72:r, 0x6c:l, 0x64:d，0x00:Null char (空字符)。</strong></p><p><strong>如果 RISC-V 是 big-endian，则i &#x3D; 0x726c6400;. 57616不需改变，因为不管怎样它的十六进制形式都不会变。</strong></p><p>6.Q:In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?<br>执行下一条语句,会输出y&#x3D;多少呢?</p><p>printf(“x&#x3D;%d y&#x3D;%d”, 3);</p><p>因为函数a0~a7都存着参数,所以说对应的输出第二个参数的内容,也就是a1寄存器的内容.</p><h2 id="Lab4-2-BackTrace"><a href="#Lab4-2-BackTrace" class="headerlink" title="Lab4_2 BackTrace"></a>Lab4_2 BackTrace</h2><p>添加一个新的功能,打印函数调用栈.在这个机器中,我们知道有一个结构叫做栈帧,可以保存当前函数调用某个函数之前的一些寄存器,返回地址和一些局部变量的信息,比如说C语言的main函数,main函数调用一个函数f1(),在进入f1()函数的执行之前,编译器会帮我们把main函数的一些寄存器、局部变量的信息保存在栈帧中放入堆栈.其中栈帧中有一个特别的元素就是上一个栈帧的地址.</p><p><img src="https://pic2.zhimg.com/80/v2-9930748a73415bd511e4fe27f81de13d_1440w.jpg"></p><p>本实验的要求就是在kernel&#x2F;printf.c 中实现backtrace()函数。在sys_sleep中插入对该函数的调用。然后运行bttest，它调用sys_sleep。输出应如下：</p><h5 id="1-在def-h添加backtrace-函数的声明"><a href="#1-在def-h添加backtrace-函数的声明" class="headerlink" title="1) 在def.h添加backtrace()函数的声明."></a>1) 在def.h添加backtrace()函数的声明.</h5><h5 id="2-GCC-编译器将当前执行的函数的帧指针存储在寄存器s0中-s0就对应上面的fp指针"><a href="#2-GCC-编译器将当前执行的函数的帧指针存储在寄存器s0中-s0就对应上面的fp指针" class="headerlink" title="2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针."></a>2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-完成backtrace"><a href="#3-完成backtrace" class="headerlink" title="3) 完成backtrace()"></a>3) 完成backtrace()</h5><p>我们知道fp指针往下走两个字节就存储的上一个函数的栈帧的最高地址,所以说我们可以循环一下,每一次循环就取上一个函数的栈帧最高地址,输出返回地址即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">backtrace(void)&#123;</span><br><span class="line">  uint64 fp = r_fp(), top = PGROUNDUP(fp);</span><br><span class="line">  printf(&quot;backtrace:\\n&quot;);</span><br><span class="line">  for(;fp&lt;top;fp=\*(uint64\*)(fp-16))&#123;</span><br><span class="line">    printf(&quot;%p\\n&quot;, \*((uint64\*)(fp-8)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab4-3-Alarm"><a href="#Lab4-3-Alarm" class="headerlink" title="Lab4_3 Alarm"></a>Lab4_3 Alarm</h2><p>在本练习中，您将向xv6添加一项功能，该功能会在使用CPU时间的情况下定期向进程发出警报。这对于想要限制消耗多少CPU时间的计算密集型进程，或者对于想要进行计算但还希望采取一些定期操作的进程很有用。</p><p>您应该添加一个新的sigalarm(interval,handler)系统调用。 如果应用程序调用sigalarm(n,fn)，则在程序每消耗n个“ tick” CPU时间之后，内核应导致调用应用程序函数fn。 当fn返回时，应用程序应从中断处恢复。 滴答是xv6中相当随意的时间单位，由硬件计时器产生中断的频率决定。 如果应用程序调用sigalarm(0,0)，则内核应停止生成定期警报调用。</p><h5 id="test0：调用处理程序"><a href="#test0：调用处理程序" class="headerlink" title="test0：调用处理程序"></a>test0：调用处理程序</h5><p>1.修改Makefile，为sigalarm和sigreturn系统调用添加桩代码。<br>2.现在，sys_sigreturn应该只返回零。<br>3.sys_sigalarm()应该将nl和handler存储在proc结构的新字段中（在kernel&#x2F;proc.h 中）。<br>4.您需要跟踪该进程自上次调用alarm handler以来已经过去了多少ticks。为此，您还需要struct proc中的一个新字段。您可以在proc.c的allocproc() 中初始化这个字段。<br>5.每当tick时，硬件时钟都会强制中断，该中断在kernel&#x2F;trap.c的usertrap()中处理。<br>6.时钟中断是：if(which_dev &#x3D;&#x3D; 2) …<br>7.您需要修改usertrap()以在进程的警报间隔到期时，用户进程执行handler。</p><h5 id="test1-test2-恢复中断的代码"><a href="#test1-test2-恢复中断的代码" class="headerlink" title="test1&#x2F;test2(): 恢复中断的代码"></a>test1&#x2F;test2(): 恢复中断的代码</h5><p>8.handler完成后，控制权返回到用户程序最初被中断的指令。必须确保寄存器内容恢复，以及重置警报计数器。以便定期调用handler。<br>9.user alarm handler需要在完成后调用sigreturn系统调用。这意味着您可以将代码添加到usertrap和sys_sigreturn中，它们会协同工作以使用户进程在处理完警报后正确恢复。<br>10.确保正确地保存和恢复寄存器。<br>11.当计时器到期时，让 usertrap 在 struct proc 中保存足够的状态，以便sigreturn可以正确返回 到被中断的用户代码。<br>12.防止对处理程序的重入调用——如果处理程序尚未返回，内核不应再次调用它。</p><p>首先就是把添加系统调用的路子走一遍.</p><h5 id="1-在user-h中添加声明"><a href="#1-在user-h中添加声明" class="headerlink" title="1) 在user.h中添加声明:"></a>1) 在user.h中添加声明:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sigalarm(int ticks, void (\*handler)());</span><br><span class="line">int sigreturn(void);</span><br></pre></td></tr></table></figure><h5 id="2-在user-pl添加函数入口以生成汇编代码"><a href="#2-在user-pl添加函数入口以生成汇编代码" class="headerlink" title="2) 在user.pl添加函数入口以生成汇编代码."></a>2) 在user.pl添加函数入口以生成汇编代码.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(&quot;sigalarm&quot;);</span><br><span class="line">entry(&quot;sigreturn&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-在syscall-h添加系统调用号-1"><a href="#3-在syscall-h添加系统调用号-1" class="headerlink" title="3) 在syscall.h添加系统调用号."></a>3) 在syscall.h添加系统调用号.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SYS_sigalarm  22</span><br><span class="line">#define SYS_sigreturn 23</span><br></pre></td></tr></table></figure><h5 id="4-在syscall-c中添加关于这两个系统调用的声明"><a href="#4-在syscall-c中添加关于这两个系统调用的声明" class="headerlink" title="4) 在syscall.c中添加关于这两个系统调用的声明."></a>4) 在syscall.c中添加关于这两个系统调用的声明.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">extern uint64 sys_sigalarm(void);</span><br><span class="line">extern uint64 sys_sigreturn(void);</span><br><span class="line">......</span><br><span class="line">[SYS_sigalarm]  sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br></pre></td></tr></table></figure><h5 id="5-在proc的进程结构体中添加成员-保存什么时候中断-中断执行什么-过多久就进行一次中断-还保存中断的时候栈顶指针和保存的栈帧"><a href="#5-在proc的进程结构体中添加成员-保存什么时候中断-中断执行什么-过多久就进行一次中断-还保存中断的时候栈顶指针和保存的栈帧" class="headerlink" title="5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧."></a>5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int interval;// interupt count</span><br><span class="line">void (\*handler)(); //handle programme</span><br><span class="line">int count; //tick interupt count</span><br><span class="line">uint64 interrupt_ra; //trapframe pointer.</span><br><span class="line">struct trapframe \*saved_trapframe;//saved_trapframe</span><br><span class="line">int isworking;</span><br></pre></td></tr></table></figure><h5 id="6-在allocproc函数中初始化这些成员"><a href="#6-在allocproc函数中初始化这些成员" class="headerlink" title="6) 在allocproc函数中初始化这些成员."></a>6) 在allocproc函数中初始化这些成员.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;interval = 0;</span><br><span class="line">p-&gt;handler = 0;</span><br><span class="line">p-&gt;count = 0;</span><br><span class="line">p-&gt;is working = 0;</span><br></pre></td></tr></table></figure><h5 id="7-完成sigalarm的系统调用-做法就是从寄存器获得参数然后赋值给proc的元素中"><a href="#7-完成sigalarm的系统调用-做法就是从寄存器获得参数然后赋值给proc的元素中" class="headerlink" title="7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中."></a>7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sigalarm(void)&#123;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  int in;</span><br><span class="line">  uint ft;</span><br><span class="line">  int interval;</span><br><span class="line">    uint64 pt;</span><br><span class="line">    if(argint(0, &amp;in) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">    if(argaddr(1, &amp;ft) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line"></span><br><span class="line">    p-&gt;interval=in;</span><br><span class="line">    p-&gt;handler=(void\*)ft;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-完成时钟"><a href="#8-完成时钟" class="headerlink" title="8) 完成时钟"></a>8) 完成时钟</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if(which_dev == 2)&#123;</span><br><span class="line">    //the proc no call the sysalaram.</span><br><span class="line">    if(p-&gt;interval==0p-&gt;working)</span><br><span class="line">    &#123;</span><br><span class="line">      yield();</span><br><span class="line">      usertrapret();</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      p-&gt;count++; </span><br><span class="line">      if(p-&gt;count==p-&gt;interval)</span><br><span class="line">      &#123;</span><br><span class="line">        //save the trapframe.</span><br><span class="line">        p-&gt;saved_trapframe=(struct trapframe\*)kalloc();</span><br><span class="line">        memmove(p-&gt;saved_trapframe,p-&gt;trapframe,PGSIZE);</span><br><span class="line">        </span><br><span class="line">        //save the trapped address</span><br><span class="line">        p-&gt;interrupt_ra=p-&gt;trapframe-&gt;epc;</span><br><span class="line">        //the programme will start at handler.</span><br><span class="line">        p-&gt;trapframe-&gt;epc=(uint64)p-&gt;handler;</span><br><span class="line">        usertrapret();</span><br><span class="line">        yield();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>处理的方式是分类,如果之前没有调用过sigalarm的话,interval为0,就和原来一样,如果不是的话就代表调用过.接着count++,如果count和interval一样的话就代表要跳转了,保存当前的trapframe以及当前被中断的指令的地址,修改epc进行跳转.还有就是要记录working,如果这个函数已经被打断了就不要再重新打断一次.</p><h5 id="9-完成返回的操作"><a href="#9-完成返回的操作" class="headerlink" title="9) 完成返回的操作."></a>9) 完成返回的操作.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_sigreturn(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  p-&gt;count=0;</span><br><span class="line">  p-&gt;trapframe-&gt;epc=p-&gt;interrupt_ra;</span><br><span class="line">  memmove(p-&gt;trapframe,p-&gt;saved_trapframe,PGSIZE);</span><br><span class="line">  p-&gt;isworking = 0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把之前保存的断点地址和栈帧读出来,清空时钟即可.</p><h1 id="6-Xv6-and-MultiThread"><a href="#6-Xv6-and-MultiThread" class="headerlink" title="6:Xv6 and MultiThread"></a>6:Xv6 and MultiThread</h1><h2 id="Lab6-1-Uthread-switching-between-threads"><a href="#Lab6-1-Uthread-switching-between-threads" class="headerlink" title="Lab6_1 Uthread: switching between threads"></a>Lab6_1 Uthread: switching between threads</h2><p>在本实验中，您将为用户级线程系统设计上下文切换机制，然后实现它。你的 xv6 有两个文件 user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S，以及 Makefile 中的一个规则来构建一个 uthread 程序。uthread.c 包含大部分用户级线程包，以及三个测试线程的代码。但线程包中缺少一些用于<strong>创建线程</strong>和<strong>线程间切换</strong>的代码。</p><p>您需要创建一个函数,这个函数可以创建一个进程,在切换进程的时候保存和恢复寄存器.</p><p>您需要在 user&#x2F;uthread.c 中的<strong>thread_create()<strong>和</strong>thread_schedule()<strong>以及user&#x2F;uthread_switch.S中的</strong>thread_switch</strong>中添加代码。</p><p>一个目标是<strong>确保当thread_schedule()第一次运行给定线程时，该线程在自己的堆栈上执行传递给thread_create()的函数</strong>(这个函数作为一个参数传递给thread_create()函数调用)。换句话说,就是创建线程的时候,有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.</p><p>另一个目标是<strong>确保thread_switch保存被切换的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后一个线程的指令中上次停止的点</strong>。您必须决定<strong>在哪里保存&#x2F;恢复寄存器</strong>；<strong>修改struct thread以保存寄存器是一个不错的计划</strong>。</p><p>您需要<strong>在thread_schedule中添加对thread_switch的调用</strong>；您可以将所需的任何参数传递给thread_switch，但目的是从线程t切换到next_thread。</p><p>thread_switch 只需要保存&#x2F;恢复callee-save registers。</p><p>要测试您的代码，使用riscv64-linux-gnu-gdb单步执行thread_switch可能会有所帮助。 您可以通过以下方式开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure><p>这将在uthread.c的第60行设置一个断点。 甚至在运行uthread之前，可能会（或可能不会）触发断点。 一旦您的xv6 shell运行，键入“ uthread”，gdb将在第60行中断。现在，您可以键入以下命令来检查uthread的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x \*next_thread</span><br></pre></td></tr></table></figure><p>使用“ x”，您可以检查存储位置的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x next_thread-&gt;stack</span><br></pre></td></tr></table></figure><p>您可以跳到thread_switch的开头，这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b thread_switch</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure><p>您可以使用以下步骤进行单步组装说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure><p>ni是下一条汇编语句,n是下一条C语言语句.</p><h5 id="1-修改thread-switch的代码-添加上关于thread-switch-的代码-只需要保存-恢复callee-save-register"><a href="#1-修改thread-switch的代码-添加上关于thread-switch-的代码-只需要保存-恢复callee-save-register" class="headerlink" title="1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:"></a>1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sd ra, 0(a0)</span><br><span class="line">sd sp, 8(a0)</span><br><span class="line">sd s0, 16(a0)</span><br><span class="line">sd s1, 24(a0)</span><br><span class="line">sd s2, 32(a0)</span><br><span class="line">sd s3, 40(a0)</span><br><span class="line">sd s4, 48(a0)</span><br><span class="line">sd s5, 56(a0)</span><br><span class="line">sd s6, 64(a0)</span><br><span class="line">sd s7, 72(a0)</span><br><span class="line">sd s8, 80(a0)</span><br><span class="line">sd s9, 88(a0)</span><br><span class="line">sd s10, 96(a0)</span><br><span class="line">sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">ld ra, 0(a1)</span><br><span class="line">ld sp, 8(a1)</span><br><span class="line">ld s0, 16(a1)</span><br><span class="line">ld s1, 24(a1)</span><br><span class="line">ld s2, 32(a1)</span><br><span class="line">ld s3, 40(a1)</span><br><span class="line">ld s4, 48(a1)</span><br><span class="line">ld s5, 56(a1)</span><br><span class="line">ld s6, 64(a1)</span><br><span class="line">ld s7, 72(a1)</span><br><span class="line">ld s8, 80(a1)</span><br><span class="line">ld s9, 88(a1)</span><br><span class="line">ld s10, 96(a1)</span><br><span class="line">ld s11, 104(a1)</span><br></pre></td></tr></table></figure><p>其中a0代表了被打断的线程的栈帧,a1代表了要切换到的线程的栈帧.其中栈帧就是相对于thread的结构体的偏移.</p><h5 id="2-在Thread的数据结构中添加寄存器信息"><a href="#2-在Thread的数据结构中添加寄存器信息" class="headerlink" title="2) 在Thread的数据结构中添加寄存器信息."></a>2) 在Thread的数据结构中添加寄存器信息.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line">  // callee-saved</span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">//修改后</span><br><span class="line">thread&#123;</span><br><span class="line">  栈帧</span><br><span class="line">  栈</span><br><span class="line">  状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-修改创建进程的代码-对ra和sp寄存器进行初始化-其中ra本质上就是断点寄存器-有一个参数就是一个地址-这个地址指向一个函数-当这个线程第一次启动的时候就从这个地址对应的指令开始执行-把这个参数传递给ra"><a href="#3-修改创建进程的代码-对ra和sp寄存器进行初始化-其中ra本质上就是断点寄存器-有一个参数就是一个地址-这个地址指向一个函数-当这个线程第一次启动的时候就从这个地址对应的指令开始执行-把这个参数传递给ra" class="headerlink" title="3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra"></a>3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;ra=(uint64)func;</span><br><span class="line">t-&gt;sp=(uint64)&amp;t-&gt;stack[STACK_SIZE-1];</span><br></pre></td></tr></table></figure><p>其中栈是从高到低的,所以说初始的栈顶指针是指向最高的地址的.</p><h5 id="4-调用switch函数-切换-其中t是当前进程-next-thread是下一个进程"><a href="#4-调用switch函数-切换-其中t是当前进程-next-thread是下一个进程" class="headerlink" title="4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程."></a>4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)t,(uint64)next_thread);</span><br></pre></td></tr></table></figure><h2 id="Lab6-2-Using-Thread"><a href="#Lab6-2-Using-Thread" class="headerlink" title="Lab6_2 Using Thread."></a>Lab6_2 Using Thread.</h2><p>文件notxv6 &#x2F; ph.c包含一个简单的哈希表，该哈希表从单个线程使用时是正确的，但从多个线程使用时则是错误的。 在您的主要xv6目录（可能是〜&#x2F; xv6-labs-2020）中，键入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make ph</span><br><span class="line">$ ./ph 1</span><br></pre></td></tr></table></figure><p>请注意，要生成ph，Makefile使用操作系统的gcc，而不是6.S081工具。 ph的参数指定在哈希表上执行放置和获取操作的线程数。 </p><p>ph运行两个基准。 首先，它通过调用put（）向哈希表添加很多键，并输出每秒达到的puts速率。 它使用get（）从哈希表中获取密钥。 它打印由于puts而应在哈希表中但丢失的数字键（在这种情况下为零），并打印每秒获得的获取次数。</p><p>您可以通过给它一个大于1的参数来告诉ph同时使用多个线程的哈希表。 尝试ph 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./ph 2</span><br><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure><p>此ph 2输出的第一行表明，当两个线程同时向哈希表添加条目时，它们每秒的总插入率为53,044。 这大约是运行ph 1时单线程的速度的两倍。这是大约2倍的出色“并行加速”，这是人们可能希望的（即两倍的内核，每单位时间产生两倍的工作量）。</p><p>但是，两行说缺少16579键，表明哈希表中不应该存在大量键。 就是说，puts应该将这些键添加到哈希表中，但是出了点问题。 看一下notxv6 &#x2F; ph.c，尤其是put（）和insert（）。</p><p>为什么缺少2个线程而不是1个线程的键？ 用2个线程标识一系列事件，这些事件可能导致键丢失。 提交您的序列，并在answer-thread.txt中提供简短解释。为避免发生此序列的事件，请在putx和get.not.v6 &#x2F; ph.c中插入lock和unlock语句，以便两个线程始终缺少0的键数。 相关的pthread调用为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock;            // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL); // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);       // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);     // release lock</span><br></pre></td></tr></table></figure><p>其实本质上,线程之间也会有互斥的关系,两个线程不能同时访问同一个缓冲区,如果同时当文同一个缓冲区的同一个位置就导致了写重复的问题,就需要对访问缓冲区的代码块上锁,只允许一个线程访问缓冲区.也就是只允许一个进程访问数组的某一个位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t locks[NBUCKET];</span><br><span class="line"></span><br><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  // is the key already present?</span><br><span class="line">  struct entry \*e = 0;</span><br><span class="line">  for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">    if (e-&gt;key == key)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  if(e)&#123;</span><br><span class="line">    // update the existing key.</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // the new is new.</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟我们学过的操作系统一样,线程在进入访问缓冲区的代码之前上锁,线程离开访问缓冲区的代码后解锁.</p><h2 id="Lab6-3-Barrier"><a href="#Lab6-3-Barrier" class="headerlink" title="Lab6_3 Barrier"></a>Lab6_3 Barrier</h2><p>在此分配中，您将实现一个障碍：应用程序中的一个点，所有参与线程必须在该点等待，直到所有其他参与线程也都到达该点。 您将使用pthread条件变量，这是一种类似于xv6的睡眠和唤醒的序列协调技术。</p><p>文件notxv6 &#x2F; barrier.c。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make barrier</span><br><span class="line">$ ./barrier 2</span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion \`i == t&#x27; failed.</span><br></pre></td></tr></table></figure><p>2指定在屏障上同步的线程数（barrier.c中的nthread）。 每个线程执行一个循环。 在每个循环迭代中，线程都会调用barrier（），然后睡眠随机数微秒。 断言触发，因为一个线程在另一线程到达屏障之前就离开了屏障。 理想的行为是每个线程都在barrier（）中阻塞，直到它们的所有nthread都调用了barrier（）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread+=1;pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">  if(bstate.nthread&lt;nthread)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);//go to sleep on cond,releasing lock mutes acquirint upon wake up</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    bstate.round+=1;//next round</span><br><span class="line">    bstate.nthread=0;//the thread that have entered the barrier() function -&gt; 0 </span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br></pre></td></tr></table></figure><p>因为要修改临界量nthread,所以说进入之前所以要加上锁.如果没到就停止,释放锁,如果到了的话就nthread&#x3D;0,round+1,调用broadcast函数即可.</p><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-29-1024x488.png"></p><h1 id="7-Xv6-and-Networking"><a href="#7-Xv6-and-Networking" class="headerlink" title="7:Xv6 and Networking"></a>7:Xv6 and Networking</h1><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>您将使用称为 E1000 的网络设备来处理网络通信。 对于 xv6（以及您编写的驱动程序），E1000 看起来像是连接到真实以太网局域网 (LAN) 的真实硬件。 实际上，您的驱动程序将与之通信的 E1000 是由 qemu 提供的仿真，连接到同样由 qemu 仿真的 LAN。 在这个模拟 LAN 上，xv6（“guest”）的 IP 地址为 10.0.2.15。 Qemu 还安排运行 qemu 的计算机出现在 IP 地址为 10.0.2.2 的 LAN 上。 当 xv6 使用 E1000 向 10.0.2.2 发送数据包时，qemu 会将数据包传送到您正在运行 qemu（“主机”）的（真实）计算机上的适当应用程序。(就是qemu模拟器传递数据到真实的计算机中)</p><p>你将会用到QEMU的 “用户态网络栈”。QEMU的文档中由很多关于用户态栈的描述。我们已经更新了 Makefile，打开了QEMU的用户态网络栈以及E1000网卡。</p><p>Makefile 设置了 QEMU记录所有的进出数据包到文件 packets.pcap。这可能对于检查接收发送的数据包是有用的。展现记录的数据包：</p><p>tcpdump -XXnr packets.pcap</p><h5 id="你的工作"><a href="#你的工作" class="headerlink" title="你的工作."></a>你的工作.</h5><p>我们已经添加了一些文件到xv6上了。文件kernel&#x2F;e1000.c包含了E1000的初始化代码以及空的传输和接收数据包的函数，这些是需要你去完成的。kernel&#x2F;e1000_dev.h包含了寄存器和标志位的定义，这些在Intel E1000的文档有描述。kernel&#x2F;net.c和kernel&#x2F;net.h包含了一个简单的包含IP、UDP、ARP协议的网络栈。这些文件页包含了一个灵活的数据结构来持有数据包，叫做mbuf。最后，kernel&#x2F;pci.c包含了在xv6启动时，在PCI总线上查找一个E1000网卡的代码.</p><p>我们在 e1000.c 中为您提供的 e1000_init() 函数将 E1000 配置为读取要从 RAM 传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，用于直接内存访问，指的是 E1000 硬件直接从 RAM 写入和读取数据包这一事实。</p><p>因为数据包的爆发可能比驱动程序处理它们的速度更快，所以 e1000_init() 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入其中。 E1000 要求这些缓冲区由 RAM 中的“描述符”数组描述；每个描述符都包含 RAM 中的一个地址，E1000 可以在其中写入接收到的数据包。 struct rx_desc 描述描述符格式。描述符数组称为接收环或接收队列。从某种意义上说，它是一个圆环，当卡或驱动程序到达阵列的末端时，它会回到起点。 e1000_init() 使用 mbufalloc() 将 E1000 的 mbuf 数据包缓冲区分配给 DMA 。还有一个传输环，驱动程序将它希望 E1000 发送的数据包放入其中。 e1000_init() 将两个环配置为具有大小 RX_RING_SIZE 和 TX_RING_SIZE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct tx_desc</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint16 length;</span><br><span class="line">  uint8 cso;</span><br><span class="line">  uint8 cmd;</span><br><span class="line">  uint8 status;</span><br><span class="line">  uint8 css;</span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br><span class="line">#define TX_RING_SIZE 16</span><br><span class="line">static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));</span><br><span class="line">static struct mbuf \*tx_mbufs[TX_RING_SIZE];</span><br><span class="line"></span><br><span class="line">// [E1000 3.2.3]</span><br><span class="line">struct rx_desc</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;       /\* Address of the descriptor&#x27;s data buffer \*/</span><br><span class="line">  uint16 length;     /\* Length of data DMAed into data buffer \*/</span><br><span class="line">  uint16 csum;       /\* Packet checksum \*/</span><br><span class="line">  uint8 status;      /\* Descriptor status \*/</span><br><span class="line">  uint8 errors;      /\* Descriptor Errors \*/</span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define RX_RING_SIZE 16</span><br><span class="line">static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));</span><br><span class="line">static struct mbuf \*rx_mbufs[RX_RING_SIZE];</span><br><span class="line"></span><br><span class="line">struct mbuf &#123;</span><br><span class="line">  struct mbuf  \*next; // the next mbuf in the chain</span><br><span class="line">  char         \*head; // the current start position of the buffer</span><br><span class="line">  unsigned int len;   // the length of the buffer</span><br><span class="line">  char         buf[MBUF_SIZE]; // the backing store</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中,tx_ring和tx_mbufs是一一对应的.</p><p>当 net.c 中的网络堆栈需要发送数据包时，它会调用 e1000_transmit() 并使用 mbuf 保存要发送的数据包。您的传输代码必须在 TX（传输）环的描述符中放置一个指向数据包数据的指针。 struct tx_desc 描述描述符格式。您需要确保每个 mbuf 最终都被释放，但只有在 E1000 完成数据包传输之后（E1000 设置描述符中的 E1000_TXD_STAT_DD 位来指示这一点）。</p><p>当 E1000 从以太网接收到每个数据包时，它首先将数据包 DMA 到下一个 RX（接收）环描述符指向的 mbuf，然后产生中断。您的 e1000_recv() 代码必须扫描 RX 环并通过调用 net_rx() 将每个新数据包的 mbuf 传送到网络堆栈（在 net.c 中）。然后，您需要分配一个新的 mbuf 并将其放入描述符中，以便当 E1000 再次到达 RX 环中的那个点时，它会找到一个新的缓冲区来 DMA 一个新的数据包。</p><p>除了在 RAM 中读取和写入描述符环之外，您的驱动程序还需要通过其内存映射控制寄存器与 E1000 交互，以检测接收到的数据包何时可用，并通知 E1000 驱动程序已填写一些 TX 描述符与要发送的数据包。全局变量 regs 持有指向 E1000 的第一个控制寄存器的指针；您的驱动程序可以通过将 regs 索引为数组来获取其他寄存器。您需要特别使用索引 E1000_RDT 和 E1000_TDT。</p><p>要测试您的驱动程序，请在一个窗口中运行 make server，在另一个窗口中运行 make qemu，然后在 xv6 中运行 nettests。 nettests 中的第一个测试尝试向主机操作系统发送一个 UDP 数据包，地址是使服务器运行的程序。如果您还没有完成实验，E1000 驱动程序实际上不会发送数据包，也不会发生任何事情。</p><p>完成实验后，E1000 驱动程序会发送数据包，qemu 会将数据包传送到您的主机，make server 会看到它，它会发送响应数据包，然后 E1000 驱动程序和 nettests 会看到响应数据包.然而，在主机发送回复之前，它会向 xv6 发送一个“ARP”请求包以查找其 48 位以太网地址，并期望 xv6 以 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，kernel&#x2F;net.c 就会处理这个问题。如果一切顺利，nettests 将打印 testing ping: OK，并且 make server 将打印一条来自 xv6! 的消息。</p><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>首先将打印语句添加到 e1000_transmit() 和 e1000_recv()，然后运行 ​​make server 和（在 xv6 中）nettests。您应该从您的打印语句中看到 nettests 生成了对 e1000_transmit 的调用。</p><p>实现 e1000_transmit 的一些提示：</p><p>首先通过读取 E1000_TDT 控制寄存器向 E1000 询问它期待下一个数据包的 TX 环索引。<br>然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则说明 E1000 还没有完成对应的上一个传输请求，因此返回错误。<br>否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。<br>然后填写描述符。 m-&gt;head 指向包在内存中的内容，m-&gt;len 是包的长度。设置必要的 cmd 标志（查看 E1000 手册中的第 3.3 节）并隐藏指向 mbuf 的指针以供以后释放。<br>最后，通过将 E1000_TDT 模 TX_RING_SIZE 加一来更新环位置。<br>如果 e1000_transmit() 成功地将 mbuf 添加到环中，则返回 0。失败时（例如，没有可用于传输 mbuf 的描述符），返回 -1 以便调用者知道释放 mbuf。</p><p>实现 e1000_recv 的一些提示：</p><p>首先通过获取 E1000_RDT 控制寄存器并加一个模 RX_RING_SIZE，向 E1000 询问下一个等待接收的数据包（如果有）所在的环索引。<br>然后通过检查描述符状态部分中的 E1000_RXD_STAT_DD 位来检查新数据包是否可用。如果没有，请停止。<br>否则，将 mbuf 的 m-&gt;len 更新为描述符中报告的长度。使用 net_rx() 将 mbuf 传送到网络堆栈。<br>然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。<br>最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。<br>e1000_init() 用 mbufs 初始化 RX 环，你会想看看它是如何做到的，也许还需要借用代码。<br>在某些时候，已经到达的数据包总数将超过环大小（16）；确保您的代码可以处理。<br>您将需要锁来应对 xv6 可能从多个进程使用 E1000 的可能性，或者当中断到达时可能在内核线程中使用 E1000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">e1000_transmit(struct mbuf \*m)</span><br><span class="line">&#123;</span><br><span class="line">  //</span><br><span class="line">  // Your code here.</span><br><span class="line">  //</span><br><span class="line">  // the mbuf contains an ethernet frame; program it into</span><br><span class="line">  // the TX descriptor ring so that the e1000 sends it. Stash</span><br><span class="line">  // a pointer so that it can be freed after sending.</span><br><span class="line">  //</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  //首先通过读取 E1000_TDT 控制寄存器向 E1000 询问它期待下一个数据包的 TX 环索引。</span><br><span class="line">  uint reg_tdt = regs[E1000_TDT];</span><br><span class="line">  //然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则说明 E1000 还没有完成对应的上一个传输请求，因此返回错误。</span><br><span class="line">  if((tx_ring[reg_tdt].status &amp; E1000_TXD_STAT_DD) == 0)&#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  //否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。</span><br><span class="line">  if(tx_mbufs[reg_tdt] != 0)</span><br><span class="line">    mbuffree(tx_mbufs[reg_tdt]);</span><br><span class="line"></span><br><span class="line">  //然后填写描述符。 m-&gt;head 指向包在内存中的内容，m-&gt;len 是包的长度。设置必要的 cmd 标志</span><br><span class="line">  tx_mbufs[reg_tdt] = m;</span><br><span class="line">  tx_ring[reg_tdt].length = m-&gt;len;</span><br><span class="line">  tx_ring[reg_tdt].addr = (uint64)(m-&gt;head);</span><br><span class="line">  tx_ring[reg_tdt].cmd = 9;</span><br><span class="line"></span><br><span class="line">  //最后，通过将 E1000_TDT 模 TX_RING_SIZE 加一来更新环位置。</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">e1000_recv(void)</span><br><span class="line">&#123;</span><br><span class="line">  //</span><br><span class="line">  // Your code here.</span><br><span class="line">  //</span><br><span class="line">  // Check for packets that have arrived from the e1000</span><br><span class="line">  // Create and deliver an mbuf for each packet (using net_rx()).</span><br><span class="line">  //首先通过获取 E1000_RDT 控制寄存器并加一个模 RX_RING_SIZE，向 E1000 询问下一个等待接收的数据包（如果有）所在的环索引。</span><br><span class="line">  uint reg_rdt = regs[E1000_RDT];</span><br><span class="line">  int i = (reg_rdt + 1)%RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  //然后通过检查描述符状态部分中的 E1000_RXD_STAT_DD 位来检查新数据包是否可用。如果没有，请停止。</span><br><span class="line">  //否则，将 mbuf 的 m-&gt;len 更新为描述符中报告的长度。使用 net_rx() 将 mbuf 传送到网络堆栈。</span><br><span class="line">   while(rx_ring[i].status &amp; E1000_RXD_STAT_DD)&#123;</span><br><span class="line">      rx_mbufs[i]-&gt;len = rx_ring[i].length;</span><br><span class="line">      net_rx(rx_mbufs[i]);</span><br><span class="line">      //然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。</span><br><span class="line">      if((rx_mbufs[i] = mbufalloc(0)) == 0)</span><br><span class="line">          panic(&quot;e1000&quot;);</span><br><span class="line">      rx_ring[i].addr = (uint64)rx_mbufs[i]-&gt;head;</span><br><span class="line">      rx_ring[i].status = 0;</span><br><span class="line">      i = (i + 1) % RX_RING_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  //最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。</span><br><span class="line">  regs[E1000_RDT] = (i - 1) % RX_RING_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-Xv6-and-Lock"><a href="#8-Xv6-and-Lock" class="headerlink" title="8:Xv6 and Lock"></a>8:Xv6 and Lock</h1><h2 id="Lab8-1-Memory-Access"><a href="#Lab8-1-Memory-Access" class="headerlink" title="Lab8_1 Memory Access."></a>Lab8_1 Memory Access.</h2><p>在这个部分的测试中,三个进程频繁地调度kalloc和kfree.</p><p>对于每个锁，acquire 维护对该锁的调用计数，以及获取中的循环尝试但未能设置锁的次数。 kalloctest 调用一个系统调用，使内核打印 kmem 和 bcache 锁（这是本实验的重点）和 5 个最争用次数最多锁的计数。如果存在锁争用，获取循环迭代的次数将会很大。系统调用返回 kmem 和 bcache 锁的循环迭代次数的总和。</p><p>对于本实验，您必须使用具有多核的专用机器。如果您使用一台正在做其他事情的机器，那么 kalloctest 打印的计数将是无稽之谈。</p><p>kalloctest 中锁争用的根本原因是 kalloc() 有一个空闲列表，由一个锁保护。要消除锁争用，您必须重新设计内存分配器以不使用一个锁和列表。基本思想是为每个 CPU 维护一个空闲列表，每个列表都有自己的锁。不同 CPU 上的分配和释放可以并行运行，因为每个 CPU 将在不同的列表上运行。主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有空闲内存的情况；在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的空闲列表的一部分。窃取可能会引入锁争用，但希望这种情况很少见。(这个叫“负载均衡”)</p><p>你的工作是实现每个 CPU 的空闲列表(就是对于每个CPU的核维护一个空闲列表,这个列表就是kmem)，并在 CPU 的空闲列表为空时进行读取。 您必须为所有以“kmem”开头的锁命名。 也就是说，您应该为每个锁调用 initlock，并传递一个以“kmem”开头的名称。 运行 kalloctest 以查看您的实现是否减少了锁争用。 要检查它是否仍然可以分配所有内存，请运行 usertests sbrkmuch。 您的输出将类似于下图所示，kmem 锁的争用总量大大减少，尽管具体数字会有所不同。 确保 usertests 中的所有测试都通过。 make Grade 应该说 kalloctests 通过了。</p><h5 id="1-按照提示-更改内存块的结构-不是所有内存块都共享一个锁-是每个CPU都有一个独立的锁"><a href="#1-按照提示-更改内存块的结构-不是所有内存块都共享一个锁-是每个CPU都有一个独立的锁" class="headerlink" title="1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁."></a>1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct run \*freelist;</span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure><h5 id="2-改为初始化所有锁"><a href="#2-改为初始化所有锁" class="headerlink" title="2) 改为初始化所有锁."></a>2) 改为初始化所有锁.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; NCPU; i++)</span><br><span class="line">    initlock(&amp;kmem[i].lock, &quot;kmem&quot;);</span><br><span class="line">  freerange(end, (void\*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-获取CPU的id-在这个地方获取id的时候要关中断-防止因为中断分配给其他CPU来进行处理了"><a href="#3-获取CPU的id-在这个地方获取id的时候要关中断-防止因为中断分配给其他CPU来进行处理了" class="headerlink" title="3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了."></a>3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push_off();</span><br><span class="line">int id = cpuid();</span><br><span class="line">pop_off();</span><br></pre></td></tr></table></figure><h5 id="4-对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁"><a href="#4-对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁" class="headerlink" title="4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁"></a>4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁</h5><p><code>acquire(&amp;kmem.lock)-&gt;acquire(&amp;kmem[id].lock)</code></p><h5 id="5-在if-r-的后面添加else-代表如果寻找失败-就到其他的核中获取"><a href="#5-在if-r-的后面添加else-代表如果寻找失败-就到其他的核中获取" class="headerlink" title="5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取."></a>5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">  for (int i = 0; i &lt; NCPU; i++) &#123;</span><br><span class="line">    if (i == id) continue;</span><br><span class="line">    acquire(&amp;kmem[i].lock);</span><br><span class="line">    r = kmem[i].freelist;</span><br><span class="line">    if(r)</span><br><span class="line">      kmem[i].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem[i].lock);</span><br><span class="line">    if(r) break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-Xv6-File-System"><a href="#9-Xv6-File-System" class="headerlink" title="9:Xv6 &amp; File System"></a>9:Xv6 &amp; File System</h1><h2 id="Lab-9-1-Large-files"><a href="#Lab-9-1-Large-files" class="headerlink" title="Lab 9_1 Large files"></a>Lab 9_1 Large files</h2><p>在这个实验中,你会拓展文件系统中文件的最大大小,其中一开始文件是12个直接连接块,1个一级索引块,一共16*16+12&#x3D;268个块,这个时候我们要修改一下改成11个直接相连,1个一级索引块,1个二级索引块,一共256*256+256+11&#x3D;65536+256+11个块.</p><p>其中xv6把文件系统映射到fs.img中,这个一共有二十万个块,其中70个保存块信息的meta块,剩下的都是数据.完成这个实验你需要关注磁盘 inode 的格式,这个由 fs.h 中的 struct dinode 定义。 您对 NDIRECT、NINDIRECT、MAXFILE 和结构 dinode 的 addrs[] 元素特别感兴趣。 查看 xv6 文本中的图 8.3 以了解标准 xv6 inode 的图表。<br>在磁盘上查找文件数据的代码在 fs.c 的 bmap() 中。 看看它，确保你明白它在做什么。 bmap() 在读取和写入文件时都会被调用。 写入时，bmap() 会根据需要分配新块来保存文件内容，并在需要时分配间接块来保存块地址。<br>bmap() 处理两种块号。 bn 参数是一个“逻辑块号”——文件中的块号，相对于文件的开头。 ip-&gt;addrs[] 中的块号和 bread() 的参数是磁盘块号。 您可以将 bmap() 视为将文件的逻辑块号映射到磁盘块号。</p><p>修改 bmap() ，使其除了直接块和单间接块外，还实现双重间接块。 你只需要 11 个直接块，而不是 12 个，就可以为新的双重间接块腾出空间； 您不能更改磁盘 inode 的大小。 ip-&gt;addrs[] 的前 11 个元素应该是直接块； 第 12 个应该是一个单独的间接块（就像现在的块一样）； 第 13 个应该是你新的双重间接块。</p><h5 id="1-修改直接映射的数量"><a href="#1-修改直接映射的数量" class="headerlink" title="1) 修改直接映射的数量."></a>1) 修改直接映射的数量.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NDIRECT 11#define NDIRECT 11</span><br><span class="line">uint addrs[NDIRECT+2];</span><br><span class="line">#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLE)//文件最大值也要改变</span><br></pre></td></tr></table></figure><p>其中直接映射的数量由原来的12个改为11个.</p><h5 id="2-对应的file-h的inode结构体也要进行更改"><a href="#2-对应的file-h的inode结构体也要进行更改" class="headerlink" title="2) 对应的file.h的inode结构体也要进行更改"></a>2) 对应的file.h的inode结构体也要进行更改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  struct sleeplock lock; // protects everything below here</span><br><span class="line">  int valid;          // inode has been read from disk?</span><br><span class="line"></span><br><span class="line">  short type;         // copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-阅读bmap的代码-0-NDIRECT-1-直接-NDIRECT-NDIRECT-NINDIRECT-1-一级间接"><a href="#3-阅读bmap的代码-0-NDIRECT-1-直接-NDIRECT-NDIRECT-NINDIRECT-1-一级间接" class="headerlink" title="3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接"></a>3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//bn:the number the blocks.</span><br><span class="line">  if(bn &lt; NDIRECT)&#123;</span><br><span class="line">    if((addr = ip-&gt;addrs[bn]) == 0)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  if(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    // Load indirect block, allocating if necessary.</span><br><span class="line">    if((addr = ip-&gt;addrs[NDIRECT]) == 0)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint\*)bp-&gt;data;</span><br><span class="line">    if((addr = a[bn]) == 0)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有个大前提,就是如果索引为0就代表这个磁盘为空,需要申请一个返回一个磁盘块号</p><p>首先第一部分,就是直接映射的部分,如果寻找的逻辑地址是在NDIRECT以内的,就可以直接访问磁盘块.</p><p>第二部分就是一级间接映射,首先先把一级映射的映射表找到,读出来,如果没有映射表就新建一个.映射表我们之前在操作系统学过就是一个int类型数组,这个时候我们就可以把映射表解释称int类型数组,然后根据索引值,也就是bn-NDIRECT来寻找,寻找就是寻找数组里面的东西.</p><h5 id="4-依葫芦画瓢作出二级索引"><a href="#4-依葫芦画瓢作出二级索引" class="headerlink" title="4) 依葫芦画瓢作出二级索引."></a>4) 依葫芦画瓢作出二级索引.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">if(bn &lt; NDOUBLE)&#123;</span><br><span class="line">  if((addr = ip-&gt;addrs[NDIRECT+1]) == 0)</span><br><span class="line">    ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint\*)bp-&gt;data;</span><br><span class="line">  int bn1 = bn / NINDIRECT,bn2 = bn % NINDIRECT;</span><br><span class="line">  //first suoyin</span><br><span class="line">  if((addr = a[bn1]) == 0)&#123;</span><br><span class="line">   a[bn1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">   log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  //second suoyin</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bp=bread(ip-&gt;dev,addr);</span><br><span class="line">  a=(uint\*)bp-&gt;data;</span><br><span class="line">  if((addr=a[bn2])==0)</span><br><span class="line">  &#123;</span><br><span class="line">      a[bn2]=addr=balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级索引需要两个索引值,一个是除得来的结果,一个是%得来的结果,首先先读一次,获得一级索引表,做法和上面是一样的,接着再读,根据一级索引表得来的结果就是对应二级索引表的位置,所以说根据一级索引表的结果打开二级索引表,找到最后属于我们的索引值.</p><h5 id="5-完成索引的释放"><a href="#5-完成索引的释放" class="headerlink" title="5) 完成索引的释放."></a>5) 完成索引的释放.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(ip-&gt;addrs[NDIRECT+1]) &#123;</span><br><span class="line">  bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);</span><br><span class="line">  a = (uint\*)bp-&gt;data;</span><br><span class="line">  for(j = 0; j &lt; NINDIRECT; j++) &#123;</span><br><span class="line">    if(a[j]) &#123;</span><br><span class="line">      bp2 = bread(ip-&gt;dev, a[j]);</span><br><span class="line">      a2 = (uint\*)bp2-&gt;data;</span><br><span class="line">      for(i = 0; i &lt; NINDIRECT; i++) &#123;</span><br><span class="line">        if(a2[i]) bfree(ip-&gt;dev, a2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp2);</span><br><span class="line">      bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      a[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);</span><br><span class="line">  ip-&gt;addrs[NDIRECT] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是先读取数组的第13项,构造一个二重循环,先进入到第一个一级索引的第一个二级索引陆续地释放所有的块.再进入到第一个一级索引的第二个二级索引…第一个一级索引的第256个二级索引….第256个二级索引的第256个一级索引…</p><h2 id="Lab9-2-Symbolic-links"><a href="#Lab9-2-Symbolic-links" class="headerlink" title="Lab9_2 Symbolic links"></a>Lab9_2 Symbolic links</h2><p>您将实现 symlink(char *target, char *path) 系统调用，它会在 path 处创建一个新的符号链接，该链接引用由 target 命名的文件。</p><p>首先，为symlink创建一个新的系统调用号，在user&#x2F;usys.pl，user&#x2F;user.h中添加一个入口，在kernel&#x2F;sysfile.c中实现一个空的sys_symlink。<br>将新文件类型 (T_SYMLINK) 添加到 kernel&#x2F;stat.h 以表示符号链接。<br>向 kernel&#x2F;fcntl.h 添加一个新标志 (O_NOFOLLOW)，可与 open 系统调用一起使用。请注意，传递给 open 的标志是使用按位 OR 运算符组合的，因此您的新标志不应与任何现有标志重叠。这将让您在将 user&#x2F;symlinktest.c 添加到 Makefile 后编译它。<br>实现 symlink(target, path) 系统调用以在指向目标的路径上创建一个新的符号链接。请注意，系统调用成功时不需要存在目标。您将需要选择某个位置来存储符号链接的目标路径，例如，在 inode 的数据块中。 symlink 应该返回一个表示成功 (0) 或失败 (-1) 的整数，类似于链接和取消链接。<br>修改 open 系统调用以处理路径引用符号链接的情况。如果文件不存在，则打开必须失败。当进程在要打开的标志中指定 O_NOFOLLOW 时， open 应该打开符号链接（而不是跟随符号链接）。<br>如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件。如果链接形成循环，则必须返回错误代码。如果链接的深度达到某个阈值（例如，10），您可以通过返回错误代码来近似此值。<br>其他系统调用（例如，链接和取消链接）不得遵循符号链接；这些系统调用对符号链接本身进行操作。<br>对于本实验，您不必处理指向目录的符号链接。</p><h5 id="1-添加系统调用-略"><a href="#1-添加系统调用-略" class="headerlink" title="1) 添加系统调用.(略)"></a>1) 添加系统调用.(略)</h5><h5 id="2-按照实验提示的信息-添加两个新的宏-略"><a href="#2-按照实验提示的信息-添加两个新的宏-略" class="headerlink" title="2) 按照实验提示的信息,添加两个新的宏.(略)"></a>2) 按照实验提示的信息,添加两个新的宏.(略)</h5><h5 id="3-完成symlink系统调用"><a href="#3-完成symlink系统调用" class="headerlink" title="3) 完成symlink系统调用."></a>3) 完成symlink系统调用.</h5><p>首先第一点,我们发现,在sysfile.c的系统调用是需要提交事务的,我们也模仿这一点进行更改,处理的思路就是获取参数,创建一个新的inode,把符号连接的文件路径写进inode里面,然后提交即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_symlink(void)</span><br><span class="line">&#123;  </span><br><span class="line">  char path[MAXPATH], target[MAXPATH];</span><br><span class="line">  struct inode \*ip;</span><br><span class="line">  // get parameter</span><br><span class="line">  if(argstr(0, target, MAXPATH) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  if(argstr(1, path, MAXPATH) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  begin_op();</span><br><span class="line">  // create a inode</span><br><span class="line">  if((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  // write the path of the file to the inode.</span><br><span class="line">  if(writei(ip, 0, (uint64)target, 0, MAXPATH) &lt; MAXPATH) &#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Xv6-and-Unix-utilities&quot;&gt;&lt;a href=&quot;#1-Xv6-and-Unix-utilities&quot; class=&quot;headerlink&quot; title=&quot;1:Xv6 and Unix utilities&quot;&gt;&lt;/a&gt;1:Xv6 and Unix</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU14-445 Lab</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/02/07/cmu14-445-lab/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/02/07/cmu14-445-lab/</id>
    <published>2023-02-07T02:46:50.000Z</published>
    <updated>2024-03-25T01:34:26.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab1-Buffer-Pool"><a href="#Lab1-Buffer-Pool" class="headerlink" title="Lab1.Buffer Pool"></a>Lab1.Buffer Pool</h1><p>这是CMU数据库系列的第一个实验,第一个实验需要我们完成关于Buffer的一些功能.在完善Buffer的功能之前,我们先了解一下buffer的一些基本知识.</p><p>buffer在这里面和操作系统很像,是主存和辅存的缓冲地带,我们需要完成的是两个特别重要的数据结构,一个是Disk Manager,用我的话说就是页表,一个是LRU Replacer,这个数据结构研究,在缓冲地带满的时候我们应该替换谁进入到辅存.这两个数据结构所存储的信息单位量是一样的(也就是说这两个数据结构都存储了n个块[你也可以认为是“页”]的信息).两个数据结构通过Pin和Unpin来互相作用.</p><h2 id="实验1-1-LRU-REPLACEMENT"><a href="#实验1-1-LRU-REPLACEMENT" class="headerlink" title="实验1.1 LRU REPLACEMENT"></a>实验1.1 LRU REPLACEMENT</h2><p>实验提示:修改src&#x2F;include&#x2F;buffer&#x2F;lru_replacer.h和src&#x2F;buffer&#x2F;lru_replacer.cpp.</p><p>首先我们知道LRU Replacer是一个依赖LRU算法进行替换的一个结构体,我们在操作系统和组成原理的课程中已经知道,模拟LRU算法一般使用堆栈,我们现在使用堆栈来进行模拟:</p><p>首先在头文件中添加有关堆栈的一些信息;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t capacity;      //容量</span><br><span class="line">size_t size;          //当前大小</span><br><span class="line">std::list&lt;frame_id_t&gt; lists;           //存储帧的栈,用list实现</span><br><span class="line">std::unordered_map&lt;frame_id_t , int&gt; maps;      //哈希映射,映射帧和是否在LRU Replacer里面.</span><br><span class="line">std::mutex locks;</span><br></pre></td></tr></table></figure><p>定义了这么多成员,我们可以实现类的方法了:</p><p>1、构造函数.(略)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRUReplacer::LRUReplacer(size_t num_pages) &#123;</span><br><span class="line">    capacity = num_pages;</span><br><span class="line">    maps.clear();</span><br><span class="line">    lists.clear();</span><br><span class="line">    size = lists.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Victim函数:</p><p>这个函数选择一个帧来被替换.返回值是是否成功输出.具体的做法是从栈中选择栈顶返回即可.然后在maps中删除掉这个帧即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool LRUReplacer::Victim(frame_id_t \*frame_id) &#123; </span><br><span class="line">    if(lists.empty()) return false; </span><br><span class="line">    locks.lock();</span><br><span class="line">    frame_id_t lasts = lists.back();</span><br><span class="line">    maps.erase(lasts);</span><br><span class="line">    lists.pop_back();</span><br><span class="line">    \*frame_id = lasts; </span><br><span class="line">    locks.unlock();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Pin函数</p><p>Pin的意思就是固定,这个意思就是Disk Manager固定了某一个页,希望这个页不会被LRU Replacer选中然后被替换掉.那么首先调用maps,看看LRU Replacer中是否存在这个帧,存在的话就删除,不存在的话就不作任何处理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void LRUReplacer::Pin(frame_id_t frame_id) &#123;</span><br><span class="line">    if(maps.count(frame_id) == 0) return;</span><br><span class="line">    locks.lock();</span><br><span class="line">    lists.remove(frame_id);</span><br><span class="line">    maps.erase(frame_id);</span><br><span class="line">    locks.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、UnPin函数</p><p>UnPin函数的意思是解除固定,这个意思就是Disk Manager解除固定某一个页,表示Disk Manager最近不需要使用这个页了,LRU Replacer最近可以对其进行替换操作.首先第一步就是查看这个帧是否存在于LRU Replacer中.如果没有就需要放进LRU Replacer中,那么就会存在问题,问题就是,万一我LRU Replacer满了怎么办?满了的话就可以选择一个元素替换下去,然后在插入.(跟我们在操作系统课程上面学习的一样,从栈顶取一个元素,然后把它放入栈底)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void LRUReplacer::Unpin(frame_id_t frame_id) &#123;</span><br><span class="line">    if(maps.count(frame_id) != 0) return;</span><br><span class="line">    locks.lock();</span><br><span class="line">    //如果已经满了,则需要淘汰一个然后放入 LRUReplacer 中</span><br><span class="line">    if (lists.size() == capacity) &#123;</span><br><span class="line">        frame_id_t last_frame = lists.back();</span><br><span class="line">        maps.erase(last_frame);</span><br><span class="line">        lists.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    lists.push_front(frame_id);</span><br><span class="line">    maps[frame_id] = 1;</span><br><span class="line">    locks.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看实验的最后怎么make的吧,一开始太智障直接cd进目录调gcc,这下丑大了,重写了一份…</p><h2 id="实验1-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#实验1-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="实验1.2 BUFFER POOL MANAGER INSTANCE"></a>实验1.2 BUFFER POOL MANAGER INSTANCE</h2><p>提示:修改src&#x2F;include&#x2F;buffer&#x2F;buffer_pool_manager_instance.h和src&#x2F;buffer&#x2F;buffer_pool_manager_instance.cpp</p><p>首先我们先来了解一下BUFFER POOL的一些成员(这个实验不需要我们添加成员),一个是存储每个页的指针的指针数组,在后面我们会使用这个结构来给定页的id获得一个页的指针,接着就是页表成员,将物理帧和页的id进行对应,接着就是空闲物理帧以及之前做的替换器元素.(其实页和物理帧是相互统一的概念,物理帧是一个物理概念,代表了一块空闲的内存空间,页就是记录数据的单位,当物理帧被赋值,被填入数据的时候,它就变成了一个页.**当然,页表的id某种程度上反映了辅存的位置**)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/\*\* Array of buffer pool pages. \*/</span><br><span class="line">Page \*pages_;</span><br><span class="line">/\*\* Pointer to the disk manager. \*/</span><br><span class="line">DiskManager \*disk_manager_ __attribute__((__unused__));</span><br><span class="line">/\*\* Pointer to the log manager. \*/</span><br><span class="line">LogManager \*log_manager_ __attribute__((__unused__));</span><br><span class="line">/\*\* Page table for keeping track of buffer pool pages. \*/</span><br><span class="line">std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_;</span><br><span class="line">/\*\* Replacer to find unpinned pages for replacement. \*/</span><br><span class="line">Replacer \*replacer_;</span><br><span class="line">/\*\* List of free pages. \*/</span><br><span class="line">std::list&lt;frame_id_t&gt; free_list_;</span><br><span class="line">/\*\* This latch protects shared data structures. We recommend updating this comment to describe what it protects. \*/</span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>1、NewPgImp函数</p><p>这个函数主要让我们申请一个新的Page,然后把Page的ID放入到page_id中,然后返回这个Page的指针.关于这个函数,提示已经说明地很明显了:</p><p>首先第一步,遍历一遍pool_size_,看看是不是所有的Page都被Pin了,如果是,那么就返回空指针,代表找不到可以申请的页.</p><p>第二步就是从freelist中获取一个新的帧,如果freelist为空,就代表我们不得不得替换一个页下来,这个页可以调用Replacer的Victim函数获得.如果要替换的页是脏的,我们要把这个页写进磁盘中.(脏块,参考组成原理)</p><p>第三步就是从给这个页一些初始数据,比如说引用数为1,页的id是page_id,存储的内容为空,最后Pin一下这个页,返回即可.然后把这个页填入到物理帧中然后加入到页表中.</p><p>代码略</p><p>2、FetchPgImp函数</p><p>这个函数主要根据页面的id来获取一个页的指针,这个提示说明的也很明显了</p><p>首先第一步,在页表中寻找page_id,看这个页是否真正存在,如果存在就跳过,如果不存在,按照第一个函数的方式申请一个页,然后把页号加载一下,把辅存的内容加载到p-&gt;data_里面,Pin一下即可.</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Page \*BufferPoolManagerInstance::FetchPgImp(page_id_t page_id) &#123;</span><br><span class="line">  // 1.     Search the page table for the requested page (P).</span><br><span class="line">  // 1.1    If P exists, pin it and return it immediately.</span><br><span class="line">  // 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br><span class="line">  //        Note that pages are always found from the free list first.</span><br><span class="line">  // 2.     If R is dirty, write it back to the disk.</span><br><span class="line">  // 3.     Delete R from the page table and insert P.</span><br><span class="line">  // 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br><span class="line">  frame_id_t fid;</span><br><span class="line">  Page\* p = nullptr;</span><br><span class="line">  // step 1.1.</span><br><span class="line">  if(page_table_.find(page_id) != page_table_.end())&#123;</span><br><span class="line">    fid = page_table_[page_id];</span><br><span class="line">    pages_[fid].pin_count_++;</span><br><span class="line">    // pin it.</span><br><span class="line">    replacer_-&gt;Pin(fid);</span><br><span class="line">    return &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  latch_.lock();</span><br><span class="line">  // step 1.2.</span><br><span class="line">  if (free_list_.empty()) &#123;  // pick from free list first.</span><br><span class="line">    //can&#x27;t find a page that can be flushed.</span><br><span class="line">    if (!replacer_-&gt;Victim(&amp;fid)) &#123;</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // the page placed in the lrureplacer need to be flushed.</span><br><span class="line">      // send it to the disk</span><br><span class="line">      p = &amp;pages_[fid];</span><br><span class="line">      if (p-&gt;is_dirty_) &#123;</span><br><span class="line">        disk_manager_-&gt;WritePage(p-&gt;page_id_, p-&gt;data_);</span><br><span class="line">        p-&gt;is_dirty_ = false;</span><br><span class="line">      &#125;</span><br><span class="line">      // erase the pagetable_.</span><br><span class="line">      page_table_.erase(p-&gt;page_id_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //found:</span><br><span class="line">    fid = free_list_.front();</span><br><span class="line">    free_list_.pop_front();</span><br><span class="line">    p = &amp;pages_[fid];</span><br><span class="line">  &#125;</span><br><span class="line">  // Step 3.</span><br><span class="line">  page_table_[page_id] = fid;</span><br><span class="line">  replacer_-&gt;Pin(fid);</span><br><span class="line">  // Step 4.</span><br><span class="line">  p-&gt;page_id_ = page_id;</span><br><span class="line">  p-&gt;pin_count_ = 1;</span><br><span class="line">  disk_manager_-&gt;ReadPage(page_id, p-&gt;data_);</span><br><span class="line">  latch_.unlock();</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、DeletePgImp函数</p><p>这个函数要求我们删除某个页.当然,代码的注释也给出了很详细的说明.</p><p>首先判断要删除的那个页到底存不存在,如果不存在的话就跳过,然后判断被删除的那个页到底有没有被Pin,如果被Pin了的话也是不能删除的,接着判断这个页是不是为脏,如果是脏页就要写回,最后把这个页的一些信息初始化,然后把这个页的信息加入到freelist里面.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool BufferPoolManagerInstance::DeletePgImp(page_id_t page_id) &#123;</span><br><span class="line">  // 0.   Make sure you call DeallocatePage!</span><br><span class="line">  // 1.   Search the page table for the requested page (P).</span><br><span class="line">  // 1.   If P does not exist, return true.</span><br><span class="line">  // 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span><br><span class="line">  // 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span><br><span class="line">  </span><br><span class="line">  if (page_table_.find(page_id) == page_table_.end()) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // P does exists.</span><br><span class="line">  frame_id_t fid = page_table_[page_id];</span><br><span class="line">  Page\* deletepage = &amp;pages_[fid];</span><br><span class="line">  // P is pinned</span><br><span class="line">  if (deletepage-&gt;pin_count_ != 0) &#123;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  // if dirty rewrite:</span><br><span class="line">  // flush the page before deallocate it.</span><br><span class="line">  latch_.lock();</span><br><span class="line">  if (deletepage-&gt;is_dirty_) &#123;</span><br><span class="line">    disk_manager_-&gt;WritePage(page_id, deletepage-&gt;data_);</span><br><span class="line">    deletepage-&gt;is_dirty_ = false;</span><br><span class="line">  &#125;</span><br><span class="line">  DeallocatePage(page_id);</span><br><span class="line">  // remove P from the page table.</span><br><span class="line">  page_table_.erase(page_id);</span><br><span class="line">  // reset its metadata.</span><br><span class="line">  // the page returned to freelist does not stores any page.</span><br><span class="line">  deletepage-&gt;page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  deletepage-&gt;is_dirty_ = false;</span><br><span class="line">  deletepage-&gt;pin_count_ = 0;</span><br><span class="line">  // return it to free_list_.</span><br><span class="line">  free_list_.push_back(fid);</span><br><span class="line">  latch_.unlock();</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了,最难的几个函数我们都做完了,剩下的几个都比较简单.</p><p>4、FlushPgImp函数</p><p>刷新一个页,把这个页里面的数据写入磁盘.</p><p>找到这个页,然后调用WritePage就可以了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool BufferPoolManagerInstance::FlushPgImp(page_id_t page_id) &#123;</span><br><span class="line">  // Make sure you call DiskManager::WritePage!</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (page_table_.find(page_id) == page_table_.end()  page_id == INVALID_PAGE_ID)</span><br><span class="line">    return false;</span><br><span class="line">  disk_manager_-&gt;WritePage(page_id, pages_[page_table_[page_id]].data_);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、UnpinPgImp函数</p><p>让一个页的pin数减1.</p><p>找到一个页,首先置脏位,然后让pin数-1,如果减为0就调用Replacer的Unpin函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty) &#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; lock(latch_); </span><br><span class="line">  frame_id_t fid = page_table_[page_id];</span><br><span class="line">  Page\* p = &amp;pages_[fid];</span><br><span class="line">  p-&gt;is_dirty_ = is_dirty;  // hold the state until victim.</span><br><span class="line">  if (p-&gt;pin_count_ &lt;= 0)</span><br><span class="line">    return false;</span><br><span class="line">  --p-&gt;pin_count_;</span><br><span class="line">  if (p-&gt;pin_count_ == 0) &#123;</span><br><span class="line">    replacer_-&gt;Unpin(fid);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验1-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#实验1-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="实验1.3 PARALLEL BUFFER POOL MANAGER"></a>实验1.3 PARALLEL BUFFER POOL MANAGER</h2><p>并行的manager,先前是一个manager工作,现在是多个manager工作,具体的思路大同小异,就是先选择究竟是哪一个manager,然后再调用这个manager的函数.</p><p>选择的方式比较淳朴,假设有N个manager,那个调用manager的序号就是id % N.</p><p>这一部分的函数,除了创建新页面这个不确定初始页面id的情况下,其他的都一模一样.</p><p>1、NewPgImp函数.</p><p>遍历一遍所有的Manager,然后调用所有的Manager的NewPgImp函数,找得到就返回,找不到就算了,返回空指针吧.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Page \*ParallelBufferPoolManager::NewPgImp(page_id_t \*page_id) &#123;</span><br><span class="line">  // create new page. We will request page allocation in a round robin manner from the underlying</span><br><span class="line">  // BufferPoolManagerInstances</span><br><span class="line">  // 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to starting index and return nullptr    </span><br><span class="line">  // 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function is called</span><br><span class="line">  for(size_t i = 0; i &lt; num_instances_; i++)&#123;</span><br><span class="line">    BufferPoolManager\* one_manager_instance = manager_[next_instacnce_];</span><br><span class="line">    Page \*page = one_manager_instance-&gt;NewPage(page_id);</span><br><span class="line">    if(page != nullptr)&#123;</span><br><span class="line">      return page;</span><br><span class="line">    &#125;</span><br><span class="line">    next_instacnce_ = (next_instacnce_ + 1) % num_instances_;</span><br><span class="line">  &#125;</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,有小伙伴就问了,你这样子做,有没有这样一种可能,就是生成这个页的时候是由i号Manager生成的,但是调用这个页的时候是由j号Manager管理,这个可以说应该是不可能的,因为next_instacnce_可以认为是和page_id同步的(起码模 N是一样的),各位做实验可以验证这个结论.</p><p>2、其他函数.</p><p>先选Manager,再调用,没啥好说的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BufferPoolManager \*ParallelBufferPoolManager::GetBufferPoolManager(page_id_t page_id) &#123;</span><br><span class="line">  // Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span><br><span class="line">  return manager_[page_id % num_instances_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page \*ParallelBufferPoolManager::FetchPgImp(page_id_t page_id) &#123;</span><br><span class="line">  // Fetch page for page_id from responsible BufferPoolManagerInstance</span><br><span class="line">  return GetBufferPoolManager(page_id)-&gt;FetchPage(page_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ParallelBufferPoolManager::UnpinPgImp(page_id_t page_id, bool is_dirty) &#123;</span><br><span class="line">  // Unpin page_id from responsible BufferPoolManagerInstance</span><br><span class="line">  return GetBufferPoolManager(page_id)-&gt;UnpinPage(page_id,is_dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ParallelBufferPoolManager::FlushPgImp(page_id_t page_id) &#123;</span><br><span class="line">  // Flush page_id from responsible BufferPoolManagerInstance</span><br><span class="line">  return GetBufferPoolManager(page_id)-&gt;FlushPage(page_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lab2-EXTENDIBLE-HASH-INDEX"><a href="#Lab2-EXTENDIBLE-HASH-INDEX" class="headerlink" title="Lab2.EXTENDIBLE HASH INDEX"></a>Lab2.EXTENDIBLE HASH INDEX</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><img src="https://sukunahust.com/wp-content/uploads/2022/10/image-1024x573.png"></p><p>左边那个就是directory page，它有一个参数叫做global depth，1&lt;&lt;global depth 为directory的大小。它存储了指向各个bucket page的指针。bucket page里面存储的则是实际的数据（在本实验中是std::pair类型的键值），每个bucket都有一个自己的local depth。</p><p>插入一个键值的过程是：先把key代入hash函数计算得到一个中间结果，取这个中间结果的最后global depth位（这就是global depth mask的作用,就是 数据&amp;global mask(具体请看下面的例子) ），得到一个数组下标，bucket的page id就在这个下标里。根据page id调入bucket，然后把这个键值插入到bucket里面。</p><h2 id="实验2-1-PAGE-LAYOUTS"><a href="#实验2-1-PAGE-LAYOUTS" class="headerlink" title="实验2.1 PAGE LAYOUTS"></a>实验2.1 PAGE LAYOUTS</h2><p>提示:完成两种页的设计,一个是桶一个是目录.</p><p>修改src&#x2F;include&#x2F;storage&#x2F;page&#x2F;hash_table_bucket_page.h、src&#x2F;storage&#x2F;page&#x2F;hash_table_bucket_page.cpp、src&#x2F;include&#x2F;storage&#x2F;page&#x2F;hash_table_directory_page.h和src&#x2F;storage&#x2F;page&#x2F;hash_table_directory_page.cpp</p><h3 id="实验2-1-1-目录页的设计"><a href="#实验2-1-1-目录页的设计" class="headerlink" title="实验2.1.1 目录页的设计"></a>实验2.1.1 目录页的设计</h3><p>我们先来看看头文件(头文件不需要修改)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">page_id_t page_id_; // 页的id</span><br><span class="line">lsn_t lsn_;</span><br><span class="line">uint32_t global_depth_&#123;0&#125;;//全局深度,也就是说下面的数组有几个元素.2^i的关系,所有局部深度不能比全局深度大</span><br><span class="line">uint8_t local_depths_[DIRECTORY_ARRAY_SIZE];//每一个页的局部深度,这个类似三级页表.第一级的页表局部深度就是2.局部深度代表你作为目录项离叶结点(bucket有多远)</span><br><span class="line">page_id_t bucket_page_ids_[DIRECTORY_ARRAY_SIZE];//下一级的页号</span><br></pre></td></tr></table></figure><p>1、GetGlobalDepthMask函数</p><p>这个函数要求我们返回一个掩码,掩码的概念我们在计算机网络中学过,对于网络地址,网络地址有几位,就有几个1,在这里,全局深度为几就有几个1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint32_t HashTableDirectoryPage::GetGlobalDepthMask() &#123; </span><br><span class="line">  uint32_t global_depth_mask =  ((1 &lt;&lt; GetGlobalDepth()) - 1);</span><br><span class="line">  return global_depth_mask; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、IncrGlobalDepth函数</p><p>这需要我们增长全局深度,根据CMU的PPT里面介绍,我们不仅要增加变量的值(value),还需要进行local_depths和bucket的初始化.初始化的方法就是1:1复制,因为这种增长是成倍增长的,对于1<del>N的节点,给N+1</del>2N赋值的时候直接完全复制就可以了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void HashTableDirectoryPage::IncrGlobalDepth() &#123; </span><br><span class="line">  int original_depth = 1 &lt;&lt; global_depth_;</span><br><span class="line">  int new_index = original_depth;</span><br><span class="line">  for(int i = 0;i &lt; original_depth;i++)&#123;</span><br><span class="line">    local_depths_[new_index] = local_depths_[i];</span><br><span class="line">    bucket_page_ids_[new_index] = bucket_page_ids_[i];</span><br><span class="line">    new_index++;</span><br><span class="line">  &#125;</span><br><span class="line">  global_depth_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、CanShrink函数</p><p>能否缩小全局变量,那就判断有没有一个局部深度比全局深度深.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool HashTableDirectoryPage::CanShrink() &#123;</span><br><span class="line">  int original_depth = 1 &lt;&lt; global_depth_;</span><br><span class="line">  for(int i = 0;i &lt; original_depth;i++)&#123;</span><br><span class="line">    if(local_depths_[i] &gt;= global_depth_) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的函数都是set和get,相信各位都可以做出来.</p><h3 id="2-1-2-桶页的设计"><a href="#2-1-2-桶页的设计" class="headerlink" title="2.1.2 桶页的设计"></a>2.1.2 桶页的设计</h3><p>首先我们来看头文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  For more on BUCKET_ARRAY_SIZE see storage/page/hash_table_page_defs.h</span><br><span class="line">char occupied_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1];</span><br><span class="line">// 0 if tombstone/brand new (never occupied), 1 otherwise.</span><br><span class="line">char readable_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1];</span><br><span class="line">MappingType array_[0];</span><br></pre></td></tr></table></figure><p>首先就是MappingType,保存了一系列键值对,还有一个bitmap,来表示占用与存储有效信息.</p><p>1、可读和占用的判断和设置</p><p>这个bitmap是一个char[]的数组,首先我们要判断出它们是在数组的哪一个元素,然后从这个元素中进行恰当的位运算.int A &#x3D; id&#x2F;8(哪一个元素) int B &#x3D; id % 8(这个元素的哪一位),这个就很像xv6文件系统中的bitmap.</p><p>然后就是设置,设置的思路其实也是一样的,找到位置和具体哪一位,然后置0或者是1,大体上类似于get和set,但是有一点不一样的就是set和get的粒度是具体到bit的,这个需要我们使用正确且高效的位运算.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_BUCKET_TYPE::IsOccupied(uint32_t bucket_idx) const &#123;</span><br><span class="line">  size_t c = occupied_[bucket_idx / 8];</span><br><span class="line">  c = c &amp; (1 &lt;&lt; (bucket_idx % 8));</span><br><span class="line">  return c != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">void HASH_TABLE_BUCKET_TYPE::SetOccupied(uint32_t bucket_idx) &#123;</span><br><span class="line">  size_t c = occupied_[bucket_idx / 8];</span><br><span class="line">  c = c  (1 &lt;&lt; (bucket_idx % 8));</span><br><span class="line">  occupied_[bucket_idx / 8] = static_cast&lt;char&gt;(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_BUCKET_TYPE::IsReadable(uint32_t bucket_idx) const &#123;</span><br><span class="line">  size_t c = readable_[bucket_idx / 8];</span><br><span class="line">  c = c &amp; (1 &lt;&lt; (bucket_idx % 8));</span><br><span class="line">  return c != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">void HASH_TABLE_BUCKET_TYPE::SetReadable(uint32_t bucket_idx) &#123;</span><br><span class="line">  size_t c = readable_[bucket_idx / 8];</span><br><span class="line">  c = c  (1 &lt;&lt; (bucket_idx % 8));</span><br><span class="line">  readable_[bucket_idx / 8] = static_cast&lt;char&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们在大一做的C语言位运算的题目嘛?这下用上了.</p><p>2、Remove系列函数</p><p>首先基础的函数就是RemoveAt函数,RemoveAt函数其实类似于SetReadable(i,0).接着就是Remove,基本思路就是比较,找到匹配的值然后删除掉即可.</p><p>其实可以思考一下,为什么Key类型的需要使用比较器,但是Value的值不需要比较器,为什么设置的模版只有3个参数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_BUCKET_TYPE::Remove(KeyType key, ValueType value, KeyComparator cmp) &#123;</span><br><span class="line">  for(size_t i = 0; i &lt; BUCKET_ARRAY_SIZE ; i++)&#123;</span><br><span class="line">    if(IsReadable(i))&#123;</span><br><span class="line">      if(cmp(key,array_[i].first) == 0 &amp;&amp; value == array_[i].second)&#123;</span><br><span class="line">        RemoveAt(i);</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">void HASH_TABLE_BUCKET_TYPE::RemoveAt(uint32_t bucket_idx) &#123;</span><br><span class="line">  size_t c = readable_[bucket_idx / 8];</span><br><span class="line">  c = c &amp; (~(1 &lt;&lt; (bucket_idx % 8)));</span><br><span class="line">  readable_[bucket_idx / 8] = static_cast&lt;char&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、是否全满,是否全空.</p><p>这类思路都是一样的,对于bitmap的全部数据,进行遍历.只不过这一次遍历的粒度不需要下降到位的级别,只需要看看,char[]里面的值是不是全0或者是全1,这下我们可以使用mask&#x3D;0xFF来进行与或运算.</p><p>这时候有小伙伴会问,万一桶的元素不为8的整数,剩下的5个怎么比较呢?我们可以把最后一个char类型的元素取出来,然后可以利用10000000取高位来进行取值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_BUCKET_TYPE::IsEmpty() &#123;</span><br><span class="line">  u_int8_t mask = 0;</span><br><span class="line">  size_t times = BUCKET_ARRAY_SIZE / 8;</span><br><span class="line">  for (size_t i = 0; i &lt; times; i++) &#123;</span><br><span class="line">    char c = readable_[i];</span><br><span class="line">    uint8_t ic = static_cast&lt;uint8_t&gt;(c);</span><br><span class="line">    if ((ic  mask) != mask) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">//剩下的</span><br><span class="line">  size_t remain = BUCKET_ARRAY_SIZE % 8;</span><br><span class="line">  if (remain &gt; 0) &#123;</span><br><span class="line">    char c = readable_[times];</span><br><span class="line">    uint8_t ic = static_cast&lt;uint8_t&gt;(c);</span><br><span class="line">    for (size_t i = 0; i &lt; remain; i++) &#123;</span><br><span class="line">//每次取1位</span><br><span class="line">      if ((ic &amp; 1) != 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">//迭代</span><br><span class="line">      ic = ic &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验2-2-HASH-TABLE-IMPLEMENTATION"><a href="#实验2-2-HASH-TABLE-IMPLEMENTATION" class="headerlink" title="实验2.2 HASH TABLE IMPLEMENTATION"></a>实验2.2 HASH TABLE IMPLEMENTATION</h2><p>0、概要</p><p>这一个部分我们需要结合之前的BufferPoolManager来完善哈希表的增删改查的操作.</p><p>初始情况下global depth为0，directory大小为1&lt;&lt;0&#x3D;1，因此只有一个bucket，此bucket的local depth为0。这时插入键值，取哈希函数中间结果的后0位，得到的directory下标总是为0，所有的元素全进入这个初始bucket。</p><p>如果一个桶满了,就需要分裂成两个桶,分裂的伪代码如下:</p><p>split–伪代码<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bucket_page = Fetch(bucket_idx);</span><br><span class="line">    if(bucket为空)&#123;</span><br><span class="line">        构造分裂映像</span><br><span class="line">        split_page = NewPage(&amp;split_idx);</span><br><span class="line">        if(全局深度 == 局部深度)&#123;</span><br><span class="line">            需要增长目录;</span><br><span class="line">            产生的许多空索引需要进行填入page_id信息以及局部深度信息</span><br><span class="line">            指向相同的page_id的索引之间相差了1&lt;&lt;(全局深度);</span><br><span class="line">            修改目录的信息以及设置分裂后的桶的相关信息            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            仅需要分裂桶;</span><br><span class="line">            先增加局部深度，接着确定兄弟索引的个数;</span><br><span class="line">            修改分裂后兄弟索引的指向;</span><br><span class="line">        &#125;</span><br><span class="line">        分配旧桶里面的数据，一般会均分到两个桶里面</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>执行插入即可</p><p>假设global_depth&#x3D;1,就是两个桶:(目录桶对应的是key的最后一位)</p><p>假设桶b满了,这个时候local_depth&#x3D;1&#x3D;global_depth.这个时候目录页需要扩充.</p><p>桶b的内容(1),平均分成01和11.桶a的内容被00和10指着</p><p>这个时候local_depth变成了2,原来的a桶depth还是1.</p><p>如果a满了,也是一样分裂,但是local_depth&#x3D;1&lt;2,目录页是不用分裂的.</p><p>插入讲完了,现在我们需要讲一讲合并.</p><p>在删除bucket_page 000 后，如果这里的000空了，空了就尝试merge。参考官方做法就是：</p><p>（1）两哈希桶均为空桶；</p><p>（2）目录项及其目标目录项（一个目录项的目标目录项可由其低第<code>j</code>位反转得到）的局部深度相同且不为0。</p><p>满足上述两个条件后就可以进行合并了。</p><p>1、查(getValue)</p><p>了解一下函数的做法首先第一步获取目录页,然后根据目录页调用KeyToPageId获取具体位于哪一个桶里面.然后调用getdata和getvalue函数进行查找.查找的返回值是有没有查找到相关信息,查找的结果返回在result变量里面.(注意page只是一个指针,你还是需要通过GetData来获得指针里面具体指向的内容),注意在最后需要调用unpin函数取消对页的pin.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_TYPE::GetValue(Transaction \*transaction, const KeyType &amp;key, std::vector&lt;ValueType&gt; \*result) &#123;</span><br><span class="line">  table_latch_.RLock();</span><br><span class="line">  HashTableDirectoryPage \*dir_page = FetchDirectoryPage();</span><br><span class="line">  page_id_t bucket_page_id = KeyToPageId(key,dir_page);</span><br><span class="line">  Page\* page = FetchBucketPage(bucket_page_id);</span><br><span class="line">  page-&gt;RLatch();</span><br><span class="line"></span><br><span class="line">  HASH_TABLE_BUCKET_TYPE \*bucket_page = reinterpret_cast&lt;HASH_TABLE_BUCKET_TYPE\*&gt;(page-&gt;GetData());</span><br><span class="line">  bool res = bucket_page-&gt;GetValue(key,comparator_,result);</span><br><span class="line"></span><br><span class="line">  page-&gt;RUnlatch();</span><br><span class="line"></span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(directory_page_id_,false);</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(bucket_page_id,false);</span><br><span class="line"></span><br><span class="line">  table_latch_.RUnlock();</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、增(Insert)</p><p>这是基本的插入操作.基本的操作还是和之前一样,获取目录,根据目录来获取桶,如果这个桶没有满的话,那么就可以直接调用桶页的相关操作,然后Unpin,返回即可.但是万一桶是满的怎么办,请往下看.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_TYPE::Insert(Transaction \*transaction, const KeyType &amp;key, const ValueType &amp;value) &#123;</span><br><span class="line">  table_latch_.WLock();</span><br><span class="line">  HashTableDirectoryPage\* dir_page = FetchDirectoryPage();</span><br><span class="line">  page_id_t bucket_page_id = KeyToPageId(key,dir_page);</span><br><span class="line">  Page\* page = FetchBucketPage(bucket_page_id);</span><br><span class="line"></span><br><span class="line">  page-&gt;WLatch();</span><br><span class="line"></span><br><span class="line">  HASH_TABLE_BUCKET_TYPE\* bucket_page = reinterpret_cast&lt;HASH_TABLE_BUCKET_TYPE\*&gt;(page-&gt;GetData());</span><br><span class="line"></span><br><span class="line">  bool flag = bucket_page-&gt;IsFull();</span><br><span class="line">  if(!flag)&#123;</span><br><span class="line">    bool ret = bucket_page-&gt;Insert(key,value,comparator_);</span><br><span class="line">    page-&gt;WUnlatch();</span><br><span class="line"></span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(bucket_page_id,true);</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(dir_page-&gt;GetPageId(),false);</span><br><span class="line"></span><br><span class="line">    table_latch_.WUnlock();</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;WUnlatch();</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(bucket_page_id,false);</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(dir_page-&gt;GetPageId(),false);</span><br><span class="line"></span><br><span class="line">  table_latch_.WUnlock();</span><br><span class="line">  return SplitInsert(transaction,key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、可扩展的增(Insert)</p><p>对于一个比较大而且满的页,一个比较直观的想法就是分裂成两个页,这两个页都可以继续执行插入操作.这个操作比较复杂,在这里我就只用分步的形式来进行描述.</p><ul><li>跟前几个函数一样,首先获取要分裂的页.(这个页就是key对应的上一层的目录页)</li><li>如果这个页的深度已经到达了最大深度,那么就不能再分裂下去,返回false.</li><li>如果这个页和全局深度一样,就增加一下全局深度.</li><li>然后获取这个桶里面的所有元素以及元素的数量.</li><li>然后构造(申请一个新的)镜像页,把镜像页的基本信息写入到目录页里面,比如说页的局部深度以及ID等等.</li></ul><p>4、删(Remove)</p><p>删除一个键值对.</p><p>首先还是基础操作,获取桶页,然后调用remove函数就可以了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span><br><span class="line">bool HASH_TABLE_TYPE::Remove(Transaction \*transaction, const KeyType &amp;key, const ValueType &amp;value) &#123;</span><br><span class="line">  table_latch_.RLock();</span><br><span class="line"></span><br><span class="line">  HashTableDirectoryPage\* dir_page = FetchDirectoryPage();</span><br><span class="line">  uint32_t bucket_page_id = KeyToPageId(key,dir_page);</span><br><span class="line">  Page\* page = FetchBucketPage(bucket_page_id);</span><br><span class="line">  page-&gt;WLatch();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE\* bucket_page = reinterpret_cast&lt;HASH_TABLE_BUCKET_TYPE\*&gt;(page-&gt;GetData())  ;</span><br><span class="line"></span><br><span class="line">  bool ret = bucket_page-&gt;Remove(key,value,comparator_);</span><br><span class="line"></span><br><span class="line">  page-&gt;WUnlatch();</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(dir_page-&gt;GetPageId(),false);</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(bucket_page_id,true); </span><br><span class="line">  table_latch_.RUnlock();</span><br><span class="line"></span><br><span class="line">  if(bucket_page-&gt;IsEmpty())&#123;</span><br><span class="line">    Merge(transaction,key,value);</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、合并(Merge)</p><p>删除了一个元组之后有可能产生空页,空页是没有意义的,要把空页和相对应的页做一个merge操作,合并在一起.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab1-Buffer-Pool&quot;&gt;&lt;a href=&quot;#Lab1-Buffer-Pool&quot; class=&quot;headerlink&quot; title=&quot;Lab1.Buffer Pool&quot;&gt;&lt;/a&gt;Lab1.Buffer Pool&lt;/h1&gt;&lt;p&gt;这是CMU数据库系列的第一个</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Stanford CS144 Lab</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/</id>
    <published>2023-02-06T02:50:55.000Z</published>
    <updated>2024-12-03T06:26:25.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab0-Warm-Up"><a href="#Lab0-Warm-Up" class="headerlink" title="Lab0.Warm Up"></a>Lab0.Warm Up</h1><h2 id="1-Networking-by-hand"><a href="#1-Networking-by-hand" class="headerlink" title="1 Networking by hand"></a>1 Networking by hand</h2><p>这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.</p><blockquote><p>Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequence of bytes into the terminal, and the same sequence of bytes will eventually be delivered, in the same order, to a program running on another computer (a server). The server responds with its own sequence of bytes, delivered back to your terminal.</p></blockquote><p>在实验资料中给出的是这么一段话,这句话的意思就是所有的应用层协议都是由底层支撑的,这个底层可以理解成可靠的二进制比特流的传输,一方应用程序会产生比特流投入到传输通道中,另一方的应用程序会从传输通道中获取到比特流信息.这个传输通道就是Socket,套接字.</p><h2 id="2-自制Socket"><a href="#2-自制Socket" class="headerlink" title="2 自制Socket"></a>2 自制Socket</h2><blockquote><p>This feature is known as a stream socket. To your program and to the Web server, the socket looks like an ordinary file descriptor (similar to a file on disk, or to the stdin or stdout I&#x2F;O streams). When two stream sockets are connected, any bytes written to one socket will eventually come out in the same order from the other socket on the other computer.</p></blockquote><p>Socket在Linux操作系统中本质上就是一个文件,一旦两个Socket相互连接,应用程序会往一个Socket递交数据,另外一个Socket就会原封不动地把数据传递过来.连接的方式在运输层有讲,客户端的一个网络端口创建一个Socket,往服务器的一个网络端口发送请求,这是第一次握手,接着服务器的网络端口传输ACK给客户端,这是第二次握手,接着客户端会传输一个最后的请求,这个叫三次握手.三次握手后,连接就完成了,这个时候两个Socket(可以理解成网络端口?)相互链接了.</p><p>需要注意的是,在应用层我们一般是注重逻辑通信,Socket是一个逻辑概念,应用程序把数据投给一个叫做Socket的东西,你可以理解成逻辑通信的一端,但是具体Socket往下是怎么做的不是应用程序需要关注的.</p><p>这个实验就需要我们模拟一个Socket应用,与一个服务器的端口建立连接.然后获取网页.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_URL</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;host, <span class="type">const</span> <span class="built_in">string</span> &amp;path)</span> &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to rearequestd() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line">    <span class="comment">// create a TCPSocket</span></span><br><span class="line">    TCPSocket client_socket;</span><br><span class="line">    <span class="comment">// connect with host. host is a parameter.</span></span><br><span class="line">    client_socket.connect(Address(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    <span class="comment">// send a request Message. the request is made of 2 sentences.</span></span><br><span class="line">    <span class="built_in">string</span> request = <span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\n&quot;</span>+<span class="string">&quot;Host: &quot;</span>+host+<span class="string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    client_socket.write(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the Message</span></span><br><span class="line">    <span class="keyword">while</span>(!client_socket.eof())&#123;</span><br><span class="line">        <span class="built_in">string</span> reply = client_socket.read();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;reply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候先创建一个TCPSocket,首先先进行连接,然后像之前一样创建request,接着这个Socket就可以把request写进去.然后服务器会返回数据,这个数据是读取到Socket的,读数据一直读到EOF即可.</p><p>由于这个实验是面向初学者的,具体Socket怎么读怎么写我们没有考虑,我们只用调用教授已经写好的写,读操作.</p><h2 id="3-缓冲区队列"><a href="#3-缓冲区队列" class="headerlink" title="3 缓冲区队列"></a>3 缓冲区队列</h2><p>要求实现一个有序字节流类（in-order byte stream），使之支持读写、容量控制。这个字节流类似于一个带容量的队列，从一头读，从另一头写。当流中的数据达到容量上限时，便无法再写入新的数据。特别的，写操作被分为了peek和pop两步。peek为从头部开始读取指定数量的字节，pop为弹出指定数量的字节。</p><p>总的来说就是做一个桶,可以从下方获得内容,也可以从上方添加内容,当桶满的时候就不可以添加东西了</p><p>ByteStream具有一定的容量，最大允许存储该容量大小的数据；在读取端读出一部分数据后，它会释放掉已经被读出的内容，以腾出空间继续让写端写入数据。  </p><p>这个实验为我们后期实现TCP协议有着帮助.</p><p>上面的是缓冲区队列的一些声明,对于读写两方,操作是不同的.</p><p>有个小提示,如果C++的构造函数可以使用像这样的方法进行初始化的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class baba (const int abab) _abab(abab)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个本质上就是数据结构题,完成缓冲区队列罢了.</p><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png"></p><h1 id="Lab1-stitching-substrings-into-a-byte-stream"><a href="#Lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Lab1.stitching substrings into a byte stream"></a>Lab1.stitching substrings into a byte stream</h1><p>该lab要求我们实现一个流重组类，可以将Sender发来的带索引号的字节碎片重组成有序的字节写入到byte_stream。接收端从发送端读取数据，调用流重组器，流重组器对数据进行排序，排序好后写入byte_stream。</p><p>流重组器也是有capasity的,也就是说流重组器也有一定的容量,一次性处理太多的信息会导致流重组器不能够正常地工作.同样的我们把流处理器当成一个双端队列即可.</p><p>private类中还有一个ByteStream类型的变量,所有的内容都输出给ByteStream,还有一个容量变量.其中ByteStream中的bytes_read返回ByteStream处理了多少元素.</p><p>因为重组类的函数中,支持的index是first unread&#x3D;_output.bytes_read()(已经读取的元素)到first unacceptable的这一块区域,我们要保证输入的字节编号是在这个区域里面的.</p><p>在重组器类的函数中，push_substring函数完成重组工作。其参数有data(string),index(size_t),eof(bool),data是待排序的数据，index是数据首元素的序号，eof用于判断是否结束。结束后将不再有数据输入。</p><p>在重组的过程中，我们会遇到重复、丢包、重叠、乱序的现象。为了使乱序的数据找到有序的位置，我使用’\0’维护重组器中数据的相对序号，例如，第一次data为make,index为0,第二次data为great,index为13,而处于两组数据中间的数据未知，我们就用’\0’代替，即make\0\0\0\0\0\0\0\0\0great。这样就维护了已经进入重组器的数据的有序。当然，写入的data中也有可能含有\0,这是，我们就需要一个bool双端队列，来记录相应位置的数据是否有序，在上述例子中，队列的bool值为111100000000011111。</p><p>所以说我们在数据结构中添加几项,一个是_unassembled_byte,是一个<a href="std::deque">std::deque</a><char>,暂时存储还乱序的字符串,_check_byte是<a href="std::deque">std::deque</a><bool>,这个元素与_unassembled_byte一一对应,当un[i]存储着还没有发送的字符的时候,ch[I]&#x3D;true,否则为false,还有一个_lens_un,这个记录乱序的字符的长度.</p><p>程序的总体结构:</p><p>发送端的数据-&gt;流重组器(重组成有序的数据)-&gt;Bytestream(在Lab0就做好的队列)-&gt;TCP接收端.<br>流重组器需要做的是,把所有有序的数据写入到接收端.<br>其中字符的编号是从1一直往后延伸的,因为队列的首和尾都可以记录.TCP的发送端发送的数据也是(字符号、字符串)字符的编号一直往后延伸.</p><p>这个时候我们回忆一下对应数据的表示:</p><p><code>output.bytes_read()</code>:接收端从ByteStream获得的字符数量.</p><p><code>output.bytes_write()</code>:流重组器写入ByteStream的字符数量-1.而且是流重组器的有效数据中index最小的序号</p><p><code>_lens_un</code>指的还在流重组器里面的数据的长度.</p><p>其中:<code>output.bytes_read()+_capacity</code>是ByteStream可以接受的范围,<code>output.bytes_write()+_lens_un</code>是流重组器的有效数据中index最大的序号.</p><p>1.我们判断输入序号是否大于内存与已读取数据之和，也就是说，该数据是否属于unacceptable中的数据，如果是这样的数据，我们没有足够的内存写入，因为写入这样的数据需要添加\0，从而超过capasity的大小。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(index&gt;_output.bytes_read()+_capacity)&#123;  </span><br><span class="line">return;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.字符串部分在区域内,但是部分在区域外,那就把区域外的内容舍弃,只读取区域内的内容.</p><p>我们需要判断data中最后一个数据的序号是否大于内存与已读取数据之和，如果大于，我们就要将能写入的部分写入，也就是按data的顺序尽可能地写入数据而不超过capasity,在写入的过程中，我们也会遇到两种情况，<strong>一种是序号index大于此时已经在流重组器的最后一个数据的序号</strong>，在这种情况下我们要在流重组器最后一个序号与index之间填入’\0′,同时将相应的bool双端队列(_check_byte)设置为false，做完这些工作后，才开始写入新的数据。<strong>另一种情况是index的小于或者等于流重组器最后一个数据的序号，我们需要弹出冲突的数据</strong>，举个例子就是，index序号为5,此时流重组器中的数据为stanford,我们就要从序号5的数据也就是o开始弹出，变成stanf,再写入data中的数据。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(index+data.length()&gt;_capacity+_output.bytes_read())&#123;</span><br><span class="line">    for(size_t i=_lens_un+_output.bytes_written();i&lt;_capacity+_output.bytes_read();i++)&#123;</span><br><span class="line">        if(i&lt;index)&#123;</span><br><span class="line">            _unassembled_byte.push_back(&#x27;\\0&#x27;);</span><br><span class="line">            _check_byte.push_back(false);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            _unassembled_byte.push_back(data[i-index]);</span><br><span class="line">            _check_byte.push_back(true);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _lens_un++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们要判断index是否等于已经写入byte_stream(_output)中的数据，如果是的，我们就直接将data中的数据写入byte_stream,然后在重组器中弹出data.length()个数据，值得注意的是，当重组器中的数据个数小于data.length()，我们就全部弹出。但是后面的数据会被当成无效数据而不进行处理,代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(index==_output.bytes_written())&#123;</span><br><span class="line">//直接写</span><br><span class="line">    _output.write(data);</span><br><span class="line">    size_t temp_len=std::min(_lens_un,data.length());</span><br><span class="line">    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">    _lens_un-=temp_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.我们要判断index是否大于流重组器中的最后一个数据的序号和写入byte_stream中的数据个数之和，如果大于，我们就可以参考1的处理，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(index&gt;_output.bytes_written()+_lens_un)&#123;</span><br><span class="line">    for(size_t i=_output.bytes_written()+_lens_un;i&lt;index;i++)&#123;</span><br><span class="line">        _unassembled_byte.push_back(&#x27;\\0&#x27;);</span><br><span class="line">        _check_byte.push_back(false);</span><br><span class="line">        _lens_un++;</span><br><span class="line">    &#125;</span><br><span class="line">[原来的data][空][新的data]</span><br><span class="line">    for(char i : data)&#123;</span><br><span class="line">        _unassembled_byte.push_back(i);</span><br><span class="line">        _lens_un++;</span><br><span class="line">        _check_byte.push_back(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.我们要判断data中的数据是否已经被写入byte_stream，这个说法有些不准确，准确的说是相应序号的数据被写入，如果data中的所有数据都被写入了byte_stream，我们就直接返回，如果只是部分被写入，我们就将data中未被写入的部分写入。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(index&lt;_output.bytes_written())&#123;</span><br><span class="line">    if(_output.bytes_written()&gt;index+data.length())&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">//[已经写入Byte_stream的][bytes_written()][新传来的data在bytes_written()之后的,入队][原来在_output.bytes_written()+_lens_un之后的data]</span><br><span class="line">//还是要写,一直写到data最后.</span><br><span class="line">    std::string data_cut(data.begin()+_output.bytes_written()-index,data.end());</span><br><span class="line">    _output.write(data_cut);</span><br><span class="line">    size_t temp_len=std::min(_lens_un,data_cut.length());</span><br><span class="line">    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">    _lens_un-=temp_len;</span><br></pre></td></tr></table></figure><p>6.不是任何情况:首先我们知道要把_output.bytes_written()~index这一部分的内容保存好,然后再把data加入进去即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//在中间插入元素</span><br><span class="line">//先弹出一部分数据保存到栈中</span><br><span class="line">std::stack&lt;char&gt; temp;</span><br><span class="line">std::stack&lt;bool&gt; temp_check;</span><br><span class="line">for(size_t i=0;i&lt;index-_output.bytes_written();i++)&#123;</span><br><span class="line">    temp.push(_unassembled_byte.at(i));</span><br><span class="line">    temp_check.push(_check_byte.at(i));</span><br><span class="line">&#125;</span><br><span class="line">[原data,入队][index][新传来的data,入队][原来在_output.bytes_written()+_lens_un之后的data]</span><br><span class="line">//这里是看数据的最后一个index有没有达到_output.bytes_written()+_lens_un,达到的话后面的内容要保留,没达到就全部删除即可</span><br><span class="line">size_t temp_len=std::min(_lens_un,data.length()+index-_output.bytes_written());</span><br><span class="line">_unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">_check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">_lens_un-=temp_len;</span><br><span class="line">for(int i=data.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">    _unassembled_byte.push_front(data[i]);</span><br><span class="line">    _check_byte.push_front(true);</span><br><span class="line">    _lens_un++;</span><br><span class="line">&#125;</span><br><span class="line">while(!temp.empty())&#123;</span><br><span class="line">    _unassembled_byte.push_front(temp.top());</span><br><span class="line">    _check_byte.push_front(temp_check.top());</span><br><span class="line">    _lens_un++;</span><br><span class="line">    temp.pop();</span><br><span class="line">    temp_check.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.输入字符串到ByteStream中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t i=0;</span><br><span class="line">while(i&lt;_lens_un)&#123;</span><br><span class="line">    if(!_check_byte.at(i))&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">std::string n(_unassembled_byte.begin(),_unassembled_byte.begin()+i);</span><br><span class="line">_output.write(n);</span><br><span class="line">_unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+i);</span><br><span class="line">_lens_un-=i;</span><br><span class="line">_check_byte.erase(_check_byte.begin(),_check_byte.begin()+i);</span><br><span class="line">if(eof) input_end_index=index+data.length();</span><br><span class="line">if(input_end_index==_output.bytes_written()) _output.end_input();</span><br></pre></td></tr></table></figure><h1 id="Lab2-TCP-Reciever"><a href="#Lab2-TCP-Reciever" class="headerlink" title="Lab2.TCP Reciever"></a>Lab2.TCP Reciever</h1><h2 id="绝对序号和相对序号的转换"><a href="#绝对序号和相对序号的转换" class="headerlink" title="绝对序号和相对序号的转换:"></a>绝对序号和相对序号的转换:</h2><p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k,则该序号范围是。 在一个有限的序号范围内，所有涉及序号的运算必须使用模运算。（即序号空间可被看作是一个长度为 的环，其中序号紧挨着0）。上面论述的序号是相对序号(相对序号的开始值是),还有一种不模的运算就是绝对序号.</p><p>这个时候我们需要完成两个函数:</p><p>1.wrap(绝对序号转化为相对序号)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) &#123;</span><br><span class="line">  DUMMY_CODE(n, isn);</span><br><span class="line">  WrappingInt32 res(n+isn.raw_value());</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用了<code>WrappingInt32</code>类的构造函数,构造函数获得一个int类型的数(uint_64等类型)然后取模之后获得32位的整形数,存放到raw_value成员中.</p><p>2.unwrap(相对序号转绝对序号)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) &#123;</span><br><span class="line">    DUMMY_CODE(n, isn, checkpoint);</span><br><span class="line">    uint64_t temp=n.raw_value()-isn.raw_value();</span><br><span class="line">    if(checkpoint==0)&#123;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t div=checkpoint/(1ul&lt;&lt;32);</span><br><span class="line">    uint32_t res=checkpoint%(1ul&lt;&lt;32);</span><br><span class="line">    if (res&lt;=temp) &#123;</span><br><span class="line">        temp=(checkpoint-temp-(div-1)\*(1ul&lt;&lt;32))&lt;(temp+div\*(1ul&lt;&lt;32)-checkpoint)?temp+(div-1)\*(1ul&lt;&lt;32):temp+div\*(1ul&lt;&lt;32);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        temp=(checkpoint-temp-div\*(1ul&lt;&lt;32))&lt;(temp+(div+1)\*(1ul&lt;&lt;32)-checkpoint)?temp+div\*(1ul&lt;&lt;32):temp+(div+1)\*(1ul&lt;&lt;32);</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定checkpoint,找到最靠近checkpoint的那个temp,返回即可.</p><h2 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h2><p>首先我们看一看TCP报文包的定义:主要是由首部和其中的元素组成:其中可以调用serialize和parse方法转化,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class TCPSegment &#123;</span><br><span class="line">  private:</span><br><span class="line">    TCPHeader _header&#123;&#125;;</span><br><span class="line">    Buffer _payload&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    //! \\brief Parse the segment from a string</span><br><span class="line">    ParseResult parse(const Buffer buffer, const uint32_t datagram_layer_checksum = 0);</span><br><span class="line"></span><br><span class="line">    //! \\brief Serialize the segment to a string</span><br><span class="line">    BufferList serialize(const uint32_t datagram_layer_checksum = 0) const;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors</span><br><span class="line">    //!@&#123;</span><br><span class="line">    const TCPHeader &amp;header() const &#123; return _header; &#125;</span><br><span class="line">    TCPHeader &amp;header() &#123; return _header; &#125;</span><br><span class="line"></span><br><span class="line">    const Buffer &amp;payload() const &#123; return _payload; &#125;</span><br><span class="line">    Buffer &amp;payload() &#123; return _payload; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief Segment&#x27;s length in sequence space</span><br><span class="line">    //! \\note Equal to payload length plus one byte if SYN is set, plus one byte if FIN is set</span><br><span class="line">    size_t length_in_sequence_space() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们来看一看TCP首部:首部的元素主要是:</p><ul><li>序号：seqno，占32位，用来标识从发送端到接收端的字节流；</li><li>确认号：ackno，占32位，只有ACK标志位为1时，确认号才有效，ackno&#x3D;seqno+1；</li><li>标志位：<ul><li>SYN：发起一个连接；</li><li>FIN：释放一个连接；</li><li>ACK：确认序号有效。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct TCPHeader &#123;</span><br><span class="line">    static constexpr size_t LENGTH = 20;  //!&lt; [TCP](\\ref rfc::rfc793) header length, not including options</span><br><span class="line"></span><br><span class="line">    //! \\struct TCPHeader</span><br><span class="line">    //! ~~~&#123;.txt&#125;</span><br><span class="line">    //!   0                   1                   2                   3</span><br><span class="line">    //!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!            Source Port                 Destination Port        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                          Sequence Number                        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                      Acknowledgment Number                      </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!    Data            UAPRSF                               </span><br><span class="line">    //!   Offset Reserved  RCSSYI            Window             </span><br><span class="line">    //!                    GKHTNN                               </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!             Checksum                     Urgent Pointer        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                      Options                        Padding    </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                               data                              </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //! ~~~</span><br><span class="line"></span><br><span class="line">    //! \\name TCP Header fields</span><br><span class="line">    //!@&#123;</span><br><span class="line">    uint16_t sport = 0;         //!&lt; source port</span><br><span class="line">    uint16_t dport = 0;         //!&lt; destination port</span><br><span class="line">    WrappingInt32 seqno&#123;0&#125;;     //!&lt; sequence number</span><br><span class="line">    WrappingInt32 ackno&#123;0&#125;;     //!&lt; ack number</span><br><span class="line">  uint8_t doff = LENGTH / 4;  //!&lt; data offset</span><br><span class="line">    bool urg = false;           //!&lt; urgent flag</span><br><span class="line">    bool ack = false;           //!&lt; ack flag</span><br><span class="line">    bool psh = false;           //!&lt; push flag</span><br><span class="line">    bool rst = false;           //!&lt; rst flag</span><br><span class="line">    bool syn = false;           //!&lt; syn flag</span><br><span class="line">    bool fin = false;           //!&lt; fin flag</span><br><span class="line">    uint16_t win = 0;           //!&lt; window size</span><br><span class="line">    uint16_t cksum = 0;         //!&lt; checksum</span><br><span class="line">    uint16_t uptr = 0;          //!&lt; urgent pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>接着看一看TCP receiver的数据结构定义:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><span class="line">#define SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><span class="line"></span><br><span class="line">#include &quot;byte_stream.hh&quot;</span><br><span class="line">#include &quot;stream_reassembler.hh&quot;</span><br><span class="line">#include &quot;tcp_segment.hh&quot;</span><br><span class="line">#include &quot;wrapping_integers.hh&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;optional&gt;</span><br><span class="line"></span><br><span class="line">//! \\brief The &quot;receiver&quot; part of a TCP implementation.</span><br><span class="line"></span><br><span class="line">//! Receives and reassembles segments into a ByteStream, and computes</span><br><span class="line">//! the acknowledgment number and window size to advertise back to the</span><br><span class="line">//! remote TCPSender.</span><br><span class="line">//接收重组segments为 ByteStream，并计算确认号和窗口大小以通告回远程 TCPSender。</span><br><span class="line">class TCPReceiver &#123;</span><br><span class="line">    //! Our data structure for re-assembling bytes.</span><br><span class="line">    //我们用于重新组装字节的数据结构。</span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    //! The maximum number of bytes we&#x27;ll store.</span><br><span class="line">    //容量大小</span><br><span class="line">    size_t _capacity;</span><br><span class="line">    WrappingInt32 ISN;</span><br><span class="line">    bool syn_flag;</span><br><span class="line">  public:</span><br><span class="line"></span><br><span class="line">    //! \\brief Construct a TCP receiver</span><br><span class="line">    //!</span><br><span class="line">    //! \\param capacity the maximum number of bytes that the receiver will</span><br><span class="line">    //!                 store in its buffers at any give time.</span><br><span class="line">    //构造函数，构造一个 TCP 接收器，容量接收器在任何给定时间将存储在其缓冲区中的最大字节数。</span><br><span class="line">    TCPReceiver(const size_t capacity) : _reassembler(capacity), _capacity(capacity),ISN(0) ,syn_flag(0)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors to provide feedback to the remote TCPSender</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief The ackno that should be sent to the peer</span><br><span class="line">    //! \\returns empty if no SYN has been received</span><br><span class="line">    //!</span><br><span class="line">    //! This is the beginning of the receiver&#x27;s window, or in other words, the sequence number</span><br><span class="line">    //! of the first byte in the stream that the receiver hasn&#x27;t received.</span><br><span class="line">    // 如果没有收到 SYN，则应发送给对等方的 ackno 为空</span><br><span class="line">    //这是接收器窗口的开始，否则，接收器未接收到的流中第一个字节的序列号。</span><br><span class="line">    std::optional&lt;WrappingInt32&gt; ackno() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief The window size that should be sent to the peer</span><br><span class="line">    //!</span><br><span class="line">    //! Operationally: the capacity minus the number of bytes that the</span><br><span class="line">    //! TCPReceiver is holding in its byte stream (those that have been</span><br><span class="line">    //! reassembled, but not consumed).</span><br><span class="line">    //!</span><br><span class="line">    //! Formally: the difference between (a) the sequence number of</span><br><span class="line">    //! the first byte that falls after the window (and will not be</span><br><span class="line">    //! accepted by the receiver) and (b) the sequence number of the</span><br><span class="line">    //! beginning of the window (the ackno).</span><br><span class="line">    size_t window_size() const;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief number of bytes stored but not yet reassembled</span><br><span class="line">    size_t unassembled_bytes() const &#123; return _reassembler.unassembled_bytes(); &#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief handle an inbound segment</span><br><span class="line">    void segment_received(const TCPSegment &amp;seg);</span><br><span class="line"></span><br><span class="line">    //! \\name &quot;Output&quot; interface for the reader</span><br><span class="line">    //!@&#123;</span><br><span class="line">    ByteStream &amp;stream_out() &#123; return _reassembler.stream_out(); &#125;</span><br><span class="line">    const ByteStream &amp;stream_out() const &#123; return _reassembler.stream_out(); &#125;</span><br><span class="line">    bool recv_fin() const;</span><br><span class="line">    //!@&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>我们知道TCP需要接受一个叫做segment类型的数据,然后存储起来,送入到Lab1已经实现好的reassemble_stream中.并返回适合的ACK.</li></ul></li></ul><p>对于接受的数据:分成两种可能,一种是第一个序列,另外的就是普通的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void TCPReceiver::segment_received(const TCPSegment &amp;seg) &#123;</span><br><span class="line">    DUMMY_CODE(seg);</span><br><span class="line">    //代表第一个传过来的seg</span><br><span class="line">    if(seg.header().syn)&#123;</span><br><span class="line">        syn_flag= true;</span><br><span class="line">        //窗口的左端</span><br><span class="line">        ISN=seg.header().seqno;</span><br><span class="line">    &#125; else if(!syn_flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  //推断数据包的序号,序号比较靠近上一个已经接收到的序号,然后塞进我们在Lab1已经写好的流重组器.</span><br><span class="line">    uint64_t received_lens=_reassembler.stream_out().bytes_written();</span><br><span class="line">    size_t index= unwrap(seg.header().seqno,ISN,received_lens);</span><br><span class="line">    if(!seg.header().syn)&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    //进行重组</span><br><span class="line">    _reassembler.push_substring(seg.payload().copy(),index,seg.header().fin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ACK的返回也很简单,流重组器输入到Byte stream的个数就代表已经输入了多少个有序的序列,返回对应的ACK即可.但是对于结束的时候的ACK回应,我们还是需要分类讨论.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;WrappingInt32&gt; TCPReceiver::ackno() const &#123;</span><br><span class="line">    if(!syn_flag)&#123;</span><br><span class="line">        return std::nullopt;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //判断是否是最后一个</span><br><span class="line">        if(_reassembler.stream_out().input_ended())&#123;</span><br><span class="line">            return ISN+_reassembler.stream_out().bytes_written()+2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          //返回的ACK的序号就是期望获得的下一个字符的数+1,流重组器的已连续写入的数据量就是最后一个有序的 //字符</span><br><span class="line">            return ISN+_reassembler.stream_out().bytes_written()+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lab3-TCP-Sender"><a href="#Lab3-TCP-Sender" class="headerlink" title="Lab3 TCP Sender"></a>Lab3 TCP Sender</h1><p>这一次我们要实现TCP的发送方,这一次我把必要的注释写在代码里面了.</p><p>1.头文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class TCPSender &#123;</span><br><span class="line">  private:</span><br><span class="line">    //! our initial sequence number, the number for our SYN.</span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line">    uint64_t base&#123;0&#125;;</span><br><span class="line">    //! outbound queue of segments that the TCPSender wants sent</span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line">    //cached TCPSegment.</span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out_cached&#123;&#125;;</span><br><span class="line">    //! retransmission timer for the connection</span><br><span class="line">    unsigned int _initial_retransmission_timeout;</span><br><span class="line"></span><br><span class="line">    //! outgoing stream of bytes that have not yet been sent</span><br><span class="line">    ByteStream _stream;</span><br><span class="line">    //nextseq numbers as the absolute TCP number.</span><br><span class="line">    uint64_t _next_seqnum&#123;0&#125;;</span><br><span class="line">    //slide windows size</span><br><span class="line">    uint16_t _curr_window_size;</span><br><span class="line">    //isfinished?</span><br><span class="line">    bool _isfin;</span><br><span class="line">    size_t _times;</span><br><span class="line">    //ticking?</span><br><span class="line">    bool _time_waiting;</span><br><span class="line">    //remission times.</span><br><span class="line">    int _consecutive_remission;</span><br><span class="line">    // when is time out?</span><br><span class="line">    size_t _time_out;</span><br><span class="line">    //empty windows?</span><br><span class="line">    bool _window_zero;</span><br><span class="line">    //! the (absolute) sequence number for the next byte to be sent</span><br><span class="line">    uint64_t _next_seqno&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    //! Initialize a TCPSender</span><br><span class="line">    TCPSender(const size_t capacity = TCPConfig::DEFAULT_CAPACITY,</span><br><span class="line">              const uint16_t retx_timeout = TCPConfig::TIMEOUT_DFLT,</span><br><span class="line">              const std::optional&lt;WrappingInt32&gt; fixed_isn = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    //! \\name &quot;Input&quot; interface for the writer</span><br><span class="line">    //!@&#123;</span><br><span class="line">    ByteStream &amp;stream_in() &#123; return _stream; &#125;</span><br><span class="line">    const ByteStream &amp;stream_in() const &#123; return _stream; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Methods that can cause the TCPSender to send a segment</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief A new acknowledgment was received</span><br><span class="line">    void ack_received(const WrappingInt32 ackno, const uint16_t window_size);</span><br><span class="line"></span><br><span class="line">    //! \\brief Generate an empty-payload segment (useful for creating empty ACK segments)</span><br><span class="line">    void send_empty_segment();</span><br><span class="line"></span><br><span class="line">    //! \\brief create and send segments to fill as much of the window as possible</span><br><span class="line">    void fill_window();</span><br><span class="line"></span><br><span class="line">    //! \\brief Notifies the TCPSender of the passage of time</span><br><span class="line">    void tick(const size_t ms_since_last_tick);</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief How many sequence numbers are occupied by segments sent but not yet acknowledged?</span><br><span class="line">    //! \\note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte</span><br><span class="line">    //! (see TCPSegment::length_in_sequence_space())</span><br><span class="line">    size_t bytes_in_flight() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief Number of consecutive retransmissions that have occurred in a row</span><br><span class="line">    unsigned int consecutive_retransmissions() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief TCPSegments that the TCPSender has enqueued for transmission.</span><br><span class="line">    //! \\note These must be dequeued and sent by the TCPConnection,</span><br><span class="line">    //! which will need to fill in the fields that are set by the TCPReceiver</span><br><span class="line">    //! (ackno and window size) before sending.</span><br><span class="line">    std::queue&lt;TCPSegment&gt; &amp;segments_out() &#123; return _segments_out; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name What is the next sequence number? (used for testing)</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief absolute seqno for the next byte to be sent</span><br><span class="line">    uint64_t next_seqno_absolute() const &#123; return _next_seqno; &#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief relative seqno for the next byte to be sent</span><br><span class="line">    WrappingInt32 next_seqno() const &#123; return wrap(_next_seqno, _isn); &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.发送数据函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">void TCPSender::fill_window() &#123;</span><br><span class="line">    // windows is full or the programe is finished.</span><br><span class="line">    if(_curr_window_size==0_isfin)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //haven&#x27;t send any bytes.</span><br><span class="line">    if(_next_seqno==0)&#123;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        // the TCP transmission start from _isn.</span><br><span class="line">        seg.header().seqno = _isn;</span><br><span class="line">        seg.header().syn = true;</span><br><span class="line">        // the TCP first connection just send 1 bytes;</span><br><span class="line">        _next_seqno = 1;</span><br><span class="line">        _curr_window_size--;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        _segments_out_cached.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //the end of the file</span><br><span class="line">    else if(_stream.eof())&#123;</span><br><span class="line">        //set the finish flag to true;</span><br><span class="line">        _isfin = true;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        seg.header().syn=false;</span><br><span class="line">        seg.header().fin=true;</span><br><span class="line">        //convert the absolute TCP number to TCP number.</span><br><span class="line">        seg.header().seqno = wrap(_next_seqno,_isn);</span><br><span class="line">        //the fin packet only send a byte.</span><br><span class="line">        _next_seqno++;</span><br><span class="line">        _curr_window_size--;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        _segments_out_cached.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //normal file</span><br><span class="line">    else&#123;</span><br><span class="line">        //make sure the windows is not full and there&#x27;s any data to convert.</span><br><span class="line">        while(!_stream.buffer_empty()&amp;&amp;_curr_window_size&gt;0)&#123;</span><br><span class="line">            //decide the length of the TCP Segment.</span><br><span class="line">            //make sure the length of TCP segment is below the silde windows size and data length.</span><br><span class="line">            uint64_t lens_byte=std::min(_stream.buffer_size(),uint64_t (_curr_window_size));</span><br><span class="line">            lens_byte=std::min(lens_byte,TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">            TCPSegment seg;</span><br><span class="line">            seg.header().seqno = wrap(_next_seqno,_isn);</span><br><span class="line">            seg.header().syn = false;</span><br><span class="line">            //get the lens_byte data to the payload.</span><br><span class="line">            seg.payload()=_stream.read(lens_byte);</span><br><span class="line">            // increase the next seq_no;</span><br><span class="line">            _next_seqno += lens_byte;</span><br><span class="line">            _curr_window_size -= lens_byte;</span><br><span class="line">            // get the end of the file.</span><br><span class="line">            if(_stream.eof()&amp;&amp;_curr_window_size&gt;0)&#123;</span><br><span class="line">                _isfin = true;</span><br><span class="line">                seg.header().fin=true;</span><br><span class="line">                //the fin packet only send a byte.</span><br><span class="line">                _next_seqno++;</span><br><span class="line">                _curr_window_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            _segments_out.push(seg);</span><br><span class="line">            _segments_out_cached.push(seg);</span><br><span class="line">            if(_isfin)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //start ticking...</span><br><span class="line">    if(!_time_waiting)&#123;</span><br><span class="line">        _time_out = _initial_retransmission_timeout;</span><br><span class="line">        _time_waiting = true;</span><br><span class="line">        _times = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.接受ACK:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//! \\param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="line">//! \\param window_size The remote receiver&#x27;s advertised window size</span><br><span class="line">void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) &#123; </span><br><span class="line">    DUMMY_CODE(ackno, window_size); </span><br><span class="line">    // get the absolute TCP number of ACK...</span><br><span class="line">    uint64_t acknos = unwrap(ackno,_isn,base);</span><br><span class="line">    //thrid connection...</span><br><span class="line">    //means the 0th bytes gets and desire to 1st bytes...</span><br><span class="line">    if(base==0&amp;&amp;acknos==1)&#123;</span><br><span class="line">        base=1;</span><br><span class="line">        _segments_out_cached.pop();</span><br><span class="line">        _consecutive_remission=0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(acknos &gt; _next_seqno)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //the ack number is bigger than first cached segment...</span><br><span class="line">    //means the cached data gets by the reciever...</span><br><span class="line">    else if(!_segments_out_cached.empty() &amp;&amp; acknos &gt;= base + _segments_out_cached.front().length_in_sequence_space())&#123;</span><br><span class="line">        //first segment in cache, and get the seqno and length of the segment...</span><br><span class="line">        uint64_t copy_seg_seqno = unwrap(_segments_out_cached.front().header().seqno, _isn, base);</span><br><span class="line">        uint64_t copy_seg_len = _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">        //find the segments that acked by recevier...</span><br><span class="line">        //hint:if seqno+len&lt;=ackno:means the data is acked by recevier...</span><br><span class="line">        while(copy_seg_len+copy_seg_seqno&lt;=acknos)&#123;</span><br><span class="line">            //move the base, base is the 1st bytes that nor acked...</span><br><span class="line">            base += _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">            _segments_out_cached.pop();</span><br><span class="line">            if(_segments_out_cached.empty()) break;</span><br><span class="line">            // judge the 2nd segs...</span><br><span class="line">            copy_seg_seqno = unwrap(_segments_out_cached.front().header().seqno, _isn, base);</span><br><span class="line">            copy_seg_len = _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">        &#125;</span><br><span class="line">        _time_out = _initial_retransmission_timeout;</span><br><span class="line">        _times = 0;</span><br><span class="line">        _consecutive_remission = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3rd disconnection.</span><br><span class="line">    else if(acknos == _next_seqno &amp;&amp; _isfin)&#123;</span><br><span class="line">        base = acknos;</span><br><span class="line">        _segments_out_cached.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //the windows is empty</span><br><span class="line">    if(_next_seqno-base==0)&#123;</span><br><span class="line">        _time_waiting = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 流量控制,发送方窗口不大于接受方窗口</span><br><span class="line">    else if(_next_seqno-base&gt;=window_size)&#123;</span><br><span class="line">        _curr_window_size = 0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(window_size==0)&#123;</span><br><span class="line">        _curr_window_size = 1;</span><br><span class="line">        _window_zero = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        _curr_window_size = window_size;</span><br><span class="line">        _window_zero = false;</span><br><span class="line">        _consecutive_remission = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    fill_window();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4. 构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] capacity the capacity of the outgoing byte stream</span><br><span class="line">//! \\param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span><br><span class="line">//! \\param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span><br><span class="line">TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.value_or(WrappingInt32&#123;random_device()()&#125;))</span><br><span class="line">    , base(0)</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity)</span><br><span class="line">    , _curr_window_size(1)</span><br><span class="line">    , _isfin(false)</span><br><span class="line">    , _times(0)</span><br><span class="line">    , _time_waiting(false)</span><br><span class="line">    , _consecutive_remission(0)</span><br><span class="line">    , _time_out(0)</span><br><span class="line">    , _window_zero(false)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5.超时处理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="line">void TCPSender::tick(const size_t ms_since_last_tick) &#123; </span><br><span class="line">    DUMMY_CODE(ms_since_last_tick);</span><br><span class="line">    // the times pased by</span><br><span class="line">    _times += ms_since_last_tick;</span><br><span class="line">    //timeout and non-empty cache. resend...</span><br><span class="line">    if(!_segments_out_cached.empty()&amp;&amp;_time_waiting&amp;&amp;_times&gt;=_time_out)&#123;</span><br><span class="line">        //resend..</span><br><span class="line">        _segments_out.push(_segments_out_cached.front());</span><br><span class="line">        // increase the time out times...</span><br><span class="line">        if(!_window_zero)&#123;</span><br><span class="line">            //add remissions</span><br><span class="line">            _consecutive_remission++;</span><br><span class="line">            _time_out\*=2;</span><br><span class="line">            _time_waiting = true;</span><br><span class="line">        &#125;</span><br><span class="line">        _times=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lab4-TCP-Connnection"><a href="#Lab4-TCP-Connnection" class="headerlink" title="Lab4 TCP Connnection"></a>Lab4 TCP Connnection</h1><p>在这里我们需要实现一个TCP连接类,在这个TCP连接类里面,我们需要组合之前已经写好的TCP发送端和接收端的函数来进行处理.</p><p>1、接受到segment的操作:</p><p>分成两种操作,一种是正常的交互,一种是握手的操作.握手又分成主动请求链接和被动链接,在这两种模式下接受握手信息的处理是不一样的.对于正常的交互,需要交付给Sender和Reciever.因为对于TCP来说,两者是相互统一的.两个主机之间也会互相传递信息,所以说交给发送端处理ACK,交给接收端返回给上层.实际的TCP协议并不是完全的类似于GBN和SR,具体的差异就在ACK的数据是相互传递的,换句话说就是连着兼有.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void TCPConnection::segment_received(const TCPSegment &amp;seg) &#123; </span><br><span class="line">    DUMMY_CODE(seg); </span><br><span class="line">    // get the segment from IP level;</span><br><span class="line">    if(!_active)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _time_since_last_segment_received=0;</span><br><span class="line">    //not get segment no send ACK.</span><br><span class="line">    //passive connection...</span><br><span class="line">    //the ackno is null and no bytes is sent</span><br><span class="line">    if(!_receiver.ackno().has_value()&amp;&amp;_sender.next_seqno_absolute()==0)&#123;</span><br><span class="line">        //only recieve syn...</span><br><span class="line">        if(!seg.header().syn) return;</span><br><span class="line">        //as the Service side,passive connected.</span><br><span class="line">        _receiver.segment_received(seg);</span><br><span class="line">        //it&#x27;s OK to connect.</span><br><span class="line">        connect();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // active connected..</span><br><span class="line">    // first connection...</span><br><span class="line">    if(_sender.next_seqno_absolute() &gt; 0 &amp;&amp; _sender.bytes_in_flight() == _sender.next_seqno_absolute() &amp;&amp; </span><br><span class="line">       !_receiver.ackno().has_value())&#123;</span><br><span class="line">        // the length of payload is not 0</span><br><span class="line">        if(seg.payload().size() )&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // if ack is no</span><br><span class="line">        // the twoside wants to setup the connection at the same time.</span><br><span class="line">        if(!seg.header().ack)&#123;</span><br><span class="line">            if(seg.header().syn)&#123;</span><br><span class="line">                _receiver.segment_received(seg);</span><br><span class="line">                // send empty ack to setup the connection.</span><br><span class="line">                _sender.send_empty_segment();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // ifsyn=1,ack=1,rst=1,then shut down.</span><br><span class="line">        if(seg.header().rst)&#123;</span><br><span class="line">            _receiver.stream_out().set_error();</span><br><span class="line">            _sender.stream_in().set_error();</span><br><span class="line">            _active = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //otherwise...</span><br><span class="line">    //recieve the segment</span><br><span class="line">    _receiver.segment_received(seg);</span><br><span class="line">    _sender.ack_received(seg.header().ackno,seg.header().win);</span><br><span class="line">    // thrid connection</span><br><span class="line">    if (_sender.stream_in().buffer_empty() &amp;&amp; seg.length_in_sequence_space())</span><br><span class="line">        _sender.send_empty_segment();</span><br><span class="line">    if (seg.header().rst) &#123;</span><br><span class="line">        _sender.send_empty_segment();</span><br><span class="line">        unclean_shutdown();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    send_sender_segments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、写seg.</p><p>将上层应用的数据写入到Bytestream中,提醒发送方发送.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t TCPConnection::write(const string &amp;data) &#123;</span><br><span class="line">    DUMMY_CODE(data);</span><br><span class="line">    // get the OS data... ready to be sent by TCP</span><br><span class="line">    if(data.size()==0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t write_size = _sender.stream_in().write(data);</span><br><span class="line">    _sender.fill_window();</span><br><span class="line">    send_sender_segments();</span><br><span class="line">    return write_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、时钟(操作系统不定期调用之)</p><p>提醒Sender处理时间,看看是不是超时了.记录一下time_since_last_segment_received.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] ms_since_last_tick number of milliseconds since the last call to this method</span><br><span class="line">void TCPConnection::tick(const size_t ms_since_last_tick) &#123; </span><br><span class="line">    DUMMY_CODE(ms_since_last_tick); </span><br><span class="line">    if(!_active) return;</span><br><span class="line">    //count</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    // tell the sender to tick</span><br><span class="line">    _sender.tick(ms_since_last_tick);</span><br><span class="line">    if(_sender.consecutive_retransmissions()&gt;TCPConfig::MAX_RETX_ATTEMPTS)&#123;</span><br><span class="line">        unclean_shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    send_sender_segments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、真正的发送信息:读取sender中的消息缓存,然后加上ack和窗口信息信息,发送出去.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void TCPConnection::send_sender_segments ()&#123;</span><br><span class="line">    //travel the queue to set the ack and windows size.</span><br><span class="line">    while(!_sender.segments_out().empty())&#123;</span><br><span class="line">        TCPSegment seg = _sender.segments_out().front();</span><br><span class="line">        _sender.segments_out().pop();</span><br><span class="line">        // the ack number is bot null</span><br><span class="line">        if(_receiver.ackno().has_value())&#123;</span><br><span class="line">            seg.header().ack=true;</span><br><span class="line">            seg.header().ackno=_receiver.ackno().value();</span><br><span class="line">            seg.header().win=_receiver.window_size();</span><br><span class="line">        &#125;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //every time send segment,we need to shutdown.</span><br><span class="line">    clean_shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab0-Warm-Up&quot;&gt;&lt;a href=&quot;#Lab0-Warm-Up&quot; class=&quot;headerlink&quot; title=&quot;Lab0.Warm Up&quot;&gt;&lt;/a&gt;Lab0.Warm Up&lt;/h1&gt;&lt;h2 id=&quot;1-Networking-by-hand&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Rustilings 练习笔记</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2023/02/06/rustilings/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2023/02/06/rustilings/</id>
    <published>2023-02-06T02:43:19.000Z</published>
    <updated>2024-02-29T07:26:00.900Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br></pre></td><td class="code"><pre><span class="line">1-1</span><br><span class="line"></span><br><span class="line">// variables1.rs</span><br><span class="line">// Make me compile!</span><br><span class="line">// Execute \`rustlings hint variables1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    x = 5;</span><br><span class="line">    println!(&quot;x has the value &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这题简单,声明的方式出错了</span><br><span class="line"></span><br><span class="line">// variables1.rs</span><br><span class="line">// Make me compile!</span><br><span class="line">// Execute \`rustlings hint variables1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    println!(&quot;x has the value &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1-2</span><br><span class="line"></span><br><span class="line">// variables2.rs</span><br><span class="line">// Execute \`rustlings hint variables2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x;</span><br><span class="line">    if x == 10 &#123;</span><br><span class="line">        println!(&quot;x is ten!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;x is not ten!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rust不能判断x的类型,指定一下就好了</span><br><span class="line"></span><br><span class="line">// variables2.rs</span><br><span class="line">// Execute \`rustlings hint variables2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x : i32 = 10;</span><br><span class="line">    if x == 10 &#123;</span><br><span class="line">        println!(&quot;x is ten!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;x is not ten!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1-3</span><br><span class="line"></span><br><span class="line">// variables3.rs</span><br><span class="line">// Execute \`rustlings hint variables3\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x: i32;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x没有初始化,Rust编译器不允许访问没有初始化的元素</span><br><span class="line"></span><br><span class="line">// variables3.rs</span><br><span class="line">// Execute \`rustlings hint variables3\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x: i32 = 10;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1-4</span><br><span class="line"></span><br><span class="line">// variables4.rs</span><br><span class="line">// Execute \`rustlings hint variables4\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 3;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">    x = 5; // don&#x27;t change this line</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rust默认变量不可变,x=5修改了变量,所以说会拒绝,所以说要让变量可变</span><br><span class="line"></span><br><span class="line">// variables4.rs</span><br><span class="line">// Execute \`rustlings hint variables4\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut x = 3;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">    x = 5; // don&#x27;t change this line</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1-5</span><br><span class="line"></span><br><span class="line">// variables5.rs</span><br><span class="line">// Execute \`rustlings hint variables5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number = &quot;T-H-R-E-E&quot;; // don&#x27;t change this line</span><br><span class="line">    println!(&quot;Spell a Number : &#123;&#125;&quot;, number);</span><br><span class="line">    number = 3; // don&#x27;t rename this variable</span><br><span class="line">    println!(&quot;Number plus two is : &#123;&#125;&quot;, number + 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rust有类型检查,执行运算或者赋值时候要遵循类型的规律,但是Rust可以重新定义同名变量,变量的类型可以发生改变</span><br><span class="line"></span><br><span class="line">// variables5.rs</span><br><span class="line">// Execute \`rustlings hint variables5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number = &quot;T-H-R-E-E&quot;; // don&#x27;t change this line</span><br><span class="line">    println!(&quot;Spell a Number : &#123;&#125;&quot;, number);</span><br><span class="line">    let number = 3; // don&#x27;t rename this variable</span><br><span class="line">    println!(&quot;Number plus two is : &#123;&#125;&quot;, number + 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1-6</span><br><span class="line"></span><br><span class="line">// variables6.rs</span><br><span class="line">// Execute \`rustlings hint variables6\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">const NUMBER = 3;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const也是一样,当系统不能判断其类型的时候,需要显示说明</span><br><span class="line"></span><br><span class="line">// variables6.rs</span><br><span class="line">// Execute \`rustlings hint variables6\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">const NUMBER : i32 = 3;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Number &#123;&#125;&quot;, NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-1</span><br><span class="line"></span><br><span class="line">// functions1.rs</span><br><span class="line">// Execute \`rustlings hint functions1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    call_me();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这一题我们需要自己声明一个无参数无返回值的函数.fn 名字 ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">// functions1.rs</span><br><span class="line">// Execute \`rustlings hint functions1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn call_me()&#123;</span><br><span class="line">    println!(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    call_me();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-2</span><br><span class="line"></span><br><span class="line">// functions2.rs</span><br><span class="line">// Execute \`rustlings hint functions2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    call_me(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn call_me(num:) &#123;</span><br><span class="line">    for i in 0..num &#123;</span><br><span class="line">        println!(&quot;Ring! Call number &#123;&#125;&quot;, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有参数的函数.参数在括号里面,用逗号隔开,名字:类型</span><br><span class="line"></span><br><span class="line">// functions2.rs</span><br><span class="line">// Execute \`rustlings hint functions2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    call_me(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn call_me(num:i32) &#123;</span><br><span class="line">    for i in 0..num &#123;</span><br><span class="line">        println!(&quot;Ring! Call number &#123;&#125;&quot;, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-3</span><br><span class="line"></span><br><span class="line">// functions3.rs</span><br><span class="line">// Execute \`rustlings hint functions3\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    call_me();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn call_me(num: u32) &#123;</span><br><span class="line">    for i in 0..num &#123;</span><br><span class="line">        println!(&quot;Ring! Call number &#123;&#125;&quot;, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">很难看不出来是函数调用的时候漏传实参了,补上实参即可</span><br><span class="line"></span><br><span class="line">2-4</span><br><span class="line"></span><br><span class="line">// functions4.rs</span><br><span class="line">// Execute \`rustlings hint functions4\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// This store is having a sale where if the price is an even number, you get</span><br><span class="line">// 10 Rustbucks off, but if it&#x27;s an odd number, it&#x27;s 3 Rustbucks off.</span><br><span class="line">// (Don&#x27;t worry about the function bodies themselves, we&#x27;re only interested</span><br><span class="line">// in the signatures for now. If anything, this is a good way to peek ahead</span><br><span class="line">// to future exercises!)</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let original_price = 51;</span><br><span class="line">    println!(&quot;Your sale price is &#123;&#125;&quot;, sale_price(original_price));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn sale_price(price: i32) -&gt; &#123;</span><br><span class="line">    if is_even(price) &#123;</span><br><span class="line">        price - 10</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        price - 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn is_even(num: i32) -&gt; bool &#123;</span><br><span class="line">    num % 2 == 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数返回返回值的方法 就是 -&gt; 返回值类型 ,返回值可以是最后一条语句的值(这个语句不要加分号),也可以定义return</span><br><span class="line"></span><br><span class="line">给sale_price的-&gt;后面添加上返回值类型i32即可</span><br><span class="line"></span><br><span class="line">2-5</span><br><span class="line"></span><br><span class="line">// functions5.rs</span><br><span class="line">// Execute \`rustlings hint functions5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let answer = square(3);</span><br><span class="line">    println!(&quot;The square of 3 is &#123;&#125;&quot;, answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn square(num: i32) -&gt; i32 &#123;</span><br><span class="line">    num \* num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义返回值不是这么定义的,一般是语句或者是return,所以说要么改成return num \* num;要么去掉分号.一个块中最后一条语句去掉分号、这个可以称为块尾,就是返回值</span><br><span class="line"></span><br><span class="line">3-1</span><br><span class="line"></span><br><span class="line">写一个bigger函数,判断返回a和b中大的那个:</span><br><span class="line"></span><br><span class="line">pub fn bigger(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    // Complete this function to return the bigger number!</span><br><span class="line">    // Do not use:</span><br><span class="line">    // - another function call</span><br><span class="line">    // - additional variables</span><br><span class="line">    if a &gt; b&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3-2</span><br><span class="line"></span><br><span class="line">修改这个函数,使得可以编译并且能够通过测试</span><br><span class="line"></span><br><span class="line">pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if fizzish == &quot;fizz&quot; &#123;</span><br><span class="line">        &quot;foo&quot;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第一个是,返回的是&amp;str,不能返回1这个数字,然后修改逻辑能够通过测试就好</span><br><span class="line"></span><br><span class="line">pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if fizzish == &quot;fizz&quot; &#123;</span><br><span class="line">        &quot;foo&quot;</span><br><span class="line">    &#125; else if fizzish == &quot;fuzz&quot; &#123;</span><br><span class="line">        &quot;bar&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        &quot;baz&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4-1</span><br><span class="line"></span><br><span class="line">// primitive_types1.rs</span><br><span class="line">// Fill in the rest of the line that has code missing!</span><br><span class="line">// No hints, there&#x27;s no tricks, just get used to typing these :)</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // Booleans (\`bool\`)</span><br><span class="line"></span><br><span class="line">    let is_morning = true;</span><br><span class="line">    if is_morning &#123;</span><br><span class="line">        println!(&quot;Good morning!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let // Finish the rest of this line like the example! Or make it be false!</span><br><span class="line">    if is_evening &#123;</span><br><span class="line">        println!(&quot;Good evening!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">只用完成一行的代码就好了.不知道这题的意义是什么23333 就是写成`let is_evening = false;`就好了</span><br><span class="line"></span><br><span class="line">4-2</span><br><span class="line"></span><br><span class="line">// primitive_types2.rs</span><br><span class="line">// Fill in the rest of the line that has code missing!</span><br><span class="line">// No hints, there&#x27;s no tricks, just get used to typing these :)</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // Characters (\`char\`)</span><br><span class="line"></span><br><span class="line">    // Note the _single_ quotes, these are different from the double quotes</span><br><span class="line">    // you&#x27;ve been seeing around.</span><br><span class="line">    let my_first_initial = &#x27;C&#x27;;</span><br><span class="line">    if my_first_initial.is_alphabetic() &#123;</span><br><span class="line">        println!(&quot;Alphabetical!&quot;);</span><br><span class="line">    &#125; else if my_first_initial.is_numeric() &#123;</span><br><span class="line">        println!(&quot;Numerical!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;Neither alphabetic nor numeric!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let your_character = &#x27;1&#x27;;// Finish this line like the example! What&#x27;s your favorite character?</span><br><span class="line">    // Try a letter, try a number, try a special character, try a character</span><br><span class="line">    // from a different language than your own, try an emoji!</span><br><span class="line">    if your_character.is_alphabetic() &#123;</span><br><span class="line">        println!(&quot;Alphabetical!&quot;);</span><br><span class="line">    &#125; else if your_character.is_numeric() &#123;</span><br><span class="line">        println!(&quot;Numerical!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;Neither alphabetic nor numeric!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码就是给定一个字符,进行判断而已.这题似乎也没难度,填写一个:`let your_character = &#x27;1&#x27;;`就好</span><br><span class="line"></span><br><span class="line">4-3</span><br><span class="line"></span><br><span class="line">这题需要我们学会怎么声明一个数组,这个和C语言几乎一样.就是`let a = [1,2,3,4];`</span><br><span class="line"></span><br><span class="line">4-4</span><br><span class="line"></span><br><span class="line">这题需要我们创建一个数组slice,就是取第2-4个元素</span><br><span class="line"></span><br><span class="line">// primitive_types4.rs</span><br><span class="line">// Get a slice out of Array a where the ??? is so that the test passes.</span><br><span class="line">// Execute \`rustlings hint primitive_types4\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn slice_out_of_array() &#123;</span><br><span class="line">    let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    let nice_slice = ???;</span><br><span class="line"></span><br><span class="line">    assert_eq!([2, 3, 4], nice_slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">答案是&amp;a[1..4],这个slice:&amp;a[a,b]会取a+1到b的元素.</span><br><span class="line"></span><br><span class="line">4-5</span><br><span class="line"></span><br><span class="line">这题需要我们写一个元组模式匹配的代码,就是(a,b)=元组</span><br><span class="line"></span><br><span class="line">// primitive_types5.rs</span><br><span class="line">// Destructure the \`cat\` tuple so that the println will work.</span><br><span class="line">// Execute \`rustlings hint primitive_types5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let cat = (&quot;Furry McFurson&quot;, 3.5);</span><br><span class="line">    let /\* your pattern here \*/ = cat;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; is &#123;&#125; years old.&quot;, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">把注释改成let (name,age) = cat;就好,这样可以像SML一样完成模式匹配</span><br><span class="line"></span><br><span class="line">4-6</span><br><span class="line"></span><br><span class="line">这题需要我们取出元组的第2个元素.</span><br><span class="line"></span><br><span class="line">// primitive_types6.rs</span><br><span class="line">// Use a tuple index to access the second element of \`numbers\`.</span><br><span class="line">// You can put the expression for the second element where ??? is so that the test passes.</span><br><span class="line">// Execute \`rustlings hint primitive_types6\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn indexing_tuple() &#123;</span><br><span class="line">    let numbers = (1, 2, 3);</span><br><span class="line">    // Replace below ??? with the tuple indexing syntax.</span><br><span class="line">    let second = ???;</span><br><span class="line"></span><br><span class="line">    assert_eq!(2, second,</span><br><span class="line">        &quot;This is not the 2nd number in the tuple!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">答案就是`let second = numbers.1;`</span><br><span class="line"></span><br><span class="line">5-1</span><br><span class="line"></span><br><span class="line">// move_semantics1.rs</span><br><span class="line">// Execute \`rustlings hint move_semantics1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let vec1 = fill_vec(vec0);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    let mut vec = vec;</span><br><span class="line"></span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">讲vec1改成mut(可变)即可,对Vec做增删改需要将Vec改为可变</span><br><span class="line"></span><br><span class="line">5-2</span><br><span class="line"></span><br><span class="line">// move_semantics2.rs</span><br><span class="line">// Make me compile without changing line 13 or moving line 10!</span><br><span class="line">// Execute \`rustlings hint move_semantics2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec(vec0);</span><br><span class="line"></span><br><span class="line">    // Do not change the following line!</span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec0&quot;, vec0.len(), vec0);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    let mut vec = vec;</span><br><span class="line"></span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec0的所有权进入到函数fill_vec中了,fill_vec结束后,vec0的所有权被释放,main丧失了对vec0的所有权,就不能访问vec0了.</span><br><span class="line"></span><br><span class="line">所以说我们要把传vec0改成传vec0的引用,传引用是不会交出所有权的.在函数中对此引用产生一个拷贝,将此拷贝传回来,这个拷贝是实际的Vec类型而不是引用</span><br><span class="line"></span><br><span class="line">// move_semantics2.rs</span><br><span class="line">// Make me compile without changing line 13 or moving line 10!</span><br><span class="line">// Execute \`rustlings hint move_semantics2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec(&amp;vec0);</span><br><span class="line"></span><br><span class="line">    // Do not change the following line!</span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec0&quot;, vec0.len(), vec0);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fill_vec(vec: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    let mut vec = (\*vec).to_vec();</span><br><span class="line"></span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    (\*vec).to_vec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5-3</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec(vec0);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主要的问题就是fill_vec函数中的vec是不可变的,要push内容是不可以的.</span><br><span class="line"></span><br><span class="line">一个解决方法就是创建一个拷贝,像5-1一样.</span><br><span class="line"></span><br><span class="line">第二个方法就是将vec0设置成mut的,fill_vec的vec也设置成mut</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec(vec0);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fill_vec(mut vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5-4</span><br><span class="line"></span><br><span class="line">// move_semantics4.rs</span><br><span class="line">// Refactor this code so that instead of passing \`vec0\` into the \`fill_vec\` function,</span><br><span class="line">// the Vector gets created in the function itself and passed back to the main</span><br><span class="line">// function.</span><br><span class="line">// Execute \`rustlings hint move_semantics4\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let vec0 = Vec::new();</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec(vec0);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// \`fill_vec()\` no longer takes \`vec: Vec&lt;i32&gt;\` as argument</span><br><span class="line">fn fill_vec() -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    let mut vec = vec;</span><br><span class="line"></span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不用vec0就把vec0相关的内容删掉,改成在函数体内new一个就好</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let mut vec1 = fill_vec();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line"></span><br><span class="line">    vec1.push(88);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// \`fill_vec()\` no longer takes \`vec: Vec&lt;i32&gt;\` as argument</span><br><span class="line">fn fill_vec() -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    let mut vec = Vec::new();</span><br><span class="line"></span><br><span class="line">    vec.push(22);</span><br><span class="line">    vec.push(44);</span><br><span class="line">    vec.push(66);</span><br><span class="line"></span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5-5</span><br><span class="line"></span><br><span class="line">// move_semantics5.rs</span><br><span class="line">// Make me compile only by reordering the lines in \`main()\`, but without</span><br><span class="line">// adding, changing or removing any of them.</span><br><span class="line">// Execute \`rustlings hint move_semantics5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut x = 100;</span><br><span class="line">    let y = &amp;mut x;</span><br><span class="line">    let z = &amp;mut x;</span><br><span class="line">    \*y += 100;</span><br><span class="line">    \*z += 1000;</span><br><span class="line">    assert_eq!(x, 1200);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不能对一个变量同时创建两个可变引用,改成这样就好:</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut x = 100;</span><br><span class="line">    let z = &amp;mut x;</span><br><span class="line">    \*z += 100;</span><br><span class="line">    \*z += 1000;</span><br><span class="line">    assert_eq!(x, 1200);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5-6</span><br><span class="line"></span><br><span class="line">// move_semantics6.rs</span><br><span class="line">// Execute \`rustlings hint move_semantics6\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line">// You can&#x27;t change anything except adding or removing references.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let data = &quot;Rust is great!&quot;.to_string();</span><br><span class="line"></span><br><span class="line">    get_char(data);</span><br><span class="line"></span><br><span class="line">    string_uppercase(&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Should not take ownership</span><br><span class="line">fn get_char(data: String) -&gt; char &#123;</span><br><span class="line">    data.chars().last().unwrap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Should take ownership</span><br><span class="line">fn string_uppercase(mut data: &amp;String) &#123;</span><br><span class="line">    data = &amp;data.to_uppercase();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码的注释都写了,不要放弃所有权就是加引用,放弃所有权就是不加引用</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let data = &quot;Rust is great!&quot;.to_string();</span><br><span class="line"></span><br><span class="line">    get_char(&amp;data);</span><br><span class="line"></span><br><span class="line">    string_uppercase(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Should not take ownership</span><br><span class="line">fn get_char(data: &amp;String) -&gt; char &#123;</span><br><span class="line">    (\*data).chars().last().unwrap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Should take ownership</span><br><span class="line">fn string_uppercase(mut data: String) &#123;</span><br><span class="line">    data = data.to_uppercase();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6-1</span><br><span class="line"></span><br><span class="line">这一题我们要了解最基础的结构体、元组型结构体以及单元结构体的定义和初始化.</span><br><span class="line"></span><br><span class="line">定义的方法两者有所不同,一个是用&#123;&#125;扩起来,不同的元素之间用逗号隔开,还有就是元组型,用()扩起来,不同的元素用逗号隔开.访问的方式一个是结构体.名字和结构体.顺序</span><br><span class="line"></span><br><span class="line">// structs1.rs</span><br><span class="line">// Address all the TODOs to make the tests pass!</span><br><span class="line">// Execute \`rustlings hint structs1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">struct ColorClassicStruct &#123;</span><br><span class="line">    red : i32,</span><br><span class="line">    blue : i32,</span><br><span class="line">    green : i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ColorTupleStruct(i32,i32,i32);</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct UnitLikeStruct;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn classic_c_structs() &#123;</span><br><span class="line">        // TODO: Instantiate a classic c struct!</span><br><span class="line">        let green = ColorClassicStruct&#123;</span><br><span class="line">            red:0,</span><br><span class="line">            green:255,</span><br><span class="line">            blue:0,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        assert_eq!(green.red, 0);</span><br><span class="line">        assert_eq!(green.green, 255);</span><br><span class="line">        assert_eq!(green.blue, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn tuple_structs() &#123;</span><br><span class="line">        // TODO: Instantiate a tuple struct!</span><br><span class="line">        let green = ColorTupleStruct(0, 255, 0);</span><br><span class="line"></span><br><span class="line">        assert_eq!(green.0, 0);</span><br><span class="line">        assert_eq!(green.1, 255);</span><br><span class="line">        assert_eq!(green.2, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn unit_structs() &#123;</span><br><span class="line">        // TODO: Instantiate a unit-like struct!</span><br><span class="line">        let unit_like_struct = UnitLikeStruct&#123;&#125;;</span><br><span class="line">        let message = format!(&quot;&#123;:?&#125;s are fun!&quot;, unit_like_struct);</span><br><span class="line"></span><br><span class="line">        assert_eq!(message, &quot;UnitLikeStructs are fun!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6-2</span><br><span class="line"></span><br><span class="line">这一题我们需要用一个已经定义好的结构体来声明一个结构体,有一种朴素的方法是,使用A : others.A来定义,还有就是先定义有不同的,再使用..other定义相同的属性.</span><br><span class="line"></span><br><span class="line">// structs2.rs</span><br><span class="line">// Address all the TODOs to make the tests pass!</span><br><span class="line">// Execute \`rustlings hint structs2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Order &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    year: u32,</span><br><span class="line">    made_by_phone: bool,</span><br><span class="line">    made_by_mobile: bool,</span><br><span class="line">    made_by_email: bool,</span><br><span class="line">    item_number: u32,</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn create_order_template() -&gt; Order &#123;</span><br><span class="line">    Order &#123;</span><br><span class="line">        name: String::from(&quot;Bob&quot;),</span><br><span class="line">        year: 2019,</span><br><span class="line">        made_by_phone: false,</span><br><span class="line">        made_by_mobile: false,</span><br><span class="line">        made_by_email: true,</span><br><span class="line">        item_number: 123,</span><br><span class="line">        count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn your_order() &#123;</span><br><span class="line">        let order_template = create_order_template();</span><br><span class="line">        // TODO: Create your own order using the update syntax and template above!</span><br><span class="line">        let your_order = Order&#123;</span><br><span class="line">            name : String::from(&quot;Hacker in Rust&quot;),</span><br><span class="line">            count : 1,</span><br><span class="line">            ..order_template</span><br><span class="line">        &#125;;</span><br><span class="line">        assert_eq!(your_order.name, &quot;Hacker in Rust&quot;);</span><br><span class="line">        assert_eq!(your_order.year, order_template.year);</span><br><span class="line">        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);</span><br><span class="line">        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);</span><br><span class="line">        assert_eq!(your_order.made_by_email, order_template.made_by_email);</span><br><span class="line">        assert_eq!(your_order.item_number, order_template.item_number);</span><br><span class="line">        assert_eq!(your_order.count, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6-3</span><br><span class="line"></span><br><span class="line">这一题我们需要完成Package的impl块</span><br><span class="line"></span><br><span class="line">    fn is_international(&amp;self) -&gt; ??? &#123;</span><br><span class="line">        // Something goes here...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_fees(&amp;self, cents_per_gram: i32) -&gt; ??? &#123;</span><br><span class="line">        // Something goes here...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">函数都很好写,然后可以这样调用:Package::get_fees来调用impl的方法</span><br><span class="line"></span><br><span class="line">impl Package &#123;</span><br><span class="line">    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&gt; Package &#123;</span><br><span class="line">        if weight_in_grams &lt;= 0 &#123;</span><br><span class="line">            panic!(&quot;Can not ship a weightless package.&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Package &#123;</span><br><span class="line">                sender_country,</span><br><span class="line">                recipient_country,</span><br><span class="line">                weight_in_grams,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn is_international(&amp;self) -&gt; bool &#123;</span><br><span class="line">        if self.sender_country == self.recipient_country&#123;</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_fees(&amp;self, cents_per_gram: i32) -&gt; i32 &#123;</span><br><span class="line">        self.weight_in_grams \* cents_per_gram</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">比如说Package::new()就可以生成一个新的Package块</span><br><span class="line"></span><br><span class="line">对于impl块的调用,我们给出了两种形式,一种是类::方法,一种是实例.方法</span><br><span class="line"></span><br><span class="line">fn create_international_package() &#123;</span><br><span class="line">        let sender_country = String::from(&quot;Spain&quot;);</span><br><span class="line">        let recipient_country = String::from(&quot;Russia&quot;);</span><br><span class="line"></span><br><span class="line">        let package = Package::new(sender_country, recipient_country, 1200);</span><br><span class="line"></span><br><span class="line">        assert!(package.is_international());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">7-1</span><br><span class="line"></span><br><span class="line">这一个我们仅需要声明一个枚举类型即可,声明的方法就是enum 名字&#123;&#125;,&#123;&#125;内内容用枚举括起来.</span><br><span class="line"></span><br><span class="line">// enums1.rs</span><br><span class="line">// No hints this time! ;)</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">enum Message &#123;</span><br><span class="line">    // TODO: define a few types of messages as used below</span><br><span class="line">    Quit,</span><br><span class="line">    Echo,</span><br><span class="line">    Move,</span><br><span class="line">    ChangeColor,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, Message::Quit);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, Message::Echo);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, Message::Move);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, Message::ChangeColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7-2</span><br><span class="line"></span><br><span class="line">这次的声明需要我们像书上说的那样,让枚举变量的每一个枚举值和一个结构体匹配.可能不仅仅是一个结构体,有可能是一个元组或者仅仅是一个值.</span><br><span class="line"></span><br><span class="line">// enums2.rs</span><br><span class="line">// Execute \`rustlings hint enums2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">enum Message &#123;</span><br><span class="line">    Move&#123;x : i32, y : i32&#125;,</span><br><span class="line">    Echo(String),</span><br><span class="line">    ChangeColor(i32,i32,i32),</span><br><span class="line">    Quit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Message &#123;</span><br><span class="line">    fn call(&amp;self) &#123;</span><br><span class="line">        println!(&quot;&#123;:?&#125;&quot;, &amp;self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let messages = [</span><br><span class="line">        Message::Move &#123; x: 10, y: 30 &#125;,</span><br><span class="line">        Message::Echo(String::from(&quot;hello world&quot;)),</span><br><span class="line">        Message::ChangeColor(200, 255, 255),</span><br><span class="line">        Message::Quit,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    for message in &amp;messages &#123;</span><br><span class="line">        message.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这种特性很好记忆,只需要把枚举值当成一种结构体的类型就好了.</span><br><span class="line"></span><br><span class="line">7-3 这一题可能会有点难,我们需要根据我们已经写好的枚举类型特出特定的匹配执行特定的操作,匹配的格式是match 表达式&#123;&#125;,&#123;&#125;里面是 表达式 =&gt; 做什么、返回什么</span><br><span class="line"></span><br><span class="line">// enums3.rs</span><br><span class="line">// Address all the TODOs to make the tests pass!</span><br><span class="line">// Execute \`rustlings hint enums3\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">enum Message &#123;</span><br><span class="line">    Move(Point),</span><br><span class="line">    Echo(String),</span><br><span class="line">    ChangeColor((u8,u8,u8)),</span><br><span class="line">    Quit,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: u8,</span><br><span class="line">    y: u8,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct State &#123;</span><br><span class="line">    color: (u8, u8, u8),</span><br><span class="line">    position: Point,</span><br><span class="line">    quit: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl State &#123;</span><br><span class="line">    fn change_color(&amp;mut self, color: (u8, u8, u8)) &#123;</span><br><span class="line">        self.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn quit(&amp;mut self) &#123;</span><br><span class="line">        self.quit = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn echo(&amp;self, s: String) &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn move_position(&amp;mut self, p: Point) &#123;</span><br><span class="line">        self.position = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn process(&amp;mut self, message: Message) &#123;</span><br><span class="line">        match message&#123;</span><br><span class="line">            Message::Move(point) =&gt; &#123;</span><br><span class="line">                State::move_position(self,point);</span><br><span class="line">            &#125;,</span><br><span class="line">            Message::Quit =&gt; &#123;</span><br><span class="line">                State::quit(self);</span><br><span class="line">            &#125;,</span><br><span class="line">            Message::ChangeColor(color) =&gt; &#123;</span><br><span class="line">                State::change_color(self,color);</span><br><span class="line">            &#125;</span><br><span class="line">            Message::Echo(mes) =&gt; &#123;</span><br><span class="line">                State::echo(self,mes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn test_match_message_call() &#123;</span><br><span class="line">        let mut state = State &#123;</span><br><span class="line">            quit: false,</span><br><span class="line">            position: Point &#123; x: 0, y: 0 &#125;,</span><br><span class="line">            color: (0, 0, 0),</span><br><span class="line">        &#125;;</span><br><span class="line">        state.process(Message::ChangeColor((255, 0, 255)));</span><br><span class="line">        state.process(Message::Echo(String::from(&quot;hello world&quot;)));</span><br><span class="line">        state.process(Message::Move(Point &#123; x: 10, y: 15 &#125;));</span><br><span class="line">        state.process(Message::Quit);</span><br><span class="line"></span><br><span class="line">        assert_eq!(state.color, (255, 0, 255));</span><br><span class="line">        assert_eq!(state.position.x, 10);</span><br><span class="line">        assert_eq!(state.position.y, 15);</span><br><span class="line">        assert_eq!(state.quit, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意有一点,再引用枚举类型的时候别忘记加::来规定,Message::Move和Move是不一样的,别忘了加Message::Move.</span><br><span class="line"></span><br><span class="line">8-1</span><br><span class="line"></span><br><span class="line">这一题需要我们把这个模块里面的某个函数隐藏起来</span><br><span class="line"></span><br><span class="line">mod sausage_factory &#123;</span><br><span class="line">    // Don&#x27;t let anybody outside of this module see this!</span><br><span class="line">    fn get_secret_recipe() -&gt; String &#123;</span><br><span class="line">        String::from(&quot;Ginger&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn make_sausage() &#123;</span><br><span class="line">        get_secret_recipe();</span><br><span class="line">        println!(&quot;sausage!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    sausage_factory::make_sausage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其实这个很简单,因为在一个模块中,模块里面的任何一个元素都是隐藏的,或者说私有的,在前面加上一个pub就是.</span><br><span class="line"></span><br><span class="line">8-2</span><br><span class="line"></span><br><span class="line">这一题需要我们使用use来将一些模块添加到我们的“相对变量环境”中,如同Linux的PATH一样.</span><br><span class="line"></span><br><span class="line">还需要我们了解as的用法.</span><br><span class="line"></span><br><span class="line">mod delicious_snacks &#123;</span><br><span class="line">    // TODO: Fix these use statements</span><br><span class="line">    pub use self::fruits::PEAR as fruit;</span><br><span class="line">    pub use self::veggies::CUCUMBER as veggie;</span><br><span class="line"></span><br><span class="line">    mod fruits &#123;</span><br><span class="line">        pub const PEAR: &amp;&#x27;static str = &quot;Pear&quot;;</span><br><span class="line">        pub const APPLE: &amp;&#x27;static str = &quot;Apple&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod veggies &#123;</span><br><span class="line">        pub const CUCUMBER: &amp;&#x27;static str = &quot;Cucumber&quot;;</span><br><span class="line">        pub const CARROT: &amp;&#x27;static str = &quot;Carrot&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然,还有一点就是,如果use前面加了个pub,就是说所有的模块都能使用这个use的结果,如果没加pub,代表仅限delicious_snacks这个模块能使用这个use的结果.</span><br><span class="line"></span><br><span class="line">8-3</span><br><span class="line"></span><br><span class="line">这一题需要我们use std里面的库,这里我使用glob运算混过去了</span><br><span class="line"></span><br><span class="line">// TODO: Complete this use statement</span><br><span class="line">use std::time::\*;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    match SystemTime::now().duration_since(UNIX_EPOCH) &#123;</span><br><span class="line">        Ok(n) =&gt; println!(&quot;1970-01-01 00:00:00 UTC was &#123;&#125; seconds ago!&quot;, n.as_secs()),</span><br><span class="line">        Err(_) =&gt; panic!(&quot;SystemTime before UNIX EPOCH!&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9-1</span><br><span class="line"></span><br><span class="line">用vec宏声明一个新的Vector.这道题负责了解Vec!和直接声明的区别.</span><br><span class="line"></span><br><span class="line">fn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) &#123;</span><br><span class="line">    let a = [10, 20, 30, 40]; // a plain array</span><br><span class="line">    let v = vec!(10,20,30,40);</span><br><span class="line">    (a, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用直接声明是一个[i32,n]的类型,用vec!()宏可以声明一个Vec&lt;T&gt;类型的变量.</span><br><span class="line"></span><br><span class="line">9-2</span><br><span class="line"></span><br><span class="line">这一题需要我们把Vec里面的所有元素\*2.</span><br><span class="line"></span><br><span class="line">我们有两种版本,一个是使用迭代器,依次迭代解引用更改即可.还可以使用map方法对里面的元素统一使用一个函数进行更改</span><br><span class="line"></span><br><span class="line">fn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    for i in v.iter_mut() &#123;</span><br><span class="line">        \*i = \*i \* 2;</span><br><span class="line">    &#125;</span><br><span class="line">    // At this point, \`v\` should be equal to [4, 8, 12, 16, 20].</span><br><span class="line">    v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;</span><br><span class="line">    v.iter().map(num &#123;</span><br><span class="line">        // TODO: Do the same thing as above - but instead of mutating the</span><br><span class="line">        // Vec, you can just return the new number!</span><br><span class="line">         num \* 2</span><br><span class="line">    &#125;).collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">10-1</span><br><span class="line"></span><br><span class="line">改错</span><br><span class="line"></span><br><span class="line">// strings1.rs</span><br><span class="line">// Make me compile without changing the function signature!</span><br><span class="line">// Execute \`rustlings hint strings1\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let answer = current_favorite_color();</span><br><span class="line">    println!(&quot;My current favorite color is &#123;&#125;&quot;, answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn current_favorite_color() -&gt; String &#123;</span><br><span class="line">    &quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“blue”不是String类型的,它是一个常量字符串,两种改法:改成let赋值模式、或者改成返回&amp;‘static 类型就好.</span><br><span class="line"></span><br><span class="line">10-2</span><br><span class="line"></span><br><span class="line">改错,也是一样的,传进来的是一个String类型的元素,但是函数的签名却是&amp;str</span><br><span class="line"></span><br><span class="line">// strings2.rs</span><br><span class="line">// Make me compile without changing the function signature!</span><br><span class="line">// Execute \`rustlings hint strings2\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let word = String::from(&quot;green&quot;); // Try not changing this line :)</span><br><span class="line">    if is_a_color_word(word) &#123;</span><br><span class="line">        println!(&quot;That is a color word I know!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;That is not a color word I know.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn is_a_color_word(attempt: &amp;str) -&gt; bool &#123;</span><br><span class="line">    attempt == &quot;green&quot;  attempt == &quot;blue&quot;  attempt == &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所以说把函数签名的&amp;str改成string就好.</span><br><span class="line"></span><br><span class="line">10-3</span><br><span class="line"></span><br><span class="line">写3个很简单的小函数.</span><br><span class="line"></span><br><span class="line">一个是在后面加一个world,就是使用push_str函数在后面加上即可.</span><br><span class="line"></span><br><span class="line">一个是去掉前面和后面的空格.就把每个单词分开来,然后组装在一起.</span><br><span class="line"></span><br><span class="line">一个是把所有的cars换成balloons,也是把每个单词分开来,加一个判断而已.</span><br><span class="line"></span><br><span class="line">fn trim_me(input: &amp;str) -&gt; String &#123;</span><br><span class="line">    // TODO: Remove whitespace from both ends of a string!</span><br><span class="line">    let s = input.to_string();</span><br><span class="line">    let mut ne = String::new();</span><br><span class="line">    for word in s.split_whitespace()&#123;</span><br><span class="line">        ne.push_str(word);</span><br><span class="line">        ne.push_str(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ne.pop();</span><br><span class="line">    ne</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn compose_me(input: &amp;str) -&gt; String &#123;</span><br><span class="line">    // TODO: Add &quot; world!&quot; to the string! There&#x27;s multiple ways to do this!</span><br><span class="line">    let mut s = input.to_string();</span><br><span class="line">    s.push_str(&quot; world!&quot;);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn replace_me(input: &amp;str) -&gt; String &#123;</span><br><span class="line">    // TODO: Replace &quot;cars&quot; in the string with &quot;balloons&quot;!</span><br><span class="line">    let s = input.to_string();</span><br><span class="line">    let mut ne = String::new();</span><br><span class="line">    for word in s.split_whitespace()&#123;</span><br><span class="line">        if word == &quot;cars&quot;&#123;</span><br><span class="line">            ne.push_str(&quot;balloons&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            ne.push_str(word);</span><br><span class="line">        &#125;</span><br><span class="line">        ne.push_str(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ne.pop();</span><br><span class="line">    ne</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">10-4</span><br><span class="line"></span><br><span class="line">判断是String还是&amp;str的?</span><br><span class="line"></span><br><span class="line">fn string_slice(arg: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arg);</span><br><span class="line">&#125;</span><br><span class="line">fn string(arg: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    ???(&quot;blue&quot;);</span><br><span class="line">    ???(&quot;red&quot;.to_string());</span><br><span class="line">    ???(String::from(&quot;hi&quot;));</span><br><span class="line">    ???(&quot;rust is fun!&quot;.to_owned());</span><br><span class="line">    ???(&quot;nice weather&quot;.into());</span><br><span class="line">    ???(format!(&quot;Interpolation &#123;&#125;&quot;, &quot;Station&quot;));</span><br><span class="line">    ???(&amp;String::from(&quot;abc&quot;)[0..1]);</span><br><span class="line">    ???(&quot;  hello there &quot;.trim());</span><br><span class="line">    ???(&quot;Happy Monday!&quot;.to_string().replace(&quot;Mon&quot;, &quot;Tues&quot;));</span><br><span class="line">    ???(&quot;mY sHiFt KeY iS sTiCkY&quot;.to_lowercase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">答案就是这个:</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    string_slice(&quot;blue&quot;);</span><br><span class="line">    string(&quot;red&quot;.to_string());</span><br><span class="line">    string(String::from(&quot;hi&quot;));</span><br><span class="line">    string(&quot;rust is fun!&quot;.to_owned());</span><br><span class="line">    string(&quot;nice weather&quot;.into());</span><br><span class="line">    string(format!(&quot;Interpolation &#123;&#125;&quot;, &quot;Station&quot;));</span><br><span class="line">    string_slice(&amp;String::from(&quot;abc&quot;)[0..1]);</span><br><span class="line">    string_slice(&quot;  hello there &quot;.trim());</span><br><span class="line">    string(&quot;Happy Monday!&quot;.to_string().replace(&quot;Mon&quot;, &quot;Tues&quot;));</span><br><span class="line">    string(&quot;mY sHiFt KeY iS sTiCkY&quot;.to_lowercase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">11-1</span><br><span class="line"></span><br><span class="line">这一题需要我们声明一个空的HashMap,然后插入若干个key-value对.插入就调用insert就好了.</span><br><span class="line"></span><br><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; &#123;</span><br><span class="line">    let mut basket = HashMap::new();// TODO: declare your hash map here.</span><br><span class="line"></span><br><span class="line">    // Two bananas are already given for you :)</span><br><span class="line">    // TODO: Put more fruits in your basket here.</span><br><span class="line">    basket.insert(String::from(&quot;banana&quot;), 2);</span><br><span class="line">    basket.insert(String::from(&quot;Apple&quot;), 2);</span><br><span class="line">    basket.insert(String::from(&quot;Orange&quot;), 2);</span><br><span class="line"></span><br><span class="line">    basket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">11-2</span><br><span class="line"></span><br><span class="line">这一题需要我们完成哈希表的判断插入,当这个表没有这个元素的时候才进行插入操作,在书本上说过可以用enrty和or_insert进行插入</span><br><span class="line"></span><br><span class="line">fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) &#123;</span><br><span class="line">    let fruit_kinds = vec![</span><br><span class="line">        Fruit::Apple,</span><br><span class="line">        Fruit::Banana,</span><br><span class="line">        Fruit::Mango,</span><br><span class="line">        Fruit::Lychee,</span><br><span class="line">        Fruit::Pineapple,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    for fruit in fruit_kinds &#123;</span><br><span class="line">        // TODO: Put new fruits if not already present. Note that you</span><br><span class="line">        // are not allowed to put any type of fruit that&#x27;s already</span><br><span class="line">        // present!</span><br><span class="line">        let k = basket.entry(fruit).or_insert(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">11-3</span><br><span class="line"></span><br><span class="line">这一题需要我们统计一个球队输球和赢球的数量,需要用到or_insert,用到or_insert的返回值,这个返回值是一个引用,可以改变value的值.</span><br><span class="line"></span><br><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">// A structure to store team name and its goal details.</span><br><span class="line">struct Team &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    goals_scored: u8,</span><br><span class="line">    goals_conceded: u8,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn build_scores_table(results: String) -&gt; HashMap&lt;String, Team&gt; &#123;</span><br><span class="line">    // The name of the team is the key and its associated struct is the value.</span><br><span class="line">    let mut scores: HashMap&lt;String, Team&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    for r in results.lines() &#123;</span><br><span class="line">        let v: Vec&lt;&amp;str&gt; = r.split(&#x27;,&#x27;).collect();</span><br><span class="line">        let team_1_name = v[0].to_string();</span><br><span class="line">        let team_1_score: u8 = v[2].parse().unwrap();</span><br><span class="line">        let team_2_name = v[1].to_string();</span><br><span class="line">        let team_2_score: u8 = v[3].parse().unwrap();</span><br><span class="line">        // TODO: Populate the scores table with details extracted from the</span><br><span class="line">        // current line. Keep in mind that goals scored by team_1</span><br><span class="line">        // will be number of goals conceded from team_2, and similarly</span><br><span class="line">        // goals scored by team_2 will be the number of goals conceded by</span><br><span class="line">        let g = scores.entry(team_1_name.to_string()).or_insert(Team&#123;name:team_1_name,goals_scored:0,goals_conceded:0&#125;);</span><br><span class="line">        (\*g).goals_scored = (\*g).goals_scored + team_1_score;</span><br><span class="line">        (\*g).goals_conceded = (\*g).goals_conceded + team_2_score;</span><br><span class="line">        let f = scores.entry(team_2_name.to_string()).or_insert(Team&#123;name:team_2_name,goals_scored:0,goals_conceded:0&#125;);</span><br><span class="line">        (\*f).goals_scored = (\*f).goals_scored + team_2_score;</span><br><span class="line">        (\*f).goals_conceded = (\*f).goals_conceded + team_1_score;</span><br><span class="line">    &#125;</span><br><span class="line">    scores</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12-1</span><br><span class="line"></span><br><span class="line">这一题单纯用来了解Result的特征,Result&lt;T,E&gt;是一个枚举类型,其中Ok的类型是T,Err的类型是E,如果一个函数会返回Result在不同情况下会返回Ok或者Err两种元素.</span><br><span class="line"></span><br><span class="line">这一题的T和E都是字符串,负责传回一个字符串.</span><br><span class="line"></span><br><span class="line">pub fn generate_nametag_text(name: String) -&gt; Result&lt;String,String&gt; &#123;</span><br><span class="line">    if name.is_empty() &#123;</span><br><span class="line">        // Empty names aren&#x27;t allowed.</span><br><span class="line">        Err(&quot;\`name\` was empty; it must be nonempty.&quot;.into())</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Ok(format!(&quot;Hi! My name is &#123;&#125;&quot;, name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12-2</span><br><span class="line"></span><br><span class="line">这一题我们需要了解最基本的错误的处理方式,第一种处理方式就是match一个Result值,Result值有两种枚举的可能,一个是Ok(T),一个是Err(E),分步处理即可.如果是Err就要直接返回.</span><br><span class="line"></span><br><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123;</span><br><span class="line">    let processing_fee = 1;</span><br><span class="line">    let cost_per_item = 5;</span><br><span class="line">    let qty = match item_quantity.parse::&lt;i32&gt;()&#123;</span><br><span class="line">        Ok(T) =&gt; T,</span><br><span class="line">        Err(E) =&gt; &#123;</span><br><span class="line">            return Err(E);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Ok(qty \* cost_per_item + processing_fee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12-3</span><br><span class="line"></span><br><span class="line">这一题主要是了解Result的?用法.</span><br><span class="line"></span><br><span class="line">如果加上了?这个符号在一个可以返回Result&lt;T,E&gt;的函数调用后面,这个符号可以完成这个任务:</span><br><span class="line"></span><br><span class="line">如果是Ok,这个表达式的值就是Ok的值,如果是Err,就会自动向上面传递问题.</span><br><span class="line"></span><br><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut tokens = 100;</span><br><span class="line">    let pretend_user_input = &quot;8&quot;;</span><br><span class="line"></span><br><span class="line">    let cost = total_cost(pretend_user_input)?;</span><br><span class="line"></span><br><span class="line">    if cost &gt; tokens &#123;</span><br><span class="line">        println!(&quot;You can&#x27;t afford that many!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tokens -= cost;</span><br><span class="line">        println!(&quot;You now have &#123;&#125; tokens.&quot;, tokens);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123;</span><br><span class="line">    let processing_fee = 1;</span><br><span class="line">    let cost_per_item = 5;</span><br><span class="line">    let qty = item_quantity.parse::&lt;i32&gt;()?;</span><br><span class="line"></span><br><span class="line">    Ok(qty \* cost_per_item + processing_fee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个代码里面就是有一个?,`item_quantity.parse::&lt;i32&gt;()?`没问题就返回这个i32,如果有问题就向上面抛出异常.</span><br><span class="line"></span><br><span class="line">上层需要处理这个异常.一种改法是让main也返回Result类型,还有一种就是把?去掉加上match函数进行处理.</span><br><span class="line"></span><br><span class="line">    let cost = match total_cost(pretend_user_input)&#123;</span><br><span class="line">        Ok(a) =&gt; a,</span><br><span class="line">        Err(E) =&gt; &#123;</span><br><span class="line">            panic!(&quot;G&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">12-4</span><br><span class="line"></span><br><span class="line">这一题和上一题一样,教我们怎么返回Ok或者抛出异常.</span><br><span class="line"></span><br><span class="line">impl PositiveNonzeroInteger &#123;</span><br><span class="line">    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; &#123;</span><br><span class="line">        // Hmm...? Why is this only returning an Ok value?</span><br><span class="line">        if value &gt; 0&#123;</span><br><span class="line">            Ok(PositiveNonzeroInteger(value as u64))</span><br><span class="line">        &#125;</span><br><span class="line">        else if value == 0&#123;</span><br><span class="line">            Err(CreationError::Zero)</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Err(CreationError::Negative)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">12-5</span><br><span class="line"></span><br><span class="line">main函数能返回Result类型:</span><br><span class="line"></span><br><span class="line">将???改为error::Error,指动态匹配错误的类型.完成了fmt::Display就是error::Error类型了!</span><br><span class="line"></span><br><span class="line">use std::error;</span><br><span class="line">use std::fmt;</span><br><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">// TODO: update the return type of \`main()\` to make this compile.</span><br><span class="line">fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; &#123;</span><br><span class="line">    let pretend_user_input = &quot;42&quot;;</span><br><span class="line">    let x: i64 = pretend_user_input.parse()?;</span><br><span class="line">    println!(&quot;output=&#123;:?&#125;&quot;, PositiveNonzeroInteger::new(x)?);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Don&#x27;t change anything below this line.</span><br><span class="line"></span><br><span class="line">#[derive(PartialEq, Debug)]</span><br><span class="line">struct PositiveNonzeroInteger(u64);</span><br><span class="line"></span><br><span class="line">#[derive(PartialEq, Debug)]</span><br><span class="line">enum CreationError &#123;</span><br><span class="line">    Negative,</span><br><span class="line">    Zero,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl PositiveNonzeroInteger &#123;</span><br><span class="line">    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; &#123;</span><br><span class="line">        match value &#123;</span><br><span class="line">            x if x &lt; 0 =&gt; Err(CreationError::Negative),</span><br><span class="line">            x if x == 0 =&gt; Err(CreationError::Zero),</span><br><span class="line">            x =&gt; Ok(PositiveNonzeroInteger(x as u64))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is required so that \`CreationError\` can implement \`error::Error\`.</span><br><span class="line">impl fmt::Display for CreationError &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;</span><br><span class="line">        let description = match \*self &#123;</span><br><span class="line">            CreationError::Negative =&gt; &quot;number is negative&quot;,</span><br><span class="line">            CreationError::Zero =&gt; &quot;number is zero&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">        f.write_str(description)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl error::Error for CreationError &#123;&#125;</span><br><span class="line"></span><br><span class="line">12-6</span><br><span class="line"></span><br><span class="line">这一个就是在Err(E)中加了点手脚,就是Err(E)中E的类型也是一个Err类型.</span><br><span class="line"></span><br><span class="line">这里是创建了一个新的Err类型,Err类型中有两种不同的枚举值.对于不同的枚举值代表两种不同的错误.</span><br><span class="line"></span><br><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">// This is a custom error type that we will be using in \`parse_pos_nonzero()\`.</span><br><span class="line">#[derive(PartialEq, Debug)]</span><br><span class="line">enum ParsePosNonzeroError &#123;</span><br><span class="line">    Creation(CreationError),</span><br><span class="line">    ParseInt(ParseIntError)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面就是错误的迭代,或者说嵌套…弄清楚错误是可以嵌套的,这道题就很好写了.</span><br><span class="line"></span><br><span class="line">impl ParsePosNonzeroError &#123;</span><br><span class="line">    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError &#123;</span><br><span class="line">        ParsePosNonzeroError::Creation(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fn from_parseint(err: ParseIntError) -&gt; ParsePosNonzeroError&#123;</span><br><span class="line">        ParsePosNonzeroError::ParseInt(err)</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO: add another error conversion function here.</span><br><span class="line">    // fn from_parseint...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn parse_pos_nonzero(s: &amp;str)</span><br><span class="line">    -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: change this to return an appropriate error instead of panicking</span><br><span class="line">    // when \`parse()\` returns an error.</span><br><span class="line">    let x: i64 = match s.parse()&#123;</span><br><span class="line">        Ok(T) =&gt; T,</span><br><span class="line">        Err(E) =&gt; &#123;</span><br><span class="line">            return Err(ParsePosNonzeroError::from_parseint(E));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    PositiveNonzeroInteger::new(x)</span><br><span class="line">        .map_err(ParsePosNonzeroError::from_creation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">13-1</span><br><span class="line"></span><br><span class="line">返回一个Option枚举值,如果时间小于24,就返回Option&lt;i32&gt;,如果大于24,就是不对的值,要返回None.这一题教我们如何返回Option类型的值</span><br><span class="line"></span><br><span class="line">fn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; &#123;</span><br><span class="line">    // We use the 24-hour system here, so 10PM is a value of 22</span><br><span class="line">    // The Option output should gracefully handle cases where time_of_day &gt; 24.</span><br><span class="line">    if time_of_day &gt; 24&#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">    else if time_of_day &gt; 12&#123;</span><br><span class="line">        Some(0)</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        Some(5)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn check_icecream() &#123;</span><br><span class="line">        assert_eq!(maybe_icecream(9), Some(5));</span><br><span class="line">        assert_eq!(maybe_icecream(10), Some(5));</span><br><span class="line">        assert_eq!(maybe_icecream(23), Some(0));</span><br><span class="line">        assert_eq!(maybe_icecream(22), Some(0));</span><br><span class="line">        assert_eq!(maybe_icecream(25), None);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn raw_value() &#123;</span><br><span class="line">        // TODO: Fix this test. How do you get at the value contained in the Option?</span><br><span class="line">        let icecreams = maybe_icecream(12);</span><br><span class="line">        assert_eq!(icecreams, Some(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">13-2</span><br><span class="line"></span><br><span class="line">这一题需要我们了解if-let和while-let的用法,if-let和while-let的核心用法就是匹配.</span><br><span class="line"></span><br><span class="line">if let Some(i) = 一个Option&lt;T&gt;值,当匹配的时候,产生一个新的变量i并且执行下面的操作.while-let也是如此</span><br><span class="line"></span><br><span class="line">核心的思想就是Some(i) = 一个Option值,然后这样可以巧妙地提取Option的内容并且避免冗杂的match表达式</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn simple_option() &#123;</span><br><span class="line">        let target = &quot;rustlings&quot;;</span><br><span class="line">        let optional_target = Some(target);</span><br><span class="line"></span><br><span class="line">        // TODO: Make this an if let statement whose value is &quot;Some&quot; type</span><br><span class="line">        if let Some(word) = optional_target&#123;</span><br><span class="line">            assert_eq!(word, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn layered_option() &#123;</span><br><span class="line">        let mut range = 10;</span><br><span class="line">        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();</span><br><span class="line">        for i in 0..(range + 1) &#123;</span><br><span class="line">            optional_integers.push(Some(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;</span><br><span class="line">        // You can stack \`Option&lt;T&gt;\`&#x27;s into while let and if let</span><br><span class="line"></span><br><span class="line">        while let Some(Some(integer)) = optional_integers.pop() &#123;</span><br><span class="line">            assert_eq!(integer, range);</span><br><span class="line">            range -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">13-3</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let y: Option&lt;Point&gt; = Some(Point &#123; x: 100, y: 200 &#125;);</span><br><span class="line"></span><br><span class="line">    match y &#123;</span><br><span class="line">        Some(ref p) =&gt; println!(&quot;Co-ordinates are &#123;&#125;,&#123;&#125; &quot;, p.x, p.y),</span><br><span class="line">        _ =&gt; println!(&quot;no match&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">    y; // Fix without deleting this line.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再取Option里面的结构体的时候,我们需要知道,结构体在option里面,所有权是归Option值的,后面又访问了一次Option值,所以说y还没有放弃所有权,只能通过引用去访问.(y没有放弃所有权,里面的结构体也是属于y的,y= Some(p)来取数据是不对的)</span><br><span class="line"></span><br><span class="line">14-1</span><br><span class="line"></span><br><span class="line">Vec是一个带有泛型(参数是类型)类型的结构,我们声明的时候需要添加泛型参数.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut shopping_list: Vec&lt;?&gt; = Vec::new();</span><br><span class="line">    shopping_list.push(&quot;milk&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?替换成String就好,因为需要声明为Vec&lt;String&gt;,因为Vec&lt;String&gt;是类型但是Vec&lt;&gt;不是类型.</span><br><span class="line"></span><br><span class="line">14-2</span><br><span class="line"></span><br><span class="line">将这个代码改成泛型,记住函数、结构体、impl块的泛型类型</span><br><span class="line"></span><br><span class="line">struct Wrapper&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Wrapper&lt;T&gt; &#123;</span><br><span class="line">    pub fn new(value: T) -&gt; Self &#123;</span><br><span class="line">        Wrapper &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">15-1</span><br><span class="line"></span><br><span class="line">完成代码,完成AppendBar这个trait,注意trait块里面的接口的返回值有可能是Self类型的,代表和本身是一个类型的.</span><br><span class="line"></span><br><span class="line">trait AppendBar &#123;</span><br><span class="line">    fn append_bar(self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl AppendBar for String &#123;</span><br><span class="line">    //Add your code here</span><br><span class="line">    fn append_bar(mut self) -&gt; String&#123;</span><br><span class="line">        self.push_str(&quot;Bar&quot;);</span><br><span class="line">        self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;Foo&quot;);</span><br><span class="line">    let s = s.append_bar();</span><br><span class="line">    println!(&quot;s: &#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn is_foo_bar() &#123;</span><br><span class="line">        assert_eq!(String::from(&quot;Foo&quot;).append_bar(), String::from(&quot;FooBar&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn is_bar_bar() &#123;</span><br><span class="line">        assert_eq!(</span><br><span class="line">            String::from(&quot;&quot;).append_bar().append_bar(),</span><br><span class="line">            String::from(&quot;BarBar&quot;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">15-2</span><br><span class="line"></span><br><span class="line">trait AppendBar &#123;</span><br><span class="line">    fn append_bar(self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn is_vec_pop_eq_bar() &#123;</span><br><span class="line">        let mut foo = vec![String::from(&quot;Foo&quot;)].append_bar();</span><br><span class="line">        assert_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));</span><br><span class="line">        assert_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">从题目中我们可以知道是要给Vec&lt;String&gt;实现AppendBar这个trait,语法和上面一样</span><br><span class="line"></span><br><span class="line">impl AppendBar for Vec&lt;String&gt;&#123;</span><br><span class="line">    fn append_bar(mut self) -&gt; Vec&lt;String&gt;&#123;</span><br><span class="line">        self.push(&quot;Bar&quot;.to_string());</span><br><span class="line">        self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">15-3</span><br><span class="line"></span><br><span class="line">这一题需要我们修改trait里面方法的默认实现模式</span><br><span class="line"></span><br><span class="line">改成这样:</span><br><span class="line"></span><br><span class="line">pub trait Licensed &#123;</span><br><span class="line">pub trait Licensed &#123;</span><br><span class="line">    fn licensing_info(&amp;self) -&gt; String&#123;</span><br><span class="line">        &quot;Some information&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct SomeSoftware &#123;</span><br><span class="line">    version_number: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct OtherSoftware &#123;</span><br><span class="line">    version_number: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Licensed for SomeSoftware &#123;&#125; // Don&#x27;t edit this line</span><br><span class="line">impl Licensed for OtherSoftware &#123;&#125; // Don&#x27;t edit this line</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn is_licensing_info_the_same() &#123;</span><br><span class="line">        let licensing_info = String::from(&quot;Some information&quot;);</span><br><span class="line">        let some_software = SomeSoftware &#123; version_number: 1 &#125;;</span><br><span class="line">        let other_software = OtherSoftware &#123;</span><br><span class="line">            version_number: &quot;v2.0.0&quot;.to_string(),</span><br><span class="line">        &#125;;</span><br><span class="line">        assert_eq!(some_software.licensing_info(), licensing_info);</span><br><span class="line">        assert_eq!(other_software.licensing_info(), licensing_info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">15-4</span><br><span class="line"></span><br><span class="line">这里需要我们用trait和泛型配合,使得函数的传参只能传已经实现某种trait的结构体</span><br><span class="line"></span><br><span class="line">pub trait Licensed &#123;</span><br><span class="line">    fn licensing_info(&amp;self) -&gt; String &#123;</span><br><span class="line">        &quot;some information&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct SomeSoftware &#123;&#125;</span><br><span class="line"></span><br><span class="line">struct OtherSoftware &#123;&#125;</span><br><span class="line"></span><br><span class="line">impl Licensed for SomeSoftware &#123;&#125;</span><br><span class="line">impl Licensed for OtherSoftware &#123;&#125;</span><br><span class="line"></span><br><span class="line">// YOU MAY ONLY CHANGE THE NEXT LINE</span><br><span class="line">fn compare_license_types(software: ??, software_two: ??) -&gt; bool &#123;</span><br><span class="line">    software.licensing_info() == software_two.licensing_info()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::\*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn compare_license_information() &#123;</span><br><span class="line">        let some_software = SomeSoftware &#123;&#125;;</span><br><span class="line">        let other_software = OtherSoftware &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        assert!(compare_license_types(some_software, other_software));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn compare_license_information_backwards() &#123;</span><br><span class="line">        let some_software = SomeSoftware &#123;&#125;;</span><br><span class="line">        let other_software = OtherSoftware &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        assert!(compare_license_types(other_software, some_software));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">把函数签名改成`fn compare_license_types&lt;T : Licensed,E : Licensed&gt;(software: T, software_two: E) -&gt; bool`就好</span><br><span class="line"></span><br><span class="line">15-5</span><br><span class="line"></span><br><span class="line">这里需要我们再15-4的基础上再进一步,函数的传参只能传已经实现多种trait的结构体.</span><br><span class="line"></span><br><span class="line">// traits5.rs</span><br><span class="line">//</span><br><span class="line">// Your task is to replace the &#x27;??&#x27; sections so the code compiles.</span><br><span class="line">// Don&#x27;t change any line other than the marked one.</span><br><span class="line">// Execute \`rustlings hint traits5\` or use the \`hint\` watch subcommand for a hint.</span><br><span class="line"></span><br><span class="line">// I AM NOT DONE</span><br><span class="line"></span><br><span class="line">pub trait SomeTrait &#123;</span><br><span class="line">    fn some_function(&amp;self) -&gt; bool &#123;</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub trait OtherTrait &#123;</span><br><span class="line">    fn other_function(&amp;self) -&gt; bool &#123;</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct SomeStruct &#123;&#125;</span><br><span class="line">struct OtherStruct &#123;&#125;</span><br><span class="line"></span><br><span class="line">impl SomeTrait for SomeStruct &#123;&#125;</span><br><span class="line">impl OtherTrait for SomeStruct &#123;&#125;</span><br><span class="line">impl SomeTrait for OtherStruct &#123;&#125;</span><br><span class="line">impl OtherTrait for OtherStruct &#123;&#125;</span><br><span class="line"></span><br><span class="line">// YOU MAY ONLY CHANGE THE NEXT LINE</span><br><span class="line">fn some_func(item: ??) -&gt; bool &#123;</span><br><span class="line">    item.some_function() &amp;&amp; item.other_function()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    some_func(SomeStruct &#123;&#125;);</span><br><span class="line">    some_func(OtherStruct &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改成这样就好</span><br><span class="line"></span><br><span class="line">16-1</span><br><span class="line"></span><br><span class="line">assert!(表达式),如果表达式为true还好,表达式为false就panic</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    #[test]</span><br><span class="line">    fn you_can_assert() &#123;</span><br><span class="line">        assert!(1 &lt; 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">16-2</span><br><span class="line"></span><br><span class="line">asserteq!(A,B),A=B是没事,反之panic</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    #[test]</span><br><span class="line">    fn you_can_assert_eq() &#123;</span><br><span class="line">        assert_eq!(1,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">16-3</span><br><span class="line"></span><br><span class="line">自己编写test,挺简单的.</span><br><span class="line"></span><br><span class="line">17-1</span><br><span class="line"></span><br><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;abcd&quot;);</span><br><span class="line">    let string2 = &quot;xyz&quot;;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">书本里的例子,作为函数要去判断传参和返回的引用符不符合生命周期的标准,也就是说传参的生命周期要和返回的生命周期匹配并且满足可以省略的要求,如果不满足可以省略的要求就需要标注生命周期标注</span><br><span class="line"></span><br><span class="line">不满足隐藏的条件显示声明生命周期,统一成一样的.即`fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str`</span><br><span class="line"></span><br><span class="line">17-2</span><br><span class="line"></span><br><span class="line">基于17-1,因为’a作为生命周期泛型,匹配传参中生命周期最短的生命周期,然后把这个生命周期返回出去,但是返回出去的生命周期不能支撑result.</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;long string is long&quot;);</span><br><span class="line">    let result;</span><br><span class="line">    &#123;</span><br><span class="line">        let string2 = String::from(&quot;xyz&quot;);</span><br><span class="line">        result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改成这样:</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;long string is long&quot;);</span><br><span class="line">    &#123;</span><br><span class="line">        let string2 = String::from(&quot;xyz&quot;);</span><br><span class="line">        let result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">        println!(&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">17-3</span><br><span class="line"></span><br><span class="line">结构体里面有引用,则需要保证结构体里面引用成员的生命周期要比结构体长.</span><br><span class="line"></span><br><span class="line">所以说要配一个泛型参数,指定结构体的生命周期是所有引用成员里面最小的那个即可.这就是泛型参数的作用</span><br><span class="line"></span><br><span class="line">struct Book &#123;</span><br><span class="line">    author: &amp;str,</span><br><span class="line">    title: &amp;str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let name = String::from(&quot;Jill Smith&quot;);</span><br><span class="line">    let title = String::from(&quot;Fish Flying&quot;);</span><br><span class="line">    let book = Book &#123; author: &amp;name, title: &amp;title &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; by &#123;&#125;&quot;, book.title, book.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">生命周期是需要在类型后面加上’xxx的,注意一下’xxx的语法</span><br><span class="line"></span><br><span class="line">struct Book&lt;&#x27;a&gt; &#123;</span><br><span class="line">    author: &amp;&#x27;a str,</span><br><span class="line">    title: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let name = String::from(&quot;Jill Smith&quot;);</span><br><span class="line">    let title = String::from(&quot;Fish Flying&quot;);</span><br><span class="line">    let book = Book &#123; author: &amp;name, title: &amp;title &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; by &#123;&#125;&quot;, book.title, book.author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="实验记录" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>南大ics面试记录</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2022/06/06/nju-ics/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2022/06/06/nju-ics/</id>
    <published>2022-06-06T07:21:29.000Z</published>
    <updated>2024-02-27T05:19:04.174Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己水平比较菜,就只敢报个软件所,不敢报lambda,4月份我投了自己的简历,当时不会写statement,statement就写了大概100多个字,太水了2333,然后5月24号通知我去面试,5月25号参加的面试.由于南大是强委员会的学校,所以说组面是比较轻松愉快的,也就是持续问了20分钟而已.但我还是在此给大家分享一下问题吧.</p><p>下面先抛一个简历:水平比较菜不要吐槽捏.当然了交给老师的简历肯定是加相片和真实姓名的.</p><p>面试我的老师是徐经纬副研究员,主要的方向是AI(查谷歌学术查到的),主要是教算法这个本科生课程,但是好巧不巧,我的算法水平非常不好,凭着自己的记忆回忆一下面试的流程吧:</p><p>第一部分是自我介绍,非常经典的面试问题,这一部分是中文作答的,但是我没准备,只介绍了1分钟左右.</p><p>第二部分是一些很基础的算法问题.</p><p>Q1:我们经常提到,归并排序、快速排序和冒泡排序,这几个排序是基于什么的排序?</p><p>Q2:那这些基于比较的排序,你觉得能突破nlogn的复杂度么,发表你的看法.</p><p>Q3:你在算法课上一定学过分治算法,其中归并和快速排序是分治算法的经典例子,那你能说说这两个排序的分治有什么区别或者联系吗?</p><p>Q4:我们知道分治算法是向下划分子问题再向上合并,那快速排序和归并排序的花费主要体现在向下还是向上?</p><p>Q5:问一下关于图的问题,你学过Floyd-Warshall算法,对于算法我们需要维护一个怎样的数据结构?</p><p>Q6:接上面的问题,Floyd-Warshall算法构造了三重循环,想问问这三重分别循环什么.它又是怎么和dp连接上的?</p><p>第三部分看了看我的简历,问了我项目,本来以为会问我xv6或者是CS144的问题,没想到问我组原和OS课设的问题,太爽了</p><p>Q7:我想问问你这个基于MIPS的CPU设计,你做了哪些工作?有哪些印象深刻的点?</p><p>我:巴拉巴拉…</p><p>Q8:那这个PKE操作系统呢?</p><p>我:巴拉巴拉…</p><p>面试官:早知道换一个老师问你了,我不是从事这个底层相关的,要是让蒋老师来问你就好了…</p><p>最后一个部分:唠唠家常</p><p>Q9:你对我们软件所有没有什么想了解的问题?</p><p>我:应该没有吧,以后还可以再联系..</p><p>面试就结束了,用时20分钟…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于自己水平比较菜,就只敢报个软件所,不敢报lambda,4月份我投了自己的简历,当时不会写statement,statement就写了大概100多个字,太水了2333,然后5月24号通知我去面试,5月25号参加的面试.由于南大是强委员会的学校,所以说组面是比较轻松愉快的,</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>做算法题综合</title>
    <link href="https://sukunashinmyoumaru-hust.github.io/2022/04/17/luogu-al/"/>
    <id>https://sukunashinmyoumaru-hust.github.io/2022/04/17/luogu-al/</id>
    <published>2022-04-17T13:10:37.000Z</published>
    <updated>2024-03-25T01:16:56.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洛谷刷题记录-2022"><a href="#洛谷刷题记录-2022" class="headerlink" title="洛谷刷题记录(2022)"></a>洛谷刷题记录(2022)</h1><h4 id="P2367-语文成绩-差分前缀和"><a href="#P2367-语文成绩-差分前缀和" class="headerlink" title="P2367 语文成绩(差分前缀和)"></a>P2367 语文成绩(差分前缀和)</h4><p><strong>题目描述</strong></p><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><p><strong>输入格式</strong></p><p>首先我们需要做一个差分数组,差分数组是数组的两个元素之间的差值.然后对每一个区间做加减运算的时候,我们只需要在首尾处对差分树组进行操作.进行操作.然后再进行合并即可.合并的操作就是给定数组的第一个元素,根据差分数组的定义进行加即可.</p><p>1、首先构造差分数组.</p><p>2、接着对每一次小区间加减进行操作.</p><p>3、然后合并差分数组.</p><p>&#x2F;&#x2F;这个时候还不会stl,甚至还没有养成用宏来开数组的习惯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,p,a[5000005],f[5000005],ans=9999999,sum;</span><br><span class="line">int min(int a,int b)&#123;</span><br><span class="line">    return a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        f[i]=a[i]-a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        f[x]+=z;</span><br><span class="line">        f[y+1]-=z;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=f[i];</span><br><span class="line">        a[i]=sum;</span><br><span class="line">        ans=min(ans,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双倍经验-CF44C-Holiday-差分前缀和"><a href="#双倍经验-CF44C-Holiday-差分前缀和" class="headerlink" title="双倍经验:CF44C Holiday (差分前缀和)"></a>双倍经验:CF44C Holiday (差分前缀和)</h4><p><strong>对于有若干个区间,求一个点被多少个区间覆盖的问题就可以使用差分前缀和的思想.因为答案数组是全0的,对应的差分数组也是全0,输入每一个区间就相当于在这个区间做加1操作.然后合并即可</strong></p><p>那么差分是怎么做的,下面看题:</p><p>天假期，安排个人来浇花，第i个人负责天，问花是否可以每天都被浇水且不重复。 可以的话输出“OK”，不可以的话输出最早出问题的那天的天号以及那天花被浇了多少次水。</p><p>这道题就是有若干个区间,你需要找到每个点被多少个区间覆盖.那么我们可以进行差分,每一次进行+1操作即可,由于一开始数组取值为0,所以说初始的构造差分数组的步骤可以省略&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int a[N];</span><br><span class="line">int b[N];</span><br><span class="line">int k[N];</span><br><span class="line">int n,m;</span><br><span class="line">int flag;</span><br><span class="line">int i;</span><br><span class="line">int ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">        k[a[i]]++;</span><br><span class="line">        k[b[i]+1]--;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        k[i]+=k[i-1];</span><br><span class="line">        if(k[i]!=1)&#123;</span><br><span class="line">            printf(&quot;%d %d&quot;,i,k[i]);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1160-队列安排-队列模版题-包含队列的添加和删除操作"><a href="#P1160-队列安排-队列模版题-包含队列的添加和删除操作" class="headerlink" title="P1160 队列安排(队列模版题,包含队列的添加和删除操作)"></a>P1160 队列安排(队列模版题,包含队列的添加和删除操作)</h4><p>这道题就是一个纯粹的队列的模拟问题,我们可以采用数组模拟链表的策略,就是记录两个数组和,来记录左边和右边的人是谁,就是在i右边的人,是i左边的人是谁,添加的时候先判断是左边还是右边,插入的方法和删除的方法不需要多说了,<strong>这就是一个双向队列的模版</strong>.插入的时候注意插入的顺序即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=2,k,p;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;k,&amp;p);</span><br><span class="line">        if(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            int before=be[k];</span><br><span class="line">            nex[before]=i;nex[i]=k;            </span><br><span class="line">            be[k]=i;be[i]=before;</span><br><span class="line">            if(k==head)    head=i;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            nex[i]=nex[k];nex[k]=i;    </span><br><span class="line">            be[nex[i]]=i;be[i]=k;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    for(int i=1,c;i&lt;=m;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c),t[c]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!t[head])    printf(&quot;%d &quot;,head);</span><br><span class="line">        head=nex[head];</span><br><span class="line">    &#125;</span><br><span class="line">//better delete.</span><br><span class="line">//int be=be[i];</span><br><span class="line">//int nex=nex[i];</span><br><span class="line">//nex[be]=nex;</span><br><span class="line">//be[nex]=be;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a>P1044 栈</h3><p>给定一个数,入栈序列一共有多少个出栈序列.</p><p>本质上是数学题,但是在计算机中比较难以计算.所以说用卡特兰数的定义是直接RE.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int computeCMN(int m, int n) &#123;</span><br><span class="line">if (n == 0  m == n) return 1;</span><br><span class="line">int c1 = computeCMN(m - 1, n);</span><br><span class="line">int c2 = computeCMN(m - 1, n - 1);</span><br><span class="line">return c1 + c2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d&quot;,computeCMN(2\*n,n)-computeCMN(2\*n,n-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们怎么办呢?我们这个时候还知道卡特兰序列有这么一个性质:</p><p>这个时候我们就可以进行递推就可以得到啦!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    nex[0]=1;</span><br><span class="line">    nex[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            nex[i]+=nex[j]\*nex[i-j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,nex[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有一种更加巧妙的.</p><h4 id="P1449-后缀表达式-栈的经典问题"><a href="#P1449-后缀表达式-栈的经典问题" class="headerlink" title="P1449 后缀表达式(栈的经典问题)"></a>P1449 后缀表达式(栈的经典问题)</h4><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p><p>如：对应的后缀表达式为：．．．．。’@’为表达式的结束符号。‘.’为操作数的结束符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char s[100005];</span><br><span class="line">int stack[100005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int top=0,i=0,x;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    while(s[i]!=&#x27;@&#x27;)&#123;</span><br><span class="line">        switch (s[i])</span><br><span class="line">        &#123;</span><br><span class="line">        case &#x27;+&#x27;:stack[--top]+=stack[top+1];break;//出栈之后再进栈</span><br><span class="line">        case &#x27;-&#x27;:stack[--top]-=stack[top+1];break;</span><br><span class="line">        case &#x27;\*&#x27;:stack[--top]\*=stack[top+1];break;</span><br><span class="line">        case &#x27;/&#x27;:stack[--top]/=stack[top+1];break;       </span><br><span class="line">        default:</span><br><span class="line">            x=0;</span><br><span class="line">            while(s[i]!=&#x27;.&#x27;)&#123;</span><br><span class="line">                x=x\*10+s[i++]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top]=x;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,stack[top]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历整个字符串,如果是基本的数字的话就把数字计算(计算方式和C语言学过的一模一样,数字字符串转数字的方法)出来然后入栈.如果是运算符就把栈顶的两个数字取出来做运算符对应的运算然后再放回栈中.</p><h4 id="双倍经验-P1981-表达式求值"><a href="#双倍经验-P1981-表达式求值" class="headerlink" title="(双倍经验) P1981 表达式求值"></a>(双倍经验) P1981 表达式求值</h4><p>给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。</p><p>先输入一个符号然后输入一个数字,然后判断符号的类型,如果是乘的话,优先级最高,就可以先做.取一个数然后乘,如果是加的话就直接把这个数字push进去就好了,因为只用处理乘,剩下的堆栈中存放的就是加法的加数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">int main()&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    int number;</span><br><span class="line">    int n1,n2;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;number);</span><br><span class="line">    num.push(number);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        if(ch==&#x27;\\n&#x27;) break;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;number);</span><br><span class="line">        if(ch==&#x27;\*&#x27;)&#123;</span><br><span class="line">            n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            num.push((n1%MOD)\*(number%MOD));</span><br><span class="line">        &#125;</span><br><span class="line">        if(ch==&#x27;+&#x27;)&#123;</span><br><span class="line">            num.push(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (!num.empty()) &#123;</span><br><span class="line">        sum += num.top();</span><br><span class="line">        sum %= 10000;</span><br><span class="line">        num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1165-日志分析-模拟栈"><a href="#P1165-日志分析-模拟栈" class="headerlink" title="P1165 日志分析(模拟栈)"></a>P1165 日志分析(模拟栈)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int n,p,now,maxn;</span><br><span class="line">int s[200005];</span><br><span class="line">int top=-1;</span><br><span class="line">int max(int x,int y)&#123;</span><br><span class="line">    return x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p);</span><br><span class="line">        if(p==0)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;s[++top]);</span><br><span class="line">            s[top]=max(s[top],s[top-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(top==-1)continue;</span><br><span class="line">            s[top--]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p==2)</span><br><span class="line">            printf(&quot;%d\\n&quot;,s[top]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>操作0（集装箱进库操作，相当于进栈），如果输入的数小于之前的最大值，就仍然存储原来的最大值因为后进先出，当前的如果小，永远不可能被操作2询问到，所以存了也没用，不然入栈，栈顶+1.栈f,就是从到元素的最大值.</li><li>操作1（集装箱出库操作，相当于出栈），直接栈顶-1.因为我们不需要知道最近入栈的元素是什么.所以说我们只需要知道当前所有元素的最大值就好了,一个元素的出栈就是我们不需要再讨论包含它的最大值,仅此而已.栈顶就是少了刚入栈的最大值即可.</li><li>操作2（集装箱询问操作，由于此时的栈顶是最大值，可以直接输出）</li></ol><h4 id="P5788-单调栈模版"><a href="#P5788-单调栈模版" class="headerlink" title="P5788 单调栈模版"></a>P5788 单调栈模版</h4><p>定义函数为第i个元素之后第一个大于的下标,求</p><p>举一个生活中的例子,就是对于若干个人排队,往后看,你可以看到第一个比你高的人,比你矮的人你全部都看不见,会被遮住,所以说这些点我们也不需要考虑了.</p><p>所以我们可以从后往前扫描并且维护一个栈,在栈中小于等于的要删掉,<strong>那么栈顶的就是第一个比大的下标</strong>.因为堆栈具有单调性质,在栈底的下标最大,在栈顶的下标最小.那我们从下标最小的栈顶往下走,找到第一个满足题目条件的下标.不满足题目条件的下标由于之后肯定用不到所以说可以删除.</p><p>最后一步就是这个数入栈.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define N = 3000005;</span><br><span class="line">int a[N], st[N], ans[N];</span><br><span class="line">int top;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">for(int i=n;i&gt;=1;i--) &#123;</span><br><span class="line">while(top&amp;&amp;a[st[top]]&lt;=a[i])top--;</span><br><span class="line">ans[i]=st[top];</span><br><span class="line">st[++top]=i;</span><br><span class="line">&#125; </span><br><span class="line">for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1886-滑动窗口-单调队列模版"><a href="#P1886-滑动窗口-单调队列模版" class="headerlink" title="P1886 滑动窗口&#x2F;单调队列模版."></a>P1886 滑动窗口&#x2F;单调队列模版.</h4><p>有一个长为  的序列，以及一个大小为的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p><p>首先是样例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p>下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。</p><ol><li>由于此时队中没有一个元素，我们直接令1进队。此时，q&#x3D;{1},p&#x3D;{1}。</li><li>现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q&#x3D;{1,3},p&#x3D;{1,2}</li><li>下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从<strong>队尾</strong>出队。同理，1从队尾出队。最后-1进队，此时q&#x3D;{-1},p&#x3D;{3} 输出-1</li><li>出现-3，同上面分析，-1&gt;-3，-1从队尾出队,-3从队尾进队。q&#x3D;{-3}，p&#x3D;{4}。 输出-3</li><li>出现5，因为5&gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q&#x3D;{-3,5},p&#x3D;{4,5} 输出-3</li><li>出现3。3先与队尾的5比较，3&lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q&#x3D;{-3,3},p&#x3D;{4,6}输出-3</li><li>出现6。6与3比较，因为3&lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从<strong>队首</strong>出队。此时，q&#x3D;{3,6},p&#x3D;{6,7} 输出3</li><li>出现7。队尾元素6小于7，7进队。此时，q&#x3D;{3,6,7},p&#x3D;{6,7,8}。 输出3</li></ol><p>总结一下: 假设入队从后往前比较:</p><p>(1)如果:</p><p>入队</p><p>(2)如果</p><p>出队,继续比较,知道队列没有元素或者有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">//stack&lt;int&gt; num;</span><br><span class="line">//stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int xianxu[1000];</span><br><span class="line">int a[10000005],value[100000005],queue1[100000005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    int h=1,t=1;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        //维护单调队列</span><br><span class="line">        while(h&lt;t&amp;&amp;value[t-1]&gt;a[i])t--;</span><br><span class="line">        value[t]=a[i];</span><br><span class="line">        queue1[t++]=i;</span><br><span class="line">        if(i-queue1[h]&gt;=k)h++;</span><br><span class="line">        if(i&gt;=k) printf(&quot;%d &quot;,value[h]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    h=1,t=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(h&lt;t&amp;&amp;value[t-1]&lt;a[i])t--;</span><br><span class="line">        value[t]=a[i];</span><br><span class="line">        queue1[t++]=i;</span><br><span class="line">        if(i-queue1[h]&gt;=k)h++;</span><br><span class="line">        if(i&gt;=k) printf(&quot;%d &quot;,value[h]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UVA540-团体队列-队列模拟"><a href="#UVA540-团体队列-队列模拟" class="headerlink" title="UVA540 团体队列(队列模拟)"></a>UVA540 团体队列(队列模拟)</h4><p>有 个团队的人正在排长队。每有一个新来的人时，他会从队首开始向后搜寻，如果发现有队友正在排队，他就会插队到他队友的身后；如果没有发现任何一个队友排队，他就只好站在长队的队尾。输入每个团队中所有队员的编号，要求支持如下  种指令：<code>ENQUEUE x</code>：编号为 x 的人进入长队。<code>DEQUEUE</code>：长队的队首出队。<code>STOP</code>：停止模拟。对于每个 <code>DEQUEUE</code> 指令，输出出队的人的编号。</p><p>这道题也是一个队列的模拟题,这一道题的难点就是在如何找到队友并插入.构建一个二维数组太慢了,不如我们用一下stl吧,这个stl叫做map,这个map可以帮我们做哈希映射,我们可以在很快的时间内找到序号和对应的分组.</p><p>就是说我们可以首次调用map[x]&#x3D;y,建立的映射,这个映射的查找是的,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MOD 10000</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int t,number=0;</span><br><span class="line">char\* str;</span><br><span class="line">int x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    str=(char\*)malloc(50);</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;t)==1&amp;&amp;t&gt;0)&#123;</span><br><span class="line">        map&lt;int ,int&gt; team;</span><br><span class="line">        printf(&quot;Scenario #%d\\n&quot;,++number);</span><br><span class="line">        for(int i=0;i&lt;t;i++)&#123;</span><br><span class="line">            int n;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">            int code;</span><br><span class="line">            while(n--)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;code);</span><br><span class="line">                team[code]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q,q_sup[100005];</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,str);</span><br><span class="line">            if(\*str==&#x27;S&#x27;) break;</span><br><span class="line">            else if(\*str==&#x27;D&#x27;)&#123;</span><br><span class="line">                x=q.front();</span><br><span class="line">                printf(&quot;%d\\n&quot;,q_sup[x].front());</span><br><span class="line">                q_sup[x].pop();</span><br><span class="line">                if(q_sup[x].empty()) q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else if(\*str==&#x27;E&#x27;)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">                int t=team[x];</span><br><span class="line">                if(q_sup[t].empty())q.push(t);</span><br><span class="line">                q_sup[t].push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始先建立map的映射关系,然后进行操作的时候我们维护一个主队列,主队列里面存储着小组的顺序,然后维护一个小组队列,存储着小组里面有什么人,由于插入的时候只会插入到每个小组的人后面,所以说出队也是按照小组的顺序出队,只有这个小组的所有人都出队了(判断方法,小组队列为空),才轮到另外一个小组出队.所以说入队的时候看看你是不是小组第一个,如果是的话就在主队列排一个队.出队的时候看看你是不是小组最后一个,如果是的话,就出主队列.总之由于出队一定是一个队一个队的顺序出队的,我们只需要记录队与队之间的顺序和队内部的顺序就好了.</p><h3 id="P1162-填涂颜色-简单深搜"><a href="#P1162-填涂颜色-简单深搜" class="headerlink" title="P1162 填涂颜色(简单深搜)"></a>P1162 填涂颜色(简单深搜)</h3><p>由数字组成的方阵中，有一任意形状闭合圈，闭合圈由数字构成，围圈时只走上下左右个方向。现要求把闭合圈内的所有空间都填写成.例如：的方阵（），涂色前和涂色后的方阵如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 1 1 1 1</span><br><span class="line">0 1 1 0 0 1</span><br><span class="line">1 1 0 0 0 1</span><br><span class="line">1 0 0 0 0 1</span><br><span class="line">1 1 1 1 1 1 </span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 1 1 1 1</span><br><span class="line">0 1 1 2 2 1</span><br><span class="line">1 1 2 2 2 1</span><br><span class="line">1 2 2 2 2 1</span><br><span class="line">1 1 1 1 1 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">int N,a[100][100];</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">    if(a[x][y]!=0)return ;</span><br><span class="line">    a[x][y]=-1;</span><br><span class="line">    if(x+1&lt;=N)dfs(x+1,y);</span><br><span class="line">    if(x-1&gt;=1)dfs(x-1,y);</span><br><span class="line">    if(y+1&lt;=N)dfs(x,y+1);</span><br><span class="line">    if(y-1&gt;=1)dfs(x,y-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        if(a[1][i]==0)dfs(1,i);</span><br><span class="line">        else if(a[N][i]==0)dfs(N,i);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        if(a[i][1]==0)dfs(i,1);</span><br><span class="line">        else if(a[i][N]==0)dfs(i,N);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i][1]==-1)printf(&quot;0&quot;);</span><br><span class="line">        else if(a[i][1]==0)printf(&quot;2&quot;);</span><br><span class="line">        else printf(&quot;1&quot;);</span><br><span class="line">        for(int j=2;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i][j]==-1)printf(&quot; 0&quot;);</span><br><span class="line">            else if(a[i][j]==0)printf(&quot; 2&quot;);</span><br><span class="line">            else printf(&quot; 1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是深度优先搜索,从边界开始进行搜索,遇到了可用的点就先进行标记,完后往上下左右搜索,遇到不可用的点(墙)就停止,这个时候没搜索到的就是被墙围起来的那部分.</p><h4 id="P1042-乒乓球-字符串小模拟"><a href="#P1042-乒乓球-字符串小模拟" class="headerlink" title="P1042 乒乓球(字符串小模拟)"></a>P1042 乒乓球(字符串小模拟)</h4><p>![image-20220410195828465](&#x2F;Users&#x2F;xupengzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220410195828465.png)</p><p>不贴代码了,这道题就是模拟题,我们就依次读取,维护两组元素,分别是11分下的胜负和21分下的胜负,用一个数组存储胜负的信息.a[N][0]存储的就是第N局的信息.判断每一局结束的标准就是分数是否超过了11(21)分并且两位选手的分差是不是大于2.</p><h4 id="P1553-数字反转升级版-字符串小模拟"><a href="#P1553-数字反转升级版-字符串小模拟" class="headerlink" title="P1553 数字反转升级版(字符串小模拟)"></a>P1553 数字反转升级版(字符串小模拟)</h4><p>给定一个数，请将该数各个位上数字反转得到一个新数。</p><p>这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为0（除非小数部分除了0没有别的数，那么只保留1个0）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为0），本次没有负数。</p><p>给定一个数，请将该数各个位上数字反转得到一个新数。</p><p>这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。</p><ul><li>整数反转是将所有数位对调。</li><li>小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。</li><li>分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。</li><li>百分数的分子一定是整数，百分数只改变数字部分。</li></ul><p>这次我们来了解一下string的一些操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;iostream&gt;</span><br><span class="line"># include&lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">bool isZero(string s)</span><br><span class="line">&#123;</span><br><span class="line">int j = 0;</span><br><span class="line">for(int i = 0;s[i];++i)</span><br><span class="line">if(s[i] == &#x27;0&#x27;)</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line">if(j == s.length())</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//倒置 </span><br><span class="line">void transpos(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = s1.length()-1,j = 0;i &gt;= 0;--i)</span><br><span class="line">s2 += s1[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//去除前导0</span><br><span class="line">void dePreZero(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">while(s1[i] == &#x27;0&#x27;)</span><br><span class="line">i++;</span><br><span class="line">s2.assign(s1,i,s1.npos);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//去除后缀0</span><br><span class="line">void  deSufZero(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">int i = s1.length()-1;</span><br><span class="line">while(s1[i] == &#x27;0&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">s2.assign(s1,0,i+1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s,ans,tmp;</span><br><span class="line">int idx;//特殊符号的位置 </span><br><span class="line"></span><br><span class="line">getline(cin,s);</span><br><span class="line">if(s.find(&#x27;.&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;.&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">cout &lt;&lt; &#x27;.&#x27;;</span><br><span class="line">tmp.clear();</span><br><span class="line">ans.clear();</span><br><span class="line">tmp.assign(s,idx+1,s.npos);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">deSufZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans; </span><br><span class="line">&#125;</span><br><span class="line">else if(s.find(&#x27;/&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;/&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; &quot;/&quot;;</span><br><span class="line">tmp.clear();</span><br><span class="line">ans.clear();</span><br><span class="line">tmp.assign(s,idx+1,s.npos);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans; </span><br><span class="line">&#125;</span><br><span class="line">else if(s.find(&#x27;%&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;%&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; &#x27;%&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(isZero(s))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(s,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是前面几个辅助的函数,函数的声明里面有一个代表函数对这个变量的修改也会顺便引起对主程序里面变量的修改(和传指针一样).首先是转置函数,从后往前把字符串的值添加到中,由于已经做好了运算符重载,所以我们可以直接用+来进行添加元素的操作.接着就是去除前导0和后置0的,无非就是从前往后遍历和从后往前遍历而已.</p><p>那就分成几种就好办了,第一种就是小数,我们找到小数点,然后把小数点前面的值做一次翻转,去掉前面的0,然后小数点后面的值做一次翻转,去掉后面的0.就可以了 分数也是一样,找到分数符号,下亦同. 百分号,从1~s.length()-1处理即可.去掉前缀0. 整数最简单.</p><h4 id="P1332-Logo语言-字符串递归"><a href="#P1332-Logo语言-字符串递归" class="headerlink" title="P1332 Logo语言(字符串递归)"></a>P1332 Logo语言(字符串递归)</h4><p>Logo 语言命令可以指挥海龟在屏幕中爬行。本问题只使用 Logo 语言的三个语句：前进 <code>FD</code>，倒退 <code>BK</code>和重复 <code>REPEAT</code>，因此，海龟只在一条直线上来回爬行。输入一行 logo 的命令行，输出海龟在屏幕中离开原来位子的距离（假设屏幕很大，可以让海龟移开 1000000010000000 的距离）。</p><p>例如：</p><ul><li>输入 <code>FD 100</code> ，输出：100。</li><li>输入 <code>FD 100 BK 150</code>， 输出：50。</li><li>输入 <code>REPEAT 5[FD 100 BK 50]</code>， 输出：250。</li><li>输入 <code>REPEAT 5[ FD 50 REPEAT 10[FD 100]]</code>， 输出：5250。</li></ul><p>一般来说,遇到带括号的式子,朴素的想法就是递归.对于括号的处理往往是系数*括号内的内容值,括号内的内容也可以理解为一个式子的值,递归的基本条件也达成了.那我们就通过cin来处理字符串,(当然你用一个函数参数表示现在处理到什么位置也可以,或者用一个全局变量也可以).这道题用printf感觉不太行,就用cin了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 100005</span><br><span class="line">#define ll long long</span><br><span class="line">int handle()&#123;</span><br><span class="line">    char ch,x;string a;int n,ans=0;</span><br><span class="line">    while (cin&gt;&gt;ch)&#123;</span><br><span class="line">        if (ch==&#x27;]&#x27;) break;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;n;</span><br><span class="line">        if (ch==&#x27;R&#x27;)&#123;</span><br><span class="line">          //读入‘[’</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans+=n\*handle();</span><br><span class="line">          //读入空格</span><br><span class="line">            x=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        if (ch==&#x27;F&#x27;)&#123;</span><br><span class="line">          //读入空格</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ch==&#x27;B&#x27;)&#123;</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans-=n;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x==&#x27;]&#x27;) break;</span><br><span class="line">    &#125;  </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout&lt;&lt;abs(handle());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先读取一下第一个指令的字符,反正只有几种,一个是FD前进,BK后退和REPEAT重复.那就每一次读取都读取一个字符串(输入剩下来的字符,比如说“EPEAT”,“D”,“K”等).还有一个数字,然后根据功能进入到不同的值中,(如果遇到了]就代表这一层括号已经结束了,可以返回递归的结果).(需要处理括号然后求出括号内的值的就需要用到递归,递归地求出值然后传给主函数)</p><h4 id="P3375-KMP字符串匹配-KMP模版"><a href="#P3375-KMP字符串匹配-KMP模版" class="headerlink" title="P3375 KMP字符串匹配(KMP模版)"></a>P3375 KMP字符串匹配(KMP模版)</h4><p>用字符串匹配就用KMP最好不过了2333</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 1000000+5</span><br><span class="line">using namespace std;</span><br><span class="line">char a[N];</span><br><span class="line">char b[N];</span><br><span class="line">int kmp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,a+1);</span><br><span class="line">    scanf(&quot;%s&quot;,b+1);</span><br><span class="line">    int a_length=strlen(a+1);</span><br><span class="line">    int b_length=strlen(b+1);</span><br><span class="line">    int p;</span><br><span class="line">    for(int i=2;i&lt;=b_length;i++)&#123;</span><br><span class="line">        p=kmp[i-1];</span><br><span class="line">        while(p&amp;&amp;b[p+1]!=b[i])&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        if(b[p+1]==b[i]) kmp[i]=p+1;</span><br><span class="line">    &#125;</span><br><span class="line">    p=0;</span><br><span class="line">    for(int i=1;i&lt;=a_length;i++)&#123;</span><br><span class="line">        if(b[p+1]==a[i]) p++;</span><br><span class="line">        else&#123;</span><br><span class="line">            while(p &amp;&amp; b[p+1]!=a[i])p=kmp[p];</span><br><span class="line">            if(b[p+1]==a[i])p++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==b_length)printf(&quot;%d\\n&quot;,i-b_length+1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=b_length;i++)printf(&quot;%d &quot;,kmp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是KMP数组.就是字符串的前位组成的子串种前j位和后j位一样,比如说””.其中,就是这个字符串前5位的前3位和后3位都是””</p><p>然后就是匹配,不匹配就直接从重新开始,就酱紫…</p><h4 id="P1030-给定中序后序求先序-双倍经验P1827-美国血统"><a href="#P1030-给定中序后序求先序-双倍经验P1827-美国血统" class="headerlink" title="P1030 给定中序后序求先序(双倍经验P1827 美国血统)"></a>P1030 给定中序后序求先序(双倍经验P1827 美国血统)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define N 10</span><br><span class="line">char houxu[N];</span><br><span class="line">char zhongxu[N];</span><br><span class="line">int find(char ch)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(zhongxu[i]!=ch)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int l1,int r1,int l2,int r2)&#123;</span><br><span class="line">    char ch = houxu[r2];</span><br><span class="line">    printf(&quot;%c&quot;,ch);</span><br><span class="line">    int m = find(ch);</span><br><span class="line">    if(m&gt;l1) DFS(l1, m-1,l2,r2-r1+m-1);//r1-m是右子树的数目</span><br><span class="line">    if(m&lt;r1) DFS(m+1, r1, l2-l1+m, r2-1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,zhongxu);</span><br><span class="line">    scanf(&quot;%s&quot;,houxu);</span><br><span class="line">    int len=strlen(zhongxu);</span><br><span class="line">    DFS(0,len-1,0,len-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们在数据结构课中做这种题就是先找到后序遍历中找到根结点.然后根据根结点把中序遍历序列分成两部分.左中右,然后在搜索左子树和右子树.即可,搜索的函数就是(中序遍历首,中序遍历尾,后序遍历首,后序遍历尾).分成左右两个子树进行搜索即可.</p><p>中序:左中右 后序:左右中 然后按照这个规则进行切割,切割出左子树的部分和右子树的部分即可.</p><h4 id="P1087-FBI树-二叉树递归构造和模拟"><a href="#P1087-FBI树-二叉树递归构造和模拟" class="headerlink" title="P1087 FBI树(二叉树递归构造和模拟)"></a>P1087 FBI树(二叉树递归构造和模拟)</h4><p>![image-20220410211808841](&#x2F;Users&#x2F;xupengzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220410211808841.png)</p><p>我们递归判断的时候可以这么做,如果这个树长度只有1,那么我们可以通过这个树的本身来判断究竟是B还是I树.如果这个树的长度比较长,那我们判断左子树和右子树的类型来判断这个树是FBI中的哪一种.进行遍历就好了,所以说甚至建树都不用建,用一个dfs打一个搜索就好啦!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 2000</span><br><span class="line">char str[N];</span><br><span class="line">int n;</span><br><span class="line">int tree(int l,int r)&#123;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        if(str[l]==&#x27;1&#x27;) &#123;</span><br><span class="line">            printf(&quot;I&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;B&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int le,ri;</span><br><span class="line">    if(l&lt;r)&#123;</span><br><span class="line">        le=tree(l,mid);</span><br><span class="line">        ri=tree(mid+1,r);</span><br><span class="line">    &#125;</span><br><span class="line">    if(le==0&amp;&amp;ri==0) &#123;</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(le==1&amp;&amp;ri==1)&#123;</span><br><span class="line">        printf(&quot;I&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;F&quot;);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    scanf(&quot;%s&quot;,str+1);</span><br><span class="line">    tree(1,pow(2,n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3884-二叉树问题-LCA–最近公共祖先-树链剖分"><a href="#P3884-二叉树问题-LCA–最近公共祖先-树链剖分" class="headerlink" title="P3884 二叉树问题(LCA–最近公共祖先,树链剖分)"></a>P3884 二叉树问题(LCA–最近公共祖先,树链剖分)</h4><p><strong>输入格式</strong></p><p>输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。</p><p><strong>输出格式</strong></p><p>三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离.</p><p>注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2， 与由根向叶结点方向（下行方向）时的边数之和。</p><p>这个是非常经典的树的问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int father[N],depth[N],width[N],son[N],parent[N];</span><br><span class="line">int n;</span><br><span class="line">int x,y;</span><br><span class="line">int find_father(int x,int y)&#123;</span><br><span class="line">    if(x==y) return x;</span><br><span class="line">    if(depth[x]==depth[y]) return find_father(parent[x], parent[y]);</span><br><span class="line">    else if(depth[x]&lt;depth[y]) return find_father(x, parent[y]);</span><br><span class="line">    else return find_father(parent[x], y);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    depth[1]=1;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;father[i],&amp;son[i]);</span><br><span class="line">        parent[son[i]]=father[i];</span><br><span class="line">        depth[son[i]]=depth[father[i]]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">    //depth</span><br><span class="line">    int max_depth=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_depth=std::max(max_depth,depth[i]);</span><br><span class="line">        width[depth[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,max_depth);</span><br><span class="line">    int max_width=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_width=std::max(max_width,width[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,max_width);</span><br><span class="line">    int fa=find_father(x,y);</span><br><span class="line">    printf(&quot;%d\\n&quot;,(depth[x]-depth[fa])\*2+(depth[y]-depth[fa]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题就是求深度,由于保证输入的时候按照序号顺序输入的,所以说可以用上面的方法.如果乱序的话还是要遍历一遍树的.求深度的时候用depth[i]表示i结点的深度是depth[i],然后再把每个深度有多少个结点保存起来,这样求宽度也求好了.</p><p>最关键的就是求两个点的距离了.求两个点的距离就是要找到最近的公共祖先,假设祖先为z,首先要从x往上走找到公共祖先,然后再从公共祖先往下走即可,走的步数可以直接用深度差表示.公共祖先找法是,先保持深度一样.然后再往上找,直到父亲是一样的为止.</p><h4 id="P4913-二叉树深度"><a href="#P4913-二叉树深度" class="headerlink" title="P4913 二叉树深度"></a>P4913 二叉树深度</h4><p>求二叉树的深度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 1000005</span><br><span class="line">struct BiTree&#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">&#125;;</span><br><span class="line">struct BiTree tr[N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int se(int root)&#123;</span><br><span class="line">    if(tr[root].l==0&amp;&amp;tr[root].r==0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=0;</span><br><span class="line">    if(tr[root].l)</span><br><span class="line">        l = se(tr[root].l)+1;</span><br><span class="line">    if(tr[root].r)</span><br><span class="line">        r = se(tr[root].r)+1;</span><br><span class="line">    return max(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;tr[i].l,&amp;tr[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    int s = se(1);</span><br><span class="line">    printf(&quot;%d&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用数组来模拟二叉树.Br[l]代表结点号为l的二叉树,成员中l为左子树结点,r为右子树结点.那就是经典前序遍历,检查本结点,遍历左子树和右子树,然后找最大值即可.</p><h4 id="P5318-查找文献-BFS和DFS"><a href="#P5318-查找文献-BFS和DFS" class="headerlink" title="P5318 查找文献(BFS和DFS)"></a>P5318 查找文献(BFS和DFS)</h4><p>给定一个图,寻找DFS和BFS序列.</p><p>在搜索之前我们先排序,因为对于图来说,优先输出数字比较小的元素,将比较小的元素放前面也有助我们排序.然后就是构建一个边的集合,在构建一个链接表,链接表LinkNodes[i]存储着所有起点为i的边的边号.</p><p>接着就是DFS和BFS了,对于BFS,就是维护一个队列,每一次都把没有遍历过且链接的东东入队,做完后取一个出队.DFS就是维护一个栈,栈的表示就是递归,搜索没有遍历过且链接的东东,找到就立刻跳转.对新结点进行搜索.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct edg&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int v;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edg&gt; edgs;</span><br><span class="line">vector&lt;int&gt; LinkNodes[100005];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int n,m;</span><br><span class="line">bool cmp(edg x,edg y)&#123;</span><br><span class="line">    if(x.v==y.v) return x.u&lt;y.u;</span><br><span class="line">    else return x.v&lt;y.v;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs_OK[100005],bfs_OK[100005];</span><br><span class="line">void bfs(int x)&#123;</span><br><span class="line">    q.push(x);</span><br><span class="line">    printf(&quot;%d &quot;,x);</span><br><span class="line">    bfs_OK[x]=true;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int k=q.front();</span><br><span class="line">        for(auto&amp;i:LinkNodes[k])&#123;</span><br><span class="line">            if(!bfs_OK[edgs[i].v])&#123;</span><br><span class="line">                q.push(edgs[i].v);</span><br><span class="line">                printf(&quot;%d &quot;,edgs[i].v);</span><br><span class="line">                bfs_OK[edgs[i].v]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(q.empty()) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    dfs_OK[x]=true;</span><br><span class="line">    printf(&quot;%d &quot;,x);</span><br><span class="line">    for(auto&amp;i:LinkNodes[x])&#123;</span><br><span class="line">        if(!dfs_OK[edgs[i].v]) dfs(edgs[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int x,y;</span><br><span class="line">    int k=m;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">        edgs.push_back((edg)&#123;x,y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edgs.begin(),edgs.end(),cmp);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        LinkNodes[edgs[i].u].push_back(i);</span><br><span class="line">    dfs(1);</span><br><span class="line">    printf(&quot;\\n&quot;);</span><br><span class="line">    bfs(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3371-单元最短路径-邻接表版本"><a href="#P3371-单元最短路径-邻接表版本" class="headerlink" title="P3371 单元最短路径(邻接表版本)"></a>P3371 单元最短路径(邻接表版本)</h4><p>主要的思路就是先从一个点开始,然后计算从A到每个点的距离,找到最小的,假设为,把它标记.,然后再把与x相接的边(注意,边的另一边没有被标记)做一次松弛操作,选出最小的标记,以此类推…</p><ul><li>选出最小的</li><li>标记</li><li>松弛<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 500005</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int weight;</span><br><span class="line">    int next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line">int cnt;</span><br><span class="line">int ans[N];</span><br><span class="line">bool vised[N];</span><br><span class="line">int head[N];</span><br><span class="line">void add(int x,int y,int w)&#123;</span><br><span class="line">    edges[++cnt].to=y;</span><br><span class="line">    edges[cnt].weight=w;</span><br><span class="line">    edges[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">bool songchi(int x,int y,int z)&#123;</span><br><span class="line">    return x+y&lt;z;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int m,n,s;</span><br><span class="line">    int x,y,w;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;m,&amp;n,&amp;s);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        ans[i]=2147483647;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[s]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        add(x, y, w);</span><br><span class="line">    &#125;</span><br><span class="line">    int pos=s;</span><br><span class="line">    while(!vised[pos])&#123;</span><br><span class="line">        long long minn = 1145141919810;</span><br><span class="line">        vised[pos]=1;</span><br><span class="line">        for(int i=head[pos];i!=0;i=edges[i].next)&#123;</span><br><span class="line">            if(!vised[edges[i].to]&amp;&amp;ans[edges[i].to]&gt;ans[pos]+edges[i].weight)&#123;</span><br><span class="line">                ans[edges[i].to]=ans[pos]+edges[i].weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            if(!vised[i]&amp;&amp;ans[i]&lt;minn)&#123;</span><br><span class="line">                pos=i;</span><br><span class="line">                minn=ans[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="P2910-双倍经验-邻接矩阵版本"><a href="#P2910-双倍经验-邻接矩阵版本" class="headerlink" title="P2910 双倍经验(邻接矩阵版本)"></a>P2910 双倍经验(邻接矩阵版本)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define N 101</span><br><span class="line">#define M 10005</span><br><span class="line">int a[N][N];</span><br><span class="line">int ans[N];</span><br><span class="line">bool vised[N];</span><br><span class="line">int weizhi[M];</span><br><span class="line">int n,m,w;</span><br><span class="line">int dj(int x,int y)&#123;</span><br><span class="line">    int pos=x;</span><br><span class="line">    ans[pos]=0;</span><br><span class="line">    while(!vised[pos])&#123;</span><br><span class="line">        long long minn = 1145141919810;</span><br><span class="line">        vised[pos]=1;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(vised[i]) continue;</span><br><span class="line">            if(ans[pos]+a[pos][i]&lt;ans[i])&#123;</span><br><span class="line">                ans[i]=ans[pos]+a[pos][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(!vised[i]&amp;&amp;ans[i]&lt;minn)&#123;</span><br><span class="line">                pos=i;</span><br><span class="line">                minn=ans[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans[y];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;weizhi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">            a[i][j]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=2;i&lt;=m;i++)&#123;</span><br><span class="line">        memset(vised,false,sizeof(vised));</span><br><span class="line">        for (int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">            ans[i]=1145141919;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=dj(weizhi[i-1],weizhi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本是进行了多次查找的,其实也差不多…</p><h4 id="P3367-并查集-往上搜索的树"><a href="#P3367-并查集-往上搜索的树" class="headerlink" title="P3367 并查集(往上搜索的树)"></a>P3367 并查集(往上搜索的树)</h4><p>就是对于N个元素,一开始有N个集合,你需要完成若干次集合的合并和判断操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">int temp[10000];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    while(x!=temp[x]) x=temp[x]=temp[temp[x]];</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);</span><br><span class="line">    int i=1;</span><br><span class="line">    while(i&lt;=N)&#123;</span><br><span class="line">        temp[i]=i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    int op,num1,num2;</span><br><span class="line">    while(M--)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;op,&amp;num1,&amp;num2);</span><br><span class="line">        int fa_a=find(num1),fa_b=find(num2);</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            temp[fa_a]=fa_b;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(fa_a==fa_b)&#123;</span><br><span class="line">                printf(&quot;Y\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(fa_a!=fa_b)&#123;</span><br><span class="line">                printf(&quot;N\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用temp[x]来表示树的父亲,如果<code>temp[x]=自己</code>的话就代表自己是根,对于若干个集合就相当于若干个树,判断是不是在同一个集合就看属于自己的树是不是根就好了,集合的合并也就是确立父子关系而已,这个相当于把两个树合并在一块.</p><h4 id="P3366-最小生成树"><a href="#P3366-最小生成树" class="headerlink" title="P3366 最小生成树"></a>P3366 最小生成树</h4><p>Prim算法:每一次选择权值最小的边,然后标记边的终点.并且保证终点是没有被搜索过的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define re register</span><br><span class="line">#define il inline</span><br><span class="line">il int read()</span><br><span class="line">&#123;</span><br><span class="line">    re int x=0,f=1;char c=getchar();</span><br><span class="line">    while(c&lt;&#x27;0&#x27;c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125;</span><br><span class="line">    while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar();</span><br><span class="line">    return x\*f;</span><br><span class="line">&#125;//快读，不理解的同学用cin代替即可</span><br><span class="line">#define inf 123456789</span><br><span class="line">#define maxn 5005</span><br><span class="line">#define maxm 200005</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">int v,w,next;</span><br><span class="line">&#125;e[maxm&lt;&lt;1];</span><br><span class="line">//注意是无向图，开两倍数组</span><br><span class="line">int head[maxn],dis[maxn],cnt,n,m,tot,now=1,ans;</span><br><span class="line">//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1-&gt;3,2-&gt;3)</span><br><span class="line">bool vis[maxn];</span><br><span class="line">//链式前向星加边</span><br><span class="line">il void add(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">e[++cnt].v=v;</span><br><span class="line">e[cnt].w=w;</span><br><span class="line">e[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//读入数据</span><br><span class="line">il void init()</span><br><span class="line">&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    for(re int i=1,u,v,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read(),v=read(),w=read();</span><br><span class="line">        add(u,v,w),add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">il int prim()</span><br><span class="line">&#123;</span><br><span class="line">//先把dis数组附为极大值</span><br><span class="line">for(re int i=2;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=inf;</span><br><span class="line">&#125;</span><br><span class="line">    //这里要注意重边，所以要用到min</span><br><span class="line">for(re int i=head[1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line">dis[e[i].v]=min(dis[e[i].v],e[i].w);</span><br><span class="line">&#125;</span><br><span class="line">    while(++tot&lt;n)//最小生成树边数等于点数-1</span><br><span class="line">    &#123;</span><br><span class="line">        re int minn=inf;//把minn置为极大值</span><br><span class="line">        vis[now]=1;//标记点已经走过</span><br><span class="line">        //枚举每一个没有使用的点</span><br><span class="line">        //找出最小值作为新边</span><br><span class="line">        //注意这里不是枚举now点的所有连边，而是1~n</span><br><span class="line">        for(re int i=1;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        //枚举now的所有连边，更新dis数组</span><br><span class="line">        for(re int i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">        re int v=e[i].v;</span><br><span class="line">        if(dis[v]&gt;e[i].w&amp;&amp;!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">        dis[v]=e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%d&quot;,prim());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3370-字符串哈希"><a href="#P3370-字符串哈希" class="headerlink" title="P3370 字符串哈希"></a>P3370 字符串哈希</h4><p>直接使用<code>set&lt;string&gt;</code>就好了,这样就可以保证哈希了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;string&gt; a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string p;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //输入string只能用cin...</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        a.insert(p);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,a.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做会不会有点阴啊…</p><p>所以说我们可以使用哈希查找:就是把字符串转化成一个整数,然后对整数排序,看看有没有相等的两个数就好了.(代码略)</p><h4 id="P1908-逆序对-归并排序"><a href="#P1908-逆序对-归并排序" class="headerlink" title="P1908 逆序对(归并排序)"></a>P1908 逆序对(归并排序)</h4><p>求一个数组的逆序对数:</p><p>这里是用归并的方式:判断左边的逆序对数,右边的逆序对数和跨过两边逆序对数.</p><p>为了方便,顺便把左右两边的归并排序也做了(方便统计) 归并排序就是左边归并右边归并,然后归并左右两边(使用双指针,哪边小保存哪边).这个时候可以统计逆序对,只要左边&gt;右边,我们就认为这是一个逆序对.(因为左右已经排好序,我们可以使用线性时间做完).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 1000000</span><br><span class="line">int a[N];</span><br><span class="line">int t[N];</span><br><span class="line">long long ans = 0;</span><br><span class="line">void merge(int l,int r)&#123;</span><br><span class="line">    if(l==r)return;</span><br><span class="line">    int mid=l+r&gt;&gt;1,i=l,k=l,j=mid+1;</span><br><span class="line">    merge(l,mid),merge(mid+1,r);</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        if(a[i]&lt;=a[j])&#123;</span><br><span class="line">            t[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            t[k++]=a[j++];</span><br><span class="line">            ans+=mid-i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid)t[k++]=a[i++];</span><br><span class="line">    while(j&lt;=r)t[k++]=a[j++];</span><br><span class="line">    for(int i=l;i&lt;=r;++i)a[i]=t[i];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    merge(0,n-1);</span><br><span class="line">    printf(&quot;%lld&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1309-双倍经验-逆序对"><a href="#P1309-双倍经验-逆序对" class="headerlink" title="P1309 (双倍经验) 逆序对"></a>P1309 (双倍经验) 逆序对</h4><p>2×<em>N</em> 名编号为 1∼2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第 3名和第 4名、……、第2K−1名和第2K名、…… 、第2N−1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得 0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p><p>这个时候我们就可以使用归并排序了.首先将选手进行排序,然后进行比拼.比拼的时候记录胜者和败者.在这个时候由于胜者都+1分,败者都不加分,所以说记录的胜者和败者都是有序的.有序的前提就是方便我们的归并.归并的方式和我们之前做的事一样的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 200005</span><br><span class="line">int n,m;</span><br><span class="line">int win[N];</span><br><span class="line">int lose[N];</span><br><span class="line">int s[N];</span><br><span class="line">int a[N];</span><br><span class="line">int p[N];</span><br><span class="line">int R,Q;</span><br><span class="line">bool cmp(int x,int y)&#123;</span><br><span class="line">    if(s[x]==s[y]) return x&lt;y;</span><br><span class="line">    else return s[x]&gt;s[y];</span><br><span class="line">&#125;</span><br><span class="line">void merge()&#123;</span><br><span class="line">    int i=1;//the position of win</span><br><span class="line">    int j=1;//the position of lose</span><br><span class="line">    int k=1;</span><br><span class="line">    //我们把win的那一部分和lose的那一部分给归并了,因为我们知道赢的那一部分和输的那一部分是有序的</span><br><span class="line">    while(i&lt;=n/2&amp;&amp;j&lt;=n/2)&#123;</span><br><span class="line">        if(cmp(win[i],lose[j]))&#123;</span><br><span class="line">            a[k++]=win[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[k++]=lose[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=n/2) a[k++]=win[i++];</span><br><span class="line">    while(j&lt;=n/2) a[k++]=lose[j++];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;R,&amp;Q);</span><br><span class="line">    n\*=2;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(a+1, a+n+1, cmp);</span><br><span class="line">    while(R--)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i+=2)&#123;</span><br><span class="line">            if(p[a[i]]&lt;p[a[i+1]])&#123;</span><br><span class="line">                s[a[i+1]]++;</span><br><span class="line">                win[(i-1)/2+1]=a[i+1];</span><br><span class="line">                lose[(i-1)/2+1]=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                s[a[i]]++;</span><br><span class="line">                win[(i-1)/2+1]=a[i];</span><br><span class="line">                lose[(i-1)/2+1]=a[i+1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        merge();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,a[Q]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1090-合并果子"><a href="#P1090-合并果子" class="headerlink" title="P1090 合并果子"></a>P1090 合并果子</h4><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>本来是想打一个区间dp的,但是发现数据样例有一点大,就直接用优先队列了,在这里记录一下优先队列的用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int n,x,ans;</span><br><span class="line">std::priority_queue&lt;int,std::vector&lt;int&gt;,std::greater&lt;int&gt;&gt; queue;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    while(queue.size()/2)&#123;</span><br><span class="line">        int a1=queue.top();</span><br><span class="line">        queue.pop();</span><br><span class="line">        int a2=queue.top();</span><br><span class="line">        queue.pop();</span><br><span class="line">        ans += (a1+a2);</span><br><span class="line">        queue.push(a1+a2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先队列可以保证入队的时候按照你规定的cmp函数来执行排序.</p><h4 id="P1138-最k小整数"><a href="#P1138-最k小整数" class="headerlink" title="P1138 最k小整数"></a>P1138 最k小整数</h4><p>这里就回忆一下sort函数的用法吧~.然后从前到后遍历一遍而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int a[10005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(a+1,a+n+1);</span><br><span class="line">    int temp=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(a[i]&gt;a[i-1]) temp++;</span><br><span class="line">        if(temp==k) &#123;</span><br><span class="line">            printf(&quot;%d&quot;,a[i]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(temp&lt;k) printf(&quot;NO RESULT&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1918-保龄球"><a href="#P1918-保龄球" class="headerlink" title="P1918 保龄球"></a>P1918 保龄球</h4><p>就可以使用一个map就可以了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int,int&gt;maps;</span><br><span class="line">int n,t,q,m;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">        maps[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        printf(&quot;%d\\n&quot;,maps[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6510-奶牛排队"><a href="#P6510-奶牛排队" class="headerlink" title="P6510 奶牛排队"></a>P6510 奶牛排队</h4><p>给定一组数据,从,找到两个一组连续的数,最左边的数是最小的,最右边的数是最大的.</p><p>我们调用单调栈的模版,首先求出A右侧第一个的位置,再求出B左侧第一个的位置.A右侧第一个小于A的数在B的右边,B左侧第一个大于B的数在A左边就可以了.</p><p>然后枚举​,看看最合适的​在哪里,遍历的方法如下:</p><ul><li>首先确定B,B左侧第一个大于B的数位.</li><li>然后确定A,A从K+1开始遍历,然后判断A右侧第一个小于A的位置是不是在B右边</li><li>计算值B的位置-A的位置+1.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct statype&#123;</span><br><span class="line">    int bhei,bpos,ahei,apos;</span><br><span class="line">&#125;sta[100010];</span><br><span class="line">int top=-1;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,ans=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        top++;</span><br><span class="line">        cin&gt;&gt;sta[top].bhei;</span><br><span class="line">        sta[top].ahei=sta[top].bhei;</span><br><span class="line">        sta[top].bpos=i;</span><br><span class="line">        sta[top].apos=i;</span><br><span class="line">        while(sta[top].bhei&gt;sta[top-1].bhei&amp;&amp;top&gt;=1)&#123;</span><br><span class="line">        if(sta[top].ahei&gt;sta[top-1].ahei)&#123;</span><br><span class="line">            sta[top].ahei=sta[top-1].ahei;</span><br><span class="line">            sta[top].apos=sta[top-1].apos;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[top-1]=sta[top];</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&lt;sta[top].bpos-sta[top].apos+1)</span><br><span class="line">        ans=sta[top].bpos-sta[top].apos+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans==1)</span><br><span class="line">    ans=0;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果是遇到了左括号,就递归求括号内的元素.</li><li>如果是遇到了右括号,就把括号内的数据返回给上层.</li><li>如果是遇到了a,就把当前的结果+1即可.</li><li>如果是遇到了,根据max(a,b,c)&#x3D;max(a,max(b,c))的结合率进行递归求解,递归求解右边的值,与当前计算得来的值进行比较.(因为遇到了就代表当前部分的串已经结束了).、</li></ul><h4 id="P3719-rexp"><a href="#P3719-rexp" class="headerlink" title="P3719 rexp."></a>P3719 rexp.</h4><p>给出一个由(,),,a组成的序列，求化简后有多少个a。</p><p>1、形如aa…aaa…aaa…a的，化简结果为“”两边a的个数最多的一项，例如aaaaaa&#x3D;aaa 2、先算带括号的序列，例如(aa)aaa&#x3D;aaa</p><p>依次输入一个字符,分成下面几种情况:</p><ul><li>如果是遇到了左括号,就递归求括号内的元素.</li><li>如果是遇到了右括号,就把括号内的数据返回给上层.</li><li>如果是遇到了a,就把当前的结果+1即可.</li><li>如果是遇到了,根据max(a,b,c)&#x3D;max(a,max(b,c))的结合率进行递归求解,递归求解右边的值,与当前计算得来的值进行比较.(因为遇到了就代表当前部分的串已经结束了).</li></ul><h4 id="P1185-绘制二叉树"><a href="#P1185-绘制二叉树" class="headerlink" title="P1185 绘制二叉树"></a>P1185 绘制二叉树</h4><p>这一题是非常复杂的一个模拟,下面分成几个部分来讲:</p><p>首先是初始化的操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    if(n==1)&#123;</span><br><span class="line">        h=1;</span><br><span class="line">        w=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(n==2)&#123;</span><br><span class="line">        h=3;</span><br><span class="line">        w=5;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        h=3;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)h\*=2;</span><br><span class="line">        w=6\*(1&lt;&lt;(n-2))-1;//计算画布大小</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=w;j++)&#123;</span><br><span class="line">            c[i][j]=&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=1;</span><br><span class="line">    isJiedian[1]=temp;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        temp=temp+g[n-i]+1;</span><br><span class="line">        isJiedian[i+1]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先计算画布的大小,初始化成空格,然后计算对于这个画布,画布的哪几行可以存放点的信息.</p><p>我们用数组来模拟树,用<code>[X][Y]</code>来模拟这是树的第X行和第Y个元素.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">while(m--)&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">    b[x][y]=true;</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">dfs(1,w/2+1,1,1,1);</span><br></pre></td></tr></table></figure><p>然后标记已经被删除的点,从根结点(1,w&#x2F;2+1)开始搜索.</p><p>搜索分成四类,一种是非叶子结点类型.dfs(画布的行,画布的列,树的行,树的列,下一个点的类型)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(k==1)&#123;</span><br><span class="line">    c[x][y]=&#x27;o&#x27;;</span><br><span class="line">    X++;</span><br><span class="line">    Y=Y\*2-1;</span><br><span class="line">    if(!b[X][Y])&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,2);</span><br><span class="line">    &#125;</span><br><span class="line">    Y++;</span><br><span class="line">    if(!b[X][Y])&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非叶子结点可以同时往左和右搜索(前提是这个结点的左儿子和右儿子没有被删掉),X++和Y&#x3D;Y*2-1是计算左儿子和右儿子在模拟数组中的值.</p><p>左下和右下走的列,这种点只能往左或者是右搜索,搜索的变数就是下一行是不是应该存储的是树的结点.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">else if(k==2)&#123;</span><br><span class="line">    c[x][y]=&#x27;/&#x27;;</span><br><span class="line">    if((x+1)==isJiedian[X])&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,1);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    c[x][y]=92;</span><br><span class="line">    if((x+1)==isJiedian[X])&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,1);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一种就是叶子结点,是时候该返回了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x==h)&#123;c[x][y]=&#x27;o&#x27;;return;&#125;</span><br></pre></td></tr></table></figure><h4 id="P3956-棋盘"><a href="#P3956-棋盘" class="headerlink" title="P3956 棋盘"></a>P3956 棋盘</h4><p>有一个m×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。</p><p>任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。另外， 你可以花费 2个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？</p><p>转化为最短路径的问题.首先先构造图,构造图的同时我们需要找到出发点和终点.然后做djkstra算法即可.</p><p>那么怎么构建图?我们可以分成两种形式的问题.</p><ul><li>遍历所有带颜色的点,如果两个点相邻,这两个点之间的距离就是0和1.</li><li>如果这两个点只差了一格,那么距离就是2+0或者1.</li><li>假如说终点是没有颜色的,加上所有点到终点的边.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 1002</span><br><span class="line">int map[N][2],z[N][N],distance[N];</span><br><span class="line">int start,end,flag;</span><br><span class="line">int color[N];</span><br><span class="line">int m,n;</span><br><span class="line">int cloud[N];</span><br><span class="line">void makeGraph()&#123;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(abs(map[i][0]-map[j][0])+abs(map[i][1]-map[j][1])==1)&#123;</span><br><span class="line">                z[i][j]=z[j][i]=abs(color[i]-color[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(abs(map[i][0]-map[j][0])+abs(map[i][1]-map[j][1])==2)&#123;</span><br><span class="line">                z[i][j]=z[j][i]=2+abs(color[i]-color[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(abs(map[i][0]-map[end][0])+abs(map[i][1]-map[end][1])==1)&#123;</span><br><span class="line">                z[i][end]=z[end][i]=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//对每条边进行松弛操作.</span><br><span class="line">void makeDj(int k)&#123;</span><br><span class="line">    distance[k]=0;</span><br><span class="line">    int maxn,t;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        maxn=99999999;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(cloud[j]==0&amp;&amp;distance[j]&lt;maxn)&#123;</span><br><span class="line">                maxn=distance[j];</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cloud[t]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            distance[j]=std::min(distance[t]+z[t][j],distance[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(z,1,sizeof(z));</span><br><span class="line">    memset(distance,1,sizeof(distance));</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;map[i][0],&amp;map[i][1],&amp;color[i]);</span><br><span class="line">      //在这里map记录了每个点的数据,所以说i和j可以代表点的序号</span><br><span class="line">        if(map[i][0]==1&amp;&amp;map[i][1]==1)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(map[i][0]==m&amp;&amp;map[i][1]==m)&#123;</span><br><span class="line">            end=i;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        end=n+1;</span><br><span class="line">        map[end][0]=map[end][1]=m;</span><br><span class="line">    &#125;</span><br><span class="line">    makeGraph();</span><br><span class="line">    makeDj(start);</span><br><span class="line">    if(distance[end]&lt;16843009)</span><br><span class="line">    printf(&quot;%d\\n&quot;,distance[end]);</span><br><span class="line">    else if(m!=1)&#123;</span><br><span class="line">        puts(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        puts(&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="P1983-车站分级-拓扑排序"><a href="#P1983-车站分级-拓扑排序" class="headerlink" title="P1983 车站分级(拓扑排序)"></a>P1983 车站分级(拓扑排序)</h4><p>一条单向的铁路线上，依次有编号为 1,2,…,n的 n个火车站。每个火车站都有一个级别，最低为 1 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）,现在给定了若干个停靠的关系,现在求最多有几级?</p><p>建图,然后拓扑排序即可.</p><p>首先是建图:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while(m--)&#123;</span><br><span class="line">    memset(is, 0, sizeof(is));</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;s);</span><br><span class="line">    for(int i=1;i&lt;=s;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;stations[i]);</span><br><span class="line">        is[stations[i]]=true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=stations[1];i&lt;=stations[s];i++)&#123;</span><br><span class="line">        if(!is[i])&#123;</span><br><span class="line">            for(int j=1;j&lt;=s;j++)&#123;</span><br><span class="line">                if(!tuopu[i][stations[j]]) &#123;</span><br><span class="line">                    tuopu[i][stations[j]]=1;</span><br><span class="line">                    rudu[stations[j]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一条铁路线路,我们有边:<code>[没停靠的站][停靠的站]=1</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int top=1;</span><br><span class="line">while(top)&#123;</span><br><span class="line">    top=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!rudu[i]&amp;&amp;!shanchu[i])&#123;</span><br><span class="line">            ruduweizero[top++]=i;</span><br><span class="line">            shanchu[i]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;top;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(tuopu[ruduweizero[i]][j]) &#123;</span><br><span class="line">                tuopu[ruduweizero[i]][j]=0;</span><br><span class="line">                rudu[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行拓扑排序,把入度为1的点全部删除掉.</p><h4 id="P1038-神经网络"><a href="#P1038-神经网络" class="headerlink" title="P1038 神经网络"></a>P1038 神经网络</h4><p>神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连.这一级传递给下一级的激励是由上一级传递给这一级的激励决定的.</p><p>现在给定每个神经元一开始的激励,然后给定神经元之间的激励传递函数.求输出神经元的输出激励.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define N 105</span><br><span class="line">#define M 10005</span><br><span class="line">int n,p;</span><br><span class="line">struct egdes&#123;</span><br><span class="line">    int y;</span><br><span class="line">    int val;</span><br><span class="line">    int next;</span><br><span class="line">&#125;a[M];</span><br><span class="line">struct answers&#123;</span><br><span class="line">    int val;</span><br><span class="line">    int x;</span><br><span class="line">&#125;ans[N];</span><br><span class="line">int total;</span><br><span class="line">int c[N],u[N],rudu[N],chudu[N],head[M];</span><br><span class="line">int cnt;</span><br><span class="line">std::queue &lt;int&gt; q;</span><br><span class="line">bool vis[N];</span><br><span class="line">void add(int x,int y,int val)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    a[cnt].y=y;</span><br><span class="line">    a[cnt].val=val;</span><br><span class="line">    a[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(struct answers a,struct answers b)&#123;</span><br><span class="line">    return a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  //输入初态</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;p);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;c[i],&amp;u[i]);</span><br><span class="line">      //把初始的结点放入队列</span><br><span class="line">        if(c[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            vis[i]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        else c[i]-=u[i];</span><br><span class="line">    &#125;</span><br><span class="line">  //输入边的构造,链式前向星</span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        int x,y,val;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;val);</span><br><span class="line">        add(x, y, val);</span><br><span class="line">        rudu[y]++;</span><br><span class="line">        chudu[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">  //从初始值开始往后传递,一条边可以进行一次传递,然后把后面的点入队.这样子可以保证按照拓扑排序的顺序来进行遍历.</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int f=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[f]=0;</span><br><span class="line">        //non-exicited</span><br><span class="line">        if(c[f]&lt;0)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //the edge start from front</span><br><span class="line">        for(int i=head[f];i;i=a[i].next)&#123;</span><br><span class="line">            int y=a[i].y;</span><br><span class="line">            c[y]+=a[i].val\*c[f];</span><br><span class="line">            if(!vis[y])&#123;</span><br><span class="line">                q.push(y);</span><br><span class="line">                vis[y]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //计算所有被激活的而且出度为0的值(最终值.)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(c[i]&gt;0&amp;&amp;chudu[i]==0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            ans[total].x=i;</span><br><span class="line">            ans[total].val=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(ans+1,ans+1+total,cmp);</span><br><span class="line">    if(total)&#123;</span><br><span class="line">        for(int i=1;i&lt;=total;i++)&#123;</span><br><span class="line">            printf(&quot;%d %d\\n&quot;,ans[i].x,ans[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1381-单词背诵"><a href="#P1381-单词背诵" class="headerlink" title="P1381 单词背诵"></a>P1381 单词背诵</h4><p>灵梦有 n个单词想要背，但她想通过一篇文章中的一段来记住这些单词。文章由 m个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。</p><p>我们每次记录此时有多少个单词，若比之前多，则直接更新长度与数量。 然后在更新左边 l，若最左边的单词不想背，或后文已出现就更新，把长度去最短即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 100005</span><br><span class="line">std::map&lt;std::string,int&gt; tongji;</span><br><span class="line">std::map&lt;std::string,bool&gt; flags;</span><br><span class="line">std::string s1[N];</span><br><span class="line">std::string s2;</span><br><span class="line">int n,m,l;</span><br><span class="line">int ans1,ans2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        std::cin&gt;&gt;s2;</span><br><span class="line">        flags[s2]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    l++;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        std::cin&gt;&gt;s1[i];</span><br><span class="line">        if(flags[s1[i]]) tongji[s1[i]]++;</span><br><span class="line">        if(tongji[s1[i]]==1) &#123;</span><br><span class="line">            ans1++;</span><br><span class="line">            ans2=i-l+1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l&lt;=i)&#123;</span><br><span class="line">            //不用背</span><br><span class="line">            if(!flags[s1[l]]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //后问已经出现了</span><br><span class="line">            if(tongji[s1[l]]&gt;1)&#123;</span><br><span class="line">                tongji[s1[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ans2=std::min(ans2,i-l+1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n%d\\n&quot;,ans1,ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1002-NOIP2002-普及组-过河卒"><a href="#P1002-NOIP2002-普及组-过河卒" class="headerlink" title="P1002 [NOIP2002 普及组] 过河卒"></a>P1002 [NOIP2002 普及组] 过河卒</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-1024x916.png"></p><p>dp方程:因为小兵只能往下或者右走,我们设一个二维dp数组dp[i][j]表示从起点到坐标为(i,j)的路径数,如果这个点能被马能吃掉的,那就dp[i][j]&#x3D;0,这个可以告诉它下面和右边的点,我这是不能到达的.然后输出dp[N][M]就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&gt;</span><br><span class="line">#include&amp;lt;iostream&gt;</span><br><span class="line">#include&amp;lt;algorithm&gt;</span><br><span class="line">#include&amp;lt;vector&gt;</span><br><span class="line">#include&amp;lt;stack&gt;</span><br><span class="line">#include &amp;lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 40</span><br><span class="line">int t[N];</span><br><span class="line">int a[N][N];</span><br><span class="line">long long dp[N][N];</span><br><span class="line">bool beimalanzhu[N][N]; //判断这个点有没有马拦住</span><br><span class="line">const int madex[] = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;</span><br><span class="line">const int madey[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;</span><br><span class="line">int c,n;</span><br><span class="line">//long long count(long long a,long long b,long long p)&#123;</span><br><span class="line">//    if(b==0) return 1;</span><br><span class="line">//    if(b==1) return a%p;</span><br><span class="line">//    long long c = count(a,b/2,p)%p;</span><br><span class="line">//    return ((b%2==0?1:a)\*c\*c)%p;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int ma_x,ma_y;</span><br><span class="line">    int b_x,b_y;</span><br><span class="line">    scanf(&quot;%d %d %d %d&quot;,&amp;amp;b_x,&amp;amp;b_y,&amp;amp;ma_x,&amp;amp;ma_y);</span><br><span class="line">    ma_x+=2;</span><br><span class="line">    ma_y+=2;</span><br><span class="line">    b_x+=2;</span><br><span class="line">    b_y+=2;</span><br><span class="line">    </span><br><span class="line">    dp[2][1]=1;</span><br><span class="line">    for(int i=0;i&amp;lt;8;i++)&#123;</span><br><span class="line">        beimalanzhu[ma_x+madex[i]][ma_y+madey[i]]=true;</span><br><span class="line">    &#125;</span><br><span class="line">    //忘记讨论马自己了</span><br><span class="line">    beimalanzhu[ma_x][ma_y] = true;</span><br><span class="line">    for(int i=2;i&amp;lt;=b_x;i++)&#123;</span><br><span class="line">        for(int j=2;j&amp;lt;=b_y;j++)&#123;</span><br><span class="line">            if(beimalanzhu[i][j]) continue;</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,dp[b_x][b_y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1095-NOIP2007-普及组-守望者的逃离"><a href="#P1095-NOIP2007-普及组-守望者的逃离" class="headerlink" title="P1095 [NOIP2007 普及组] 守望者的逃离"></a>P1095 [NOIP2007 普及组] 守望者的逃离</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-1-1006x1024.png"></p><p>这个其实我们都知道,根据中学物理的知识都知道我们瞬移最好,但是有这么一种情况,就是你瞬移没蓝了,但是终点离你不远,这时候还不如直接开跑,等在这里等蓝还不如直接run<br>这个时候就有个最优选择了:维护一个一维的dp数组dp[T]来表示到t时间最远能run多远,那我们假设一个dp[t],dp[1,….t-1]都是已知的了,那就可以维护了dp[t]&#x3D;max[dp[t-1]+17,r[t]],r[t]就代表一直瞬移的距离,如果这个时候一直瞬移还不如现在直接跑来得快,那就选跑</p><p>对于这位可怜的人,一直闪现肯定是最优解,但是这里dp其实判断的是,对于这个时刻,没有蓝了,是停在原地回蓝好还是直接撒腿就跑好,是判断这俩的选择的.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#define N 300005</span><br><span class="line">int dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int M,S,T;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;amp;M,&amp;amp;S,&amp;amp;T);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    int run;</span><br><span class="line">    int flash;</span><br><span class="line">    for(int i=1;i&amp;lt;=T;i++)&#123;</span><br><span class="line">        if(M&amp;gt;=10) &#123;</span><br><span class="line">            dp[i]=dp[i-1]+60;</span><br><span class="line">            M-=10;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            dp[i]=dp[i-1];</span><br><span class="line">            M+=4;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=T;i++)&#123;</span><br><span class="line">        if(dp[i]&amp;lt;dp[i-1]+17) dp[i]=dp[i-1]+17;</span><br><span class="line">        if(dp[i]&amp;gt;S)&#123;</span><br><span class="line">            printf(&quot;Yes\\n%d&quot;,i);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;No\\n%d&quot;,dp[T]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h1 id="P1048-NOIP2005-普及组-采药"><a href="#P1048-NOIP2005-普及组-采药" class="headerlink" title="P1048 [NOIP2005 普及组] 采药"></a>P1048 [NOIP2005 普及组] 采药</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-2-1024x941.png"></p><p>动态规划方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int  weigth[105],value[105];</span><br><span class="line">//dp[i][j]代表处理第i个,背包容量还剩下j个</span><br><span class="line">int dp[105][1005];</span><br><span class="line">int total,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;amp;total,&amp;amp;m);</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;amp;weigth[i],&amp;amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        for(int j=total;j&amp;gt;=0;j--)&#123;</span><br><span class="line">            //表示这个元素可以选入</span><br><span class="line">            if(j&amp;gt;=weigth[i])&#123;</span><br><span class="line">                dp[i][j]=max(dp[i-1][j-weigth[i]]+value[i],dp[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //不可以</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dp[m][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1616-疯狂的采药"><a href="#P1616-疯狂的采药" class="headerlink" title="P1616 疯狂的采药"></a>P1616 疯狂的采药</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-4-1024x795.png"></p><p>一维dp数组,dp[m]代表用m的背包就可以获得的最大元素,还是两层循环,外循环是对物品种类进行讨论,内循环对dp方程进行处理,看看对于一个重量$j$,我要不要选择第$i$号元素放入背包中.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;;</span><br><span class="line">#include&lt;iostream&amp;gt;</span><br><span class="line">#include&lt;algorithm&amp;gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int M = 1e7+5;</span><br><span class="line">long long  weigth[M],value[10005];</span><br><span class="line">//dp[i][j]代表处理第i个,背包容量还剩下j个</span><br><span class="line">long long dp[M];</span><br><span class="line">long long total,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld %lld&quot;,&amp;amp;total,&amp;amp;m);</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;amp;weigth[i],&amp;amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        for(int j=weigth[i];j&amp;lt;=total;j++)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-weigth[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,dp[total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h1><h1 id="P1091-NOIP2004-提高组-合唱队形"><a href="#P1091-NOIP2004-提高组-合唱队形" class="headerlink" title="P1091 [NOIP2004 提高组] 合唱队形"></a>P1091 [NOIP2004 提高组] 合唱队形</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-5-1024x841.png"></p><p>这是一个脑筋急转弯类型的题目,第一步就是计算[1,i]的最长上升子序列的长度,记在dp[i][0]中,第二步就是计算[i,n]的最长下降子序列的长度,记在dp[i][1].但是有一点就是这个最长上升子序列长度是要包括自己的.<br>记dp1[i]&#x3D;dp[i][0]+dp[i][1]<br>最后的结果就是需要找到一个点使得dp1[i]最大,这样就代表这个点左右更加光滑.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#define N 105</span><br><span class="line">int a[N];</span><br><span class="line">int dp[N][2];</span><br><span class="line">int res[N];</span><br><span class="line">//dp数组,dp[i][0]</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;amp;n);</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;a[i]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //从左到右扫描</span><br><span class="line">    for(int i=2;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&amp;lt;i;j++)&#123;</span><br><span class="line">            if(a[i]&amp;gt;a[j]&amp;amp;&amp;amp;dp[i][0]&amp;lt;=dp[j][0]+1)&#123;</span><br><span class="line">                dp[i][0]=dp[j][0]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n-1;i&amp;gt;=1;i--)&#123;</span><br><span class="line">        for(int j=i+1;j&amp;lt;=n;j++)&#123;</span><br><span class="line">            if(a[i]&amp;gt;a[j]&amp;amp;&amp;amp;dp[i][1]&amp;lt;=dp[j][1]+1)&#123;</span><br><span class="line">                dp[i][1]=dp[j][1]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        res[i]=dp[i][0]+dp[i][1]+1;</span><br><span class="line">        if(res[i]&amp;gt;result) result=res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,n-result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1439-【模板】最长公共子序列"><a href="#P1439-【模板】最长公共子序列" class="headerlink" title="P1439 【模板】最长公共子序列"></a>P1439 【模板】最长公共子序列</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-6-1024x415.png"></p><p>排列中没有重复元素，俩排列置换后 (重命名) 的 LCS 长度不变:不妨用置换$\sigma$将排列$P_1$$\to$[1:n].  </p><p>这个时候我们可以将排列$P_1$变成[1,2,3,….,n]然后排列$P_2$映射成与$P_1$相匹配的形式.排列$P_2$中第$i$个元素存储的就是原来的元素在$P_1$中的位置  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#include&amp;lt;algorithm&amp;gt;</span><br><span class="line">#define N 100005</span><br><span class="line">using namespace std;</span><br><span class="line">int a[N],b[N],c[N],found[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;amp;n);</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;a[i]);</span><br><span class="line">        c[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;b[i]);</span><br><span class="line">        found[i]=114514;</span><br><span class="line">    &#125;</span><br><span class="line">    int LCS_length=0;</span><br><span class="line">    for (int i=1; i&amp;lt;=n; i++) &#123;</span><br><span class="line">        int l=0,r=LCS_length,mid;</span><br><span class="line">        //如果大于:直接放在后面</span><br><span class="line">        if(c[b[i]]&amp;gt;found[LCS_length])&#123;</span><br><span class="line">            found[++LCS_length]=c[b[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果小于二分查找</span><br><span class="line">        else&#123;</span><br><span class="line">            while (l&amp;lt;r) &#123;</span><br><span class="line">                mid=(l+r)/2;</span><br><span class="line">                if(found[mid]&amp;gt;c[b[i]])&#123;</span><br><span class="line">                    r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    l=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            found[l]=min(c[b[i]],found[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,LCS_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1880-NOI1995-石子合并"><a href="#P1880-NOI1995-石子合并" class="headerlink" title="P1880 [NOI1995] 石子合并"></a>P1880 [NOI1995] 石子合并</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-12-1024x719.png"></p><p>让dp[i][j]代表第i堆到第j堆的合并分数,我们要做的事$dp[i][i+n-1]$最大(小),只需要在区间[i][j]中找到一个最佳的分划k,让i-k,k+1,j这两个区域内部得分和合并这两个区域的得分最大(小),即$max(a[i][k]+a[k+1][j]+d(i,j))$分别代表两个区域的分划和合并两部分的得分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define N 205</span><br><span class="line">int mins[N][N];</span><br><span class="line">int maxs[N][N];</span><br><span class="line">int stones[N];</span><br><span class="line">int sums[N];//前缀和</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;stones[i]);</span><br><span class="line">        sums[i]=sums[i-1]+stones[i];</span><br><span class="line">        stones[i+n]=stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n+1;i&lt;=2\*n;i++)&#123;</span><br><span class="line">        sums[i]=sums[i-1]+stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int length=1;length&lt;n;length++)&#123;</span><br><span class="line">        for(int i=1,j=i+length;j&lt;2\*n&amp;&amp;i&lt;2\*n;i++,j=length+i)&#123;</span><br><span class="line">            mins[i][j]=1145141919;</span><br><span class="line">            for(int k=i;k&lt;j;k++)&#123;</span><br><span class="line">                maxs[i][j]=std::max(maxs[i][j],maxs[i][k]+maxs[k+1][j]+sums[j]-sums[i-1]);</span><br><span class="line">                mins[i][j]=std::min(mins[i][j],mins[i][k]+mins[k+1][j]+sums[j]-sums[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int min_res=114514;</span><br><span class="line">    int max_res=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_res=std::max(max_res,maxs[i][i+n-1]);</span><br><span class="line">        min_res=std::min(min_res,mins[i][i+n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n%d&quot;,min_res,max_res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.6 解码异或后的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) &#123;</span><br><span class="line">        int n=encoded.size()+1;</span><br><span class="line">        vector&lt;int&gt; arr(n);</span><br><span class="line">        arr[0]=first;</span><br><span class="line">        for (int i=1; i&lt;n; i++) &#123;</span><br><span class="line">            arr[i]=arr[i-1]^encoded[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>异或是满足交换律和结合律的,就是x和y异或&#x3D;z,已知x和z,y是能求出来的!</p><p>5.7 数组的异或操作:这个不想说了,太简单了</p><p>5.8 完成工作的最短时间<br>这道题我犯了四个很低级的错误:<br>1.二分查找的时候没有更新mid<br>2.传参数没有传引用,导致所有的结果都没变<br>3.判断能否完成的时候没有考虑刚好完成所带来<br>4.工作时间加了之后,如果判断不行没减回去<br>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。<br>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。<br>返回分配方案中尽可能 最小 的 最大工作时间 。<br>示例 1：<br>输入：jobs &#x3D; [3,2,3], k &#x3D; 3<br>输出：3<br>解释：给每位工人分配一项工作，最大工作时间是 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs">https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>这道题是一道搜索类型的题目,是一道直接搜索答案的题目,总的思路就两点<br>1.主函数做二分搜索<br>2.子函数验证这个结果对不对,来帮助主函数做二分搜索</p><p>这道题要注意一点,要不然时间这一块把握不住<br>1.建议使用贪心算法,就是把大的任务先安排下去<br>2.在任务已经明确不能完成或者说是一定能够完成的情况下自动退出</p><p>判断的方法也稍微提一下:就是给每个工人分配任务,分配任务的形式就是更改一个数组,这个数组存放了每个工人工作的总时间,分配就是依据每个总时间进行分配的,分配的方式就是递归,有一步出现问题就返回报错,到达叶节点(分配完成)就返回OK</p><p>如果有思路,写出代码来还是很简单的,这一种题真的和滑动窗口很像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        sort(jobs.begin(), jobs.end(), greater&lt;int&gt;());</span><br><span class="line">        int first = jobs[0], total = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        //没有达到最优解</span><br><span class="line">        while(first&lt;total)&#123;</span><br><span class="line">            //检查一下mid行不行</span><br><span class="line">            int mid = (first+total)/2;</span><br><span class="line">            if(ok(jobs,k,mid))&#123;</span><br><span class="line">                total=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                first=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    bool ok(vector&lt;int&gt;&amp; jobs, int k, int value)&#123;</span><br><span class="line">        vector&lt;int&gt; workers(k,0);</span><br><span class="line">        return check(jobs,workers,0,value);</span><br><span class="line">    &#125;</span><br><span class="line">    //递归寻找</span><br><span class="line">    bool check (vector&lt;int&gt;&amp; jobs,vector&lt;int&gt; workers, int now,int value)&#123;</span><br><span class="line">        if(jobs.size()&lt;=now)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            int cur=jobs[now];</span><br><span class="line">            for (auto&amp; workload : workers) &#123;</span><br><span class="line">                if (workload+cur&lt;=value) &#123;</span><br><span class="line">                    workload+=cur;</span><br><span class="line">                    if (check(jobs,workers,now+1,value)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    workload-=cur;</span><br><span class="line">                &#125;</span><br><span class="line">                if (workload==0workload+cur==value) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.9 制作花束的最少天数<br>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。<br>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。<br>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。<br>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p><p>示例 1：<br>输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, <em>,</em> , <em>,</em> ] &#x2F;&#x2F; 只能制作 1 束花<br>2 天后：[x, <em>,</em> , <em>, x] &#x2F;&#x2F; 只能制作 2 束花 3 天后：[x,</em> , x, _, x] &#x2F;&#x2F; 可以制作 3 束花，答案为 3</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets">https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>这道题的思路和昨天的其实很像,就说说判断在某一天之内能否生产那么多花束的思路:其实就是一个遍历+模拟就可以完成的,就是假设这一天已经来到,看看有哪些花盛开了.就取哪些花,有连续的几朵就可以组成一个花束,这么简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123;</span><br><span class="line">        if(bloomDay.size()&lt;m\*k)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int high=0,low=INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; bloomDay.size(); i++) &#123;</span><br><span class="line">            low=min(low, bloomDay[i]);</span><br><span class="line">            high=max(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(high&gt;low)&#123;</span><br><span class="line">            int mid=(high+low)/2;</span><br><span class="line">            if(check(bloomDay,m,k,mid))&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                low=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">    bool check(vector&lt;int&gt;&amp; bloomDay, int m, int k,int days)&#123;</span><br><span class="line">        int hua=0,huashu=0;</span><br><span class="line">        for(int i=0;i&lt;bloomDay.size()&amp;&amp;huashu&lt;m;i++)&#123;</span><br><span class="line">            if(bloomDay[i]&lt;=days)&#123;</span><br><span class="line">                hua++;</span><br><span class="line">                if(hua==k)&#123;</span><br><span class="line">                    huashu++;</span><br><span class="line">                    hua=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                    hua=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return huashu&gt;=m;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面两题向我们展示了一个利用二分搜索搜索答案的思路:<br>1.主函数二分搜索<br>2.子函数验证<br>众所周知,求解比验证难许多</p><p>5.10 叶子相似的树</p><p>前序遍历就可以了.前序遍历能保证叶子是从左到右被遍历到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool leafSimilar(TreeNode\* root1, TreeNode\* root2) &#123;</span><br><span class="line">        vector&lt;int&gt; a1;</span><br><span class="line">        vector&lt;int&gt; a2;</span><br><span class="line">        if(root1) forwardTraverse(root1,a1);</span><br><span class="line">        if(root2) forwardTraverse(root2,a2);</span><br><span class="line">        return a1==a2;</span><br><span class="line">    &#125;</span><br><span class="line">    void forwardTraverse(TreeNode\* root,vector&lt;int&gt;&amp;list)&#123;</span><br><span class="line">        if(!(root-&gt;left)&amp;&amp;!(root-&gt;right))&#123;</span><br><span class="line">            list.push_back(root-&gt;val);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left) forwardTraverse(root-&gt;left,list);</span><br><span class="line">        if(root-&gt;right) forwardTraverse(root-&gt;right,list);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.11 解码异或后的排列<br>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。<br>它被加密成另一个长度为 n – 1 的整数数组 encoded ，满足 encoded[i] &#x3D; perm[i] XOR perm[i + 1] 。比方说，如果 perm &#x3D; [1,3,2] ，那么 encoded &#x3D; [2,1] 。<br>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。<br>示例 1：<br>输入：encoded &#x3D; [3,1]<br>输出：[1,2,3]<br>解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]<br>示例 2：</p><p>之前我们就做过异或之后的数组怎么解码:最重要的就是寻找到那个first元素,这里我们也可以寻找到first元素</p><p>我们知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-c34b52deeb305f9413f534b570f9fed7_l3.svg" alt="x\lxor x=0">,那我们寻找到第一个元素,就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-131d0c2aa952b43d45bba07dfc407e81_l3.svg" alt="(x_0\oplus x_1\oplus x_2...\oplus x_n)\oplus (x_1 \oplus x_2\oplus x_3....x_n)=x1"></p><p>我们还知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-dbe284a90142f25d096bec9394436c2a_l3.svg" alt="encode[2k+1]=a[2k]\oplus a[2k+1]">刚好对所有奇数元素的数列一异或就可以把上述式子异或符号右边的元素求出来</p><p>注意,原来的数据是从1-n的排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encode) &#123;</span><br><span class="line">        int n=encode.size()+1;</span><br><span class="line">        vector&lt;int&gt; decode(n,0);</span><br><span class="line">        int total=0;</span><br><span class="line">        int except_0=0;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">            total=total^i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n;i+=2)&#123;</span><br><span class="line">            except_0=except_0^encode[i];</span><br><span class="line">        &#125;</span><br><span class="line">        decode[0]=except_0^total;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            decode[i]=decode[i-1]^encode[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return decode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.12 字数组异或查询<br>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。<br>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。<br>并返回一个包含给定查询 queries 所有结果的数组。<br>示例 1：<br>输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8]<br>解释：<br>数组中元素的二进制表示形式是：<br>1 &#x3D; 0001<br>3 &#x3D; 0011<br>4 &#x3D; 0100<br>8 &#x3D; 1000<br>查询的 XOR 值为：<br>[0,1] &#x3D; 1 xor 3 &#x3D; 2<br>[1,2] &#x3D; 3 xor 4 &#x3D; 7<br>[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14<br>[3,3] &#x3D; 8</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray">https://leetcode-cn.com/problems/xor-queries-of-a-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>一个式子就可以明白:这里截取官方题解了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        vector&lt;int&gt; xors(arr.size()+1);</span><br><span class="line">        for (int i=0;i&lt;arr.size();i++) &#123;</span><br><span class="line">            xors[i+1]=xors[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(vector&lt;int&gt;temp:queries)&#123;</span><br><span class="line">            int total=0;</span><br><span class="line">            total=xors[temp[0]]^xors[temp[1]+1];</span><br><span class="line">            result.push_back(total);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.13 停在原地的方案数<br>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。<br>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。<br>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。<br>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。<br>示例 1<br>输入：steps &#x3D; 3, arrLen &#x3D; 2<br>输出：4<br>解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。<br>向右，向左，不动<br>不动，向右，向左<br>向右，不动，向左<br>不动，不动，不动</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps">https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int MODULO = 1000000007;</span><br><span class="line">    int numWays(int steps, int arrLen) &#123;</span><br><span class="line">        int maxc=min(arrLen-1,steps/2);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(steps+1, vector&lt;int&gt;(maxc+1));</span><br><span class="line">        dp[0][0]=1;</span><br><span class="line">        for(int i=1;i&lt;=steps;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=maxc;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j];</span><br><span class="line">                if(j-1&gt;=0)&#123;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i-1][j-1])%MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j+1&lt;=maxc)&#123;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i-1][j+1])%MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[steps][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划:dp[行动的步数][获得的这个结果]&#x3D;走的方案数<br>官方题解还可以优化,比如说压缩到一维动态规划<br>动态规划最重要的就是:初态+状态转移,这里的初态:<br><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-076590b86ba207ce143e94b2e823ad03_l3.svg" alt="dp[0][0]=1,dp[0][i]=0">,状态转移:来源于三个操作:一个是向左,一个是向右,一个是不动:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8c01feeb7f41da7bdd5ef7afa96f778d_l3.svg" alt="dp[i][j]=dp[i-1][j]+dp[i-1][j+1]+dp[i-1][j-1](if j+1,j-1 exists)"></p><p>5.14 整数转罗马数字<br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>变相的数位转换罢了,注意的是1000-900-500-400-100-90-50-40-10-9-5-4-1这套转化法则,一开始就是没反应过来23333</p><p>5.15 罗马数字转整数</p><p>还是一样的,读取罗马数字,如果下一个罗马数字对应的值比我这个大,那么说明应该是IX之类的问题,就要减去这个罗马数字对应的值如果小,就加这个罗马数字对应的值就行</p><p>5.16 数组中最大的异或值</p><p><strong>输入：</strong>nums &#x3D; [3,10,5,25,2,8]<br><strong>输出：</strong>28<br><strong>解释：</strong>最大运算结果是 5 XOR 25 &#x3D; 28.</p><p>这个代码是题解里面的</p><p>第一种方法是贪心算法,就是我们已经知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-062b76d533174cda72c813758355544f_l3.svg" alt="x=a_i \oplus a_j">所以说我们就假设x,然后找有没有适合的a_i和a_j就好了,我们按位查找,从高位到低位查找:<br>首先看最高位有没有<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-259b6415756adf3480ea5e8a80d1d578_l3.svg" alt="a_i\oplus a_j=x">有的话就取1:就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg" alt="2x+1">没有的话就取0,就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg" alt="2x">,以此类推</p><p>第二种方法就是字典法:</p><p>这个是一个字典树,每个元素从高位到低位按照0和1的顺序建立树<br>当检查x的最大性的时候的做法:<br>因为要让异或最大,那就读取一个数,从高位到低位判断,如果这个位为0,那就看看这个位有没有位1的数,反之亦然.有的话异或的值就可以<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg" alt="2x+1">,没有的话就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg" alt="2x"></p><p>这里需要说明一下二进制的求值方法:从高位到低位扫描,扫描到1的话<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-73e0257639a78306bcf13ad0c68fcbdb_l3.svg" alt="2y+1">,扫描到0的时候就为<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-85ca23a1e42ccdfafecd1cf9622b44c3_l3.svg" alt="2y"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">struct Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    Trie\* left = nullptr;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    Trie\* right = nullptr;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie\* root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    static constexpr int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void add(int num) &#123;</span><br><span class="line">        Trie\* cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int check(int num) &#123;</span><br><span class="line">        Trie\* cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x \* 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x \* 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x \* 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x \* 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            add(nums[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.17 二叉树的堂兄弟节点</p><p>这个东西就是做一遍二叉树的遍历,找到:层数+父节点,比较就行了.传参数比较麻烦的话就开全局变量就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // x 的信息</span><br><span class="line">    int x;</span><br><span class="line">    TreeNode\* x_parent;</span><br><span class="line">    int x_depth;</span><br><span class="line"></span><br><span class="line">    // y 的信息</span><br><span class="line">    int y;</span><br><span class="line">    TreeNode\* y_parent;</span><br><span class="line">    int y_depth;</span><br><span class="line"></span><br><span class="line">    void level1(TreeNode\* root,int x,int k)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val==x)&#123;</span><br><span class="line">            x_depth=k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            level1(root-&gt;left,x,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            level1(root-&gt;right,x,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void level2(TreeNode\* root,int y,int k)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val==y)&#123;</span><br><span class="line">            y_depth=k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            level2(root-&gt;left,y,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            level2(root-&gt;right,y,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void parent2(TreeNode\* root,int y)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val==y)&#123;</span><br><span class="line">            y_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val==y)&#123;</span><br><span class="line">            y_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            parent2(root-&gt;left,y);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            parent2(root-&gt;right,y);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void parent1(TreeNode\* root,int x)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val==x)&#123;</span><br><span class="line">            x_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val==x)&#123;</span><br><span class="line">            x_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            parent1(root-&gt;left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            parent1(root-&gt;right,x);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isCousins(TreeNode\* root, int x, int y) &#123;</span><br><span class="line">        parent1(root,x);</span><br><span class="line">        parent2(root,y);</span><br><span class="line">        level1(root,x,0);</span><br><span class="line">        level2(root,y,0);</span><br><span class="line">        return (x_depth==y_depth)&amp;&amp;(x_parent!=y_parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.18 形成两个异或相等的三元组数目</p><p>给你一个整数数组 arr 。<br>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;&#x3D; i &lt; j &lt;&#x3D; k &lt; arr.length) 。<br>a 和 b 定义如下：<br>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j – 1]<br>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]<br>注意：^ 表示 按位异或 操作。<br>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>还是那张图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countTriplets(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int count=arr.size();</span><br><span class="line">        vector&lt;int&gt; abab(count+1);</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            abab[i+1]=abab[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;count;j++)&#123;</span><br><span class="line">                for(int k=j;k&lt;count;k++)&#123;</span><br><span class="line">                    if(abab[i]==abab[k+1])&#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5.19 找出第K大的异或坐标值</p><p>最近力扣是和这个公式杠上了么…,这道题就是一个模拟就行的了,但是我们可以建表来记录(m,k)之内的元素异或的和,这三项刚好可以表示</p><p>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。<br>矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;&#x3D; i &lt;&#x3D; a &lt; m 且 0 &lt;&#x3D; j &lt;&#x3D; b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。<br>请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。<br>示例 1：<br>输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1<br>输出：7<br>解释：坐标 (0,1) 的值是 5 XOR 2 &#x3D; 7 ，为最大的值。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value">https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;洛谷刷题记录-2022&quot;&gt;&lt;a href=&quot;#洛谷刷题记录-2022&quot; class=&quot;headerlink&quot; title=&quot;洛谷刷题记录(2022)&quot;&gt;&lt;/a&gt;洛谷刷题记录(2022)&lt;/h1&gt;&lt;h4 id=&quot;P2367-语文成绩-差分前缀和&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="杂记" scheme="https://sukunashinmyoumaru-hust.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
