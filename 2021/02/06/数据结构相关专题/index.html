<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="树1.树的有关定义和术语1.术语1.树（tree):树是n(n≥0)个结点的有限集T,当n&#x3D;0时，T为空树；当n&gt;0时,(1)有且仅有一个称为T的根的结点,(2)当n&gt;1时,余下的结点分为m(m&gt;0)个互不相交的有限集,,…, ,每个Ti(1≤i≤m)也是一棵树,且称为根的子树。这个定义是递归的,是一层套一层的  树的定义都是一级套一级的 2.结点的度(degree):">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构相关专题">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="树1.树的有关定义和术语1.术语1.树（tree):树是n(n≥0)个结点的有限集T,当n&#x3D;0时，T为空树；当n&gt;0时,(1)有且仅有一个称为T的根的结点,(2)当n&gt;1时,余下的结点分为m(m&gt;0)个互不相交的有限集,,…, ,每个Ti(1≤i≤m)也是一棵树,且称为根的子树。这个定义是递归的,是一层套一层的  树的定义都是一级套一级的 2.结点的度(degree):">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-618f46a9ddcaebb0fd0160ec0f2e5496_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ea1bcdd3ea46bc1cc5d0e3157998599a_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-157f30459e104b25ffb600c70be0c70b_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-1-1024x704.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-2.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-3.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-695d9d59bd04859c6c99e7feb11daab6_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-91cd221bd61623774d67d47c45110976_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6c7a5a39d7690a4967ac55d6255eeeff_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6c7a5a39d7690a4967ac55d6255eeeff_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-fc7c93845426d9d18bdeba6fb6bc6821_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-4-1024x639.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-5-1024x323.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-3a31add7e720dead9b92e8a3580a5a05_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-6-1024x627.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-7-1024x668.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-8-1024x676.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-9-1024x706.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-10-1024x689.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-11.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-12-1024x630.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-13-1024x616.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-14-1024x683.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-18-1024x741.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-19.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-15.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-16-1024x714.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-17-1024x643.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-20-1024x671.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-21-1024x599.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-22-1024x726.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-23-1024x679.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-24-1024x733.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-25-1024x654.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-26-1024x713.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-c9d2b688b0c3a0b0f5e2c65833b340d4_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-183e391544bdec00c0d0978c23c4982a_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-27-1024x660.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-28-1024x903.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-29-1024x757.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-478c7dbb76fc8e5b0b52edad79847b31_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-478c7dbb76fc8e5b0b52edad79847b31_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-30-1024x657.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-31.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-82a18ef57600e3aa4bea85ff07f6c358_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-32-1024x662.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-33.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-34-1024x369.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-35-1024x409.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-36.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-37-1024x721.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-38-1024x714.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-39-1024x547.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-40-1024x695.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-41-1024x587.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-42-1024x623.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-43-1024x745.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-44-1024x755.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-45-1024x757.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-46-1024x772.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-47-1024x750.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-48-1024x762.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-49-1024x618.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-50-1024x706.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/10/image-51-1024x670.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-1024x771.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-7.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-8-1024x637.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6f1958c79da2263f659595e986dd20a5_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-9.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-5fca13df3a8bf1c72af05b3b530665ed_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-10-1024x746.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-12-1024x441.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-073146ae056a8f4f00ab453fb5bdbf1d_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-13-1024x701.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-14-1024x701.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-15-1024x736.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-16-1024x771.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-17-1024x627.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-19-1024x723.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-20-1024x746.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-21-1024x620.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-22-1024x766.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-23-1024x772.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-27.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-28-1024x607.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-29.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-30-1024x689.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-31.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-32.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-33-1024x721.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-34-1024x686.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-35-1024x711.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-36.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-37.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-38-1024x732.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-e62441dc3fec6b2e6c96754d2eb3ea5e_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-31c2cdca867987ac2a6e27b1434ae748_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-22a4dafb17035ef91361c6a58809420f_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-43-852x1024.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ed392a9187fc44b002c7f34039bceffb_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ed392a9187fc44b002c7f34039bceffb_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-d1a0977d9e713b6eb464199427db69ec_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-42.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-07ce0328ccb22f350ed439f36f77fd84_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-43d0a3104bdc468e0aa362b3b2129224_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8a4da773c29ce91d743867baab6e88d1_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-07ce0328ccb22f350ed439f36f77fd84_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-e4c9ffb6b7150926f5ce18b72cddae3b_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8a4da773c29ce91d743867baab6e88d1_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-40.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-b88d2ed52fc70c959cc939c76a09d9ec_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-39.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2020/11/image-41.png">
<meta property="article:published_time" content="2021-02-06T03:26:24.000Z">
<meta property="article:modified_time" content="2024-02-27T05:01:50.117Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-618f46a9ddcaebb0fd0160ec0f2e5496_l3.svg">
    
    
      
        
          <link rel="shortcut icon" href="/project/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/project/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/project/images/favicon-192x192.png">
        
      
    
    <!-- title -->
    <title>数据结构相关专题</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/project/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/project/2021/04/25/%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6verilog%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&text=数据结构相关专题"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&is_video=false&description=数据结构相关专题"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=数据结构相关专题&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&name=数据结构相关专题&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&t=数据结构相关专题"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E6%9C%89%E5%85%B3%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">1.树的有关定义和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">2.二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">3.二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.4.</span> <span class="toc-text">3.树和森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Huffman%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">4.Huffman树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.1.</span> <span class="toc-text">1.图的定义和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.图的存储形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">3.图的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">4.最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%BA%94%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">4.有向无环图应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">5 最短路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text">1 顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.2.</span> <span class="toc-text">2 二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3 索引顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">3.4.</span> <span class="toc-text">4 二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">5 平衡二叉树(AVL树)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 简单插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2.折半插入排序（二分插入排序）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F-%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3.希尔(shell)排序 (缩小增量排序)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 简单选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 树形选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5 基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text">6 计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.7.</span> <span class="toc-text">7 排序算法的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">2 线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">3 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A0%88"><span class="toc-number">8.1.</span> <span class="toc-text">3.1 栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%98%9F%E5%88%97"><span class="toc-number">8.2.</span> <span class="toc-text">3.2 队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">4 串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">5 数组</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        数据结构相关专题
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Sukuna</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-02-06T03:26:24.000Z" class="dt-published" itemprop="datePublished">2021-02-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/project/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="1-树的有关定义和术语"><a href="#1-树的有关定义和术语" class="headerlink" title="1.树的有关定义和术语"></a>1.树的有关定义和术语</h4><p>1.术语<br>1.树（tree):<br>树是n(n≥0)个结点的有限集T,<br>当n&#x3D;0时，T为空树；<br>当n&gt;0时,<br>(1)有且仅有一个称为T的根的结点,<br>(2)当n&gt;1时,余下的结点分为m(m&gt;0)个互不相交的有限集<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-618f46a9ddcaebb0fd0160ec0f2e5496_l3.svg" alt="T_1">,<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ea1bcdd3ea46bc1cc5d0e3157998599a_l3.svg" alt="T_2">,…,<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-157f30459e104b25ffb600c70be0c70b_l3.svg" alt="T_m"> ,每个Ti(1≤i≤m)也是一棵树,且称为根的子树。<br>这个定义是递归的,是一层套一层的</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-1-1024x704.png"></p>
<p>树的定义都是一级套一级的</p>
<p>2.结点的度(degree):<br>结点的子树数目<br>3.树的度:<br>树中各结点的度的最大值<br>4.n度树: 度为n的树<br>&#x2F;&#x2F;注意这里度和图的度之间的区别<br>&#x2F;&#x2F;2度树一定是二叉树,二叉树不一定是二度树<br>5.叶子(终端结点): 度为0的结点<br>6.分枝结点(非终端结点,非叶子):<br>度不为0的结点<br>7.双亲(父母,parent)和孩子(儿子,child) :<br>若结点C是结点P的子树的根,称P是C的双亲，C是P的孩子。<br>8.结点的层(level):<br>规定树T的根的层为1，其余任一结点的层等于其双亲的层加1。<br>9.树的深度(depth,高度):<br>树中各结点的层的最大值。<br>10.兄弟(sibling):<br>同一双亲的结点之间互为兄弟。<br>11.堂兄弟:<br>同一层号的结点互为堂兄弟。<br>12.祖先: 从树的根到某结点所经分枝上的所有结点为该结点的祖先。<br>13.子孙: 一个结点的所有子树的结点为该结点的子孙。<br>14.有序树:若任一结点的各棵子树，规定从左至右是有次序的,即不能互换位置,则称该树为有序树。 二叉树一般是有序的<br>15.无序树: 若任一结点的各棵子树，规定从左至右是无次序的,即能互换位置,则称该树为无序树。普通的树一般是无序的<br>16.森林: m(m≥0)棵互不相交的树的集合。</p>
<p>2.其他表现形式<br>1.广义表表现形式</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-2.png"></p>
<p>广义表其实就是一种树,一环套一环</p>
<p>2.Venn图嵌套集合<br>3.书目表</p>
<h4 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h4><p>1.二叉树的递归定义<br>二叉树是有限个结点的集合，它或者为空集；或者是由一个根结点和两棵互不相交的，且分别称为根的左子树和右子树的二叉树所组成。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-3.png"></p>
<p>二叉树的五种功能,T4和T5</p>
<p>2、二叉树的一些性质<br>(1)二叉树的第<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-695d9d59bd04859c6c99e7feb11daab6_l3.svg" alt="i">层最多有<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-91cd221bd61623774d67d47c45110976_l3.svg" alt="2^{i-1}">个结点,<br>(2)深度为k的二叉树最多有<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6c7a5a39d7690a4967ac55d6255eeeff_l3.svg" alt="2^k-1">个结点<br>&#x2F;&#x2F;这个性质可以由等比数列的前n项和推出来<br>(3)叶子的数目&#x3D;度为2的结点数目+1<br>(4)满二叉树:深度为k,且结点数目为<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6c7a5a39d7690a4967ac55d6255eeeff_l3.svg" alt="2^k-1">的二叉树,这个时候满二叉树的深度为<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-fc7c93845426d9d18bdeba6fb6bc6821_l3.svg" alt="log_2(n+1)"><br>对于满二叉树的每一个结点,有以下性质</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-4-1024x639.png"></p>
<p>堆排序里会用到这个性质,堆就是个完全二叉树</p>
<p>5.完全二叉树（full binary tree):<br>深度为k的有n个结点的二叉树,当且仅当每一个结点都与同深度的满二叉树中编号从1至n的结点一一对应,称之为完全二叉树</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-5-1024x323.png"></p>
<p>深度就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-3a31add7e720dead9b92e8a3580a5a05_l3.svg" alt="upper(log_2(n+1))"></p>
<p>6.二叉树的存储结构<br>(1)、对于完全二叉树,我们会使用数组来处理<br>&#x2F;&#x2F;不是完全二叉树的话,内存就不能充分的利用,尽量不要选择,如果不得不选择就在缺失的位置补上不存在的标志</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-6-1024x627.png"></p>
<p>跟上面是一样的</p>
<p>(2)、链表(二叉和三叉的)</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-7-1024x668.png"></p>
<p>二叉链表就是有两个指针域</p>
<p>三叉链表:多了一个指向父亲结点的指针</p>
<p>(3)、静态链表<br>就是用一个结构体数组,存入数据,左边的结构序号和右边的结构序号</p>
<h4 id="3-二叉树的遍历"><a href="#3-二叉树的遍历" class="headerlink" title="3.二叉树的遍历"></a>3.二叉树的遍历</h4><p>1.遍历顺序<br>前序:根结点-左-右<br>中序:左-根结点-右<br>后序:左-右-根结点<br>层序遍历:一层一层地遍历</p>
<p>2.递归算法实现</p>
<p>void InorderTraversal( BinTree BT )<br>{<br>    if( BT ) {<br>        InorderTraversal( BT-&gt;Left );<br>        &#x2F;* 此处假设对BT结点的访问就是打印数据 *&#x2F;<br>        printf(“%d “, BT-&gt;Data); &#x2F;* 假设数据为整型 *&#x2F;<br>        InorderTraversal( BT-&gt;Right );<br>    }<br>}</p>
<p>void PreorderTraversal( BinTree BT )<br>{<br>    if( BT ) {<br>        printf(“%d “, BT-&gt;Data );<br>        PreorderTraversal( BT-&gt;Left );<br>        PreorderTraversal( BT-&gt;Right );<br>    }<br>}</p>
<p>void PostorderTraversal( BinTree BT )<br>{<br>    if( BT ) {<br>        PostorderTraversal( BT-&gt;Left );<br>        PostorderTraversal( BT-&gt;Right );<br>        printf(“%d “, BT-&gt;Data);<br>    }<br>}</p>
<p>void LevelorderTraversal ( BinTree BT )<br>{<br>    Queue Q;<br>    BinTree T;</p>
<pre><code>if ( !BT ) return; /\* 若是空树则直接返回 \*/

Q = CreatQueue(); /\* 创建空队列Q \*/
AddQ( Q, BT );
while ( !IsEmpty(Q) ) &#123;
    T = DeleteQ( Q );
    printf(&quot;%d &quot;, T-&gt;Data); /\* 访问取出队列的结点 \*/
    if ( T-&gt;Left )   AddQ( Q, T-&gt;Left );
    if ( T-&gt;Right )  AddQ( Q, T-&gt;Right );
&#125;
</code></pre>
<p>}<br>&#x2F;&#x2F;source:ZJU</p>
<p>3.中序遍历的非递归实现</p>
<p>void Midorder(struct BiTNode *t)      &#x2F;&#x2F;t为根指针<br>{ struct BiTNode *st[maxleng];&#x2F;&#x2F;定义指针栈<br>  int top&#x3D;0；                  &#x2F;&#x2F;置空栈</p>
<p>do{            </p>
<pre><code>while(t)               //根指针t表示的为非空二叉树 

   &#123; if (top==maxleng) exit(OVERFLOW)；//栈已满,退出
                 
     st\[top++\]=t；             //根指针进栈
  
     t=t-&gt;lchild；             //t移向左子树
 
   &#125;   //循环结束表示以栈顶元素的指向为
     
       //根结点的二叉树的左子树遍历结束

if (top)                    //为非空栈   

   &#123; t=st\[--top\]；             //弹出根指针
                            printf(&quot;%c&quot;,t-&gt;data)；    //访问根结点
  
     t=t-&gt;rchild；             //遍历右子树
 
   &#125;
</code></pre>
<p>   } while(topt)； &#x2F;&#x2F;父结点未访问，或右子树未遍历<br> }<br>source:HUST</p>
<p>思路就是先找到最左的结点,把经过的根结点都保存了,后来左子树遍历完了就找上面根结点的右子树,再把右子树看成个树遍历,遍历完了就返回上一级(退栈),相当于更大的左子树访问完了</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-8-1024x676.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-9-1024x706.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-10-1024x689.png"></p>
<p>后面就不截图了</p>
<p>4.先序遍历的非递归实现</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-11.png"></p>
<p>一样的,只不过不同的是,这里入栈就输出</p>
<p>5.后序遍历的非递归实现</p>
<p>注意,由于后序遍历需要遍历一遍左子树,在遍历一遍右子树,所以说保存根结点是十分必要的,所以说这里退栈就不会真退,仅仅是访问而已,如果右子树能能和之前访问过的结点匹配的话,就说明已经回到了根结点了!</p>
<p>核心：一个结点需要弹出两次,第一次弹出的时候还需要放回原位（左子树遍历完毕）,第二次弹出的时候才输出其值（右子树遍历完毕）；<br>Status PostOrder2(BTree *BT) {<br>     Stack s,s2;<br>     BTree *T;<br>     int flag[MaxSize];<br>     s.top&#x3D;0;<br>     T&#x3D;BT;<br>     while(s.top!&#x3D;0T){<br>         while(T)<br>         {<br>             s.data[s.top++]&#x3D;T;<br>             flag[s.top-1]&#x3D;0;<br>             T&#x3D;T-&gt;lchild;<br>          }<br>          while(s.top!&#x3D;0&amp;&amp;flag[s.top-1]&#x3D;&#x3D;1){<br>              T&#x3D;s.data[–s.top];<br>              printf(“%3d”,T-&gt;data);<br>          }<br>          if(s.top!&#x3D;0){<br>              flag[s.top-1]&#x3D;1;<br>              T&#x3D;s.data[s.top-1];<br>              T&#x3D;T-&gt;rchild;<br>          }<br>          else   break;<br>     }<br>     return OK;<br>source:博客园</p>
<pre><code> 这里规定了访问次数这个量,被访问了两次就是要输出了
</code></pre>
<p>while (p !&#x3D; nullptr  !s.empty()) {<br>         &#x2F;&#x2F; 入栈<br>         if (p !&#x3D; nullptr) {<br>             s.push(p);<br>             p &#x3D; p-&gt;left;<br>         }</p>
<pre><code>     // 出栈
     if (p == nullptr) &#123;
         p = s.top();
         s.pop();

         p-&gt;times++;

         //遍历右子树
         if (p-&gt;times == 1) &#123;
             s.push(p);
             p = p-&gt;right;
         &#125;

         //p.times==2; 继续弹栈
         else &#123;
             cout &lt;&lt; p-&gt;data;
             p = nullptr;   // 回溯的关键步骤
         &#125;
     &#125;
 &#125;
</code></pre>
<p>6.输入一组先序序列,构建二叉树</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-12-1024x630.png"></p>
<p>BiTree CreatBiTree2()</p>
<p>{ char ch;  BiTree root;  &#x2F;&#x2F;二叉链表根结点指针<br>              scanf(“%c”,&amp;ch);      &#x2F;&#x2F;输入一个结点</p>
<p>if (ch &#x3D;&#x3D;’  ‘)<br>     root&#x3D;NULL;</p>
<p>else {</p>
<p>root&#x3D;(BiTree) malloc(leng);  &#x2F;&#x2F;生成根结点          </p>
<p>root-&gt;data&#x3D;ch;</p>
<p>root-&gt;lchild&#x3D;CreatBiTree2(); &#x2F;&#x2F;递归构造左子树 </p>
<p>root-&gt;rchild&#x3D;CreatBiTree2(); &#x2F;&#x2F;递归构造右子树</p>
<p>}<br>  return root;</p>
<p>}</p>
<p>当然,传指针传引用都是可以的</p>
<p>7.线索二叉树<br>二叉树一共有2n个指针域,占用了n-1和,剩下n+1个就会被利用</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-13-1024x616.png"></p>
<p>中序和后序都是一样的</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-14-1024x683.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-18-1024x741.png"></p>
<p>左子树存进栈里</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-19.png"></p>
<p>弹出根结点,如果结点有左孩子话,tag为0,没有的话记为1,注意保存一个pre,保存序列上一个结点的内容,总之很抽象,需要好好研读</p>
<p>当然了,带个头指针在指向二叉树本身的操作也是被允许的</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-15.png"></p>
<p>这下非递归的遍历就很方便了</p>
<p>8.表达式二叉树</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-16-1024x714.png"></p>
<p>这样利用构造中序遍历的二叉树,先序遍历输出的结果是波兰式,后序遍历输出的是逆波兰式</p>
<p>9.中序+前序&amp;后序表达式唯一确定二叉树zhon</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-17-1024x643.png"></p>
<p>根据前序表达式确定根结点,中序表达式分割左子树和右子树</p>
<h4 id="3-树和森林"><a href="#3-树和森林" class="headerlink" title="3.树和森林"></a>3.树和森林</h4><p>1.数组(双亲表示法) 数组里面存的是结构体,结构体两个元素,存数据和双亲</p>
<p>2.孩子表示法(链表)</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-20-1024x671.png"></p>
<p>固定了内存,有损耗</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-21-1024x599.png"></p>
<p>3.孩子链表表示法<br>链Hash(bushi)</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-22-1024x726.png"></p>
<p>4.带双亲的孩子链表表示法:每一个结构体加一个双亲</p>
<p>5.树与二叉树的转换</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-23-1024x679.png"></p>
<p>红色的往右走,黑色的往左走</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-24-1024x733.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-25-1024x654.png"></p>
<p>左子树的左儿子的右儿子可以连线,然后右儿子关系断裂</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-26-1024x713.png"></p>
<p>根的右儿子的右儿子与一个虚无链接,构成树林</p>
<p>树的遍历:<br>前根遍历:根——第一个儿子——……<br>后跟遍历:第一个儿子——第二个儿子——……——根</p>
<h4 id="4-Huffman树"><a href="#4-Huffman树" class="headerlink" title="4.Huffman树"></a>4.Huffman树</h4><p>1.路径长度—-路径上分枝的数目(连线的数目)<br>2.树T的路径长度—-从树T的根到其余每个结点的路径长度之和,记作PL(T)<br>当n个结点的二叉树为完全二叉树时,PL(T)具有最小值:</p>
<p><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-c9d2b688b0c3a0b0f5e2c65833b340d4_l3.svg" alt="[sum=\int_{i=1}^n down(log_2i)]" title="Rendered by QuickLaTeX.com"></p>
<p>当n个结点的二叉树为单枝树时,PL(T)具有最大值：<br>PL(T) &#x3D; 1+2+…+(n-1) &#x3D; n(n-1)&#x2F;2<br>树T的带权路径长度—-每个叶子的权与根到该叶子的路径长度的乘积之和，记作WPL(T)&#x3D;</p>
<p><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-183e391544bdec00c0d0978c23c4982a_l3.svg" alt="\int^n_{k=1}w_kl_k" title="Rendered by QuickLaTeX.com"></p>
<p> n:叶子数 w_k叶子k的权 l_k路径长度</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-27-1024x660.png"></p>
<p>构建方式离散数学有讲,注意排序合并中排序不能漏</p>
<p>构建的方式用代码实现:<br>其实树可以表示成父母孩子表示法,每次合并的时候就找最小的两个数,标记已合并,构建新结点,新结点是没合并过的</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-28-1024x903.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-29-1024x757.png"></p>
<p>Huffman编码的构建:就从自己开始找反序列,在调转即可</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="1-图的定义和术语"><a href="#1-图的定义和术语" class="headerlink" title="1.图的定义和术语"></a>1.图的定义和术语</h4><p>1.图<br>图G由顶点集V和关系集E组成,记为:G&#x3D;(V,E),V是顶点(元素)的有穷非空集，E是两个顶点之间的关系的集合。<br>若图G任意两顶点a,b之间的关系为有序对,∈E, 则称为从a到b的一条弧&#x2F;有向边；其中： a是的弧尾，b是的弧头；称该图G是有向图。<br>若图G的任意两顶点a,b之间的关系为无序对(a,b), 则称(a,b)为无向边(边）,称该图G是无向图。 无向图可简称为图。<br>2.完全图<br>3.网:带权的图<br>4.子图:对图 G&#x3D;(V,E)和G’&#x3D;(V’,E’)，<br>若V’<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-478c7dbb76fc8e5b0b52edad79847b31_l3.svg" alt="\in">V 且 E’<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-478c7dbb76fc8e5b0b52edad79847b31_l3.svg" alt="\in">E，则称G’是G的一个子图<br>5.度:与顶点x相关联的边(x,y)的数目,称为x的度，记作TD(x) 或D(x)<br>以顶点x为弧尾的弧的数目,称为x的出度，记作OD(x)。<br>以顶点x为弧头的弧的数目,称为x的入度，记作ID(x)。<br>6.图的连通性质<br>对无向图G：<br>● 若从顶点vi到vj有路径,则称vi和vj是连通的。<br>● 若图G中任意两顶点是连通的,则称G是连通图。<br>● 若图G’是G的一个极大连通子图,则称G’是G的一个连通分量。(连通图的连通分量是自身)<br>对有向图G<br>● 若在图G中,每对顶点vi和vj之间, 从vi到vj,且从 vj到vi都存在路径,则称G是强连通图。<br>● 若图G’是G的一个极大强连通子图,则称G’是G的一个强连通分量。(强连通图的强连通分量是自身)<br>●设G&#x3D;(V,E),G’&#x3D;(V’,E’),V&#x3D;V’,若G是连通图,G’是G的一个极小连通子图, 则G’是G的一棵生成树。<br>● 若有向图G有且仅有一个顶点的入度为0，其余顶点的入度<br>为1,则G是一棵有向树。</p>
<h4 id="2-图的存储形式"><a href="#2-图的存储形式" class="headerlink" title="2.图的存储形式"></a>2.图的存储形式</h4><p>1.数组表示法&#x2F;邻接矩阵<br>顶点数组—用一维数组存储顶点(元素)<br>邻接矩阵—用二维数组存储顶点(元素)之间的关系(边或弧)<br>无向图的邻接矩阵是对称的由0-1构成</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-30-1024x657.png"></p>
<p>列和和行和都是i的度</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-31.png"></p>
<p>有向图中<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-82a18ef57600e3aa4bea85ff07f6c358_l3.svg" alt="a_{i,j}=n">表示从i到j有n条边,列和就是入度,行和是出度</p>
<p>对于网来说道理亦同</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-32-1024x662.png"></p>
<p>2.邻接表:<br>无向图:把与头结点相连的所有元素都存进对应的链表里<br>有向图的邻接表:它指向的元素存进链表<br>有向图的逆邻接表:指向它的元素存进链表</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-33.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-34-1024x369.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-35-1024x409.png"></p>
<p>如果把图改成了网,那就把每个指向的结点加上一个权重空间</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-36.png"></p>
<p>3.有向图的十字链表<br>其实也很简单,每一个边结点加上弧尾和弧头,第一个指针下一个弧头一样的结点,第二个指针指向下一个弧尾一样结点<br>点结点就是两个指针:第一个指针指向第一个弧头为该结点的边结点;第二个指针就指向第一个弧尾为该结点的边结点</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-37-1024x721.png"></p>
<p>4.邻接多重表<br>点结点:就是data和第一个含有这个顶点的边<br>边结点,mark—-标志域，可用以标记该条边是否被搜索过；<br>vi和vj—-该条边依附的两个顶点在图中的位置；<br>vilink—-指向下一条依附于顶点vi的边；<br>vjlink—-指向下一条依附于顶点vj的边。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-38-1024x714.png"></p>
<p>找不到下一个没有被指的边了,那就赋值为NULL,没有被指就是链接下来,该结点是最后一个没有被指的结点</p>
<h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h4><p>1.深度优先搜索:一直往下走,如果没有没被搜索到的结点,就搜索上一个被搜索的结点(Stack)</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-39-1024x547.png"></p>
<p>2.广度优先搜索:无论如何先把该结点的每个儿子先遍历了(队列)</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-40-1024x695.png"></p>
<h4 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4.最小生成树"></a>4.最小生成树</h4><p>1.DFS和BFS的生成树</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-41-1024x587.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-42-1024x623.png"></p>
<p>生成森林:对图的每个联通分枝进行生成树搜索</p>
<p>5.网的最小生成树:<br>在网G的各生成树中，其中各边的权之和最小的生成树称为G的最小生成树<br>MST性质：设G&#x3D;（V，E）是一个连通图，通过某种算法构造其最小生成树,T&#x3D;（U，TE）是正在构造的最小生成树。如果边（u,v)是G中所有一端在U中（即u∈U）而另一端在V-U中（即v∈V-U）具有最小值的一条边，则必存在一棵包含边（u,v)的最小生成树。</p>
<p>6.Prim算法:<br>对n个顶点的连通网，初始时， T&#x3D;（U，TE），U为一个开始顶点，TE&#x3D;φ，以后根据MST性质，每次增加一个顶点和一条边，重复n-1次。Ｕ不断增大，Ｖ－Ｕ不断减小直到为空。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-43-1024x745.png"></p>
<p>初始化:把进入点标记为U集合,每个节点到进入点的距离标记为V-U中各顶点到U的最短直接路径,相邻结点数组标记为A</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-44-1024x755.png"></p>
<p>进入Prim算法:遍历一遍V-U中各顶点到U的最短直接路径,发现V集合中1是最小的,C进入U集<br>接着遍历与C连接的的点,更新V-U中各顶点到U的最短直接路径,我们发现C到F的距离为8,比无穷大小,更新值为8,把F中的相邻结点记为C</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-45-1024x757.png"></p>
<p>注意:在找最小的结点时,要忽略已经进入U集的结点的值,这是B进入结点,遍历一遍B到每个结点的距离,发现5&lt;6,更新数据集,D的邻接结点为B</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-46-1024x772.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-47-1024x750.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-48-1024x762.png"></p>
<p>&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</p>
<p>Vertex FindMinDist( MGraph Graph, WeightType dist[] )<br>{ &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;<br>    Vertex MinV, V;<br>    WeightType MinDist &#x3D; INFINITY;</p>
<pre><code>for (V=0; V&lt;Graph-&gt;Nv; V++) &#123;
    if ( dist\[V\]!=0 &amp;&amp; dist\[V\]&lt;MinDist) &#123;
        /\* 若V未被收录，且dist\[V\]更小 \*/
        MinDist = dist\[V\]; /\* 更新最小距离 \*/
        MinV = V; /\* 更新对应顶点 \*/
    &#125;
&#125;
if (MinDist &lt; INFINITY) /\* 若找到最小dist \*/
    return MinV; /\* 返回对应的顶点下标 \*/
else return ERROR;  /\* 若这样的顶点不存在，返回-1作为标记 \*/
</code></pre>
<p>}</p>
<p>int Prim( MGraph Graph, LGraph MST )<br>{ &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;<br>    WeightType dist[MaxVertexNum], TotalWeight;<br>    Vertex parent[MaxVertexNum], V, W;<br>    int VCount;<br>    Edge E;</p>
<pre><code>/\* 初始化。默认初始点下标是0 \*/
   for (V=0; V&lt;Graph-&gt;Nv; V++) &#123;
    /\* 这里假设若V到W没有直接的边，则Graph-&gt;G\[V\]\[W\]定义为INFINITY \*/
       dist\[V\] = Graph-&gt;G\[0\]\[V\];
       parent\[V\] = 0; /\* 暂且定义所有顶点的父结点都是初始点0 \*/ 
&#125;
TotalWeight = 0; /\* 初始化权重和     \*/
VCount = 0;      /\* 初始化收录的顶点数 \*/
/\* 创建包含所有顶点但没有边的图。注意用邻接表版本 \*/
MST = CreateGraph(Graph-&gt;Nv);
E = (Edge)malloc( sizeof(struct ENode) ); /\* 建立空的边结点 \*/
       
/\* 将初始点0收录进MST \*/
dist\[0\] = 0;
VCount ++;
parent\[0\] = -1; /\* 当前树根是0 \*/

while (1) &#123;
    V = FindMinDist( Graph, dist );
    /\* V = 未被收录顶点中dist最小者 \*/
    if ( V==ERROR ) /\* 若这样的V不存在 \*/
        break;   /\* 算法结束 \*/
        
    /\* 将V及相应的边&lt;parent\[V\], V&gt;收录进MST \*/
    E-&gt;V1 = parent\[V\];
    E-&gt;V2 = V;
    E-&gt;Weight = dist\[V\];
    InsertEdge( MST, E );
    TotalWeight += dist\[V\];
    dist\[V\] = 0;
    VCount++;
    
    for( W=0; W&lt;Graph-&gt;Nv; W++ ) /\* 对图中的每个顶点W \*/
        if ( dist\[W\]!=0 &amp;&amp; Graph-&gt;G\[V\]\[W\]&lt;INFINITY ) &#123;
        /\* 若W是V的邻接点并且未被收录 \*/
            if ( Graph-&gt;G\[V\]\[W\] &lt; dist\[W\] ) &#123;
            /\* 若收录V使得dist\[W\]变小 \*/
                dist\[W\] = Graph-&gt;G\[V\]\[W\]; /\* 更新dist\[W\] \*/
                parent\[W\] = V; /\* 更新树 \*/
            &#125;
        &#125;
&#125; /\* while结束\*/
if ( VCount &lt; Graph-&gt;Nv ) /\* MST中收的顶点不到V个 \*/
   TotalWeight = ERROR;
return TotalWeight;   /\* 算法执行完毕，返回最小权重和或错误标记 \*/
</code></pre>
<p>}</p>
<p>2.克鲁斯卡尔:<br>需要将边按递增次序排列以供选择。选择权重最小的边,然后保证没有环<br>怎么保证没有环?度!</p>
<h4 id="4-有向无环图应用"><a href="#4-有向无环图应用" class="headerlink" title="4.有向无环图应用"></a>4.有向无环图应用</h4><p>一个无环的有向图称为有向无环图（directed acycline graph), 简称DAG图。</p>
<p>1.拓扑排序:<br>AOV网（Activity On Vertex network:以顶点表示活动，弧表示活动之间的优先关系的DAG图。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-49-1024x618.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-50-1024x706.png"></p>
<p>拓扑排序算法思想：重复下列操作，直到所有顶点输出完。<br>（1）在有向图中选一个没有前驱的顶点输出(选择入度为0的顶点)；<br>（2）从图中删除该顶点和所有以它为尾的弧(修改其它顶点入度) 。</p>
<p>2.AOE网<br>AOE网研究的问题：<br>（1） 完成整项工程至少需要多少时间；<br>（2） 哪些活动是影响工程进度的关键。</p>
<p>1.(顶点）事件vi的最早发生时间ve(vi)：从开始点到vi的最长路径长度。（ve(v1)&#x3D;0）,既表示事件vi的最早发生时间，也表示所有以vi为尾的弧所表示的活动ak的最早发生时间e(k)。<br>如果结点只有一个前驱结点:那就是前驱结点ve+到这个结点的边<br>有多个前驱结点:前驱结点ve+到这的边求最大值<br>2.活动最早开始时间ee(e)&#x3D;所连接的弧尾的标记值<br>3.(顶点）事件vi允许的最迟开始时间vl(vi) &#x3D; 完成点（汇点）vn的的最早发生时间ve(vn)减去vk到vn的最长路径长度。<br>如果有多个后继结点,对每个结点的值求最小即可<br>4.确定了顶点vi的最迟开始时间后，确定所有以vi为弧头的活动ak的最迟开始时间l(k)：表示在不推迟整个工程完成的前提下，活动ak最迟必须开始的时间。<br>l(ak)&#x3D;vl(ak弧头对应顶点)-活动ak的持续时间</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/10/image-51-1024x670.png"></p>
<h4 id="5-最短路径"><a href="#5-最短路径" class="headerlink" title="5 最短路径"></a>5 最短路径</h4><p>算法1（Dijkstra算法）：<br>以每一个顶点为源点，重复执行Dijkstra算法n次，即可求出每一对顶点之间的最短路径。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-1024x771.png"></p>
<p>&#x2F;* 邻接矩阵存储 - 有权图的单源最短路算法 *&#x2F;</p>
<p>Vertex FindMinDist( MGraph Graph, int dist[], int collected[] )<br>{ &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;<br>    Vertex MinV, V;<br>    int MinDist &#x3D; INFINITY;</p>
<pre><code>for (V=0; V&lt;Graph-&gt;Nv; V++) &#123;
    if ( collected\[V\]==false &amp;&amp; dist\[V\]&lt;MinDist) &#123;
        /\* 若V未被收录，且dist\[V\]更小 \*/
        MinDist = dist\[V\]; /\* 更新最小距离 \*/
        MinV = V; /\* 更新对应顶点 \*/
    &#125;
&#125;
if (MinDist &lt; INFINITY) /\* 若找到最小dist \*/
    return MinV; /\* 返回对应的顶点下标 \*/
else return ERROR;  /\* 若这样的顶点不存在，返回错误标记 \*/
</code></pre>
<p>}</p>
<p>bool Dijkstra( MGraph Graph, int dist[], int path[], Vertex S )<br>{<br>    int collected[MaxVertexNum];<br>    Vertex V, W;</p>
<pre><code>/\* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 \*/
for ( V=0; V&lt;Graph-&gt;Nv; V++ ) &#123;
    dist\[V\] = Graph-&gt;G\[S\]\[V\];
    if ( dist\[V\]&lt;INFINITY )
        path\[V\] = S;
    else
        path\[V\] = -1;
    collected\[V\] = false;
&#125;
/\* 先将起点收入集合 \*/
dist\[S\] = 0;
collected\[S\] = true;

while (1) &#123;
    /\* V = 未被收录顶点中dist最小者 \*/
    V = FindMinDist( Graph, dist, collected );
    if ( V==ERROR ) /\* 若这样的V不存在 \*/
        break;      /\* 算法结束 \*/
    collected\[V\] = true;  /\* 收录V \*/
    for( W=0; W&lt;Graph-&gt;Nv; W++ ) /\* 对图中的每个顶点W \*/
        /\* 若W是V的邻接点并且未被收录 \*/
        if ( collected\[W\]==false &amp;&amp; Graph-&gt;G\[V\]\[W\]&lt;INFINITY ) &#123;
            if ( Graph-&gt;G\[V\]\[W\]&lt;0 ) /\* 若有负边 \*/
                return false; /\* 不能正确解决，返回错误标记 \*/
            /\* 若收录V使得dist\[W\]变小 \*/
            if ( dist\[V\]+Graph-&gt;G\[V\]\[W\] &lt; dist\[W\] ) &#123;
                dist\[W\] = dist\[V\]+Graph-&gt;G\[V\]\[W\]; /\* 更新dist\[W\] \*/
                path\[W\] = V; /\* 更新S到W的路径 \*/
            &#125;
        &#125;
&#125; /\* while结束\*/
return true; /\* 算法执行完毕，返回正确标记 \*/
</code></pre>
<p>}<br>Source:ZJU</p>
<p>算法2（Floyd算法）：<br>算法思想：<br>假设求Vi到Vj的最短路径，如果从Vi到Vj有弧，则存在一条长度为arcs[i][j]的路径，该路径不一定是最短路径，尚需进行n次试探。</p>
<p>首先考虑(Vi,V0,Vj)是否存在（即判断(Vi,V0)和( V0,Vj)是否存在)，如果存在，比较(Vi, Vj)和(Vi,V0)+( V0,Vj)，取长度较短的为从Vi到Vj的中间顶点序号不大于0的最短路径。</p>
<p>再考虑路径上再增加一个顶点V1，如果考虑(Vi,…V1)和(V1,….Vj)， (Vi,…V1)和(V1,….Vj)都是中间顶点序号不大于0的最短路径。 (Vi,…V1，….Vj)可能是从Vi到Vj的中间顶点序号不大于1的最短路径。<br>比较Vi到Vj的中间顶点序号不大于0的最短路径和(Vi,…V1)+(V1,….Vj)，取长度较短的为从Vi到Vj的中间顶点序号不大于1的最短路径。</p>
<p>bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )<br>{<br>    Vertex i, j, k;</p>
<pre><code>/\* 初始化 \*/
for ( i=0; i&lt;Graph-&gt;Nv; i++ )
    for( j=0; j&lt;Graph-&gt;Nv; j++ ) &#123;
        D\[i\]\[j\] = Graph-&gt;G\[i\]\[j\];
        path\[i\]\[j\] = -1;
    &#125;

for( k=0; k&lt;Graph-&gt;Nv; k++ )
    for( i=0; i&lt;Graph-&gt;Nv; i++ )
        for( j=0; j&lt;Graph-&gt;Nv; j++ )
            if( D\[i\]\[k\] + D\[k\]\[j\] &lt; D\[i\]\[j\] ) &#123;
                D\[i\]\[j\] = D\[i\]\[k\] + D\[k\]\[j\];
                if ( i==j &amp;&amp; D\[i\]\[j\]&lt;0 ) /\* 若发现负值圈 \*/
                    return false; /\* 不能正确解决，返回错误标记 \*/
                path\[i\]\[j\] = k;/\*记录I和j之间的中间结点\*/
            &#125;
return true; /\* 算法执行完毕，返回正确标记 \*/
</code></pre>
<p>}</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找表: 由同一类型的数据元素（记录）组成的集合。<br>记作：ST&#x3D;{a1,a2,…,an}<br>● 关键字: 可以标识一个记录的数据项<br>● 主关键字: 可以唯一地标识一个记录的数据项<br>● 次关键字: 可以识别若干记录的数据项</p>
<p>查找—-根据给定的某个关键字值，在查找表中确定一个其关键字等于给定值的记录或数据元素。<br>设k为给定的一个关键字值，R[1..n]为n个记录的表,若存在R[i].key&#x3D;k,1≤i≤n,称查找成功；否则称查找失败。</p>
<p>静态查找: 查询某个特定的元素，检查某个特定的数据元素的属性,不插入新元素或删除元素(记录) 。<br>动态查找: 在查找过程中，同时插入查找表中不存在的数据元素(记录)。</p>
<h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1 顺序查找"></a>1 顺序查找</h4><p>typedef struct node<br>{ keytype key ； &#x2F;&#x2F;关键字类型<br>char name[6]； &#x2F;&#x2F;姓名<br>…… &#x2F;&#x2F;其它<br>} ElemType；<br>typedef struct<br>{<br>ElemType elem[maxsize+1]；&#x2F;&#x2F;maxsize+1个记录,<br>&#x2F;&#x2F;elem[0]为监视哨<br>int length;<br>} SSTable;<br>SSTable ST1,ST2;</p>
<p>不使用监视哨的判断语句:i&gt;&#x3D;1 &amp;&amp; k!&#x3D;ST.elem[i].key<br>监视哨:将数组第0个元素设置为要查找的元素<br>含有监视哨的查找表是肯定能找到的,如果在0找到就是没找到,就符合相等的直接返回下标即可</p>
<p>查找算法的性能分析:</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-7.png"></p>
<p>● 考虑查找失败: 使用监视哨elem[0],为 n+1<br>不使用监视哨elem[0],为 n</p>
<p>假定查找成功和失败的机会相同，对每个记录的查找概率相等， Pi&#x3D;1&#x2F;(2*n), 则 ASL&#x3D;3(n+1)&#x2F;4</p>
<h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2 二分查找"></a>2 二分查找</h4><p>int binsrch(SSTable  ST,keytype k)<br>{<br>    int low,mid,hig；</p>
<p>  low&#x3D;1；</p>
<p>  hig&#x3D;ST.length；</p>
<pre><code>while (low&lt;=hig)

&#123;  mid=(low+hig)/2；     //计算中间记录的地址 
 
   if (k&lt;ST.elem\[mid\].key) 
      
       hig=mid-1；       //查左子表 
 
   else if (k==ST.elem\[mid\].key) 
      
       return mid；           //查找成功,退出循环
 
   else low=mid+1；  //查右子表
</code></pre>
<p>   ｝<br>    return 0;</p>
<p>小了,往小了猜,大了,往大了猜</p>
<p>判定树</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-8-1024x637.png"></p>
<p>如果判定树只有一个儿子,那这个儿子一定是右儿子</p>
<p>插入方法:右子树最右,左子树最右,递归排序<br>ASL计算:每一个结点所在的层数求和&#x2F;总的结点个数<br>满二叉树:公式:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-6f1958c79da2263f659595e986dd20a5_l3.svg" alt="\frac{n+1}{n}log_2(n+1)-1"></p>
<h4 id="3-索引顺序表"><a href="#3-索引顺序表" class="headerlink" title="3 索引顺序表"></a>3 索引顺序表</h4><p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-9.png"></p>
<p>查找效率<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-5fca13df3a8bf1c72af05b3b530665ed_l3.svg" alt="O(b+s)"></p>
<p>● 条件<br>(1)分块表”按块有序”, 索引表”按key有序”<br>(2)设n个记录分为b个块，每块的记录数s&#x3D;n&#x2F;b<br>● 查找方法<br>(1)顺序查找(或折半查找)索引表<br>确定k值所在的块号或块的首地址<br>(2)在某一块中顺序查找<br>● 最佳分块<br>s&#x3D;√n b&#x3D;√n</p>
<h4 id="4-二叉排序树"><a href="#4-二叉排序树" class="headerlink" title="4 二叉排序树"></a>4 二叉排序树</h4><p>(1) 二叉排序树的定义<br>如果二叉树的任一结点大于其非空左子树的所有结点，而小于其非空右子树的所有结点，则这棵二叉树称为二叉排序树。对一棵二叉排序树进行中序遍历，所得的结点序列一定是递增有序的。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-10-1024x746.png"></p>
<p>小的往左走,大的往右走,遇到NULL就插入</p>
<p>ASL计算:同查找树<br>存储结构:跟二叉树一样</p>
<p>查找算法:大的往右,小的往左,找到了返回,遇到NULL就失败</p>
<p>插入算法:</p>
<p>删除算法:在二叉排序树中删除一个结点时，必须将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会失去。<br>为保证在删除节点后二叉排序树的性质不会丢失:<br>1、删除叶结点，只需将其双亲结点指向它的指针置空，再释放它即可。<br>2、被删结点缺左子树（或右子树），可以用被删节点的右子树（或左子树）顶替它的位置，再释放它。<br>3、被删结点左、右子树都存在，可以在它的右子树中寻找中序下的第一个结点(关键值最小),用它的值填补到被删结点中，再来处理这个结点的删除问题。<br>这个中序下的第一个结点就是右子树最左,交换结点域之后删除右子树最左的地方</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-12-1024x441.png"></p>
<p>找到右子树最左:78,然后78和81值域交换,删除原来78所在的域:这就和第二个删除一样的</p>
<p>BinTree Insert( BinTree BST, ElementType X )<br>{<br>    if( !BST ){ &#x2F;* 若原树为空，生成并返回一个结点的二叉搜索树 *&#x2F;<br>        BST &#x3D; (BinTree)malloc(sizeof(struct TNode));<br>        BST-&gt;Data &#x3D; X;<br>        BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL;<br>    }<br>    else { &#x2F;* 开始找要插入元素的位置 *&#x2F;<br>        if( X &lt; BST-&gt;Data )<br>            BST-&gt;Left &#x3D; Insert( BST-&gt;Left, X );   &#x2F;*递归插入左子树*&#x2F;<br>        else  if( X &gt; BST-&gt;Data )<br>            BST-&gt;Right &#x3D; Insert( BST-&gt;Right, X ); &#x2F;*递归插入右子树*&#x2F;<br>        &#x2F;* else X已经存在，什么都不做 *&#x2F;<br>    }<br>    return BST;<br>}</p>
<p>BinTree Delete( BinTree BST, ElementType X )<br>{<br>    Position Tmp; </p>
<pre><code>if( !BST ) 
    printf(&quot;要删除的元素未找到&quot;); 
else &#123;
    if( X &lt; BST-&gt;Data ) 
        BST-&gt;Left = Delete( BST-&gt;Left, X );   /\* 从左子树递归删除 \*/
    else if( X &gt; BST-&gt;Data ) 
        BST-&gt;Right = Delete( BST-&gt;Right, X ); /\* 从右子树递归删除 \*/
    else &#123; /\* BST就是要删除的结点 \*/
        /\* 如果被删除结点有左右两个子结点 \*/ 
        if( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;
            /\* 从右子树中找最小的元素填充删除结点 \*/
            Tmp = FindMin( BST-&gt;Right );
            BST-&gt;Data = Tmp-&gt;Data;
            /\* 从右子树中删除最小元素 \*/
            BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );
        &#125;
        else &#123; /\* 被删除结点有一个或无子结点 \*/
            Tmp = BST; 
            if( !BST-&gt;Left )       /\* 只有右孩子或无子结点 \*/
                BST = BST-&gt;Right; 
            else                   /\* 只有左孩子 \*/
                BST = BST-&gt;Left;
            free( Tmp );
        &#125;
    &#125;
&#125;
return BST;
</code></pre>
<p>}<br>Source:ZJU</p>
<p>ASL:<br>最好情况(为满二叉树）<br>ASL&#x3D;<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-073146ae056a8f4f00ab453fb5bdbf1d_l3.svg" alt="\frac{n+1}{n}log2(n+1)-1"> &#x3D; O(log2 n)<br>最坏情况(为单枝树): ASL&#x3D;(1+2+…+n)&#x2F;n&#x3D;(n+1)&#x2F;2<br>平均值: ASL≈O(log2 n)</p>
<h4 id="5-平衡二叉树-AVL树"><a href="#5-平衡二叉树-AVL树" class="headerlink" title="5 平衡二叉树(AVL树)"></a>5 平衡二叉树(AVL树)</h4><p>AVL树：由G.M.Adelson-Velskii和E.M.Landis提出。<br>结点的平衡因子：结点的左右子树的深度之差。<br>平衡二叉树：任意结点的平衡因子的绝对值小于等于1的二叉树。<br>存储类型:<br>typedef int DataType; &#x2F;&#x2F;结点数据类型<br>typedef struct node { &#x2F;&#x2F;AVL树结点定义<br>DataType data; &#x2F;&#x2F;结点数据域<br>int balance; &#x2F;&#x2F;结点平衡因子域<br>struct node *leftChild, *rightChild;<br>&#x2F;&#x2F;结点左、右子树指针域<br>} AVLNode;<br>typedef AVLNode * AVLTree; &#x2F;&#x2F;AVL树</p>
<p>如果在某一结点发现高度不平衡，停止回溯。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点。<br>如果这三个结点处于一条直线上，则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转, 其中一个是另一 个的镜像，其方向与不平衡的形状相关。<br>如果这三个结点处于一条折线上，则采用双旋转进行平衡化。双旋转分为先左后右和先右后左两类。</p>
<p>我们看:不平衡的发现者是A,麻烦结点(让A发现不平衡的结点)在A的右边的右边,就需要做左单旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-13-1024x701.png"></p>
<p>往右的直线:做左单旋转,C的左子树变成A的右子树</p>
<p>我们看:不平衡的发现者是A,麻烦结点(让A发现不平衡的结点)在A的左边的左边,就需要做右单旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-14-1024x701.png"></p>
<p>往左的直线:做右单旋转,B的右子树变成A的左子树</p>
<p>需要变换的子树都是含有麻烦结点子树的兄弟<br>我们看:不平衡的发现者是A,麻烦结点(让A发现不平衡的结点)在A的左边的右边,就需要做左右旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-15-1024x736.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-16-1024x771.png"></p>
<p>先对BEG做一次左单旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-17-1024x627.png"></p>
<p>在对AEB做一次右单旋转</p>
<p>我们看:不平衡的发现者是A,麻烦结点(让A发现不平衡的结点)在A的右边的左边,就需要做右左旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-19-1024x723.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-20-1024x746.png"></p>
<p>先对CDF做一次右单旋转</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-21-1024x620.png"></p>
<p>在对ADC做一次左单旋转</p>
<p>ZJU给出了一个更加直接的结论,可以下载文档查看:</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-22-1024x766.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-23-1024x772.png"></p>
<p>代码:</p>
<p>typedef struct AVLNode *Position;<br>typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;<br>struct AVLNode{<br>    ElementType Data; &#x2F;* 结点数据 *&#x2F;<br>    AVLTree Left;     &#x2F;* 指向左子树 *&#x2F;<br>    AVLTree Right;    &#x2F;* 指向右子树 *&#x2F;<br>    int Height;       &#x2F;* 树高 *&#x2F;<br>};</p>
<p>int Max ( int a, int b )<br>{<br>    return a &gt; b ? a : b;<br>}</p>
<p>AVLTree SingleLeftRotation ( AVLTree A )<br>{ &#x2F;* 注意：A必须有一个左子结点B *&#x2F;<br>  &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F;     </p>
<pre><code>AVLTree B = A-&gt;Left;
A-&gt;Left = B-&gt;Right;
B-&gt;Right = A;
A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;

return B;
</code></pre>
<p>}</p>
<p>AVLTree DoubleLeftRightRotation ( AVLTree A )<br>{ &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;<br>  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;</p>
<pre><code>/\* 将B与C做右单旋，C被返回 \*/
A-&gt;Left = SingleRightRotation(A-&gt;Left);
/\* 将A与C做左单旋，C被返回 \*/
return SingleLeftRotation(A);
</code></pre>
<p>}</p>
<p>&#x2F;*************************************&#x2F;<br>&#x2F;* 对称的右单旋与右-左双旋请自己实现 *&#x2F;<br>&#x2F;*************************************&#x2F;</p>
<p>AVLTree Insert( AVLTree T, ElementType X )<br>{ &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F;<br>    if ( !T ) { &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F;<br>        T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode));<br>        T-&gt;Data &#x3D; X;<br>        T-&gt;Height &#x3D; 0;<br>        T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;<br>    } &#x2F;* if (插入空树) 结束 *&#x2F;</p>
<pre><code>else if ( X &lt; T-&gt;Data ) &#123;
    /\* 插入T的左子树 \*/
    T-&gt;Left = Insert( T-&gt;Left, X);
    /\* 如果需要左旋 \*/
    if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == 2 )
        if ( X &lt; T-&gt;Left-&gt;Data ) 
           T = SingleLeftRotation(T);      /\* 左单旋 \*/
        else 
           T = DoubleLeftRightRotation(T); /\* 左-右双旋 \*/
&#125; /\* else if (插入左子树) 结束 \*/

else if ( X &gt; T-&gt;Data ) &#123;
    /\* 插入T的右子树 \*/
    T-&gt;Right = Insert( T-&gt;Right, X );
    /\* 如果需要右旋 \*/
    if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -2 )
        if ( X &gt; T-&gt;Right-&gt;Data ) 
           T = SingleRightRotation(T);     /\* 右单旋 \*/
        else 
           T = DoubleRightLeftRotation(T); /\* 右-左双旋 \*/
&#125; /\* else if (插入右子树) 结束 \*/

/\* else X == T-&gt;Data，无须插入 \*/

/\* 别忘了更新树高 \*/
T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;

return T;
</code></pre>
<p>}</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h4><p>算法基本思想<br>将待排序的记录插入到已排序的子文件中去，使得插入之后得到的子文件仍然是有序子文件。插入一个记录，首先要对有序子文件进行查找，以确定这个记录的插入位置。按查找方式的不同，插入排序又可以分为线性插入排序和折半插入排序，前者使用顺序查找，后者使用折半查找。</p>
<h5 id="1-1-简单插入排序"><a href="#1-1-简单插入排序" class="headerlink" title="1.1 简单插入排序"></a>1.1 简单插入排序</h5><p>插入排序:设待排序的文件为：(r[1],r[2],…,r[n])<br>关键字为：(r[1].key,r[2].key,…,r[n].key)<br>首先,将初始文件中的记录r[1]看作有序子文件；<br>第1遍：将r[2]插入有序子文件中，若：<br>r[2].key&lt;r[1].key，<br>则r[2]插在r[1]之前；否则，插在r[1]的后面。<br>第2遍：将记录r[3]插入前面已有2个记录的有序子文件中，得到3个记录的有序子文件。<br>以此类推，依次插入r[4],…,r[n],最后得到n个记录的递增有序文件。</p>
<p>就是找到最好的插入位置</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-27.png"></p>
<p>void InsertSort(RecType r[],int n）<br>&#x2F;&#x2F; 对数组r[1..n]中的n个记录作插入排序<br>{ int i,j；<br>for (i&#x3D;2；i&lt;&#x3D;n；i++){<br>r[0]&#x3D;r[i]； &#x2F;&#x2F;待插记录r[i]存入监视哨中<br>j&#x3D;i-1； &#x2F;&#x2F;以排序的范围1-i-1<br>&#x2F;&#x2F;从r[i-1]开始向左扫描<br>while(r[0].key&lt;r[j].key)<br>{ <br>r[j+1]&#x3D;r[j]； &#x2F;&#x2F;记录后移<br>j–； &#x2F;&#x2F;继续向左扫描<br>}<br>r[j+1]&#x3D;r[0]； &#x2F;&#x2F;插入记录r[0],即原r[i]<br>}<br>}</p>
<p>(1)最好情况，原n个记录递增有序：比较关键字n-1次,移动记录2(n-1)次,(将数据复制到r[0]后又复制回来)<br>(2)最坏情况:$O(n^2)$</p>
<h5 id="1-2-折半插入排序（二分插入排序）"><a href="#1-2-折半插入排序（二分插入排序）" class="headerlink" title="1.2.折半插入排序（二分插入排序）"></a>1.2.折半插入排序（二分插入排序）</h5><p>（a）由于插入排序的基本思想是在一个有序序列中插入一个新的记录，因此可以利用“折半查找”查询插入位置，由此得到的插入排序算法为“折半插入排序”，又被称为二分法插入排序。<br>（b）直接插入排序的算法简单易行，对长度(n)很大的记录序列宜采用性能更好的插入排序算法。<br>（c）折半插入排序过程中的折半查找的目的是查询插入点，因此不论是否存在和给定值相同的关键字，结束查找过程的条件都是high&lt;low，并且插入位置为low指示的地方。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-28-1024x607.png"></p>
<p>实例:插入到low处,low&gt;high处停下</p>
<p>void BInsertSort (SqList &amp;L)  {<br>&#x2F;&#x2F; 对顺序表L作折半插入排序　<br>    for ( i&#x3D;2; i&lt;&#x3D;L.length; ++i ) 　<br>    { &#x2F;&#x2F;假定第一个记录有序　　<br>        L.r[0] &#x3D; L.r[i];&#x2F;&#x2F; 将L.r[i]暂存到L.r[0]　　<br>        low &#x3D; 1; high &#x3D; i-1;　　<br>        while (low&lt;&#x3D;high) 　　<br>        { 　　&#x2F;&#x2F; 在r[low..high]中折半查找有序插入的位置　　　<br>            m &#x3D; (low+high)&#x2F;2; &#x2F;&#x2F; 折半　　　<br>            if (L.r[0].key &lt; L.r[m].key))<br>                high &#x3D; m-1;&#x2F;&#x2F; 插入点在低半区　　　<br>            else<br> low &#x3D; m+1; &#x2F;&#x2F; 插入点在高半区<br>    　　} &#x2F;&#x2F; while　　<br>       for ( j&#x3D;i-1; j&gt;&#x3D;low; - -j ) L.r[j+1] &#x3D; L.r[j]; &#x2F;&#x2F; 记录后移　　 L.r[high+1] &#x3D; L.r[0];&#x2F;&#x2F; 插入　<br>    } &#x2F;&#x2F;for<br>} &#x2F;&#x2F; BInsertSort</p>
<h5 id="1-3-希尔-shell-排序-缩小增量排序"><a href="#1-3-希尔-shell-排序-缩小增量排序" class="headerlink" title="1.3.希尔(shell)排序 (缩小增量排序)"></a>1.3.希尔(shell)排序 (缩小增量排序)</h5><p>（a）是插入排序中效率最高的一种排序方法。又称“缩小增量排序”，是由D.L.Shell在1959年提出来的。<br>（b）基本思想是，先对待排序列进行“宏观调整”，待序列中的记录“基本有序”时再进行直接插入排序。注：所谓“ 基本有序” 是指，在序列中的各个关键字之前，只存在少量关键字比它大的记录。<br>（c）做法是：先取定一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组，所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序；然后，到第二个增量d2&lt;d1重复上述分组和排序，直至所取的增量dt&#x3D;1（dt&lt;dt-1&lt;…&lt;d2&lt;d1），即所有记录放在同一组中进行直接插入排序为止。</p>
<p>例如·:3 2 1</p>
<p>1 4 5 3 2 6<br>3:三类:14 25 36<br>1 2 5 3 4 6<br>2:2类:135 246<br>1 2 4 3 5 6<br>1:一类:123456<br>1 2 3 4 5 6</p>
<h4 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2 交换排序"></a>2 交换排序</h4><h5 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h5><p>基本思想: 设待排序的文件为r[1..n]<br>第1趟(遍)：从r[1]开始,依次比较两个相邻记录的关键字r[i].key和r[i+1].key,若r[i].key&gt;r[i+1].key，则交换记录r[i]和r[i+1]的位置；否则,不交换。(i&#x3D;1,2,…n-1)<br>第1趟之后,n个关键字中最大的记录移到了r[n]的位置上。<br>第2趟：从r[1]开始,依次比较两个相邻记录的关键字r[i].key和r[i+1].key,若r[i].key&gt;r[i+1].key，则交换记录r[i]和r[i+1]的位置；否则,不交换。(i&#x3D;1,2,…n-2)<br>第2趟之后,前n-1个关键字中最大的记录移到了r[n-1]的位置上。<br>……<br>作完n-1趟,或者不需再交换记录时为止。</p>
<pre><code>void  bubble1(int a\[\],int n)

&#123; int i,j,temp；

for(i=0；i&lt;n-1；i++)     //作n-1趟排序
     
</code></pre>
<p>for(j&#x3D;0；j&lt;n-1-i；j++)       </p>
<pre><code>          if (a\[j\]&gt;a\[j+1\])            
      
              &#123; temp=a\[j\]；      //交换记录 
  
                a\[j\]=a\[j+1\]；           
 
                a\[j+1\]=temp；           

              &#125;       
  
for(i=0；i&lt;n；i++)
</code></pre>
<p>   printf(“%d”,a[i])；  &#x2F;&#x2F;输出排序后的元素 </p>
<pre><code>  &#125;
</code></pre>
<p>可以加一个swap变量,如果一次排序没换过元素,那就是</p>
<p>● 最好情况: 待排序的文件已是有序文件，只需要进行1趟<br>排序,共计比较关键字的次数为 n-1 不交换记录。<br>● 最坏情况: 要经过n-1趟排序，所需总的比较关键字的次数为<br>(n-1)+(n-2)+…+1＝n(n-1)&#x2F;2<br>交换记录的次数最多为<br>(n-1)+(n-2)+…+1＝n(n-1)&#x2F;2<br>移动记录次数最多为<br>3n(n-1)&#x2F;2 。<br>● 只需要少量中间变量作为辅助空间。 O(1)<br>● 算法是稳定的。</p>
<h5 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h5><p>基本思想：首先在r[1..n]中，确定一个r[i]，经过比较和移动，将r[i]放到”中间”某个位置上，使得r[i]左边所有记录的关键字小于等于r[i].key，r[i]右边所有记录的关键字大于等于r[i].key。以r[i]为界,将文件划分为左、右两个子文件。<br>用同样的方法分别对这两个子文件进行划分, 得到4个更小的子文件。继续进行下去,使得每个子文件只有一个记录为止,便得到原文件的有序文件。</p>
<p>设置两个指针:一个大区域,一个小区域</p>
<p>void quksort(RecType r[],int low,int high)<br>{  RecType x；int i,j；</p>
<p>  if (low&lt;high)                       &#x2F;&#x2F;有两个以上记录</p>
<p>   { i&#x3D;low；j&#x3D;high；x&#x3D;r[i]；          &#x2F;&#x2F;保存记录到变量x中</p>
<pre><code> do &#123;                             //此时i指示位置可用
    while (i&lt;j &amp;&amp; r\[j\].key&gt;=x.key)
 
    j--；     //j从右向左端扫描通过key不小于x.key的元素

       if (i&lt;j)                        //i,j未相遇
       &#123;   r\[i\]=r\[j\]； i++；            //此时j指示位置可用
           while(i&lt;j &amp;&amp; r\[i\].key&lt;=x.key)
           i++；   //i从左向右端扫描通过key不大于x.key的元素
           if (i&lt;j)
         
           &#123; r\[j\]=r\[i\]；j--；&#125;
      
       &#125;

   &#125; while (i!=j)；                 //i,j未相遇
</code></pre>
<p> }</p>
<p>在上一级的函数就分治即可</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-29.png"></p>
<p>找到左边第一个比20大的,右边第一个比20小的,交换位置</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-30-1024x689.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-31.png"></p>
<p>就平均速度而言，快速排序是已知内部排序方法中最好的一种排序方法,其时间复杂度为$O(nlog_2n)$。<br>但是，在最坏情况下（基本有序时），快速排序所需的比较次数和冒泡排序的比较次数相同,其时间复杂度为$O(n^2)$。<br>快速排序需要一个栈空间来实现递归。若每次划分均能将文件均匀分割为两部分，则栈的最大深度为$log_2n+1$，所需栈空间为$O(log_2n)$,即空间复杂度 $S(n)&#x3D; O (log2n)$<br>快速排序是不稳定的。</p>
<p>ElementType Median3( ElementType A[], int Left, int Right )<br>{<br>    int Center &#x3D; (Left+Right) &#x2F; 2;<br>    if ( A[Left] &gt; A[Center] )<br>        Swap( &amp;A[Left], &amp;A[Center] );<br>    if ( A[Left] &gt; A[Right] )<br>        Swap( &amp;A[Left], &amp;A[Right] );<br>    if ( A[Center] &gt; A[Right] )<br>        Swap( &amp;A[Center], &amp;A[Right] );<br>    &#x2F;* 此时A[Left] &lt;&#x3D; A[Center] &lt;&#x3D; A[Right] *&#x2F;<br>    Swap( &amp;A[Center], &amp;A[Right-1] ); &#x2F;* 将基准Pivot藏到右边*&#x2F;<br>    &#x2F;* 只需要考虑A[Left+1] … A[Right-2] *&#x2F;<br>    return  A[Right-1];  &#x2F;* 返回基准Pivot *&#x2F;<br>}</p>
<p>void Qsort( ElementType A[], int Left, int Right )<br>{ &#x2F;* 核心递归函数 *&#x2F;<br>     int Pivot, Cutoff, Low, High;</p>
<pre><code> if ( Cutoff &lt;= Right-Left ) &#123; /\* 如果序列元素充分多，进入快排 \*/
      Pivot = Median3( A, Left, Right ); /\* 选基准 \*/ 
      Low = Left; High = Right-1;
      while (1) &#123; /\*将序列中比基准小的移到基准左边，大的移到右边\*/
           while ( A\[++Low\] &lt; Pivot ) ;
           while ( A\[--High\] &gt; Pivot ) ;
           if ( Low &lt; High ) Swap( &amp;A\[Low\], &amp;A\[High\] );
           else break;
      &#125;
      Swap( &amp;A\[Low\], &amp;A\[Right-1\] );   /\* 将基准换到正确的位置 \*/ 
      Qsort( A, Left, Low-1 );    /\* 递归解决左边 \*/ 
      Qsort( A, Low+1, Right );   /\* 递归解决右边 \*/  
 &#125;
 else InsertionSort( A+Left, Right-Left+1 ); /\* 元素太少，用简单排序 \*/ 
</code></pre>
<p>}</p>
<p>（52, 49, 80, 36, 14, 75, 58, 97, 23, 61）<br>经第1趟快速排序之后为：(23, 49, 14, 36) 52 (75, 58, 97, 80, 61)<br>经第2趟快速排序之后为：(14) 23 (49, 36) 52 (61, 58) 75 (80, 97)<br>经第3趟快速排序之后为：(14, 23, 36, 49, 52, 58, 61, 75, 80, 97)<br>注：为避免出现枢轴记录关键字为”最大”或”最小”的情况，通常进行的快速排序采用”三者取中”的改进方案，即以 R[s]、R[t] 和 R[(s+t)&#x2F;2] 三者中关键字介于中值者为枢轴。只要将它和 R[s] 互换，一次划分的算法仍不变。</p>
<h4 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h4><h5 id="3-1-简单选择"><a href="#3-1-简单选择" class="headerlink" title="3.1 简单选择"></a>3.1 简单选择</h5><p>算法思想:设待排序的文件为(r[1],r[2],…,r[n]),关键字为(r[1].key,r[2].key,…,r[n].key),<br>第1趟(遍)：在(r[1],r[2],…,r[n])中,选出关键字最小的记录r[min].key，若min≠1,则交换r[1]和r[min]；<br>需要进行n-1次比较。<br>　 第2趟(遍)：在n-1个记录(r[2],…,r[n])中,选出关键字最小的记录r[min].key，若min≠2,则交换r[2]和r[min]；<br>　 需要进行n-2次比较。<br>　 第n-1趟(遍)：在最后的2个记录记录(r[n-1],r[n])中,选出关键字最小的记录r[min].key，若min≠n-1,则交换r[n-1]和r[min]；需要进行1次比较。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-32.png"></p>
<h5 id="3-2-树形选择排序"><a href="#3-2-树形选择排序" class="headerlink" title="3.2 树形选择排序"></a>3.2 树形选择排序</h5><p>树形选择排序又称锦标赛排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。可用一棵有n个叶子结点的完全二叉树表示。<br>基本思想为：<br>首先对n个记录的关键字进行两两比较，然后在其中n&#x2F;2个较小者之间再进行两两比较，如此重复，直到选出最小关键字的记录为止（树根）。<br>将最小关键字输出，且将其原来位置改为极大数，与此位置相关部分重新（向树根方向）进行比较，选出次小关键字，保留结果。<br>如此下去，直至全部排序完成。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-33-1024x721.png"></p>
<p>$19_1,1,23,27,55,19_2,84,14$</p>
<p>该方法比直接选择排序速度上有很大提高，其缺点有：<br>（1）需要另开储存空间保存排序结果；<br>（2）n个待排序关键字，需要额外的（n-1）个内部结点（包括根结点），增加了内存开销。<br>（3）将最小关键字改为极大数，再与兄弟结点比较属于多余。<br>故：树形选择排序一般不是用来排序而是用来证明某些问题。为了弥补以上缺点，威洛姆斯在1964年提出了另一种形式的选择排序—堆排序。</p>
<h5 id="3-3-堆排序"><a href="#3-3-堆排序" class="headerlink" title="3.3 堆排序"></a>3.3 堆排序</h5><p>堆的定义略<br>问题1：如何将序列{k1,k2,…,kn} 处理成（大顶）堆（初始化）？<br>问题2：如何在堆顶元素被替换后，调整剩余元素成为一个新的堆。</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-34-1024x686.png"></p>
<p>孩子比父亲大:最大的孩子和父亲交换,一直到没有孩子或者孩子都比父亲小</p>
<p>void Swap( ElementType *a, ElementType *b )<br>{<br>     ElementType t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;<br>}</p>
<p>void PercDown( ElementType A[], int p, int N )<br>{ &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;<br>  &#x2F;* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 *&#x2F;<br>    int Parent, Child;<br>    ElementType X;</p>
<pre><code>X = A\[p\]; /\* 取出根结点存放的值 \*/
for( Parent=p; (Parent\*2+1)&lt;N; Parent=Child ) &#123;
    Child = Parent \* 2 + 1;
    if( (Child!=N-1) &amp;&amp; (A\[Child\]&lt;A\[Child+1\]) )
        Child++;  /\* Child指向左右子结点的较大者 \*/
    if( X &gt;= A\[Child\] ) break; /\* 找到了合适位置 \*/
    else  /\* 下滤X \*/
        A\[Parent\] = A\[Child\];
&#125;
A\[Parent\] = X;
</code></pre>
<p>}</p>
<p>void HeapSort( ElementType A[], int N )<br>{ &#x2F;* 堆排序 *&#x2F;<br>     int i;</p>
<pre><code> for ( i=N/2-1; i&gt;=0; i-- )/\* 建立最大堆 \*/
     PercDown( A, i, N );
 
 for ( i=N-1; i&gt;0; i-- ) &#123;
     /\* 删除最大堆顶 \*/
     Swap( &amp;A\[0\], &amp;A\[i\] ); /\* 见代码7.1 \*/
     PercDown( A, 0, i );
 &#125;
</code></pre>
<p>}</p>
<p>这个代码把问题1和问题2统一化了<br>时间复杂度:O(nlogn)</p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4 归并排序"></a>4 归并排序</h4><p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-35-1024x711.png"></p>
<p>归并的操作,就是两个指针,谁少就copy谁,最后就把剩下的元素copy过去</p>
<p>第一个想法:<br>每个子文件的长度从2,4,8一直递增</p>
<p>1.假如说:现在还剩下2s以上的空缺,就直接s和s互相互补即可<br>2.假如说:现在还剩下s-2s的空缺,就剩下的部分归并<br>3.假如说:现在还剩下0-s的空缺,就直接照抄</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-36.png"></p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-37.png"></p>
<p>当然,还有一种写法就是找到最中间的一个元素,然后进行分化</p>
<p>&#x2F;* 归并排序 - 递归实现 *&#x2F;</p>
<p>&#x2F;* L &#x3D; 左边起始位置, R &#x3D; 右边起始位置, RightEnd &#x3D; 右边终点位置*&#x2F;<br>void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )<br>{ &#x2F;* 将有序的A[L]<del>A[R-1]和A[R]</del>A[RightEnd]归并成一个有序序列 *&#x2F;<br>     int LeftEnd, NumElements, Tmp;<br>     int i;</p>
<pre><code> LeftEnd = R - 1; /\* 左边终点位置 \*/
 Tmp = L;         /\* 有序序列的起始位置 \*/
 NumElements = RightEnd - L + 1;
 
 while( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;
     if ( A\[L\] &lt;= A\[R\] )
         TmpA\[Tmp++\] = A\[L++\]; /\* 将左边元素复制到TmpA \*/
     else
         TmpA\[Tmp++\] = A\[R++\]; /\* 将右边元素复制到TmpA \*/
 &#125;

 while( L &lt;= LeftEnd )
     TmpA\[Tmp++\] = A\[L++\]; /\* 直接复制左边剩下的 \*/
 while( R &lt;= RightEnd )
     TmpA\[Tmp++\] = A\[R++\]; /\* 直接复制右边剩下的 \*/
     
 for( i = 0; i &lt; NumElements; i++, RightEnd -- )
     A\[RightEnd\] = TmpA\[RightEnd\]; /\* 将有序的TmpA\[\]复制回A\[\] \*/
</code></pre>
<p>}</p>
<p>void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )<br>{ &#x2F;* 核心递归排序函数 *&#x2F;<br>     int Center;</p>
<pre><code> if ( L &lt; RightEnd ) &#123;
      Center = (L+RightEnd) / 2;
      Msort( A, TmpA, L, Center );              /\* 递归解决左边 \*/ 
      Msort( A, TmpA, Center+1, RightEnd );     /\* 递归解决右边 \*/  
      Merge( A, TmpA, L, Center+1, RightEnd );  /\* 合并两段有序序列 \*/ 
 &#125;
</code></pre>
<p>}</p>
<p>void MergeSort( ElementType A[], int N )<br>{ &#x2F;* 归并排序 *&#x2F;<br>     ElementType *TmpA;<br>     TmpA &#x3D; (ElementType *)malloc(N*sizeof(ElementType));</p>
<pre><code> if ( TmpA != NULL ) &#123;
      Msort( A, TmpA, 0, N-1 );
      free( TmpA );
 &#125;
 else printf( &quot;空间不足&quot; );
</code></pre>
<p>}</p>
<p>&#x2F;* 归并排序 - 循环实现 *&#x2F;<br>&#x2F;* 这里Merge函数在递归版本中给出 *&#x2F;</p>
<p>&#x2F;* length &#x3D; 当前有序子列的长度*&#x2F;<br>void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )<br>{ &#x2F;* 两两归并相邻有序子列 *&#x2F;<br>     int i, j;</p>
<pre><code> for ( i=0; i &lt;= N-2\*length; i += 2\*length )
     Merge( A, TmpA, i, i+length, i+2\*length-1 );
 if ( i+length &lt; N ) /\* 归并最后2个子列\*/
     Merge( A, TmpA, i, i+length, N-1);
 else /\* 最后只剩1个子列\*/
     for ( j = i; j &lt; N; j++ ) TmpA\[j\] = A\[j\];
</code></pre>
<p>}</p>
<p>void Merge_Sort( ElementType A[], int N )<br>{<br>     int length;<br>     ElementType *TmpA;</p>
<pre><code> length = 1; /\* 初始化子序列长度\*/
 TmpA = malloc( N \* sizeof( ElementType ) );
 if ( TmpA != NULL ) &#123;
      while( length &lt; N ) &#123;
          Merge\_pass( A, TmpA, N, length );
          length \*= 2;
          Merge\_pass( TmpA, A, N, length );
          length \*= 2;
      &#125;
      free( TmpA );
 &#125;
 else printf( &quot;空间不足&quot; );
</code></pre>
<p>}</p>
<h4 id="5-基数排序"><a href="#5-基数排序" class="headerlink" title="5 基数排序"></a>5 基数排序</h4><p>就是构建十个桶,按照个位,先按照各元素放入桶里.<br>接着再取出,按照0-9的顺序,接着是十位,接着是百位</p>
<p>&#x2F;* 基数排序 - 次位优先 *&#x2F;</p>
<p>&#x2F;* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix *&#x2F;<br>#define MaxDigit 4<br>#define Radix 10</p>
<p>&#x2F;* 桶元素结点 *&#x2F;<br>typedef struct Node *PtrToNode;<br>struct Node {<br>    int key;<br>    PtrToNode next;<br>};</p>
<p>&#x2F;* 桶头结点 *&#x2F;<br>struct HeadNode {<br>    PtrToNode head, tail;<br>};<br>typedef struct HeadNode Bucket[Radix];</p>
<p>int GetDigit ( int X, int D )<br>{ &#x2F;* 默认次位D&#x3D;1, 主位D&lt;&#x3D;MaxDigit *&#x2F;<br>    int d, i;</p>
<pre><code>for (i=1; i&lt;=D; i++) &#123;
    d = X % Radix;
    X /= Radix;
&#125;
return d;
</code></pre>
<p>}</p>
<p>void LSDRadixSort( ElementType A[], int N )<br>{ &#x2F;* 基数排序 - 次位优先 *&#x2F;<br>     int D, Di, i;<br>     Bucket B;<br>     PtrToNode tmp, p, List &#x3D; NULL; </p>
<pre><code> for (i=0; i&lt;Radix; i++) /\* 初始化每个桶为空链表 \*/
     B\[i\].head = B\[i\].tail = NULL;
 for (i=0; i&lt;N; i++) &#123; /\* 将原始序列逆序存入初始链表List \*/
     tmp = (PtrToNode)malloc(sizeof(struct Node));
     tmp-&gt;key = A\[i\];
     tmp-&gt;next = List;
     List = tmp;
 &#125;
 /\* 下面开始排序 \*/ 
 for (D=1; D&lt;=MaxDigit; D++) &#123; /\* 对数据的每一位循环处理 \*/
     /\* 下面是分配的过程 \*/
     p = List;
     while (p) &#123;
         Di = GetDigit(p-&gt;key, D); /\* 获得当前元素的当前位数字 \*/
         /\* 从List中摘除 \*/
         tmp = p; p = p-&gt;next;
         /\* 插入B\[Di\]号桶尾 \*/
         tmp-&gt;next = NULL;
         if (B\[Di\].head == NULL)
             B\[Di\].head = B\[Di\].tail = tmp;
         else &#123;
             B\[Di\].tail-&gt;next = tmp;
             B\[Di\].tail = tmp;
         &#125;
     &#125;
     /\* 下面是收集的过程 \*/
     List = NULL; 
     for (Di=Radix-1; Di&gt;=0; Di--) &#123; /\* 将每个桶的元素顺序收集入List \*/
         if (B\[Di\].head) &#123; /\* 如果桶不为空 \*/
             /\* 整桶插入List表头 \*/
             B\[Di\].tail-&gt;next = List;
             List = B\[Di\].head;
             B\[Di\].head = B\[Di\].tail = NULL; /\* 清空桶 \*/
         &#125;
     &#125;
 &#125;
 /\* 将List倒入A\[\]并释放空间 \*/
 for (i=0; i&lt;N; i++) &#123;
    tmp = List;
    List = List-&gt;next;
    A\[i\] = tmp-&gt;key;
    free(tmp);
 &#125; 
</code></pre>
<p>}</p>
<h4 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6 计数排序"></a>6 计数排序</h4><p>这个可以用于排序的数范围已知的情况,非常好写</p>
<h4 id="7-排序算法的比较"><a href="#7-排序算法的比较" class="headerlink" title="7 排序算法的比较"></a>7 排序算法的比较</h4><p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-38-1024x732.png"></p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h3><p>1.<strong>数据,数据元素,数据对象,数据项,数据结构</strong>的概念<br>什么是基本单位,什么是最小单位,什么是所有能输入到计算机中并被计算机程序处理的符号总称?性质相同的元素的集合?</p>
<p>2.<strong>结构的分类?</strong><br>逻辑结构:集合,线性表,树,图<br>物理结构:顺序存储结构,物理存储结构,索引存储结构,哈希存储结构</p>
<p>3.引用参数:&amp;:可以扩展为指针</p>
<p>4.<strong>算法的五个特征</strong><br>(1)有穷性<br>(2)可读性<br>(3)健壮性<br>(4)可行性<br>(5)高效性</p>
<p>5.时间复杂度的分析:<br>(1)大致的时间复杂度<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-e62441dc3fec6b2e6c96754d2eb3ea5e_l3.svg" alt="O(n^2),O(n),O(nlogn)">为多数<br>(2)递归或者循环调用时,调用的每个语句都要算进去<br>(3)计算语句频度的方法?</p>
<p>6.空间复杂度分析:<br>(1)递归:有栈存储,至少<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-31c2cdca867987ac2a6e27b1434ae748_l3.svg" alt="O(n)">的空间<br>(2)有递归次数:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-22a4dafb17035ef91361c6a58809420f_l3.svg" alt="O(nm)"></p>
<h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h3><p>1.表长:表长与存储的长度区别,maxlength和size的区别<br>2.直接前驱后继:首元素没有前驱,尾元素没有后继<br>3.抽象数据类型:了解(跟class一样)</p>
<p>4.存储特征:<br>顺序存储结构:可以随机读取元素,插入删除复杂<br>链式存储结构:不可以随机读取元素,插入删除较为简单</p>
<p>5.自由区:空闲的空间<br>6.首地址+偏移量选址法<br>(见数组)</p>
<p>7.动态静态分配的顺序存储结构</p>
<p>静态存取</p>
<p>#define maxleng 100<br> typedef struct<br>   { ElemType elem[maxleng]；&#x2F;&#x2F;下标:0,1,…,maxleng-1<br>     int length；            &#x2F;&#x2F;表长<br>    } SqList；<br>   SqList La；</p>
<p>动态存取:</p>
<p>#define LIST_INIT_SIZE 100<br> #define LISTINCREMENT 10<br>typedef struct<br>   { ElemType *elem；&#x2F;&#x2F;存储空间基地址<br>     int length；    &#x2F;&#x2F;表长<br>     int listsize;   &#x2F;&#x2F;当前分配的存储容量<br>                     &#x2F;&#x2F;（以sizeof(ElemType)为单位<br>    } SqList；<br>   SqList Lb；</p>
<p>有增量#define LISTINCREMENT 10</p>
<p>溢出时扩充的方法</p>
<p>if (L.length&gt;&#x3D;L.listsize)    &#x2F;*溢出时扩充*&#x2F;<br>      {<br>     ElemType *newbase;<br>     newbase&#x3D;(ElemType *) realloc(L.elem,<br>        (L.listsize+LISTINCREMENT)*sizeof(ElemType));<br>      if (newbase&#x3D;&#x3D;NULL) return OVERFLOW;   &#x2F;&#x2F;扩充失败<br>     L.elem&#x3D;newbase;<br>     L.listsize+&#x3D;LISTINCREMENT;<br>      }</p>
<p>9.链表<br>1.带头结点和不带头结点<br>带头结点的作用:需要额外开辟一个空间,但是插入和删除首元素时不用进行特殊处理</p>
<p>10.静态链表:用数组模拟,数组里面有data域和下一个元素的编号,head-&gt;0,尾元素指向0</p>
<p>11.循环链表:<br>尾指针:有头:指向表头<br>无头:指向第一个元素<br>head:设置任意一个指<br>只需要设一个尾指针就可以满足,可以找到链表的任何一个值</p>
<p>12.双向链表</p>
<p>首结点前驱是空,尾结点后继是空<br>表头结点前驱是尾结点,后继指头结点<br><strong>会考一些操作</strong></p>
<p>13.双向循环链表:没有哪一个指针域是空</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-43-852x1024.png"></p>
<h3 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h3><h4 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h4><p>1.先进后出</p>
<p>2.栈顶和栈底的定义</p>
<p>3.栈顶的几个定义法:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ed392a9187fc44b002c7f34039bceffb_l3.svg" alt="a_n">和<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-ed392a9187fc44b002c7f34039bceffb_l3.svg" alt="a_n">的上一个单元:空栈时分别对应-1和0</p>
<p>4.进展顺序判断:第二斯特林数,溢出和下溢的判断</p>
<p>5.符号表达式和代替递归函数</p>
<p>6.存储形式<br>(1)数组,加个top<br>(2)链式存储,用表头插入:搞清楚插入删除的复杂度:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-d1a0977d9e713b6eb464199427db69ec_l3.svg" alt="O(1)"></p>
<h4 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h4><p>1.先进先出</p>
<p>2.双向队列:中间值不能动<br>输入受限:只允许在表的一端插入、在两端删除元素的线性表<br>输出受限:只许在表的两端插入、在一端删除元素的线性表</p>
<p>3.循环队列:<br>溢出判断:(Q.rear+1)% MAXLENGQ.front<br>下溢判断:Q.front&#x3D;&#x3D;Q.rear<br>算队列长的方法:(Q.rearQ.front+maxlength)%maxlength<br>改进:有6个空间,只存5个元素</p>
<p>还要记住几个插入删除的算法怎么写</p>
<h2 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h2><p>1.’\0’C语言<br>a[0]存指定的串长 Pascal</p>
<p>2.字符堆:指针指向一个地址(第一个字母的地址),还有一个元素存长度</p>
<p>3.链式堆的存储密度<br>(1)多字符和单字符<br>(2)计算方式:,开辟的总空间&#x3D;字符数+指针域</p>
<p>4.KMP算法,求那个next数组的值</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-42.png"></p>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h3><p>1.行存储和列存储:<br>首元素寻址法:有0行0列和无0行0列</p>
<p>从左到右&amp;从右到左</p>
<p>例子:三维数组a[1..p,1..m,1..n],假定无0页0行0列<br>1)以行序为主序，<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-07ce0328ccb22f350ed439f36f77fd84_l3.svg" alt="a[k][i][j]">的地址为<br><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-43d0a3104bdc468e0aa362b3b2129224_l3.svg" alt="Loc(k,i,j)=Loc(1,1,1)+(m&lt;em&gt;n&lt;/em&gt;(k-1)+n(i-1)+j-1)&lt;em&gt;s =h+(m&lt;/em&gt;n&lt;em&gt;(k-1)+n(i-1)+j-1)&lt;/em&gt;s"> <img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8a4da773c29ce91d743867baab6e88d1_l3.svg" alt="1\lek\lep, 1\lei\lem, 1\lej\len"></p>
<p>(2)以列序为主序，<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-07ce0328ccb22f350ed439f36f77fd84_l3.svg" alt="a[k][i][j]">的地址为<br><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-e4c9ffb6b7150926f5ce18b72cddae3b_l3.svg" alt="Loc(k,i,j)=Loc(1,1,1)+(p&lt;em&gt;m&lt;/em&gt;(j-1)+p&lt;em&gt;(i-1)+k-1)&lt;/em&gt;s=h+(p&lt;em&gt;m&lt;/em&gt;(j-1)+p&lt;em&gt;(i-1)+k-1)&lt;/em&gt;s"></p>
<p><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8a4da773c29ce91d743867baab6e88d1_l3.svg" alt="1\lek\lep, 1\lei\lem, 1\lej\len" title="Rendered by QuickLaTeX.com"></p>
<p>如果有0行0列:所有-1去掉</p>
<p>2.矩阵压缩存储</p>
<p>(1)对称矩阵与三对角</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-40.png"></p>
<p><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-b88d2ed52fc70c959cc939c76a09d9ec_l3.svg" alt="k= (3*(i-1)-1)+(j-i+2) = 2(i-1)+j" title="Rendered by QuickLaTeX.com"></p>
<p>3.稀疏矩阵<br>(1)三元组表:存行列值和元素值<br>(2)十字链表</p>
<p>4.广义表:加递归,元素可以是单独的值也可以是新的广义表</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-39.png"></p>
<p>结构位置表示:a,b,c,d 都表明好<br>(1)广义表的图型表示—-树型结构<br>约定 □—-单元素&#x2F;原子<br>○—-列表,若有表名,附表名：对应（）<br>(2)存储结构</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2020/11/image-41.png"></p>
<p>(3)表头:第一个元素:可元素,可表<br>(4)表尾:剩下的元素都是表尾,一定是广义表</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/project/">首页</a></li>
        
          <li><a href="/project/about/">关于</a></li>
        
          <li><a href="/project/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E6%9C%89%E5%85%B3%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">1.树的有关定义和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">2.二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">3.二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.4.</span> <span class="toc-text">3.树和森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Huffman%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">4.Huffman树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.1.</span> <span class="toc-text">1.图的定义和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.图的存储形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">3.图的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">4.最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%BA%94%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">4.有向无环图应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.</span> <span class="toc-text">5 最短路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text">1 顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.2.</span> <span class="toc-text">2 二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3 索引顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">3.4.</span> <span class="toc-text">4 二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">5 平衡二叉树(AVL树)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 简单插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2.折半插入排序（二分插入排序）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E5%B8%8C%E5%B0%94-shell-%E6%8E%92%E5%BA%8F-%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3.希尔(shell)排序 (缩小增量排序)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 简单选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 树形选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5 基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text">6 计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.7.</span> <span class="toc-text">7 排序算法的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">2 线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">3 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A0%88"><span class="toc-number">8.1.</span> <span class="toc-text">3.1 栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%98%9F%E5%88%97"><span class="toc-number">8.2.</span> <span class="toc-text">3.2 队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">4 串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">5 数组</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&text=数据结构相关专题"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&is_video=false&description=数据结构相关专题"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=数据结构相关专题&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&title=数据结构相关专题"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&name=数据结构相关专题&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/&t=数据结构相关专题"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    Sukuna
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/project/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
