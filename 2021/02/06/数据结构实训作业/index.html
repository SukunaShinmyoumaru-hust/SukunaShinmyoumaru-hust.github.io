<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="(I) 第一关 本关任务：已知顺序表L中的数据元素递增有序，数据元素类型为int。相关定义如下： #define LIST_INIT_SIZE 20 #define LISTINCREMENT 10 typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; 试写一算法，将x插">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构实训作业">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="(I) 第一关 本关任务：已知顺序表L中的数据元素递增有序，数据元素类型为int。相关定义如下： #define LIST_INIT_SIZE 20 #define LISTINCREMENT 10 typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; 试写一算法，将x插">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.educoder.net/api/attachments/1132765">
<meta property="article:published_time" content="2021-02-06T03:22:53.000Z">
<meta property="article:modified_time" content="2024-02-27T05:01:50.115Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.educoder.net/api/attachments/1132765">
    
    
      
        
          <link rel="shortcut icon" href="/project/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/project/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/project/images/favicon-192x192.png">
        
      
    
    <!-- title -->
    <title>数据结构实训作业</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/project/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B8%93%E9%A2%98/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/project/2020/10/11/%E7%83%82%E6%B4%BB%E7%94%A8cmd%E7%AA%97%E5%8F%A3%E8%BE%93%E5%87%BA%E5%9B%BE%E7%94%BB/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&text=数据结构实训作业"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&is_video=false&description=数据结构实训作业"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=数据结构实训作业&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&name=数据结构实训作业&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&t=数据结构实训作业"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        数据结构实训作业
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Sukuna</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-02-06T03:22:53.000Z" class="dt-published" itemprop="datePublished">2021-02-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/project/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/">实验记录</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>(I)</p>
<p>第一关</p>
<p><strong>本关任务</strong>：已知顺序表L中的数据元素递增有序，数据元素类型为int。相关定义如下： <br>#define LIST_INIT_SIZE 20 <br>#define LISTINCREMENT 10 <br>typedef int ElemType; <br>typedef struct { ElemType *elem; <br>int length; <br>int listsize; } SqList; <br>试写一算法，将x插入到顺序表的适当位置上，以保持该表的有序性。 <br><strong>函数原型</strong>：int insert(SqList &amp;L,ElemType x);</p>
<p>这道题白给</p>
<p>int insert(SqList &amp;L, ElemType x)<br>{<br>    &#x2F;**********begin**********&#x2F;<br>    int cnt &#x3D; 0;<br>    while (L.elem[cnt] &lt; x &amp;&amp; cnt &lt; L.length)<br>        cnt++;&#x2F;&#x2F;计算应该到达的位置<br>&#x2F;&#x2F;这个时候cnt应该指向刚好比x大的那一位,那这一位后面的所有的元素都往后摞一位,处理即可<br>    for (int i &#x3D; L.length; i &gt; cnt; i–)<br>    {<br>        L.elem[i] &#x3D; L.elem[i - 1];&#x2F;&#x2F;从最后一个元素的下一个空格开始移动<br>    }<br>&#x2F;&#x2F;从后往前进行处理<br>    L.elem[cnt] &#x3D; x;<br>    L.length +&#x3D; 1;<br>    if (L.length &gt; L.listsize)<br>    {<br>        ElemType *newbase;<br>        newbase &#x3D; (ElemType *)realloc(L.elem,<br>                                      (L.listsize + LISTINCREMENT) * sizeof(ElemType));<br>&#x2F;&#x2F;溢出的处理<br>        L.elem &#x3D; newbase;<br>        L.listsize +&#x3D; LISTINCREMENT;<br>    }<br>    return 1;<br>    &#x2F;**********end**********&#x2F;<br>}</p>
<p>第二关</p>
<p><strong>本关任务</strong>：设以带头结点的双向循环链表表示线性表L&#x3D;（a1，a2，…，an），试编写一个时间复杂度为O(n)的算法，将L改变成L&#x3D;（a1，a3，…，an，…，a4，a2）。 相关定义如下：<br>typedef int ElemType; <br>typedef struct Dnode { <br>ElemType data; <br>struct Dnode * prior, * next; <br>} * DuLinkList; <br><strong>函数原型</strong>：void adjust(DuLinkList L);</p>
<p>&#x2F;&#x2F;思路就是,奇数的节点,往前插,偶数的节点,插后面去<br>void  adjust(DuLinkList&amp;  L)<br>{<br>        DuLinkList Lnew &#x3D; (DuLinkList)malloc(sizeof(Dnode));<br>        Lnew-&gt;data &#x3D; 0;<br>        Lnew-&gt;prior &#x3D; Lnew;<br>        Lnew-&gt;next &#x3D; Lnew;<br>        Dnode *p, *q, *pa, *pb;<br>        q &#x3D; p &#x3D; L-&gt;next;<br>        pa &#x3D; pb &#x3D; Lnew;<br>&#x2F;&#x2F;建一个空的双向链表<br>&#x2F;&#x2F;p和q遍历L,pb和pa来构建新的逻辑关系,pb最后,pa最前<br>        while (p !&#x3D; L)&#x2F;&#x2F;没有遍历到最后<br>        {<br>            if (p !&#x3D; L)<br>            {<br>                &#x2F;*L中奇数个数据插入Lnew*&#x2F;<br>                q &#x3D; p-&gt;next;&#x2F;&#x2F;保留 L 链表<br>                &#x2F;&#x2F;pa之后插入p<br>                p-&gt;prior &#x3D; pa;<br>&#x2F;&#x2F;p是当前要插入的偶数节点,q保存了p的下一个节点<br>                pa-&gt;next &#x3D; p;<br>&#x2F;&#x2F;pa往后补一个节点<br>                p-&gt;next &#x3D; pb;<br>&#x2F;&#x2F;p往后指,构建循环<br>                pb-&gt;prior &#x3D; p;<br>&#x2F;&#x2F;最前面的结点指向最后面的结点<br>                pa &#x3D; pa-&gt;next;<br>&#x2F;&#x2F;pa指到最后<br>                p &#x3D; q;&#x2F;&#x2F;p指向 待操作 L<br>&#x2F;&#x2F;p指向q(偶数节点)<br>            }<br>            if (p !&#x3D; L)<br>            {<br>                &#x2F;*L中偶数个数据插入Lnew*&#x2F;<br>                q &#x3D; p-&gt;next;&#x2F;&#x2F;保留 L 链表<br>                &#x2F;&#x2F;pb之前插入p<br>                p-&gt;next &#x3D; pb;<br>&#x2F;&#x2F;p的下一个指向原链表的最后一个指针<br>                pb-&gt;prior &#x3D; p;<br>&#x2F;&#x2F;最后一个指针往回指<br>                p-&gt;prior &#x3D; pa;<br>&#x2F;&#x2F;p往回指向最后的结点,构建循环<br>                pa-&gt;next &#x3D; p;<br>&#x2F;&#x2F;也循环回去<br>                pb &#x3D; pb-&gt;prior;<br>&#x2F;&#x2F;pb往回指,保证pb指向最后<br>                p &#x3D; q;&#x2F;&#x2F;p指向 待操作 L<br>            }<br>        }<br>    L &#x3D; Lnew;<br>}<br>主要是每个链表的逻辑关系<br>一定要注意!保存原链表L</p>
<p>第三关</p>
<p>已知A、B和C为3个递增有序的线性表，现要求对A表做如下操作，删除那些既在B中出现，也在C中出现的元素。以顺序表作为线性表的物理结构，编写实现上述操作的算法。 <br><strong>函数原型</strong>：void TriSqList(SqList &amp;A,SqList B,SqList C)</p>
<p>void TriSqList(SqList &amp;A, SqList B, SqList C)<br>{<br>&#x2F;**********Begin**********&#x2F;<br>int pa &#x3D; 0, pb &#x3D; 0, pc &#x3D; 0;<br>if (A.length &gt; 0)<br>{<br>while (pa &lt; A.length &amp;&amp; pb &lt; B.length &amp;&amp; pc &lt; C.length)<br>&#x2F;&#x2F;如果没到末尾<br>{<br>if(B.elem[pb]&#x3D;&#x3D;C.elem[pc])<br>&#x2F;&#x2F;如果B和C的存在相同的元素<br>{<br>                                 if(A.elem[pa]&#x3D;&#x3D;B.elem[pb])<br>&#x2F;&#x2F;这个时候ABC相同,就可以删除A.elem[pa]了<br>{<br>int nxt&#x3D;pa+1,nsiz&#x3D;1;<br>while (A.elem[nxt]&#x3D;&#x3D;A.elem[pa])&#x2F;&#x2F;寻找有重复的元素,然后都删除掉<br>{<br>nxt++;<br>nsiz++;<br>}<br>for(int i&#x3D;nxt;i&lt;A.length;i++)<br>{<br>A.elem[i-nsiz]&#x3D;A.elem[i];<br>}<br>A.length-&#x3D;nsiz;&#x2F;&#x2F;A减少<br>pb++;<br>pc++;<br>&#x2F;&#x2F;B和C往后移<br>}<br>else if(A.elem[pa]&lt;B.elem[pb])pa++;<br>&#x2F;&#x2F;如果A比B小,那A就往后移动匹配B<br>else<br>&#x2F;&#x2F;A比B大,BC往后移动匹配A<br>{<br>pb++;<br>pc++;<br>}<br>}<br>else if(B.elem[pb]&lt;C.elem[pc])<br>&#x2F;&#x2F;B比C小,B往后移<br>{<br>                pb++;<br>}<br>else<br>{<br>pc++;<br>}<br>}<br>}<br>&#x2F;**********End**********&#x2F;<br>}<br>这个是常见操作,设置双指针,适合处理有大小差别的元素,一遍遍历就可以了,通过指针的比较来判断指针移动的方向</p>
<p>第四关</p>
<p><strong>本关任务</strong>：已知A、B和C为3个递增有序的线性表，现要求对A表做如下操作，删除那些既在B中出现，也在C中出现的元素。以带表头结点的单链表作为线性表的物理结构，编写实现上述操作的算法。 <br><strong>函数原型</strong>：void TriLinkList(LinkList A,LinkList B,LinkList C)；</p>
<p>void TriLinkList(LinkList ha,LinkList hb,LinkList hc)<br>{&#x2F;&#x2F;本算法的前提是三个表都不能为空<br>    &#x2F;&#x2F;本算法的功能是除去表a中在表b和表c同时出现的元素</p>
<pre><code>//删除单链表A中的即在单链表B中又在单链表C中的元素
//A,B,C均递增有序
LinkList pa = ha-&gt;next;
LinkList prev = ha;
LinkList pb = hb-&gt;next;
LinkList pc = hc-&gt;next;
while (pb &amp;&amp; pc &amp;&amp; pa)&#123;
    if (pb-&gt;data &lt; pc-&gt;data)&#123;
        pb = pb-&gt;next;
    &#125;
    else if (pb-&gt;data &gt; pc-&gt;data)&#123;
        pc = pc-&gt;next;
    &#125;
    //移动使得pb和pc值是一样的
    else&#123;
        if (pa-&gt;data &lt; pb-&gt;data)&#123;//移动使得pa,pb,pc都一样
            prev = pa;
            pa = pa-&gt;next;
        &#125;
        else if (pa-&gt;data &gt; pb-&gt;data)&#123;//pa比pb,pc大,那就是pa里找不到,pb和pc往后移
            pc = pc-&gt;next;
            pb = pb-&gt;next;
        &#125;
        else&#123;//找到了,删除A
            prev-&gt;next = pa-&gt;next;
            free(pa);
            pa = prev-&gt;next;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>这个是常见操作,设置双指针,适合处理有大小差别的元素,一遍遍历就可以了,通过指针的比较来判断指针移动的方向</p>
<p>II</p>
<p>第一关</p>
<p>本关任务：编写程序实现双向栈。 假定以顺序存储结构实现一个双向栈，即在一个一维数组的存储空间中存在着两个栈，它们的栈底分别设在数组的两个端点。试编写实现着个双向栈的3个函数： 初始化栈inistack、入栈push和出栈pop</p>
<p>双向栈的物理结构示意图如下：</p>
<p><img src="https://www.educoder.net/api/attachments/1132765"></p>
<p>相应地，根据该示意图定义其数据类型：<br>#define N 100 <br>typedef struct TWSTACK { ElemType elem[N]; int top1,top2; } TWSTACK;</p>
<p>&#x2F;&#x2F;在下面的begin和end间填写相应代码<br>void inistack(TWSTACK &amp;S)<br>&#x2F;&#x2F;该函数实现初始化S，得到2个空栈。根据双向栈的示意图，理解初始化要求。<br>{<br>&#x2F;***************begin***************&#x2F;<br>    for(int i&#x3D;0;i&lt;N;i++){<br>        S.elem[i]&#x3D;0;&#x2F;&#x2F;每个元素置0<br>    }<br>    S.top1&#x3D;0;<br>    S.top2&#x3D;N-1;&#x2F;&#x2F;初始化指针<br>&#x2F;*************** end ***************&#x2F;<br>}<br>int push(TWSTACK &amp;S,int i,ElemType e)<br>&#x2F;&#x2F;i取值1或2，分别对应左或右栈，将元素e压入S的对应栈。成功入栈返回1，否则返回0<br>{<br>&#x2F;***************begin***************&#x2F;<br>    if(i&#x3D;&#x3D;1){<br>        if(S.top1&gt;S.top2) return 0;<br>        S.elem[S.top1++]&#x3D;e;<br>        return 1;<br>    }<br>    else{<br>        if(S.top1&gt;S.top2) return 0;<br>        S.elem[S.top2–]&#x3D;e;<br>        return 1;<br>    }<br>    &#x2F;*************** end ***************&#x2F;<br>}</p>
<p>int pop(TWSTACK &amp;S,int i, ElemType &amp;e)<br>&#x2F;&#x2F;i取值1或2，分别对应左或右栈，将S对应栈的栈顶元素出栈，赋值给e。成功出栈返回1，否则返回0<br>{<br>&#x2F;***************begin***************&#x2F;<br>    if(i&#x3D;&#x3D;1){<br>        if(S.top1&#x3D;&#x3D;0) return 0;<br>        e&#x3D;S.elem[–S.top1];<br>        return 1;<br>    }<br>    else{<br>        if(S.top2&#x3D;&#x3D;N-1) return 0;<br>        e&#x3D;S.elem[++S.top2];<br>        return 1;<br>    }</p>
<p>&#x2F;*************** end ***************&#x2F;<br>}<br>注意根据栈指针的特性规定前缀还是后缀</p>
<p>第二关</p>
<p>本关任务：编写程序实现循环队列。 假定以循环队列定义为：以域变量front和length分别指示循环队列中的队首元素的位置和内含元素的个数。试编写实现循环队列3个函数： 初始化队列iniQueue、入队enQueue和出队deQueue</p>
<p>为了完成本关任务，你需要掌握：1.队列，2.循环队列。 循环队列数据类型： #define MAXLENGTH 100 <br>typedef struct QUEUE { ElemType elem[MAXLENGTH];<br>int front，length; <br>} QUEUE;</p>
<p>&#x2F;&#x2F;在下面的begin和end间填写相应代码<br>void iniQueue(QUEUE &amp;Q)<br>&#x2F;&#x2F;该函数实现初始化Q<br>{<br>&#x2F;***************begin***************&#x2F;<br>    for(int i&#x3D;0;i&lt;MAXLENGTH;i++){<br>        Q.elem[i]&#x3D;0;<br>    }<br>    Q.front&#x3D;0;<br>    Q.length&#x3D;0;<br>&#x2F;*************** end ***************&#x2F;<br>}<br>int enQueue(QUEUE &amp;Q,ElemType e)<br>&#x2F;&#x2F;将元素e入队Q。成功入栈返回1，否则返回0<br>{<br>&#x2F;***************begin***************&#x2F;<br>    if(Q.length&#x3D;&#x3D;MAXLENGTH) return 0;<br>    Q.elem[(Q.front+Q.length)%MAXLENGTH]&#x3D;e;<br>    Q.length++;<br>&#x2F;*************** end ***************&#x2F;<br>}<br>int deQueue(QUEUE &amp;Q, ElemType &amp;e)<br>&#x2F;&#x2F;将Q队首元素出队，赋值给e。成功出队返回1，否则返回0<br>{<br>&#x2F;***************begin***************&#x2F;<br>    if(!Q.length) return 0;<br>    e&#x3D;Q.elem[Q.front];<br>    Q.front&#x3D;(Q.front+1)%MAXLENGTH;<br>    Q.length–;<br>&#x2F;*************** end ***************&#x2F;<br>}<br>注意循环链表的移动规则<br>判定双向链表为满的规则?</p>
<p>第三关</p>
<p>本关任务：假设称正读和反读都相同的字符序列为“回文”，例如，‘abba’和‘abcba’ 是回文，‘abcde’和‘ababab’则不是回文。试写一个算法判别读入的一个以‘@’为 结束符的字符序列是否是“回文”。</p>
<p>int isPalindrome(char *str)<br>&#x2F;&#x2F;判断字符串str是否回文，是则返回1，否则返回0<br>{<br>&#x2F;**********begin**********&#x2F;<br>    char x,y;<br>    TWSTACK S;<br>    QUEUE Q;<br>    iniQueue(Q);<br>    inistack(S);<br>    while(*str!&#x3D;‘@’){<br>        push(S,1,*str);<br>        enQueue(Q,*str);<br>        str++;<br>    }<br>    while(S.top1){<br>        pop(S,1,x);<br>        deQueue(Q,y);<br>        if(x!&#x3D;y) return 0;<br>    }<br>    return 1;<br>&#x2F;********** end **********&#x2F;<br>}</p>
<p>这就是,把字符串分别放进栈和队列里,根据栈和队列的出入特性来判断,队列或者栈空了那就是结束了.</p>
<p>(III)</p>
<p>第一关</p>
<p>本关任务：编写一个算法，将数组A中的n个元素A[0]至A[n-1]循环右移k位。要求算法时间复杂度为O（n），空间复杂度为O（1）</p>
<p>这一关的写出来不难,但是想出好的过程很难,这里就是对数组进行调换,因为我们发现循环之后数组分成两部分,类似于快速排序的分划结果,这个时候我们会思考可不可以用两部分颠倒的的思想来做</p>
<p>void reverse(ElemType a[],int s,int e)<br>{<br>int temp;<br>while(s &lt; e)<br>{<br>temp &#x3D; a[s];<br>a[s] &#x3D; a[e];<br>a[e] &#x3D; temp;<br>s++;<br>e–;<br>}</p>
<p>}<br>void ShiftRightCircular(ElemType *A,int n,int k)<br>{<br>&#x2F;************** begin *****************&#x2F;<br>    if(k &gt;&#x3D; n)<br>k &#x3D; k%n;<br>    if(k &gt; 0){<br>        reverse(A,0,n-k-1);<br>reverse(A+(n-k),0,k-1);<br>reverse(A,0,n-1);<br>    }<br>if(k &lt; 0){<br>        reverse(A,0,-k-1);<br>        reverse(A+(n+k),0,-k-1);<br>        reverse(A,0,n-1);<br>    }<br>&#x2F;**************  end  *****************&#x2F;<br>}</p>
<p>第二关</p>
<p>矩阵加法,矩阵的形式是三元组顺序表</p>
<p>我先写个函数,表示矩阵的插入(往后插),接着就对A和B进行遍历,如果行列值不一样,就插入行列值较少的数,i和j是两个数据指针,指向目前遍历的位置,插入A就i后移,插入B就B往后移,以此类推(行列相等就判断相加是否为0,最后i和j都要加)</p>
<p>void EnterTriple(TSMatrix *Q,int row,int col,int e)<br>{<br>    Q-&gt;tu++;<br>    Q-&gt;data[Q-&gt;tu].i&#x3D;row;<br>    Q-&gt;data[Q-&gt;tu].j&#x3D;col;<br>    Q-&gt;data[Q-&gt;tu].e&#x3D;e;<br>}<br>TSMatrix ADD(TSMatrix A,TSMatrix B)<br>&#x2F;&#x2F;返回矩阵A、B相加的结果<br>{<br>&#x2F;************** begin *****************&#x2F;<br>    TSMatrix C;<br>    for(int i&#x3D;0;i&lt;MAXSIZE+1;i++) {<br>        C.data[i].i&#x3D;0;<br>        C.data[i].j&#x3D;0;<br>        C.data[i].e&#x3D;0;<br>    }<br>    C.tu&#x3D;1;<br>    C.nu&#x3D;A.nu;<br>    C.mu&#x3D;A.mu;<br>    int i&#x3D;1,j&#x3D;1;<br>        while(i&lt;&#x3D;A.tu&amp;&amp;j&lt;&#x3D;B.tu)<br>        {<br>            if(A.data[i].i&lt;B.data[j].i)<br>            {<br>                EnterTriple(&amp;C,A.data[i].i,A.data[i].j,A.data[i].e);<br>                i++;<br>            }<br>            else if(A.data[i].i&#x3D;&#x3D;B.data[j].i)<br>            {<br>                if(A.data[i].j&lt;B.data[j].j)<br>                {<br>                    EnterTriple(&amp;C,A.data[i].i,A.data[i].j,A.data[i].e);<br>                    i++;<br>                }<br>                else if(A.data[i].j&gt;B.data[j].j)<br>                {<br>                    EnterTriple(&amp;C,B.data[j].i,B.data[j].j,B.data[j].e);<br>                    j++;<br>                }<br>                else<br>                {<br>                    if(B.data[j].e+A.data[i].e!&#x3D;0)<br>                        EnterTriple(&amp;C,B.data[j].i,B.data[j].j,B.data[j].e+A.data[i].e);<br>                    i++;<br>                    j++;<br>                }<br>            }<br>            else<br>            {<br>                EnterTriple(&amp;C,B.data[j].i,B.data[j].j,B.data[j].e);<br>                j++;<br>            }<br>        }<br>        while(i&lt;&#x3D;A.tu)<br>        {<br>            EnterTriple(&amp;C,A.data[i].i,A.data[i].j,A.data[i].e);<br>            i++;<br>        }<br>        while(j&lt;&#x3D;B.tu)<br>        {<br>            EnterTriple(&amp;C,B.data[j].i,B.data[j].j,B.data[j].e);<br>            j++;<br>        }<br>    for(int i&#x3D;0;i&lt;C.tu;i++){<br>        C.data[i]&#x3D;C.data[i+1];<br>    }<br>    C.tu–;<br>    return C;<br>&#x2F;**************  end  *****************&#x2F;<br>}</p>
<p>第三关</p>
<p>思想是这样的首先找到子串出现的位置,然后把子串之后的保存,经过几个操作,temp里存的是字符串后面的元素,pFound由于是指针操作,改变了原地址的值,所以说S.ch目前指向之前的元素加第二个子串,链接即可<br>由于main函数里面用了fget,所以说要去除回车的影响,把应有的元素设置为0</p>
<p>#include &lt;string.h&gt;<br>void Replace(HString &amp;S,HString T,HString V)<br>&#x2F;&#x2F;<br>{<br>&#x2F;************** begin *****************&#x2F;<br>    *(S.ch+S.length)&#x3D;0;<br>    *(T.ch+T.length)&#x3D;0;<br>    *(V.ch+V.length)&#x3D;0;<br>    char *pFound&#x3D;NULL;<br>    pFound&#x3D;strstr(S.ch,T.ch);<br>    while(pFound){<br>        char temp[100]&#x3D;{0};<br>        strcpy(temp,pFound+T.length);<br>        strcpy(pFound,V.ch);<br>        strcat(S.ch,temp);<br>        pFound&#x3D;strstr(pFound+V.length,T.ch);<br>    }<br>    S.length&#x3D;strlen(S.ch);<br>&#x2F;**************  end  *****************&#x2F;<br>}</p>
<p>(IV)</p>
<p>二叉搜索树和排序的一些问题</p>
<p>第一题:判断是不是二叉排序树?</p>
<p>status JudgeBiTree(BiTree T)<br>&#x2F;&#x2F;判断二叉树T是否为二叉排序树<br>{<br>    &#x2F;&#x2F; 请在这里补充代码，完成本关任务<br>    &#x2F;********** Begin *********&#x2F;<br>    struct BiTNode * St[100], *p;<br>    int top &#x3D; 0; &#x2F;&#x2F;置空栈<br>    if(T){<br>    St[top++] &#x3D; T;<br>        while(top){<br>        p &#x3D; St[–top];<br>            if(p-&gt;rchild !&#x3D; NULL){<br>                St[top++] &#x3D; p-&gt;rchild;<br>                if(p-&gt;data.key&gt;p-&gt;rchild-&gt;data.key) return NO;<br>            }<br>        if(p-&gt;lchild !&#x3D; NULL){<br>                St[top++] &#x3D; p-&gt;lchild;<br>                if(p-&gt;data.key<p->lchild-&gt;data.key) return NO;<br>            }<br>        }<br>    }<br>    return YES;<br>    &#x2F;********** End **********&#x2F;<br>}</p>
<p>前序遍历的非递归实现,每一次访问结点的时候就判断一下是不是满足二叉搜索树的条件,如果能成功安全退出,那就是搜索树了</p>
<p>第二题:线性时间复杂度的排序</p>
<p>想到了计数排序,开个新数组存就完事了</p>
<p>void sort(int a[],int n,int k)<br>&#x2F;&#x2F;将a中元素递增排序<br>{<br>    &#x2F;&#x2F; 请在这里补充代码，完成本关任务<br>    &#x2F;********** Begin *********&#x2F;<br>    int c[100]&#x3D;{0};<br>    int ranked[100]&#x3D;{0};<br>    for (int i &#x3D; 0; i &lt; n ; i++){<br>        c[a[i]]++;<br>    }<br>    for (int i &#x3D; 1; i &lt; k+1; ++i)<br>        c[i] +&#x3D; c[i-1];<br>    for (int i &#x3D; n-1; i &gt;&#x3D; 0; –i)<br>        ranked[–c[a[i]]] &#x3D; a[i];<br>    for (int i &#x3D; 0; i &lt; n; i++){<br>        a[i]&#x3D;ranked[i];<br>    }<br>    &#x2F;********** End **********&#x2F;<br>}</p>
<p>第二题:查找中位数</p>
<p>快速排序</p>
<p>void swap (int *a,int *b){<br>    int temp;<br>    temp&#x3D;*a;<br>    *a&#x3D;*b;<br>    *b&#x3D;temp;<br>}</p>
<p>int partition(int L[],int low,int high)<br>{<br>int i,num&#x3D;low;<br>for(i&#x3D;low+1;i&lt;&#x3D;high;i++)<br>{<br>if(L[i]&lt;L[low])<br>{<br>swap(&amp;L[i],&amp;L[num+1]);<br>num++;<br>}<br>}<br>swap(&amp;L[low],&amp;L[num]);<br>return num;<br>}<br>int MidValue(int a[],int n)<br>&#x2F;&#x2F;求a的中位数<br>{<br>    &#x2F;&#x2F; 请在这里补充代码，完成本关任务<br>    &#x2F;********** Begin *********&#x2F;<br>    int low&#x3D;0,high&#x3D;n-1,pos;<br>    int mid&#x3D;n&#x2F;2;<br>    while(1){<br>        pos&#x3D;partition(a,low,high);<br>if(pos&#x3D;&#x3D;mid)<br>break;<br>else if(pos&gt;mid)<br>high&#x3D;pos-1;<br>else low&#x3D;pos+1;<br>    }<br>    if(n%2) return a[mid];<br>    else return (a[mid]+a[mid-1])&#x2F;2;<br>    &#x2F;********** End **********&#x2F;<br>}</p>
<p>如果是偶数,怎么样怎么样,如果是奇数,怎么样怎么样……</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/project/">首页</a></li>
        
          <li><a href="/project/about/">关于</a></li>
        
          <li><a href="/project/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li>
        
      </ul>
    </div>

    
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&text=数据结构实训作业"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&is_video=false&description=数据结构实训作业"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=数据结构实训作业&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&title=数据结构实训作业"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&name=数据结构实训作业&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E4%BD%9C%E4%B8%9A/&t=数据结构实训作业"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    Sukuna
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/project/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
