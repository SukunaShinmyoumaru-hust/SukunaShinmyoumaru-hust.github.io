



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/1.jpg">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/1.jpg" color="">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://sukunashinmyoumaru-hust.github.io/2021/12/18/oslab2/">



  <title>
华中科技大学OS实验解析(Lab2) - 实验记录 |
Suwa shrine = 灵山之上神风起 = 一个普通的华中科技大学在读硕士研究生</title>
<meta name="generator" content="Hexo 7.1.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">华中科技大学OS实验解析(Lab2)
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-12-18 01:35:56">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-12-18T01:35:56+08:00">2021-12-18</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>26k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>24 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Suwa shrine</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/4663c8f5b7019dfd.jpg"></li>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/5d3d43e0f7dc0697.jpg"></li>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/bac1b1e69e7ebfb7.jpg"></li>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/7d2279310f1bb2f7.jpg"></li>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/97c3cfc23ec60f4c.jpg"></li>
          <li class="item" data-background-image="https://s3.bmp.ovh/imgs/2024/06/17/7c97ca6398f62495.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" itemprop="item" rel="index" title="分类于 实验记录"><span itemprop="name">实验记录</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://sukunashinmyoumaru-hust.github.io/2021/12/18/oslab2/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/IMG_1335.PNG">
    <meta itemprop="name" content="Sukuna">
    <meta itemprop="description" content="一个普通的华中科技大学在读硕士研究生, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="灵山之上神风起">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>许可证:</p>
<p>版权归<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9z">华中科技大学操作系统团队</span>所有,下面是许可证书,本文档是对<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MlRTclOUElODQlRTklODMlQTglRTUlODglODYlRTQlQkYlQUUlRTYlOTQlQjklRTUlOTIlOEMlRTglQTclQTMlRTklODclOEE=">https://gitee.com/hustos/pke-doc的部分修改和解释</span>.</p>
<h2 id="4-1-实验2的基础知识"><a href="#4-1-实验2的基础知识" class="headerlink" title="4.1 实验2的基础知识"></a>4.1 实验2的基础知识</h2><p>在过去的<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQ=">第一组实验(lab1)</span>中，为了简化设计，我们采用了Bare模式来完成虚拟地址到物理地址的转换（实际上，就是不转换，认为：虚拟地址&#x3D;物理地址），也未开启（模拟）RISC-V机器的分页功能。在本组实验（实验2）中，我们将开启和使用Sv39页式虚拟内存管理，无论是操作系统内核还是应用，都通过页表来实现逻辑地址到物理地址的转换。</p>
<p>实际上，我们在本书的<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjFfcmlzY3YubWQjcGFnaW5n">第一章的1.5节</span>曾介绍过RISC-V的Sv39页式虚拟内存的管理方式，在本章，我们将尽量结合PKE的实验代码讲解RISC-V的Sv39虚拟内存管理机制，并通过3个基础实验加深读者对该管理机制的理解。</p>
<h3 id="4-1-1-Sv39虚地址管理方案回顾"><a href="#4-1-1-Sv39虚地址管理方案回顾" class="headerlink" title="4.1.1 Sv39虚地址管理方案回顾"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDExLXN2MzklRTglOTklOUElRTUlOUMlQjAlRTUlOUQlODAlRTclQUUlQTElRTclOTAlODYlRTYlOTYlQjklRTYlQTElODglRTUlOUIlOUUlRTklQTElQkU="></span>4.1.1 Sv39虚地址管理方案回顾</h3><p>我们先回顾一下RISC-V的sv39虚地址管理方案，在该方案中，逻辑地址（就是我们的程序中各个符号，在链接时被赋予的地址）通过页表转换为其对应的物理地址。由于我们考虑的机器采用了RV64G指令集，意味着逻辑地址和物理地址理论上都是64位的。然而，对于逻辑地址，实际上我们的应用规模还用不到全部64位的寻找空间，所以Sv39方案中只使用了64位虚地址中的低39位（Sv48方案使用了低48位），意味着我们的应用程序的地址空间可以到512GB；对于物理地址，目前的RISC-V设计只用到了其中的低56位。</p>
<p>Sv39将39位虚拟地址“划分”为4个段（如下图所示）：</p>
<ul>
<li>[38,30]：共9位，图中的VPN[2]，用于在512（2^9）个页目录（page directory）项中检索页目录项（page directory entry, PDE）；</li>
<li>[29,21]：共9位，图中的VPN[1]，用于在512（2^9）个页中间目录（page medium directory）中检索PDE；</li>
<li>[20,12]：共9位，图中的VPN[0]，用于在512（2^9）个页表（page medium directory）中检索PTE；</li>
<li>[11,0]：共12位，图中的offset，充当4KB页的页内位移。</li>
</ul>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/fig1_8.png" alt="fig1_8"></p>
<p>图4.1 Sv39中虚拟地址到物理地址的转换过程</p>
<p>由于每个物理页的大小为4KB，同时，每个目录项（PDE）或页表项（PTE）占据8个字节，所以一个物理页能够容纳的PDE或PTE的数量为4KB&#x2F;8B&#x3D;512，这也是为什么VPN[2]&#x3D;VPN[1]&#x3D;VPN[0]&#x3D;512的原因。</p>
<p>编者注:对于一个va,首先根据satp(页表基址寄存器)+VPN[2]这个地址获得页表表项,这个表项就是下一级页表的基址satp1,根据stap1+VPN[1]这个地址获得页表表项,这个表项就是下一级页表的基址satp2,根据stap2+VPN[0]这个地址获得页表表项,这个表项就是最后的PPN.(当然页表表项里面的元素有PPN还有各种控制信号)</p>
<p>8字节的PDE或者PTE的格式如下：</p>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/fig1_7.png" alt="fig1_7"></p>
<p>图4.2 Sv39中PDE&#x2F;PTE格式</p>
<p>其中的各个位的含意为：</p>
<p>● V（Valid）位决定了该PDE&#x2F;PTE是否有效（V&#x3D;1时有效），即是否有对应的实页。</p>
<p>● R（Read）、W（Write）和X（eXecutable）位分别表示此页对应的实页是否可读、可写和可执行。这3个位只对PTE有意义，对于PDE而言这3个位都为0。</p>
<p>● U（User）位表示该页是不是一个用户模式页。如果U&#x3D;1，表示用户模式下的代码可以访问该页，否则就表示不能访问。S模式下的代码对U&#x3D;1页面的访问取决于sstatus寄存器中的SUM字段取值。</p>
<p>● G（Global）位表示该PDE&#x2F;PTE是不是全局的。我们可以把操作系统中运行的一个进程，认为是一个独立的地址空间，有时会希望某个虚地址空间转换可以在一组进程中共享，这种情况下，就可以将某个PDE的G位设置为1，达到这种共享的效果。</p>
<p>● A（Access）位表示该页是否被访问过。</p>
<p>● D（Dirty）位表示该页的内容是否被修改。</p>
<p>● RSW位（2位）是保留位，一般由运行在S模式的代码（如操作系统）来使用。</p>
<p>● PPN（44位）是物理页号（Physical Page Number，简写为PPN）。</p>
<p>其中PPN为44位的原因是：对于物理地址，现有的RISC-V规范只用了其中的56位，同时，这56位中的低12位为页内位移。所以，PPN的长度&#x3D;56-12&#x3D;44（位）。</p>
<h3 id="4-1-2-物理内存布局与规划"><a href="#4-1-2-物理内存布局与规划" class="headerlink" title="4.1.2 物理内存布局与规划"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDEyLSVFNyU4OSVBOSVFNyU5MCU4NiVFNSU4NiU4NSVFNSVBRCU5OCVFNSVCOCU4MyVFNSVCMSU4MCVFNCVCOCU4RSVFOCVBNyU4NCVFNSU4OCU5Mg=="></span>4.1.2 物理内存布局与规划</h3><p>PKE实验用到的RISC-V机器，实际上是spike模拟出来的，例如，采用以下命令：</p>
<p>$ spike .&#x2F;obj&#x2F;riscv-pke .&#x2F;obj&#x2F;app_helloworld</p>
<p>spike将创建一个模拟的RISC-V机器，该机器拥有一个支持RV64G指令集的处理器，2GB的（模拟）物理内存。实际上，我们可以通过在spike命令行中使用<code>-m</code>开关指定模拟机器的物理内存大小，如使用<code>-m512</code>即可获得拥有512MB物理内存的模拟机器。默认的（2GB物理内存）配置等效于<code>-m2048</code>，在之后对模拟RISC-V机器物理内存布局的讨论中，我们将只考虑默认配置以简化论述。另外，也可以在spike命令行中使用<code>-p</code>开关指定模拟机器中处理器的个数，这样就可以模拟出一个多核的RISC-V平台了。</p>
<p>需要注意的是，<strong>对于我们的模拟RISC-V机器而言，2GB的物理内存并不是从0地址开始编址，而是从0x80000000（见kernel&#x2F;memlayout.h文件中的DRAM_BASE宏定义）开始编址的</strong>。这样做的理由是，部分低物理地址[0x0, 0x80000000]并无物理内存与之对应，该空间留作了MMIO的用途。例如，我们在lab1_3中遇到的CLINT（Core Local Interrupter，timer中断的产生就是通过往这个地址写数据控制的），见kernel&#x2F;riscv.h文件中的CLINT定义，的地址是0x2000000，就位于这一空间。从0x80000000开始对物理内存进行编址的好处是，避免类似x86平台那样产生内存空洞（memory hole，如640KB~1MB的<strong>BIOS空间</strong>），从而导致内存的浪费和管理上的复杂性。</p>
<p>我们的代理内核（构造出来的.&#x2F;obj&#x2F;riscv-pke文件）的<strong>逻辑地址也是从0x80000000开始的</strong>，见kernel&#x2F;kernel.lds文件中的内容，spike将代理内核载入（模拟）物理内存时，也是将该代理内核的代码段、数据段载入到0x80000000开始的内存空间，如图4.3所示。</p>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/physical_mem_layout.png" alt="physical_mem_layout.png"></p>
<p>图4.3 初始内存布局和载入操作系统内核后的内存布局</p>
<p>这样，操作系统内核的逻辑地址和物理地址就有了一一对应的关系，这也是我们在lab1中采用直模式（Bare mode）虚拟地址翻译机制也不会出错的原因。这里，需要解释的是对内核的<strong>机器模式栈</strong>的处理。通过实验一，我们知道机器模式栈是一个4KB的空间，它<strong>位于内核数据段</strong>，而不是专门分配一个额外的页面。这样（简单）处理的原因是PKE上运行的应用往往只有一个，算是非常简单的多任务环境，且操作系统利用机器模式栈的时机只有特殊的异常（如lab1_2中的非法指令异常）以及一些外部中断（如lab1_3中的时钟中断）。</p>
<p>如图4.3b所示，在spike将操作系统内核装入物理内存后，<strong>剩余的内存空间应该是从内核数据段的结束（_end符号）到0xffffffff（即4GB-1的地址）</strong>。但是由于PKE操作系统内核的特殊性（它只需要支持给定应用的运行），lab2的代码将操作系统管理的空间进一步缩减，定义了一个操作系统需要管理的最大内存空间（kernel&#x2F;config.h文件），从而提升实验代码的执行速度：</p>
<p> 10 &#x2F;&#x2F; the maximum memory space that PKE is allowed to manage<br> 11 #define PKE_MAX_ALLOWABLE_RAM 128 * 1024 * 1024<br> 12<br> 13 &#x2F;&#x2F; the ending physical address that PKE observes<br> 14 #define PHYS_TOP (DRAM_BASE + PKE_MAX_ALLOWABLE_RAM)</p>
<p>可以看到，实验代码“人为”地将PKE操作系统所能管理的内存空间限制到了128MB（即PKE_MAX_ALLOWABLE_RAM的定义），同时，定义了PHYS_TOP为新的内存物理地址上限。实际上，kernel&#x2F;pmm.c文件所定义的pmm_init()函数包含了PKE对物理内存进行管理的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">62 **void** **pmm_init**() &#123;</span><br><span class="line">63   // start of kernel program segment</span><br><span class="line">64   uint64 g_kernel_start = KERN_BASE;</span><br><span class="line">65   uint64 g_kernel_end = (uint64)&amp;_end;</span><br><span class="line">66</span><br><span class="line">67   uint64 pke_kernel_size = g_kernel_end - g_kernel_start;</span><br><span class="line">68   sprint(&quot;PKE kernel start 0x%lx, PKE kernel end: 0x%lx, PKE kernel size: 0x%lx .\\n&quot;,</span><br><span class="line">69     g_kernel_start, g_kernel_end, pke_kernel_size);</span><br><span class="line">70</span><br><span class="line">71   // free memory starts from the end of PKE kernel and must be page-aligined</span><br><span class="line">72   free_mem_start_addr = ROUNDUP(g_kernel_end , PGSIZE);</span><br><span class="line">73</span><br><span class="line">74   // recompute g_mem_size to limit the physical memory space that PKE kernel</span><br><span class="line">75   // needs to manage</span><br><span class="line">76   g_mem_size = MIN(PKE_MAX_ALLOWABLE_RAM, g_mem_size);</span><br><span class="line">77   **if**( g_mem_size &lt; pke_kernel_size )</span><br><span class="line">78     panic( &quot;Error when recomputing physical memory size (g_mem_size).\\n&quot; );</span><br><span class="line">79</span><br><span class="line">80   free_mem_end_addr = g_mem_size + DRAM_BASE;</span><br><span class="line">81   sprint(&quot;free physical memory address: [0x%lx, 0x%lx] \\n&quot;, free_mem_start_addr,</span><br><span class="line">82     free_mem_end_addr - 1);</span><br><span class="line">83</span><br><span class="line">84   sprint(&quot;kernel memory manager is initializing ...\\n&quot;);</span><br><span class="line">85   // create the list of free pages</span><br><span class="line">86   create_freepage_list(free_mem_start_addr, free_mem_end_addr);</span><br><span class="line">87 &#125;</span><br></pre></td></tr></table></figure>

<p>在76行，pmm_init()函数会计算g_mem_size，其值在PKE_MAX_ALLOWABLE_RAM和spike所模拟的物理内存大小中取最小值，<strong>也就是说除非spike命令行参数中-m参数后面所带的数字小于128（即128M），g_mem_size的大小将为128MB</strong>。</p>
<p>另外，为了对空闲物理内存（**地址范围为[_end，g_mem_size+DRAM_BASE(即PHYS_TOP)]**）进行有效管理，pmm_init()函数在86行通过调用create_freepage_list()函数定义了一个链表，用于对空闲物理内存的分配和回收。kernel&#x2F;pmm.c文件中包含了所有对物理内存的初始化、分配和回收的例程，它们的实现非常的简单，感兴趣的读者请对里面的函数进行阅读理解。</p>
<p>编者注:这里的PHYS_TOP是栈的最顶部,就是物理地址不能超过PHYS_TOP,<strong>g_mem_size的大小</strong>就是spike命令行-m参数后面的数值.单位为B</p>
<h3 id="4-1-3-PKE操作系统和应用进程的逻辑地址空间结构"><a href="#4-1-3-PKE操作系统和应用进程的逻辑地址空间结构" class="headerlink" title="4.1.3 PKE操作系统和应用进程的逻辑地址空间结构"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDEzLXBrZSVFNiU5MyU4RCVFNCVCRCU5QyVFNyVCMyVCQiVFNyVCQiU5RiVFNSU5MiU4QyVFNSVCQSU5NCVFNyU5NCVBOCVFOCVCRiU5QiVFNyVBOCU4QiVFNyU5QSU4NCVFOSU4MCVCQiVFOCVCRSU5MSVFNSU5QyVCMCVFNSU5RCU4MCVFNyVBOSVCQSVFOSU5NyVCNCVFNyVCQiU5MyVFNiU5RSU4NA=="></span>4.1.3 PKE操作系统和应用进程的逻辑地址空间结构</h3><p>通过4.1.2的讨论，我们知道对于PKE内核来说，有逻辑地址&#x3D;物理地址的关系成立，这也是在实验一中我们可以采用Bare模式进行地址映射的原因。采用Bare模式的地址映射，在进行内存访问时，无需经过页表和硬件进行逻辑地址到物理地址的转换。然而，在实验二中我们将采用Sv39虚拟地址管理方案，通过页表和硬件（spike模拟的MMU）进行访存地址的转换。为实现这种转换，首先需要确定的就是将要被转换的逻辑地址空间，即需要对哪部分逻辑地址空间进行转换的问题。在PKE的实验二中，存在两个需要被转换的实体，<strong>一个是操作系统内核，另一个是我们的实验给定的应用程序所对应的进程。下面我们对它们分别讨论：</strong></p>
<h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU2JTkzJThEJUU0JUJEJTlDJUU3JUIzJUJCJUU3JUJCJTlGJUU1JTg2JTg1JUU2JUEwJUI4"></span>操作系统内核</h4><p>操作系统内核的逻辑地址与物理地址存在一一对应的关系，但是在开启了Sv39虚拟内存管理方案后，所有的逻辑地址到物理地址的翻译都<strong>必须</strong>通过页表和MMU硬件进行，所以，为操作系统内核建立页表是必不可少的工作。<strong>操作系统的逻辑地址空间可以简单的认为是从内核代码段的起始（即KERN_BASE&#x3D;0x80000000）到物理地址的顶端（也就是PHYS_TOP）</strong>，因为操作系统是系统中拥有最高权限的软件，需要实现对所有物理内存空间的直接管理。这段逻辑地址空间，即**[KERN_BASE，PHYS_TOP]，所映射的物理地址空间也是[KERN_BASE，PHYS_TOP]<strong>。也就是说对于操作系统内核，我们在实验二中通过Sv39的页表，仍然保持和实验一一样的逻辑地址到物理地址的一一对应关系。在权限方面，对于内核代码段所对应的页面来说是</strong>可读可执行<strong>，对于数据段以及空闲内存空间，其权限为</strong>可读可写**。</p>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/kernel_address_mapping.png" alt="kernel_address_mapping.png"></p>
<p>图4.4 PKE操作系统内核的逻辑地址空间和它到物理地址空间的映射</p>
<p>操作系统内核建立页表的过程可以参考kernel&#x2F;vmm.c文件中的kern_vm_init()函数的实现，需要说明的是kern_vm_init()函数在PKE操作系统内核的<strong>S态初始化过程（s_start函数）中被调用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">119 **void** **kern_vm_init**(**void**) &#123;</span><br><span class="line">120   pagetable_t t_page_dir;</span><br><span class="line">121</span><br><span class="line">122   // allocate a page (t_page_dir) to be the page directory for kernel</span><br><span class="line">123   t_page_dir = (pagetable_t)alloc_page();</span><br><span class="line">124   memset(t_page_dir, 0, PGSIZE);</span><br><span class="line">125</span><br><span class="line">126   // map virtual address [KERN_BASE, _etext] to physical address [DRAM_BASE, DRAM_BASE+(_etext - KERN_BASE)],</span><br><span class="line">127   // to maintain (direct) text section kernel address mapping.</span><br><span class="line">128   kern_vm_map(t_page_dir, KERN_BASE, DRAM_BASE, (uint64)_etext - KERN_BASE,</span><br><span class="line">129          prot_to_type(PROT_READ  PROT_EXEC, 0));</span><br><span class="line">130</span><br><span class="line">131   sprint(&quot;KERN_BASE 0x%lx\\n&quot;, lookup_pa(t_page_dir, KERN_BASE));</span><br><span class="line">132</span><br><span class="line">133   // also (direct) map remaining address space, to make them accessable from kernel.</span><br><span class="line">134   // this is important when kernel needs to access the memory content of user&#x27;s app</span><br><span class="line">135   // without copying pages between kernel and user spaces.</span><br><span class="line">136   kern_vm_map(t_page_dir, (uint64)_etext, (uint64)_etext, PHYS_TOP - (uint64)_etext,</span><br><span class="line">137          prot_to_type(PROT_READ  PROT_WRITE, 0));</span><br><span class="line">138</span><br><span class="line">139   sprint(&quot;physical address of _etext is: 0x%lx\\n&quot;, lookup_pa(t_page_dir, (uint64)_etext));</span><br><span class="line">140</span><br><span class="line">141   g_kernel_pagetable = t_page_dir;</span><br><span class="line">142 &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，kern_vm_init()函数会首先（123行）从空闲物理内存中获取（分配）一个t_page_dir指针所指向的物理页，该页将作为内核页表的根目录（page directory，对应图4.1中的VPN[2]）。接下来，将该页的内容清零（124行）、<strong>映射代码段到它对应的物理地址（128–129行）、映射数据段的起始到PHYS_TOP到它对应的物理地址空间（136–137行），最后记录内核页表的根目录页（141行）。</strong></p>
<p>编者注:在这里面是构建了图4.1 VPN[2]对应的表,也就是说,对应了内核代码和内核数据段+用户段两项的转化</p>
<h4 id="应用进程"><a href="#应用进程" class="headerlink" title="应用进程"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUJBJTk0JUU3JTk0JUE4JUU4JUJGJTlCJUU3JUE4JThC"></span>应用进程</h4><p>对于实验一的所有应用，我们通过指定应用程序中所有的符号地址对应的逻辑地址的方法（参见<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjc3Vic2VjX2xkcw==">第三章的3.1.3节</span>），将应用程序中的逻辑地址“强行”对应到图4.3中的“实际空闲内存”空间，并在ELF加载时将程序段加载到了这块内存空间中的对应位置，从而使得应用程序（所对应的进程）也可以采用类似操作系统内核那样的直映射（Bare模式）方式。然而，这样做是因为实验一中的应用都是单线程应用，它们的执行并不会产生新的执行体（如子进程），所以可以采用指定逻辑地址的办法进行简化。但是实际情况是，我们在代理内核上是有可能执行多进程应用的，特别是在开发板上验证多核RISC-V处理器的场景（我们在实验三中，也将开始讨论在PKE实验中实现和完善进程的管理）。在这种场景下，由于无法保证应用所要求的逻辑地址空间“恰好”能找到对应的物理地址空间，且后者还未被占据。</p>
<p>这里，我们可以观察一下在未指定逻辑地址的情况下的应用对应的逻辑地址。首先切换到lab2_1_pagetable，然后构造内核和应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 切换到lab2_1_pagetable分支</span><br><span class="line">$ git checkout lab2_1_pagetable</span><br><span class="line">// 构造内核和应用</span><br><span class="line">$ make</span><br><span class="line">// 显示应用程序中将被加载的程序段</span><br><span class="line">$ riscv64-unknown-elf-readelf -l ./obj/app_helloworld_no_lds</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x100f6</span><br><span class="line">There is 1 program header, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000010000 0x0000000000010000</span><br><span class="line">                 0x0000000000000360 0x0000000000000360  R E    0x1000</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata</span><br></pre></td></tr></table></figure>

<p>通过以上结果，我们看到，lab2_1的应用app_helloworld_no_lds（实际上就是lab1_1中的app_helloworld，不同的地方在于没有用到lab1_1中的user&#x2F;user.lds来约束逻辑地址）只包含一个代码段，它的起始地址为0x0000000000010000（即0x10000）。</p>
<p>对比<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjcGh5c2ljYWxtZW1vcnk=">4.1.2节</span>中讨论的物理内存布局，我们知道spike模拟的RISC-V机器并无处于0x10000的物理地址空间与其对应。这样，我们就需要通过Sv39虚地址管理方案将0x10000开始的代码段，映射到app_helloworld_no_lds中代码段<strong>实际</strong>被加载到的物理内存（显然位于图4.3中的“实际内存空间”所标识的区域）区域。</p>
<p>PKE实验二中的应用加载是通过kernel&#x2F;kernel.c文件中的load_user_program函数来完成的：</p>
<p>编者注:load_bincode_from_host_elf()函数将应用程序对应的二进制代码实际地载入。有页表转换的要比直接映射的函数要复杂.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">37 **void** **load_user_program**(process \*proc) &#123;</span><br><span class="line">38   sprint(&quot;User application is loading.\\n&quot;);</span><br><span class="line">39   proc-&gt;trapframe = (trapframe \*)alloc_page();  //trapframe</span><br><span class="line">40   memset(proc-&gt;trapframe, 0, **sizeof**(trapframe));</span><br><span class="line">41</span><br><span class="line">42   //user pagetable</span><br><span class="line">43   proc-&gt;pagetable = (pagetable_t)alloc_page();</span><br><span class="line">44   memset((**void** \*)proc-&gt;pagetable, 0, PGSIZE);</span><br><span class="line">45</span><br><span class="line">46   proc-&gt;kstack = (uint64)alloc_page() + PGSIZE;   //user kernel stack top</span><br><span class="line">47   uint64 user_stack = (uint64)alloc_page();       //phisical address of user stack bottom</span><br><span class="line">48   proc-&gt;trapframe-&gt;regs.sp = USER_STACK_TOP;  //virtual address of user stack top</span><br><span class="line">49</span><br><span class="line">50   sprint(&quot;user frame 0x%lx, user stack 0x%lx, user kstack 0x%lx \\n&quot;, proc-&gt;trapframe,</span><br><span class="line">51          proc-&gt;trapframe-&gt;regs.sp, proc-&gt;kstack);</span><br><span class="line">52</span><br><span class="line">53   load_bincode_from_host_elf(proc);</span><br><span class="line">54</span><br><span class="line">55   // map user stack in userspace</span><br><span class="line">56   user_vm_map((pagetable_t)proc-&gt;pagetable, USER_STACK_TOP - PGSIZE, PGSIZE, user_stack,</span><br><span class="line">57          prot_to_type(PROT_WRITE  PROT_READ, 1));</span><br><span class="line">58</span><br><span class="line">59   // map trapframe in user space (direct mapping as in kernel space).</span><br><span class="line">60   user_vm_map((pagetable_t)proc-&gt;pagetable, (uint64)proc-&gt;trapframe, PGSIZE, (uint64)proc-&gt;trapframe,</span><br><span class="line">61          prot_to_type(PROT_WRITE  PROT_READ, 0));</span><br><span class="line">62</span><br><span class="line">63   // map S-mode trap vector section in user space (direct mapping as in kernel space)</span><br><span class="line">64   // we assume that the size of usertrap.S is smaller than a page.</span><br><span class="line">65   user_vm_map((pagetable_t)proc-&gt;pagetable, (uint64)trap_sec_start, PGSIZE, (uint64)trap_sec_start,</span><br><span class="line">66          prot_to_type(PROT_READ  PROT_EXEC, 0));</span><br><span class="line">67 &#125;</span><br></pre></td></tr></table></figure>

<p>load_user_program()函数对于应用进程逻辑空间的操作可以分成以下几个部分：</p>
<ul>
<li>（39–40行）分配一个物理页面，将其作为<strong>栈帧（trapframe）</strong>，即发生中断时保存用户进程执行上下文的内存空间。由于物理页面都是从位于物理地址范围[_end，PHYS_TOP]的空间中分配的，它的首地址也将位于该区间。所以第60–61行的映射，也是做一个proc-&gt;trapframe到所分配页面的<strong>直映射</strong>（逻辑地址&#x3D;物理地址）。</li>
<li>（43–44行）分配一个物理页面作为存放进程页表根目录（page directory，对应图4.1中的VPN[2]）的空间。</li>
<li>（46行）分配了一个物理页面，作为用户进程的<strong>内核态栈，该栈将在用户进程进入中断处理时用作S模式内核处理函数使用的栈</strong>。然而，这个栈<strong>并未映射</strong>到用户进程的逻辑地址空间，而是将其首地址保存在proc-&gt;kstack中。</li>
<li>（47–48行）再次分配一个物理页面，作为<strong>用户进程的用户态栈</strong>，该栈供应用在用户模式下使用，并在第56–57行映射到用户进程的逻辑地址<strong>USER_STACK_TOP</strong>。</li>
<li>（53行）调用load_bincode_from_host_elf()函数，该函数将读取应用所对应的ELF文件，并将其中的<strong>代码段读取到新分配的内存空间（物理地址位于[_end，PHYS_TOP]区间）</strong>。</li>
<li>（65–66行）将内核中的S态trap入口函数所在的物理页一一映射到用户进程的逻辑地址空间。</li>
</ul>
<p>通过以上load_user_program()函数，我们可以大致画出用户进程的逻辑地址空间，以及该地址空间到物理地址空间的映射。</p>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/user_address_mapping.png" alt="user_address_mapping.png"></p>
<p>图4.5 用户进程的逻辑地址空间和到物理地址空间的映射</p>
<p>我们看到，用户进程在装入后，其逻辑地址空间有4个区间建立了和物理地址空间的映射。从上往下观察，“用户进程trapframe”和“trap入口页面”的逻辑地址大于0x80000000，且与承载它们的物理空间建立了一对一的映射关系。另外两个区间，即“用户态栈”和“用户代码段”的逻辑地址都低于0x80000000，它们所对应的物理空间则都位于实际空闲内存区域，同时，这种映射的逻辑地址显然不等于物理地址。</p>
<h3 id="4-1-4-与页表操作相关的重要函数"><a href="#4-1-4-与页表操作相关的重要函数" class="headerlink" title="4.1.4 与页表操作相关的重要函数"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDE0LSVFNCVCOCU4RSVFOSVBMSVCNSVFOCVBMSVBOCVFNiU5MyU4RCVFNCVCRCU5QyVFNyU5QiVCOCVFNSU4NSVCMyVFNyU5QSU4NCVFOSU4NyU4RCVFOCVBNiU4MSVFNSU4NyVCRCVFNiU5NSVCMA=="></span>4.1.4 与页表操作相关的重要函数</h3><p>实验二与页表操作相关的函数都放在kernel&#x2F;vmm.c文件中，其中比较重要的函数有：</p>
<ul>
<li>int map_pages(pagetable_t page_dir, uint64 va, uint64 size, uint64 pa, int perm);</li>
</ul>
<p>该函数的第一个输入参数page_dir为根目录所在物理页面的首地址，第二个参数va则是将要被映射的逻辑地址，第三个参数size为所要建立映射的区间的长度，第四个参数pa为逻辑地址va所要被映射到的物理地址首地址，最后（第五个）的参数perm为映射建立后页面访问的权限。</p>
<p>总的来说，该函数将在给定的page_dir所指向的根目录中，建立[va，va+size]到[pa，pa+size]的映射。</p>
<ul>
<li>pte_t *page_walk(pagetable_t page_dir, uint64 va, int alloc);</li>
</ul>
<p>该函数的第一个输入参数page_dir为根目录所在物理页面的首地址，第二个参数va为所要查找（walk）的逻辑地址，第三个参数实际上是一个bool类型：当它为1时，如果它所要查找的逻辑地址并未建立与物理地址的映射（图4.1中的Page Medium Directory）不存在，则通过分配内存空间建立从根目录到页表的完整映射，并最终返回va所对应的页表项；当它为0时，如果它所要查找的逻辑地址并未建立与物理地址的映射，则返回NULL，否则返回va所对应的页表项。</p>
<ul>
<li>uint64 lookup_pa(pagetable_t pagetable, uint64 va);</li>
</ul>
<p>查找逻辑地址va所对应的物理地址pa。如果没有与va对应的物理页面，则返回NULL；否则，返回va对应的物理地址。</p>
<h2 id="4-2-lab2-1-虚实地址转换"><a href="#4-2-lab2-1-虚实地址转换" class="headerlink" title="4.2 lab2_1 虚实地址转换"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDItbGFiMl8xLSVFOCU5OSU5QSVFNSVBRSU5RSVFNSU5QyVCMCVFNSU5RCU4MCVFOCVCRCVBQyVFNiU4RCVBMg=="></span>4.2 lab2_1 虚实地址转换</h2><h4 id="给定应用"><a href="#给定应用" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4"></span><strong>给定应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_helloworld_no_lds.c</span><br><span class="line"></span><br><span class="line">  1 /\*</span><br><span class="line">  2  \* Below is the given application for lab2_1.</span><br><span class="line">  3  \* This app runs in its own address space, in contrast with in direct mapping.</span><br><span class="line">  4  \*/</span><br><span class="line">  5</span><br><span class="line">  6 #include &quot;user_lib.h&quot;</span><br><span class="line">  7 #include &quot;util/types.h&quot;</span><br><span class="line">  8</span><br><span class="line">  9 **int** **main**(**void**) &#123;</span><br><span class="line"> 10   printu(&quot;Hello world!\\n&quot;);</span><br><span class="line"> 11   exit(0);</span><br><span class="line"> 12 &#125;</span><br></pre></td></tr></table></figure>

<p>该应用的代码跟lab1_1是一样的。但是，不同的地方在于，它的编译和链接并未指定程序中符号的逻辑地址。</p>
<ul>
<li>（先提交lab1_3的答案，然后）切换到lab2_1，继承lab1_3中所做的修改，并make后的直接运行结果：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//切换到lab2_1</span><br><span class="line">$ git checkout lab2_1_pagetable</span><br><span class="line"></span><br><span class="line">//继承lab1_3以及之前的答案</span><br><span class="line">$ git merge lab1_3_irq -m &quot;continue to work on lab2_1&quot;</span><br><span class="line"></span><br><span class="line">//重新构造</span><br><span class="line">$ make clean; make</span><br><span class="line"></span><br><span class="line">//运行构造结果</span><br><span class="line">$ spike ./obj/riscv-pke ./obj/app_helloworld_no_lds</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_helloworld_no_lds</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100f6</span><br><span class="line">Switching to user mode...</span><br><span class="line">You have to implement user_va_to_pa (convert user va to pa) to print messages **in** lab2_1.</span><br><span class="line"></span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure>

<p>从以上运行结果来看，我们的应用app_helloworld_no_lds并未如愿地打印出“Hello world!\n”，这是因为user&#x2F;app_helloworld_no_lds.c的第10行<code>printu(&quot;Hello world!\n&quot;);</code>中的“Hello world!\n”字符串本质上是存储在.rodata段，它被和代码段（.text）一起被装入内存。从逻辑地址结构来看，它的逻辑地址就应该位于图4.5中的“用户代码段”，显然低于0x80000000。</p>
<p>而printu是一个典型的系统调用（参考<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjc3lzY2FsbA==">lab1_1</span>的内容），它的执行逻辑是通过ecall指令，陷入到内核（S模式）完成到屏幕的输出。<strong>然而，对于内核而言，显然不能继续使用“Hello world!\n”的逻辑地址对它进行访问，而必须将其转换成物理地址</strong>（因为如图4.4所示，操作系统内核已建立了到“实际空闲内存”的直映射）。而lab2_1的代码，显然未实现这种转换。</p>
<p>编者注:逻辑地址是对于程序的,是对于用户态的,进入中断到了管态后要使用物理地址.</p>
<h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5"></span><strong>实验内容</strong></h4><p>实现user_va_to_pa()函数，完成给定逻辑地址到物理地址的转换，并获得以下预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ spike ./obj/riscv-pke ./obj/app_helloworld_no_lds</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_helloworld_no_lds</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100f6</span><br><span class="line">Switching to user mode...</span><br><span class="line">Hello world!</span><br><span class="line">User exit with code:0.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>

<h4 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJD"></span><strong>实验指导</strong></h4><p>读者可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjc3lzY2FsbA==">lab1_1</span>的内容，重走从应用的printu到S态的系统调用的完整路径，最终来到kernel&#x2F;syscall.c文件的sys_user_print()函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21 **ssize_t** **sys_user_print**(**const** **char**\* buf, **size_t** n) &#123;</span><br><span class="line">22   //buf is an address in user space on user stack,</span><br><span class="line">23   //so we have to transfer it into phisical address (kernel is running in direct mapping).</span><br><span class="line">24   assert( current );</span><br><span class="line">25   **char**\* pa = (**char**\*)user_va_to_pa((pagetable_t)(current-&gt;pagetable), (**void**\*)buf);</span><br><span class="line">26   sprint(pa);</span><br><span class="line">27   **return** 0;</span><br><span class="line">28 &#125;</span><br></pre></td></tr></table></figure>
<p>该函数最终在第26行通过调用sprint将结果输出，但是在输出前，需要将buf地址转换为物理地址传递给sprint，这一转换是通过user_va_to_pa()函数完成的。而user_va_to_pa()函数的定义在kernel&#x2F;vmm.c文件中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">150 **void** \***user_va_to_pa**(pagetable_t page_dir, **void** \*va) &#123;</span><br><span class="line">151   // TODO (lab2_1): implement user_va_to_pa to convert a given user virtual address &quot;va&quot;</span><br><span class="line">152   // to its corresponding physical address, i.e., &quot;pa&quot;. To do it, we need to walk</span><br><span class="line">153   // through the page table, starting from its directory &quot;page_dir&quot;, to locate the PTE</span><br><span class="line">154   // that maps &quot;va&quot;. If found, returns the &quot;pa&quot; by using:</span><br><span class="line">155   // pa = PYHS_ADDR(PTE) + (va - va &amp; (1&lt;&lt;PGSHIFT -1))</span><br><span class="line">156   // Here, PYHS_ADDR() means retrieving the starting address (4KB aligned), and</span><br><span class="line">157   // (va - va &amp; (1&lt;&lt;PGSHIFT -1)) means computing the offset of &quot;va&quot; in its page.</span><br><span class="line">158   // Also, it is possible that &quot;va&quot; is not mapped at all. in such case, we can find</span><br><span class="line">159   // invalid PTE, and should return NULL.</span><br><span class="line">160   panic( &quot;You have to implement user_va_to_pa (convert user va to pa) to print messages in lab2_1.\\n&quot; );</span><br><span class="line">161</span><br><span class="line">162 &#125;</span><br></pre></td></tr></table></figure>
<p>如注释中的提示，为了在page_dir所指向的页表中查找逻辑地址va，就必须通过调用<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjcGFnZXRhYmxlY29vaw==">页表操作相关函数</span>找到包含va的页表项（PTE），通过该PTE的内容得知va所在的物理页面的首地址，最后再通过计算va在页内的位移得到va最终对应的物理地址。</p>
<p>答案:</p>
<p>编者注:PTE2PA是获得44位PPN的,va取低位获得offset两个合并就是最后的地址(页+页内偏移)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//将地址转换为uint类型</span><br><span class="line">  uint va0 = (uint64)va;</span><br><span class="line">  //获取虚拟地址对应的PTE页表项</span><br><span class="line">  pte_t \* PTE = page_walk(page_dir, va0, 0);</span><br><span class="line">  uint64 pa = 0;</span><br><span class="line">  //如果返回的PTE不为空，计算pa物理地址</span><br><span class="line">  if(PTE)</span><br><span class="line">  &#123;</span><br><span class="line">    //PTE2PA(\*PTE)取44位PPN，va0 &amp; ((1 &lt;&lt; PGSHIFT) - 1)计算偏移地址</span><br><span class="line">    pa = PTE2PA(\*PTE) + (va0 &amp; ((1 &lt;&lt; PGSHIFT) - 1));</span><br><span class="line">  &#125;</span><br><span class="line">  return (void\*)pa;</span><br></pre></td></tr></table></figure>
<p><strong>实验完毕后，记得提交修改（命令行中-m后的字符串可自行确定），以便在后续实验中继承lab2_1中所做的工作</strong>：</p>
<p>$ git commit -a -m “my work on lab2_1 is done.”</p>
<h2 id="4-3-lab2-2-简单内存分配和回收"><a href="#4-3-lab2-2-简单内存分配和回收" class="headerlink" title="4.3 lab2_2 简单内存分配和回收"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDMtbGFiMl8yLSVFNyVBRSU4MCVFNSU4RCU5NSVFNSU4NiU4NSVFNSVBRCU5OCVFNSU4OCU4NiVFOSU4NSU4RCVFNSU5MiU4QyVFNSU5QiU5RSVFNiU5NCVCNg=="></span>4.3 lab2_2 简单内存分配和回收</h2><h4 id="给定应用-1"><a href="#给定应用-1" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTE="></span><strong>给定应用</strong></h4><ul>
<li>user&#x2F;app_naive_malloc.c</li>
</ul>
<p>该应用的逻辑非常简单：首先分配一个空间（内存页面）来存放my_structure结构，往my_structure结构的实例中存储信息，打印信息，并最终将之前所分配的空间释放掉。这里，新定义了两个用户态函数naive_malloc()和naive_free()，它们最终会转换成系统调用，完成内存的分配和回收操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">*   （先提交lab2_1的答案，然后）切换到lab2_2，继承lab2_1以及之前实验所做的修改，并make后的直接运行结果：</span><br><span class="line"></span><br><span class="line">//切换到lab2_2</span><br><span class="line">$ git checkout lab2_2_allocatepage</span><br><span class="line"></span><br><span class="line">//继承lab2_1以及之前的答案</span><br><span class="line">$ git merge lab2_1_pagetable -m &quot;continue to work on lab2_2&quot;</span><br><span class="line"></span><br><span class="line">//重新构造</span><br><span class="line">$ make clean; make</span><br><span class="line"></span><br><span class="line">//运行构造结果</span><br><span class="line">$ spike ./obj/riscv-pke ./obj/app_naive_malloc</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_naive_malloc</span><br><span class="line">Application program entry point (virtual address): 0x0000000000010078</span><br><span class="line">Switching to user mode...</span><br><span class="line">s: 0000000000400000, &#123;a 1&#125;</span><br><span class="line">You have to implement user_vm_unmap to free pages using naive_free **in** lab2_2.</span><br><span class="line"></span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure>
<p>从输出结果来看，<code>s: 0000000000400000, &#123;a 1&#125;</code>的输出说明分配内存已经做好（也就是说naive_malloc函数及其内核功能的实现已完成），且打印出了我们预期的结果。但是，naive_free对应的功能并未完全做好。</p>
<h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTE="></span><strong>实验内容</strong></h4><p>如输出提示所表明的那样，需要完成naive_free对应的功能，并获得以下预期的结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ spike ./obj/riscv-pke ./obj/app_naive_malloc</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_naive_malloc</span><br><span class="line">Application program entry point (virtual address): 0x0000000000010078</span><br><span class="line">Switching to user mode...</span><br><span class="line">s: 0000000000400000, &#123;a 1&#125;</span><br><span class="line">User exit with code:0.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<h4 id="实验指导-1"><a href="#实验指导-1" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTE="></span><strong>实验指导</strong></h4><p>一般来说，应用程序执行过程中的动态内存分配和回收，是操作系统中的堆（Heap）管理的内容。在本实验中，我们实际上是为PKE操作系统内核实现一个简单到不能再简单的“堆”。为实现naive_free()的内存回收过程，我们需要了解其对偶过程，即内存是如何“分配”给应用程序，并供后者使用的。为此，我们先阅读kernel&#x2F;syscall.c文件中的naive_malloc()函数的底层实现，sys_user_allocate_page()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">43 uint64 **sys_user_allocate_page**() &#123;</span><br><span class="line">44   **void**\* pa = alloc_page();</span><br><span class="line">45   uint64 va = g_ufree_page;</span><br><span class="line">46   g_ufree_page += PGSIZE;</span><br><span class="line">47   user_vm_map((pagetable_t)current-&gt;pagetable, va, PGSIZE, (uint64)pa,</span><br><span class="line">48          prot_to_type(PROT_WRITE  PROT_READ, 1));</span><br><span class="line">49</span><br><span class="line">50   **return** va;</span><br><span class="line">51 &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在44行分配了一个首地址为pa的物理页面，这个物理页面要以何种方式映射给应用进程使用呢？第45行给出了pa对应的逻辑地址va &#x3D; g_ufree_page，并在46行对g_ufree_page进行了递增操作。最后在47–48行，将pa映射给了va地址。这个过程中，g_ufree_page是如何定义的呢？我们可以找到它在kernel&#x2F;process.c文件中的定义：</p>
<p>编者注:g_ufree_page就是用户现在可以获得的内存位置,每分配一次,就分配一页,下一个可行的地址就是下一页的首地址.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">27 // start virtual address of our simple heap.</span><br><span class="line">28 uint64 g_ufree_page = USER_FREE_ADDRESS_START;</span><br></pre></td></tr></table></figure>
<p>而USER_FREE_ADDRESS_START的定义在kernel&#x2F;memlayout.h文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17 // simple heap bottom, virtual address starts from 4MB</span><br><span class="line">18 #define USER_FREE_ADDRESS_START **0x00000000** + PGSIZE \* 1024</span><br></pre></td></tr></table></figure>
<p>可以看到，在我们的PKE操作系统内核中，应用程序执行过程中所动态分配（类似malloc）的内存是被映射到USER_FREE_ADDRESS_START（4MB）开始的地址的。那么，这里的USER_FREE_ADDRESS_START对应图4.5中的用户进程的逻辑地址空间的哪个部分呢？<strong>这一点请读者自行判断，并分析为什么是4MB，以及能不能用其他的逻辑地址？</strong></p>
<p>以上了解了内存的分配过程后，我们就能够大概了解其反过程的回收应该怎么做了，大概分为以下步骤：</p>
<ul>
<li>找到一个给定va所对应的页表项PTE（查找<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvcGFnZXRhYmxlY29vaw==">4.1.4节</span>，看哪个函数能满足此需求）；</li>
<li>如果找到（过滤找不到的情形），通过该PTE的内容得知va所对应物理页的首地址pa；</li>
<li>回收pa对应的物理页，并将PTE中的Valid位置为0。</li>
</ul>
<p><strong>本实验若出现M模式的非法异常<code>unexpected exception happened in M-mode.</code>，说明<code>naive_malloc</code>对应的系统调用未返回正确的逻辑地址。解决问题的方法是，回头检查你在lab1_1中所做的答案！</strong>：</p>
<p>答案:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(free)</span><br><span class="line">  &#123;</span><br><span class="line">    pte_t \* PTE = page_walk(page_dir, va, 0);</span><br><span class="line">    if(PTE)&#123;</span><br><span class="line">      free_page((void\*)user_va_to_pa(page_dir, (void\*)va));</span><br><span class="line">      \*PTE = \*PTE &amp; (~PTE_V);//let valid to be 0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>实验完毕后，记得提交修改（命令行中-m后的字符串可自行确定），以便在后续实验中继承lab2_2中所做的工作</strong>：</p>
<p>$ git commit -a -m “my work on lab2_2 is done.”</p>
<h2 id="4-4-lab2-3-缺页异常"><a href="#4-4-lab2-3-缺页异常" class="headerlink" title="4.4 lab2_3 缺页异常"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjNDQtbGFiMl8zLSVFNyVCQyVCQSVFOSVBMSVCNSVFNSVCQyU4MiVFNSVCOCVCOA=="></span>4.4 lab2_3 缺页异常</h2><h4 id="给定应用-2"><a href="#给定应用-2" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTI="></span><strong>给定应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_sum_sequence.c</span><br><span class="line"></span><br><span class="line">  1 /\*</span><br><span class="line">  2  \* The application of lab2_3.</span><br><span class="line">  3  \*/</span><br><span class="line">  4</span><br><span class="line">  5 #include &quot;user_lib.h&quot;</span><br><span class="line">  6 #include &quot;util/types.h&quot;</span><br><span class="line">  7</span><br><span class="line">  8 //</span><br><span class="line">  9 // compute the summation of an arithmetic sequence. for a given &quot;n&quot;, compute</span><br><span class="line"> 10 // result = n + (n-1) + (n-2) + ... + 0</span><br><span class="line"> 11 // sum_sequence() calls itself recursively till 0. The recursive call, however,</span><br><span class="line"> 12 // may consume more memory (from stack) than a physical 4KB page, leading to a page fault.</span><br><span class="line"> 13 // PKE kernel needs to improved to handle such page fault by expanding the stack.</span><br><span class="line"> 14 //</span><br><span class="line"> 15 uint64 **sum_sequence**(uint64 n) &#123;</span><br><span class="line"> 16   **if** (n == 0)</span><br><span class="line"> 17     **return** 0;</span><br><span class="line"> 18   **else**</span><br><span class="line"> 19     **return** sum_sequence( n-1 ) + n;</span><br><span class="line"> 20 &#125;</span><br><span class="line"> 21</span><br><span class="line"> 22 **int** **main**(**void**) &#123;</span><br><span class="line"> 23   // we need a large enough &quot;n&quot; to trigger pagefaults in the user stack</span><br><span class="line"> 24   uint64 n = 1000;</span><br><span class="line"> 25</span><br><span class="line"> 26   printu(&quot;Summation of an arithmetic sequence from 0 to %ld is: %ld \\n&quot;, n, sum_sequence(1000) );</span><br><span class="line"> 27   exit(0);</span><br><span class="line"> 28 &#125;</span><br></pre></td></tr></table></figure>
<p>给定一个递增的等差数列：<code>0, 1, 2, ..., n</code>，如何求该数列的和？以上的应用给出了它的递归（recursive）解法。通过定义一个函数sum_sequence(n)，将求和问题转换为sum_sequence(n-1) + n的问题。问题中n依次递减，直至为0时令sum_sequence(0)&#x3D;0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">*   （先提交lab2_2的答案，然后）切换到lab2_3、继承lab2_2及以前所做修改，并make后的直接运行结果：</span><br><span class="line"></span><br><span class="line">//切换到lab2_3</span><br><span class="line">$ git checkout lab2_3_pagefault</span><br><span class="line"></span><br><span class="line">//继承lab2_2以及之前的答案</span><br><span class="line">$ git merge lab2_2_allocatepage -m &quot;continue to work on lab2_3&quot;</span><br><span class="line"></span><br><span class="line">//重新构造</span><br><span class="line">$ make clean; make</span><br><span class="line"></span><br><span class="line">//运行构造结果</span><br><span class="line">$ spike ./obj/riscv-pke ./obj/app_sum_sequence</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_sum_sequence</span><br><span class="line">Application program entry point (virtual address): 0x0000000000010096</span><br><span class="line">Switching to user mode...</span><br><span class="line">handle_page_fault: 000000007fffdff8</span><br><span class="line">You need to implement the operations that actually handle the page fault **in** lab2_3.</span><br><span class="line"></span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure>
<p>以上执行结果，为什么会出现handle_page_fault呢？这就跟我们给出的应用程序（递归求解等差数列的和）有关了。</p>
<p>递归解法的特点是，函数调用的路径会被完整地保存在栈（stack）中，也就是说函数的下一次调用会将上次一调用的现场（包括参数）压栈，直到n&#x3D;0时依次返回到最开始给定的n值，从而得到最终的计算结果。显然，在以上计算等差数列的和的程序中，n值给得越大，就会导致越深的栈，而栈越深需要的内存空间也就越多。</p>
<p>通过<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjdmlydHVhbGFkZHJlc3NzcGFjZQ==">4.1.3节</span>中对用户进程逻辑地址空间的讨论，以及图4.5的图示，我们知道应用程序最开始被载入（并装配为用户进程）时，它的用户态栈空间（栈底在0x7ffff000，即USER_STACK_TOP）仅有1个4KB的页面。显然，只要以上的程序给出的n值“足够”大，就一定会“压爆”用户态栈。而以上运行结果中，出问题的地方（即handle_page_fault后出现的地址，0x7fffdff8）也恰恰在用户态栈所对应的空间。</p>
<p>以上分析表明，之所以运行.&#x2F;obj&#x2F;app_sum_sequence会出现错误（handle_page_fault），是因为给sum_sequence()函数的n值太大，把用户态栈“压爆”了。</p>
<h4 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTI="></span><strong>实验内容</strong></h4><p>在PKE操作系统内核中完善用户态栈空间的管理，使得它能够正确处理用户进程的“压栈”请求。</p>
<p>实验完成后的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ spike ./obj/riscv-pke ./obj/app_sum_sequence</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: ./obj/app_sum_sequence</span><br><span class="line">Application program entry point (virtual address): 0x0000000000010096</span><br><span class="line">Switching to user mode...</span><br><span class="line">handle_page_fault: 000000007fffdff8</span><br><span class="line">handle_page_fault: 000000007fffcff8</span><br><span class="line">handle_page_fault: 000000007fffbff8</span><br><span class="line">Summation of an arithmetic sequence from 0 to 1000 is: 500500</span><br><span class="line">User exit with code:0.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<h4 id="实验指导-2"><a href="#实验指导-2" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTI="></span><strong>实验指导</strong></h4><p>本实验需要结合<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjZXhjZXB0aW9u">lab1_2</span>中的异常处理知识，但要注意的是，lab1_2中我们处理的是非法指令异常，对该异常的处理足够操作系统将应用进程“杀死”。本实验中，我们处理的是缺页异常（app_sum_sequence.c执行的显然是“合法”操作），不能也不应该将应用进程杀死。正确的做法是：首先，通过异常的类型，判断我们处理的确实是缺页异常；接下来，判断发生缺页的是不是用户栈空间，如果是则分配一个物理页空间，最后将该空间通过vm_map“粘”到用户栈上以扩充用户栈空间。</p>
<p>另外，lab1_2中处理的非法指令异常是在M模式下处理的，原因是我们根本没有将该异常代理给S模式。但是，对于本实验中的缺页异常是不是也是需要在M模式处理呢？我们先回顾以下kernel&#x2F;machine&#x2F;minit.c文件中的delegate_traps()函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">51 **static** **void** **delegate_traps**() &#123;</span><br><span class="line">52   **if** (!supports_extension(&#x27;S&#x27;)) &#123;</span><br><span class="line">53     // confirm that our processor supports supervisor mode. abort if not.</span><br><span class="line">54     sprint(&quot;s mode is not supported.\\n&quot;);</span><br><span class="line">55     **return**;</span><br><span class="line">56   &#125;</span><br><span class="line">57</span><br><span class="line">58   **uintptr_t** interrupts = MIP_SSIP  MIP_STIP  MIP_SEIP;</span><br><span class="line">59   **uintptr_t** exceptions = (1U &lt;&lt; CAUSE_MISALIGNED_FETCH)  (1U &lt;&lt; CAUSE_FETCH_PAGE_FAULT) </span><br><span class="line">60                          (1U &lt;&lt; CAUSE_BREAKPOINT)  (1U &lt;&lt; CAUSE_LOAD_PAGE_FAULT) </span><br><span class="line">61                          (1U &lt;&lt; CAUSE_STORE_PAGE_FAULT)  (1U &lt;&lt; CAUSE_USER_ECALL);</span><br><span class="line">62</span><br><span class="line">63   write_csr(mideleg, interrupts);</span><br><span class="line">64   write_csr(medeleg, exceptions);</span><br><span class="line">65   assert(read_csr(mideleg) == interrupts);</span><br><span class="line">66   assert(read_csr(medeleg) == exceptions);</span><br><span class="line">67 &#125;</span><br></pre></td></tr></table></figure>
<p>而在本实验的应用中，产生缺页异常的本质还是应用往未被映射的内存空间“写”（以及后续的访问）所导致的，所以CAUSE_STORE_PAGE_FAULT是我们应该关注的异常。通过阅读delegate_traps()函数，我们看到该函数显然已将缺页异常（CAUSE_STORE_PAGE_FAULT）代理给了S模式，所以，接下来我们就应阅读kernel&#x2F;strap.c文件中对于这类异常的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">49 **void** **handle_user_page_fault**(uint64 mcause, uint64 sepc, uint64 stval) &#123;</span><br><span class="line">50   sprint(&quot;handle_page_fault: %lx\\n&quot;, stval);</span><br><span class="line">51   **switch** (mcause) &#123;</span><br><span class="line">52     **case** CAUSE_STORE_PAGE_FAULT:</span><br><span class="line">53       // TODO (lab2_3): implement the operations that solve the page fault to</span><br><span class="line">54       // dynamically increase application stack.</span><br><span class="line">55       // hint: first allocate a new physical page, and then, maps the new page to the</span><br><span class="line">56       // virtual address that causes the page fault.</span><br><span class="line">57       panic( &quot;You need to implement the operations that actually handle the page fault in lab2_3.\\n&quot; );</span><br><span class="line">58</span><br><span class="line">59       **break**;</span><br><span class="line">60     **default**:</span><br><span class="line">61       sprint(&quot;unknown page fault.\\n&quot;);</span><br><span class="line">62       **break**;</span><br><span class="line">63   &#125;</span><br><span class="line">64 &#125;</span><br></pre></td></tr></table></figure>
<p>编者注:缺页异常本身就是一种异常,按照异常的方式处理即可.</p>
<p>这里，我们找到了之前运行.&#x2F;obj&#x2F;app_sum_sequence出错的地方，我们只需要改正这一错误实现缺页处理，使得程序获得正确的输出就好。实现缺页处理的思路如下：</p>
<p>编者注:注意要进行页面对齐.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(stval&gt;USER_STACK_TOP&amp;&amp;(USER_STACK_TOP-stval)&gt;=20\*(STACK_SIZE))&#123;</span><br><span class="line">        user_vm_map((pagetable_t)current-&gt;pagetable, stval - stval%PGSIZE, PGSIZE, (uint64)alloc_page(), prot_to_type(PROT_WRITE  PROT_READ, 1));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过输入的参数stval（存放的是发生缺页异常时，程序想要访问的逻辑地址）判断缺页的逻辑地址在用户进程逻辑地址空间中的位置，看是不是比USER_STACK_TOP更大，且比我们预设的可能的用户栈最大空间小（这里，我们可以给用户栈一个上限，例如20个4KB的页面）；</li>
<li>分配一个物理页，将所分配的物理页面映射到stval所对应的虚拟地址上。</li>
</ul>
<p><strong>实验完毕后，记得提交修改（命令行中-m后的字符串可自行确定），以便在后续实验中继承lab2_3中所做的工作</strong>：</p>
<p>$ git commit -a -m “my work on lab2_3 is done.”</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-02-29 15:25:14" itemprop="dateModified" datetime="2024-02-29T15:25:14+08:00">2024-02-29</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.jpg" alt="Sukuna 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.jpg" alt="Sukuna 支付宝">
        <p>支付宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Sukuna <i class="ic i-at"><em>@</em></i>灵山之上神风起
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://sukunashinmyoumaru-hust.github.io/2021/12/18/oslab2/" title="华中科技大学OS实验解析(Lab2)">https://sukunashinmyoumaru-hust.github.io/2021/12/18/oslab2/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/12/18/oslab1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2024&#x2F;06&#x2F;17&#x2F;f841728a51c3ae78.jpg" title="华中科技大学OS实验解析(Lab1)">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 实验记录</span>
  <h3>华中科技大学OS实验解析(Lab1)</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/02/26/oschallengelab/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2024&#x2F;06&#x2F;17&#x2F;4663c8f5b7019dfd.jpg" title="华中科技大学操作系统挑战实验(PKE)基础解析">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 实验记录</span>
  <h3>华中科技大学操作系统挑战实验(PKE)基础解析</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AE%9E%E9%AA%8C2%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">4.1 实验2的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Sv39%E8%99%9A%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.1.</span> <span class="toc-text">4.1.1 Sv39虚地址管理方案回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%A7%84%E5%88%92"><span class="toc-number">1.2.</span> <span class="toc-text">4.1.2 物理内存布局与规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-PKE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">4.1.3 PKE操作系统和应用进程的逻辑地址空间结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">1.3.1.</span> <span class="toc-text">操作系统内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">应用进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E4%B8%8E%E9%A1%B5%E8%A1%A8%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4.1.4 与页表操作相关的重要函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-lab2-1-%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">4.2 lab2_1 虚实地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC"><span class="toc-number">2.0.3.</span> <span class="toc-text">实验指导</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-lab2-2-%E7%AE%80%E5%8D%95%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">4.3 lab2_2 简单内存分配和回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-1"><span class="toc-number">3.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-1"><span class="toc-number">3.0.3.</span> <span class="toc-text">实验指导</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-lab2-3-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">4.4 lab2_3 缺页异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-2"><span class="toc-number">4.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-2"><span class="toc-number">4.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-2"><span class="toc-number">4.0.3.</span> <span class="toc-text">实验指导</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2021/04/25/verilog/" rel="bookmark" title="华中科技大学Verilog实验解析">华中科技大学Verilog实验解析</a></li><li><a href="/2021/12/18/oslab1/" rel="bookmark" title="华中科技大学OS实验解析(Lab1)">华中科技大学OS实验解析(Lab1)</a></li><li class="active"><a href="/2021/12/18/oslab2/" rel="bookmark" title="华中科技大学OS实验解析(Lab2)">华中科技大学OS实验解析(Lab2)</a></li><li><a href="/2022/02/26/oschallengelab/" rel="bookmark" title="华中科技大学操作系统挑战实验(PKE)基础解析">华中科技大学操作系统挑战实验(PKE)基础解析</a></li><li><a href="/2023/02/06/rustilings/" rel="bookmark" title="Rustilings 练习笔记">Rustilings 练习笔记</a></li><li><a href="/2023/02/06/stanford-cs144-lab/" rel="bookmark" title="Stanford CS144 Lab">Stanford CS144 Lab</a></li><li><a href="/2023/02/07/cmu14-445-lab/" rel="bookmark" title="CMU14-445 Lab">CMU14-445 Lab</a></li><li><a href="/2023/02/08/mit-6-s081-lab/" rel="bookmark" title="MIT_6.s081_Lab">MIT_6.s081_Lab</a></li><li><a href="/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/" rel="bookmark" title="MIT_6.S081_xv6.Information 集合">MIT_6.S081_xv6.Information 集合</a></li><li><a href="/2023/09/13/nju-pa/" rel="bookmark" title="南大pa">南大pa</a></li><li><a href="/2024/04/17/stanford-cs143-PA/" rel="bookmark" title="Stanford CS143 PA">Stanford CS143 PA</a></li><li><a href="/2024/04/19/mit-6-824-mr/" rel="bookmark" title="MIT_6.824:PA1-MapReduce">MIT_6.824:PA1-MapReduce</a></li><li><a href="/2024/04/28/mit-6-824-raft/" rel="bookmark" title="In Search of an Understandable Consensus Algorithm (Extended Version)">In Search of an Understandable Consensus Algorithm (Extended Version)</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Sukuna"
      data-src="/images/IMG_1335.PNG">
  <p class="name" itemprop="name">Sukuna</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">25</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">3</span>
        <span class="name">分类</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1a3VuYXNoaW5teW91bWFydS1odXN0" title="https:&#x2F;&#x2F;github.com&#x2F;Sukunashinmyoumaru-hust"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zdWt1bmFfd2lyZWxlc3M=" title="https:&#x2F;&#x2F;twitter.com&#x2F;sukuna_wireless"><i class="ic i-twitter"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI5NDE3ODM1MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;294178351"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9zdWt1bmFodXN0Lm1vZS9hYm91dA==" title="https:&#x2F;&#x2F;sukunahust.moe&#x2F;about"><i class="ic i-address-card"></i></span>
      <a href="/sukuna@hust.edu.cn" title="sukuna@hust.edu.cn" class="item email"><i class="ic i-envelope"></i></a>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friend/" rel="section"><i class="ic i-heart"></i>友链</a>
  </li>

    
  <li class="item">
    <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1a3VuYVNoaW5teW91bWFydS1odXN0L0h1c3Qtb3BlbnNvdXJjZS1YdWVqaWU="><i class="ic i-github"></i>HUST-学解</span>
  </li>

    
  <li class="item">
    <a href="/picture/" rel="section"><i class="ic i-magic"></i>赠画感谢</a>
  </li>

    
  <li class="item">
    <a href="/source/" rel="section"><i class="ic i-address-card"></i>资料下载</a>
  </li>

    
  <li class="item">
    <a href="/travel/" rel="section"><i class="ic i-heart"></i>旅行日志</a>
  </li>

    
  <li class="item">
    <a href="/gbook/" rel="section"><i class="ic i-magic"></i>Sukuna冬令营</a>
  </li>

    
  <li class="item">
    <span class="exturl" data-url="aHR0cHM6Ly9nMmNlemVwZC55aWNoYWZlbi5jb20="><i class="ic i-magic"></i>相关查询</span>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/12/18/oslab1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/02/26/oschallengelab/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sukuna @ Suwa shrine</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">463k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">7:01</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/12/18/oslab2/',
    favicon: {
      show: "（●´3｀●）あややややや～",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
