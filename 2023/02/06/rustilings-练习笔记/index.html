<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="1-1 &#x2F;&#x2F; variables1.rs&#x2F;&#x2F; Make me compile!&#x2F;&#x2F; Execute &#96;rustlings hint variables1&#96; or use the &#96;hint&#96; watch subcommand for a hint. &#x2F;&#x2F; I AM NOT DONE fn main() {    x &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Rustilings 练习笔记">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="1-1 &#x2F;&#x2F; variables1.rs&#x2F;&#x2F; Make me compile!&#x2F;&#x2F; Execute &#96;rustlings hint variables1&#96; or use the &#96;hint&#96; watch subcommand for a hint. &#x2F;&#x2F; I AM NOT DONE fn main() {    x &amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-06T02:43:19.000Z">
<meta property="article:modified_time" content="2024-02-27T05:01:50.131Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/project/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/project/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/project/images/favicon-192x192.png">
        
      
    
    <!-- title -->
    <title>Rustilings 练习笔记</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/project/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/project/2023/02/06/cmu14-445-lab/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/project/2022/10/24/trajectory-modifification-considering-dynamic-constraintsof-autonomous-robots/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&text=Rustilings 练习笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&is_video=false&description=Rustilings 练习笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Rustilings 练习笔记&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&name=Rustilings 练习笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&t=Rustilings 练习笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Rustilings 练习笔记
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Sukuna</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-02-06T02:43:19.000Z" class="dt-published" itemprop="datePublished">2023-02-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/project/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/">实验记录</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>1-1</p>
<p>&#x2F;&#x2F; variables1.rs<br>&#x2F;&#x2F; Make me compile!<br>&#x2F;&#x2F; Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    x &#x3D; 5;<br>    println!(“x has the value {}”, x);<br>}</p>
<p>这题简单,声明的方式出错了</p>
<p>&#x2F;&#x2F; variables1.rs<br>&#x2F;&#x2F; Make me compile!<br>&#x2F;&#x2F; Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let x &#x3D; 5;<br>    println!(“x has the value {}”, x);<br>}</p>
<p>1-2</p>
<p>&#x2F;&#x2F; variables2.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let x;<br>    if x &#x3D;&#x3D; 10 {<br>        println!(“x is ten!”);<br>    } else {<br>        println!(“x is not ten!”);<br>    }<br>}</p>
<p>Rust不能判断x的类型,指定一下就好了</p>
<p>&#x2F;&#x2F; variables2.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let x : i32 &#x3D; 10;<br>    if x &#x3D;&#x3D; 10 {<br>        println!(“x is ten!”);<br>    } else {<br>        println!(“x is not ten!”);<br>    }<br>}</p>
<p>1-3</p>
<p>&#x2F;&#x2F; variables3.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let x: i32;<br>    println!(“Number {}”, x);<br>}</p>
<p>x没有初始化,Rust编译器不允许访问没有初始化的元素</p>
<p>&#x2F;&#x2F; variables3.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let x: i32 &#x3D; 10;<br>    println!(“Number {}”, x);<br>}</p>
<p>1-4</p>
<p>&#x2F;&#x2F; variables4.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let x &#x3D; 3;<br>    println!(“Number {}”, x);<br>    x &#x3D; 5; &#x2F;&#x2F; don’t change this line<br>    println!(“Number {}”, x);<br>}</p>
<p>Rust默认变量不可变,x&#x3D;5修改了变量,所以说会拒绝,所以说要让变量可变</p>
<p>&#x2F;&#x2F; variables4.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let mut x &#x3D; 3;<br>    println!(“Number {}”, x);<br>    x &#x3D; 5; &#x2F;&#x2F; don’t change this line<br>    println!(“Number {}”, x);<br>}</p>
<p>1-5</p>
<p>&#x2F;&#x2F; variables5.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let number &#x3D; “T-H-R-E-E”; &#x2F;&#x2F; don’t change this line<br>    println!(“Spell a Number : {}”, number);<br>    number &#x3D; 3; &#x2F;&#x2F; don’t rename this variable<br>    println!(“Number plus two is : {}”, number + 2);<br>}</p>
<p>Rust有类型检查,执行运算或者赋值时候要遵循类型的规律,但是Rust可以重新定义同名变量,变量的类型可以发生改变</p>
<p>&#x2F;&#x2F; variables5.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let number &#x3D; “T-H-R-E-E”; &#x2F;&#x2F; don’t change this line<br>    println!(“Spell a Number : {}”, number);<br>    let number &#x3D; 3; &#x2F;&#x2F; don’t rename this variable<br>    println!(“Number plus two is : {}”, number + 2);<br>}</p>
<p>1-6</p>
<p>&#x2F;&#x2F; variables6.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>const NUMBER &#x3D; 3;<br>fn main() {<br>    println!(“Number {}”, NUMBER);<br>}</p>
<p>const也是一样,当系统不能判断其类型的时候,需要显示说明</p>
<p>&#x2F;&#x2F; variables6.rs<br>&#x2F;&#x2F; Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.</p>
<p>const NUMBER : i32 &#x3D; 3;<br>fn main() {<br>    println!(“Number {}”, NUMBER);<br>}</p>
<p>2-1</p>
<p>&#x2F;&#x2F; functions1.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    call_me();<br>}</p>
<p>这一题我们需要自己声明一个无参数无返回值的函数.fn 名字 (){}</p>
<p>&#x2F;&#x2F; functions1.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.</p>
<p>fn call_me(){<br>    println!(“Hello World”);<br>}<br>fn main() {<br>    call_me();<br>}</p>
<p>2-2</p>
<p>&#x2F;&#x2F; functions2.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    call_me(3);<br>}</p>
<p>fn call_me(num:) {<br>    for i in 0..num {<br>        println!(“Ring! Call number {}”, i + 1);<br>    }<br>}</p>
<p>有参数的函数.参数在括号里面,用逗号隔开,名字:类型</p>
<p>&#x2F;&#x2F; functions2.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    call_me(3);<br>}</p>
<p>fn call_me(num:i32) {<br>    for i in 0..num {<br>        println!(“Ring! Call number {}”, i + 1);<br>    }<br>}</p>
<p>2-3</p>
<p>&#x2F;&#x2F; functions3.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    call_me();<br>}</p>
<p>fn call_me(num: u32) {<br>    for i in 0..num {<br>        println!(“Ring! Call number {}”, i + 1);<br>    }<br>}</p>
<p>很难看不出来是函数调用的时候漏传实参了,补上实参即可</p>
<p>2-4</p>
<p>&#x2F;&#x2F; functions4.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; This store is having a sale where if the price is an even number, you get<br>&#x2F;&#x2F; 10 Rustbucks off, but if it’s an odd number, it’s 3 Rustbucks off.<br>&#x2F;&#x2F; (Don’t worry about the function bodies themselves, we’re only interested<br>&#x2F;&#x2F; in the signatures for now. If anything, this is a good way to peek ahead<br>&#x2F;&#x2F; to future exercises!)</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let original_price &#x3D; 51;<br>    println!(“Your sale price is {}”, sale_price(original_price));<br>}</p>
<p>fn sale_price(price: i32) -&gt; {<br>    if is_even(price) {<br>        price - 10<br>    } else {<br>        price - 3<br>    }<br>}</p>
<p>fn is_even(num: i32) -&gt; bool {<br>    num % 2 &#x3D;&#x3D; 0<br>}</p>
<p>函数返回返回值的方法 就是 -&gt; 返回值类型 ,返回值可以是最后一条语句的值(这个语句不要加分号),也可以定义return</p>
<p>给sale_price的-&gt;后面添加上返回值类型i32即可</p>
<p>2-5</p>
<p>&#x2F;&#x2F; functions5.rs<br>&#x2F;&#x2F; Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let answer &#x3D; square(3);<br>    println!(“The square of 3 is {}”, answer);<br>}</p>
<p>fn square(num: i32) -&gt; i32 {<br>    num * num;<br>}</p>
<p>定义返回值不是这么定义的,一般是语句或者是return,所以说要么改成return num * num;要么去掉分号.一个块中最后一条语句去掉分号、这个可以称为块尾,就是返回值</p>
<p>3-1</p>
<p>写一个bigger函数,判断返回a和b中大的那个:</p>
<p>pub fn bigger(a: i32, b: i32) -&gt; i32 {<br>    &#x2F;&#x2F; Complete this function to return the bigger number!<br>    &#x2F;&#x2F; Do not use:<br>    &#x2F;&#x2F; - another function call<br>    &#x2F;&#x2F; - additional variables<br>    if a &gt; b{<br>        a<br>    }<br>    else{<br>        b<br>    }<br>}</p>
<p>3-2</p>
<p>修改这个函数,使得可以编译并且能够通过测试</p>
<p>pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {<br>    if fizzish &#x3D;&#x3D; “fizz” {<br>        “foo”<br>    } else {<br>        1<br>    }<br>}</p>
<p>第一个是,返回的是&amp;str,不能返回1这个数字,然后修改逻辑能够通过测试就好</p>
<p>pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {<br>    if fizzish &#x3D;&#x3D; “fizz” {<br>        “foo”<br>    } else if fizzish &#x3D;&#x3D; “fuzz” {<br>        “bar”<br>    }<br>    else{<br>        “baz”<br>    }<br>}</p>
<p>4-1</p>
<p>&#x2F;&#x2F; primitive_types1.rs<br>&#x2F;&#x2F; Fill in the rest of the line that has code missing!<br>&#x2F;&#x2F; No hints, there’s no tricks, just get used to typing these :)</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    &#x2F;&#x2F; Booleans (`bool`)</p>
<pre><code>let is\_morning = true;
if is\_morning &#123;
    println!(&quot;Good morning!&quot;);
&#125;

let // Finish the rest of this line like the example! Or make it be false!
if is\_evening &#123;
    println!(&quot;Good evening!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>只用完成一行的代码就好了.不知道这题的意义是什么23333 就是写成<code>let is_evening = false;</code>就好了</p>
<p>4-2</p>
<p>&#x2F;&#x2F; primitive_types2.rs<br>&#x2F;&#x2F; Fill in the rest of the line that has code missing!<br>&#x2F;&#x2F; No hints, there’s no tricks, just get used to typing these :)</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    &#x2F;&#x2F; Characters (`char`)</p>
<pre><code>// Note the \_single\_ quotes, these are different from the double quotes
// you&#39;ve been seeing around.
let my\_first\_initial = &#39;C&#39;;
if my\_first\_initial.is\_alphabetic() &#123;
    println!(&quot;Alphabetical!&quot;);
&#125; else if my\_first\_initial.is\_numeric() &#123;
    println!(&quot;Numerical!&quot;);
&#125; else &#123;
    println!(&quot;Neither alphabetic nor numeric!&quot;);
&#125;

let your\_character = &#39;1&#39;;// Finish this line like the example! What&#39;s your favorite character?
// Try a letter, try a number, try a special character, try a character
// from a different language than your own, try an emoji!
if your\_character.is\_alphabetic() &#123;
    println!(&quot;Alphabetical!&quot;);
&#125; else if your\_character.is\_numeric() &#123;
    println!(&quot;Numerical!&quot;);
&#125; else &#123;
    println!(&quot;Neither alphabetic nor numeric!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>代码就是给定一个字符,进行判断而已.这题似乎也没难度,填写一个:<code>let your_character = &#39;1&#39;;</code>就好</p>
<p>4-3</p>
<p>这题需要我们学会怎么声明一个数组,这个和C语言几乎一样.就是<code>let a = [1,2,3,4];</code></p>
<p>4-4</p>
<p>这题需要我们创建一个数组slice,就是取第2-4个元素</p>
<p>&#x2F;&#x2F; primitive_types4.rs<br>&#x2F;&#x2F; Get a slice out of Array a where the ??? is so that the test passes.<br>&#x2F;&#x2F; Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.</p>
<p>#[test]<br>fn slice_out_of_array() {<br>    let a &#x3D; [1, 2, 3, 4, 5];</p>
<pre><code>let nice\_slice = ???;

assert\_eq!(\[2, 3, 4\], nice\_slice)
</code></pre>
<p>}</p>
<p>答案是&amp;a[1..4],这个slice:&amp;a[a,b]会取a+1到b的元素.</p>
<p>4-5</p>
<p>这题需要我们写一个元组模式匹配的代码,就是(a,b)&#x3D;元组</p>
<p>&#x2F;&#x2F; primitive_types5.rs<br>&#x2F;&#x2F; Destructure the `cat` tuple so that the println will work.<br>&#x2F;&#x2F; Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let cat &#x3D; (“Furry McFurson”, 3.5);<br>    let &#x2F;* your pattern here *&#x2F; &#x3D; cat;</p>
<pre><code>println!(&quot;&#123;&#125; is &#123;&#125; years old.&quot;, name, age);
</code></pre>
<p>}</p>
<p>把注释改成let (name,age) &#x3D; cat;就好,这样可以像SML一样完成模式匹配</p>
<p>4-6</p>
<p>这题需要我们取出元组的第2个元素.</p>
<p>&#x2F;&#x2F; primitive_types6.rs<br>&#x2F;&#x2F; Use a tuple index to access the second element of `numbers`.<br>&#x2F;&#x2F; You can put the expression for the second element where ??? is so that the test passes.<br>&#x2F;&#x2F; Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>#[test]<br>fn indexing_tuple() {<br>    let numbers &#x3D; (1, 2, 3);<br>    &#x2F;&#x2F; Replace below ??? with the tuple indexing syntax.<br>    let second &#x3D; ???;</p>
<pre><code>assert\_eq!(2, second,
    &quot;This is not the 2nd number in the tuple!&quot;)
</code></pre>
<p>}</p>
<p>答案就是<code>let second = numbers.1;</code></p>
<p>5-1</p>
<p>&#x2F;&#x2F; move_semantics1.rs<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let vec0 &#x3D; Vec::new();</p>
<pre><code>let vec1 = fill\_vec(vec0);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>fn fill_vec(vec: Vec<i32>) -&gt; Vec<i32> {<br>    let mut vec &#x3D; vec;</p>
<pre><code>vec.push(22);
vec.push(44);
vec.push(66);

vec
</code></pre>
<p>}</p>
<p>讲vec1改成mut(可变)即可,对Vec做增删改需要将Vec改为可变</p>
<p>5-2</p>
<p>&#x2F;&#x2F; move_semantics2.rs<br>&#x2F;&#x2F; Make me compile without changing line 13 or moving line 10!<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let vec0 &#x3D; Vec::new();</p>
<pre><code>let mut vec1 = fill\_vec(vec0);

// Do not change the following line!
println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec0&quot;, vec0.len(), vec0);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>fn fill_vec(vec: Vec<i32>) -&gt; Vec<i32> {<br>    let mut vec &#x3D; vec;</p>
<pre><code>vec.push(22);
vec.push(44);
vec.push(66);

vec
</code></pre>
<p>}</p>
<p>vec0的所有权进入到函数fill_vec中了,fill_vec结束后,vec0的所有权被释放,main丧失了对vec0的所有权,就不能访问vec0了.</p>
<p>所以说我们要把传vec0改成传vec0的引用,传引用是不会交出所有权的.在函数中对此引用产生一个拷贝,将此拷贝传回来,这个拷贝是实际的Vec类型而不是引用</p>
<p>&#x2F;&#x2F; move_semantics2.rs<br>&#x2F;&#x2F; Make me compile without changing line 13 or moving line 10!<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let vec0 &#x3D; Vec::new();</p>
<pre><code>let mut vec1 = fill\_vec(&amp;vec0);

// Do not change the following line!
println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec0&quot;, vec0.len(), vec0);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>fn fill_vec(vec: &amp;Vec<i32>) -&gt; Vec<i32> {<br>    let mut vec &#x3D; (*vec).to_vec();</p>
<pre><code>vec.push(22);
vec.push(44);
vec.push(66);

(\*vec).to\_vec()
</code></pre>
<p>}</p>
<p>5-3</p>
<p>fn main() {<br>    let vec0 &#x3D; Vec::new();</p>
<pre><code>let mut vec1 = fill\_vec(vec0);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>fn fill_vec(vec: Vec<i32>) -&gt; Vec<i32> {<br>    vec.push(22);<br>    vec.push(44);<br>    vec.push(66);</p>
<pre><code>vec
</code></pre>
<p>}</p>
<p>主要的问题就是fill_vec函数中的vec是不可变的,要push内容是不可以的.</p>
<p>一个解决方法就是创建一个拷贝,像5-1一样.</p>
<p>第二个方法就是将vec0设置成mut的,fill_vec的vec也设置成mut</p>
<p>fn main() {<br>    let mut vec0 &#x3D; Vec::new();</p>
<pre><code>let mut vec1 = fill\_vec(vec0);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>fn fill_vec(mut vec: Vec<i32>) -&gt; Vec<i32> {<br>    vec.push(22);<br>    vec.push(44);<br>    vec.push(66);</p>
<pre><code>vec
</code></pre>
<p>}</p>
<p>5-4</p>
<p>&#x2F;&#x2F; move_semantics4.rs<br>&#x2F;&#x2F; Refactor this code so that instead of passing `vec0` into the `fill_vec` function,<br>&#x2F;&#x2F; the Vector gets created in the function itself and passed back to the main<br>&#x2F;&#x2F; function.<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let vec0 &#x3D; Vec::new();</p>
<pre><code>let mut vec1 = fill\_vec(vec0);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; `fill_vec()` no longer takes `vec: Vec<i32>` as argument<br>fn fill_vec() -&gt; Vec<i32> {<br>    let mut vec &#x3D; vec;</p>
<pre><code>vec.push(22);
vec.push(44);
vec.push(66);

vec
</code></pre>
<p>}</p>
<p>不用vec0就把vec0相关的内容删掉,改成在函数体内new一个就好</p>
<p>fn main() {</p>
<pre><code>let mut vec1 = fill\_vec();

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

vec1.push(88);

println!(&quot;&#123;&#125; has length &#123;&#125; content \`&#123;:?&#125;\`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; `fill_vec()` no longer takes `vec: Vec<i32>` as argument<br>fn fill_vec() -&gt; Vec<i32> {<br>    let mut vec &#x3D; Vec::new();</p>
<pre><code>vec.push(22);
vec.push(44);
vec.push(66);

vec
</code></pre>
<p>}</p>
<p>5-5</p>
<p>&#x2F;&#x2F; move_semantics5.rs<br>&#x2F;&#x2F; Make me compile only by reordering the lines in `main()`, but without<br>&#x2F;&#x2F; adding, changing or removing any of them.<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let mut x &#x3D; 100;<br>    let y &#x3D; &amp;mut x;<br>    let z &#x3D; &amp;mut x;<br>    *y +&#x3D; 100;<br>    *z +&#x3D; 1000;<br>    assert_eq!(x, 1200);<br>}</p>
<p>不能对一个变量同时创建两个可变引用,改成这样就好:</p>
<p>fn main() {<br>    let mut x &#x3D; 100;<br>    let z &#x3D; &amp;mut x;<br>    *z +&#x3D; 100;<br>    *z +&#x3D; 1000;<br>    assert_eq!(x, 1200);<br>}</p>
<p>5-6</p>
<p>&#x2F;&#x2F; move_semantics6.rs<br>&#x2F;&#x2F; Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.<br>&#x2F;&#x2F; You can’t change anything except adding or removing references.</p>
<p>fn main() {<br>    let data &#x3D; “Rust is great!”.to_string();</p>
<pre><code>get\_char(data);

string\_uppercase(&amp;data);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Should not take ownership<br>fn get_char(data: String) -&gt; char {<br>    data.chars().last().unwrap()<br>}</p>
<p>&#x2F;&#x2F; Should take ownership<br>fn string_uppercase(mut data: &amp;String) {<br>    data &#x3D; &amp;data.to_uppercase();</p>
<pre><code>println!(&quot;&#123;&#125;&quot;, data);
</code></pre>
<p>}</p>
<p>代码的注释都写了,不要放弃所有权就是加引用,放弃所有权就是不加引用</p>
<p>fn main() {<br>    let data &#x3D; “Rust is great!”.to_string();</p>
<pre><code>get\_char(&amp;data);

string\_uppercase(data);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Should not take ownership<br>fn get_char(data: &amp;String) -&gt; char {<br>    (*data).chars().last().unwrap()<br>}</p>
<p>&#x2F;&#x2F; Should take ownership<br>fn string_uppercase(mut data: String) {<br>    data &#x3D; data.to_uppercase();</p>
<pre><code>println!(&quot;&#123;&#125;&quot;, data);
</code></pre>
<p>}</p>
<p>6-1</p>
<p>这一题我们要了解最基础的结构体、元组型结构体以及单元结构体的定义和初始化.</p>
<p>定义的方法两者有所不同,一个是用{}扩起来,不同的元素之间用逗号隔开,还有就是元组型,用()扩起来,不同的元素用逗号隔开.访问的方式一个是结构体.名字和结构体.顺序</p>
<p>&#x2F;&#x2F; structs1.rs<br>&#x2F;&#x2F; Address all the TODOs to make the tests pass!<br>&#x2F;&#x2F; Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.</p>
<p>struct ColorClassicStruct {<br>    red : i32,<br>    blue : i32,<br>    green : i32,<br>}</p>
<p>struct ColorTupleStruct(i32,i32,i32);</p>
<p>#[derive(Debug)]<br>struct UnitLikeStruct;</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn classic\_c\_structs() &#123;
    // TODO: Instantiate a classic c struct!
    let green = ColorClassicStruct&#123;
        red:0,
        green:255,
        blue:0,
    &#125;;

    assert\_eq!(green.red, 0);
    assert\_eq!(green.green, 255);
    assert\_eq!(green.blue, 0);
&#125;

#\[test\]
fn tuple\_structs() &#123;
    // TODO: Instantiate a tuple struct!
    let green = ColorTupleStruct(0, 255, 0);

    assert\_eq!(green.0, 0);
    assert\_eq!(green.1, 255);
    assert\_eq!(green.2, 0);
&#125;

#\[test\]
fn unit\_structs() &#123;
    // TODO: Instantiate a unit-like struct!
    let unit\_like\_struct = UnitLikeStruct&#123;&#125;;
    let message = format!(&quot;&#123;:?&#125;s are fun!&quot;, unit\_like\_struct);

    assert\_eq!(message, &quot;UnitLikeStructs are fun!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>6-2</p>
<p>这一题我们需要用一个已经定义好的结构体来声明一个结构体,有一种朴素的方法是,使用A : others.A来定义,还有就是先定义有不同的,再使用..other定义相同的属性.</p>
<p>&#x2F;&#x2F; structs2.rs<br>&#x2F;&#x2F; Address all the TODOs to make the tests pass!<br>&#x2F;&#x2F; Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.</p>
<p>#[derive(Debug)]<br>struct Order {<br>    name: String,<br>    year: u32,<br>    made_by_phone: bool,<br>    made_by_mobile: bool,<br>    made_by_email: bool,<br>    item_number: u32,<br>    count: u32,<br>}</p>
<p>fn create_order_template() -&gt; Order {<br>    Order {<br>        name: String::from(“Bob”),<br>        year: 2019,<br>        made_by_phone: false,<br>        made_by_mobile: false,<br>        made_by_email: true,<br>        item_number: 123,<br>        count: 0,<br>    }<br>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn your\_order() &#123;
    let order\_template = create\_order\_template();
    // TODO: Create your own order using the update syntax and template above!
    let your\_order = Order&#123;
        name : String::from(&quot;Hacker in Rust&quot;),
        count : 1,
        ..order\_template
    &#125;;
    assert\_eq!(your\_order.name, &quot;Hacker in Rust&quot;);
    assert\_eq!(your\_order.year, order\_template.year);
    assert\_eq!(your\_order.made\_by\_phone, order\_template.made\_by\_phone);
    assert\_eq!(your\_order.made\_by\_mobile, order\_template.made\_by\_mobile);
    assert\_eq!(your\_order.made\_by\_email, order\_template.made\_by\_email);
    assert\_eq!(your\_order.item\_number, order\_template.item\_number);
    assert\_eq!(your\_order.count, 1);
&#125;
</code></pre>
<p>}</p>
<p>6-3</p>
<p>这一题我们需要完成Package的impl块</p>
<pre><code>fn is\_international(&amp;self) -&gt; ??? &#123;
    // Something goes here...
&#125;

fn get\_fees(&amp;self, cents\_per\_gram: i32) -&gt; ??? &#123;
    // Something goes here...
&#125;
</code></pre>
<p>函数都很好写,然后可以这样调用:Package::get_fees来调用impl的方法</p>
<p>impl Package {<br>    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&gt; Package {<br>        if weight_in_grams &lt;&#x3D; 0 {<br>            panic!(“Can not ship a weightless package.”)<br>        } else {<br>            Package {<br>                sender_country,<br>                recipient_country,<br>                weight_in_grams,<br>            }<br>        }<br>    }</p>
<pre><code>fn is\_international(&amp;self) -&gt; bool &#123;
    if self.sender\_country == self.recipient\_country&#123;
        false
    &#125;
    else&#123;
        true
    &#125;
&#125;

fn get\_fees(&amp;self, cents\_per\_gram: i32) -&gt; i32 &#123;
    self.weight\_in\_grams \* cents\_per\_gram
&#125;
</code></pre>
<p>}</p>
<p>比如说Package::new()就可以生成一个新的Package块</p>
<p>对于impl块的调用,我们给出了两种形式,一种是类::方法,一种是实例.方法</p>
<p>fn create_international_package() {<br>        let sender_country &#x3D; String::from(“Spain”);<br>        let recipient_country &#x3D; String::from(“Russia”);</p>
<pre><code>    let package = Package::new(sender\_country, recipient\_country, 1200);

    assert!(package.is\_international());
&#125;
</code></pre>
<p>7-1</p>
<p>这一个我们仅需要声明一个枚举类型即可,声明的方法就是enum 名字{},{}内内容用枚举括起来.</p>
<p>&#x2F;&#x2F; enums1.rs<br>&#x2F;&#x2F; No hints this time! ;)</p>
<p>#[derive(Debug)]<br>enum Message {<br>    &#x2F;&#x2F; TODO: define a few types of messages as used below<br>    Quit,<br>    Echo,<br>    Move,<br>    ChangeColor,<br>}</p>
<p>fn main() {<br>    println!(“{:?}”, Message::Quit);<br>    println!(“{:?}”, Message::Echo);<br>    println!(“{:?}”, Message::Move);<br>    println!(“{:?}”, Message::ChangeColor);<br>}</p>
<p>7-2</p>
<p>这次的声明需要我们像书上说的那样,让枚举变量的每一个枚举值和一个结构体匹配.可能不仅仅是一个结构体,有可能是一个元组或者仅仅是一个值.</p>
<p>&#x2F;&#x2F; enums2.rs<br>&#x2F;&#x2F; Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>#[derive(Debug)]<br>enum Message {<br>    Move{x : i32, y : i32},<br>    Echo(String),<br>    ChangeColor(i32,i32,i32),<br>    Quit,<br>}</p>
<p>impl Message {<br>    fn call(&amp;self) {<br>        println!(“{:?}”, &amp;self);<br>    }<br>}</p>
<p>fn main() {<br>    let messages &#x3D; [<br>        Message::Move { x: 10, y: 30 },<br>        Message::Echo(String::from(“hello world”)),<br>        Message::ChangeColor(200, 255, 255),<br>        Message::Quit,<br>    ];</p>
<pre><code>for message in &amp;messages &#123;
    message.call();
&#125;
</code></pre>
<p>}</p>
<p>这种特性很好记忆,只需要把枚举值当成一种结构体的类型就好了.</p>
<p>7-3 这一题可能会有点难,我们需要根据我们已经写好的枚举类型特出特定的匹配执行特定的操作,匹配的格式是match 表达式{},{}里面是 表达式 &#x3D;&gt; 做什么、返回什么</p>
<p>&#x2F;&#x2F; enums3.rs<br>&#x2F;&#x2F; Address all the TODOs to make the tests pass!<br>&#x2F;&#x2F; Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>enum Message {<br>    Move(Point),<br>    Echo(String),<br>    ChangeColor((u8,u8,u8)),<br>    Quit,<br>}</p>
<p>struct Point {<br>    x: u8,<br>    y: u8,<br>}</p>
<p>struct State {<br>    color: (u8, u8, u8),<br>    position: Point,<br>    quit: bool,<br>}</p>
<p>impl State {<br>    fn change_color(&amp;mut self, color: (u8, u8, u8)) {<br>        self.color &#x3D; color;<br>    }</p>
<pre><code>fn quit(&amp;mut self) &#123;
    self.quit = true;
&#125;

fn echo(&amp;self, s: String) &#123;
    println!(&quot;&#123;&#125;&quot;, s);
&#125;

fn move\_position(&amp;mut self, p: Point) &#123;
    self.position = p;
&#125;

fn process(&amp;mut self, message: Message) &#123;
    match message&#123;
        Message::Move(point) =&gt; &#123;
            State::move\_position(self,point);
        &#125;,
        Message::Quit =&gt; &#123;
            State::quit(self);
        &#125;,
        Message::ChangeColor(color) =&gt; &#123;
            State::change\_color(self,color);
        &#125;
        Message::Echo(mes) =&gt; &#123;
            State::echo(self,mes);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn test\_match\_message\_call() &#123;
    let mut state = State &#123;
        quit: false,
        position: Point &#123; x: 0, y: 0 &#125;,
        color: (0, 0, 0),
    &#125;;
    state.process(Message::ChangeColor((255, 0, 255)));
    state.process(Message::Echo(String::from(&quot;hello world&quot;)));
    state.process(Message::Move(Point &#123; x: 10, y: 15 &#125;));
    state.process(Message::Quit);

    assert\_eq!(state.color, (255, 0, 255));
    assert\_eq!(state.position.x, 10);
    assert\_eq!(state.position.y, 15);
    assert\_eq!(state.quit, true);
&#125;
</code></pre>
<p>}</p>
<p>注意有一点,再引用枚举类型的时候别忘记加::来规定,Message::Move和Move是不一样的,别忘了加Message::Move.</p>
<p>8-1</p>
<p>这一题需要我们把这个模块里面的某个函数隐藏起来</p>
<p>mod sausage_factory {<br>    &#x2F;&#x2F; Don’t let anybody outside of this module see this!<br>    fn get_secret_recipe() -&gt; String {<br>        String::from(“Ginger”)<br>    }</p>
<pre><code>fn make\_sausage() &#123;
    get\_secret\_recipe();
    println!(&quot;sausage!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>fn main() {<br>    sausage_factory::make_sausage();<br>}</p>
<p>其实这个很简单,因为在一个模块中,模块里面的任何一个元素都是隐藏的,或者说私有的,在前面加上一个pub就是.</p>
<p>8-2</p>
<p>这一题需要我们使用use来将一些模块添加到我们的“相对变量环境”中,如同Linux的PATH一样.</p>
<p>还需要我们了解as的用法.</p>
<p>mod delicious_snacks {<br>    &#x2F;&#x2F; TODO: Fix these use statements<br>    pub use self::fruits::PEAR as fruit;<br>    pub use self::veggies::CUCUMBER as veggie;</p>
<pre><code>mod fruits &#123;
    pub const PEAR: &amp;&#39;static str = &quot;Pear&quot;;
    pub const APPLE: &amp;&#39;static str = &quot;Apple&quot;;
&#125;

mod veggies &#123;
    pub const CUCUMBER: &amp;&#39;static str = &quot;Cucumber&quot;;
    pub const CARROT: &amp;&#39;static str = &quot;Carrot&quot;;
&#125;
</code></pre>
<p>}</p>
<p>当然,还有一点就是,如果use前面加了个pub,就是说所有的模块都能使用这个use的结果,如果没加pub,代表仅限delicious_snacks这个模块能使用这个use的结果.</p>
<p>8-3</p>
<p>这一题需要我们use std里面的库,这里我使用glob运算混过去了</p>
<p>&#x2F;&#x2F; TODO: Complete this use statement<br>use std::time::*;</p>
<p>fn main() {<br>    match SystemTime::now().duration_since(UNIX_EPOCH) {<br>        Ok(n) &#x3D;&gt; println!(“1970-01-01 00:00:00 UTC was {} seconds ago!”, n.as_secs()),<br>        Err(_) &#x3D;&gt; panic!(“SystemTime before UNIX EPOCH!”),<br>    }<br>}</p>
<p>9-1</p>
<p>用vec宏声明一个新的Vector.这道题负责了解Vec!和直接声明的区别.</p>
<p>fn array_and_vec() -&gt; ([i32; 4], Vec<i32>) {<br>    let a &#x3D; [10, 20, 30, 40]; &#x2F;&#x2F; a plain array<br>    let v &#x3D; vec!(10,20,30,40);<br>    (a, v)<br>}</p>
<p>用直接声明是一个[i32,n]的类型,用vec!()宏可以声明一个Vec<T>类型的变量.</p>
<p>9-2</p>
<p>这一题需要我们把Vec里面的所有元素*2.</p>
<p>我们有两种版本,一个是使用迭代器,依次迭代解引用更改即可.还可以使用map方法对里面的元素统一使用一个函数进行更改</p>
<p>fn vec_loop(mut v: Vec<i32>) -&gt; Vec<i32> {<br>    for i in v.iter_mut() {<br>        *i &#x3D; *i * 2;<br>    }<br>    &#x2F;&#x2F; At this point, `v` should be equal to [4, 8, 12, 16, 20].<br>    v<br>}</p>
<p>fn vec_map(v: &amp;Vec<i32>) -&gt; Vec<i32> {<br>    v.iter().map(num {<br>        &#x2F;&#x2F; TODO: Do the same thing as above - but instead of mutating the<br>        &#x2F;&#x2F; Vec, you can just return the new number!<br>         num * 2<br>    }).collect()<br>}</p>
<p>10-1</p>
<p>改错</p>
<p>&#x2F;&#x2F; strings1.rs<br>&#x2F;&#x2F; Make me compile without changing the function signature!<br>&#x2F;&#x2F; Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>fn main() {<br>    let answer &#x3D; current_favorite_color();<br>    println!(“My current favorite color is {}”, answer);<br>}</p>
<p>fn current_favorite_color() -&gt; String {<br>    “blue”<br>}</p>
<p>“blue”不是String类型的,它是一个常量字符串,两种改法:改成let赋值模式、或者改成返回&amp;‘static 类型就好.</p>
<p>10-2</p>
<p>改错,也是一样的,传进来的是一个String类型的元素,但是函数的签名却是&amp;str</p>
<p>&#x2F;&#x2F; strings2.rs<br>&#x2F;&#x2F; Make me compile without changing the function signature!<br>&#x2F;&#x2F; Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.</p>
<p>fn main() {<br>    let word &#x3D; String::from(“green”); &#x2F;&#x2F; Try not changing this line :)<br>    if is_a_color_word(word) {<br>        println!(“That is a color word I know!”);<br>    } else {<br>        println!(“That is not a color word I know.”);<br>    }<br>}</p>
<p>fn is_a_color_word(attempt: &amp;str) -&gt; bool {<br>    attempt &#x3D;&#x3D; “green”  attempt &#x3D;&#x3D; “blue”  attempt &#x3D;&#x3D; “red”<br>}</p>
<p>所以说把函数签名的&amp;str改成string就好.</p>
<p>10-3</p>
<p>写3个很简单的小函数.</p>
<p>一个是在后面加一个world,就是使用push_str函数在后面加上即可.</p>
<p>一个是去掉前面和后面的空格.就把每个单词分开来,然后组装在一起.</p>
<p>一个是把所有的cars换成balloons,也是把每个单词分开来,加一个判断而已.</p>
<p>fn trim_me(input: &amp;str) -&gt; String {<br>    &#x2F;&#x2F; TODO: Remove whitespace from both ends of a string!<br>    let s &#x3D; input.to_string();<br>    let mut ne &#x3D; String::new();<br>    for word in s.split_whitespace(){<br>        ne.push_str(word);<br>        ne.push_str(“ “);<br>    }<br>    ne.pop();<br>    ne<br>}</p>
<p>fn compose_me(input: &amp;str) -&gt; String {<br>    &#x2F;&#x2F; TODO: Add “ world!” to the string! There’s multiple ways to do this!<br>    let mut s &#x3D; input.to_string();<br>    s.push_str(“ world!”);<br>    s<br>}</p>
<p>fn replace_me(input: &amp;str) -&gt; String {<br>    &#x2F;&#x2F; TODO: Replace “cars” in the string with “balloons”!<br>    let s &#x3D; input.to_string();<br>    let mut ne &#x3D; String::new();<br>    for word in s.split_whitespace(){<br>        if word &#x3D;&#x3D; “cars”{<br>            ne.push_str(“balloons”);<br>        }<br>        else{<br>            ne.push_str(word);<br>        }<br>        ne.push_str(“ “);<br>    }<br>    ne.pop();<br>    ne<br>}</p>
<p>10-4</p>
<p>判断是String还是&amp;str的?</p>
<p>fn string_slice(arg: &amp;str) {<br>    println!(“{}”, arg);<br>}<br>fn string(arg: String) {<br>    println!(“{}”, arg);<br>}</p>
<p>fn main() {<br>    ???(“blue”);<br>    ???(“red”.to_string());<br>    ???(String::from(“hi”));<br>    ???(“rust is fun!”.to_owned());<br>    ???(“nice weather”.into());<br>    ???(format!(“Interpolation {}”, “Station”));<br>    ???(&amp;String::from(“abc”)[0..1]);<br>    ???(“  hello there “.trim());<br>    ???(“Happy Monday!”.to_string().replace(“Mon”, “Tues”));<br>    ???(“mY sHiFt KeY iS sTiCkY”.to_lowercase());<br>}</p>
<p>答案就是这个:</p>
<p>fn main() {<br>    string_slice(“blue”);<br>    string(“red”.to_string());<br>    string(String::from(“hi”));<br>    string(“rust is fun!”.to_owned());<br>    string(“nice weather”.into());<br>    string(format!(“Interpolation {}”, “Station”));<br>    string_slice(&amp;String::from(“abc”)[0..1]);<br>    string_slice(“  hello there “.trim());<br>    string(“Happy Monday!”.to_string().replace(“Mon”, “Tues”));<br>    string(“mY sHiFt KeY iS sTiCkY”.to_lowercase());<br>}</p>
<p>11-1</p>
<p>这一题需要我们声明一个空的HashMap,然后插入若干个key-value对.插入就调用insert就好了.</p>
<p>use std::collections::HashMap;</p>
<p>fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {<br>    let mut basket &#x3D; HashMap::new();&#x2F;&#x2F; TODO: declare your hash map here.</p>
<pre><code>// Two bananas are already given for you :)
// TODO: Put more fruits in your basket here.
basket.insert(String::from(&quot;banana&quot;), 2);
basket.insert(String::from(&quot;Apple&quot;), 2);
basket.insert(String::from(&quot;Orange&quot;), 2);

basket
</code></pre>
<p>}</p>
<p>11-2</p>
<p>这一题需要我们完成哈希表的判断插入,当这个表没有这个元素的时候才进行插入操作,在书本上说过可以用enrty和or_insert进行插入</p>
<p>fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {<br>    let fruit_kinds &#x3D; vec![<br>        Fruit::Apple,<br>        Fruit::Banana,<br>        Fruit::Mango,<br>        Fruit::Lychee,<br>        Fruit::Pineapple,<br>    ];</p>
<pre><code>for fruit in fruit\_kinds &#123;
    // TODO: Put new fruits if not already present. Note that you
    // are not allowed to put any type of fruit that&#39;s already
    // present!
    let k = basket.entry(fruit).or\_insert(1);
&#125;
</code></pre>
<p>}</p>
<p>11-3</p>
<p>这一题需要我们统计一个球队输球和赢球的数量,需要用到or_insert,用到or_insert的返回值,这个返回值是一个引用,可以改变value的值.</p>
<p>use std::collections::HashMap;</p>
<p>&#x2F;&#x2F; A structure to store team name and its goal details.<br>struct Team {<br>    name: String,<br>    goals_scored: u8,<br>    goals_conceded: u8,<br>}</p>
<p>fn build_scores_table(results: String) -&gt; HashMap&lt;String, Team&gt; {<br>    &#x2F;&#x2F; The name of the team is the key and its associated struct is the value.<br>    let mut scores: HashMap&lt;String, Team&gt; &#x3D; HashMap::new();</p>
<pre><code>for r in results.lines() &#123;
    let v: Vec&lt;&amp;str&gt; = r.split(&#39;,&#39;).collect();
    let team\_1\_name = v\[0\].to\_string();
    let team\_1\_score: u8 = v\[2\].parse().unwrap();
    let team\_2\_name = v\[1\].to\_string();
    let team\_2\_score: u8 = v\[3\].parse().unwrap();
    // TODO: Populate the scores table with details extracted from the
    // current line. Keep in mind that goals scored by team\_1
    // will be number of goals conceded from team\_2, and similarly
    // goals scored by team\_2 will be the number of goals conceded by
    let g = scores.entry(team\_1\_name.to\_string()).or\_insert(Team&#123;name:team\_1\_name,goals\_scored:0,goals\_conceded:0&#125;);
    (\*g).goals\_scored = (\*g).goals\_scored + team\_1\_score;
    (\*g).goals\_conceded = (\*g).goals\_conceded + team\_2\_score;
    let f = scores.entry(team\_2\_name.to\_string()).or\_insert(Team&#123;name:team\_2\_name,goals\_scored:0,goals\_conceded:0&#125;);
    (\*f).goals\_scored = (\*f).goals\_scored + team\_2\_score;
    (\*f).goals\_conceded = (\*f).goals\_conceded + team\_1\_score;
&#125;
scores
</code></pre>
<p>}</p>
<p>12-1</p>
<p>这一题单纯用来了解Result的特征,Result&lt;T,E&gt;是一个枚举类型,其中Ok的类型是T,Err的类型是E,如果一个函数会返回Result在不同情况下会返回Ok或者Err两种元素.</p>
<p>这一题的T和E都是字符串,负责传回一个字符串.</p>
<p>pub fn generate_nametag_text(name: String) -&gt; Result&lt;String,String&gt; {<br>    if name.is_empty() {<br>        &#x2F;&#x2F; Empty names aren’t allowed.<br>        Err(“`name` was empty; it must be nonempty.”.into())<br>    } else {<br>        Ok(format!(“Hi! My name is {}”, name))<br>    }<br>}</p>
<p>12-2</p>
<p>这一题我们需要了解最基本的错误的处理方式,第一种处理方式就是match一个Result值,Result值有两种枚举的可能,一个是Ok(T),一个是Err(E),分步处理即可.如果是Err就要直接返回.</p>
<p>use std::num::ParseIntError;</p>
<p>pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {<br>    let processing_fee &#x3D; 1;<br>    let cost_per_item &#x3D; 5;<br>    let qty &#x3D; match item_quantity.parse::<i32>(){<br>        Ok(T) &#x3D;&gt; T,<br>        Err(E) &#x3D;&gt; {<br>            return Err(E);<br>        },<br>    };</p>
<pre><code>Ok(qty \* cost\_per\_item + processing\_fee)
</code></pre>
<p>}</p>
<p>12-3</p>
<p>这一题主要是了解Result的?用法.</p>
<p>如果加上了?这个符号在一个可以返回Result&lt;T,E&gt;的函数调用后面,这个符号可以完成这个任务:</p>
<p>如果是Ok,这个表达式的值就是Ok的值,如果是Err,就会自动向上面传递问题.</p>
<p>use std::num::ParseIntError;</p>
<p>fn main() {<br>    let mut tokens &#x3D; 100;<br>    let pretend_user_input &#x3D; “8”;</p>
<pre><code>let cost = total\_cost(pretend\_user\_input)?;

if cost &gt; tokens &#123;
    println!(&quot;You can&#39;t afford that many!&quot;);
&#125; else &#123;
    tokens -= cost;
    println!(&quot;You now have &#123;&#125; tokens.&quot;, tokens);
&#125;
</code></pre>
<p>}</p>
<p>pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {<br>    let processing_fee &#x3D; 1;<br>    let cost_per_item &#x3D; 5;<br>    let qty &#x3D; item_quantity.parse::<i32>()?;</p>
<pre><code>Ok(qty \* cost\_per\_item + processing\_fee)
</code></pre>
<p>}</p>
<p>这个代码里面就是有一个?,<code>item_quantity.parse::&lt;i32&gt;()?</code>没问题就返回这个i32,如果有问题就向上面抛出异常.</p>
<p>上层需要处理这个异常.一种改法是让main也返回Result类型,还有一种就是把?去掉加上match函数进行处理.</p>
<pre><code>let cost = match total\_cost(pretend\_user\_input)&#123;
    Ok(a) =&gt; a,
    Err(E) =&gt; &#123;
        panic!(&quot;G&quot;);
    &#125;
&#125;;
</code></pre>
<p>12-4</p>
<p>这一题和上一题一样,教我们怎么返回Ok或者抛出异常.</p>
<p>impl PositiveNonzeroInteger {<br>    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {<br>        &#x2F;&#x2F; Hmm…? Why is this only returning an Ok value?<br>        if value &gt; 0{<br>            Ok(PositiveNonzeroInteger(value as u64))<br>        }<br>        else if value &#x3D;&#x3D; 0{<br>            Err(CreationError::Zero)<br>        }<br>        else{<br>            Err(CreationError::Negative)<br>        }<br>    }<br>}</p>
<p>12-5</p>
<p>main函数能返回Result类型:</p>
<p>将???改为error::Error,指动态匹配错误的类型.完成了fmt::Display就是error::Error类型了!</p>
<p>use std::error;<br>use std::fmt;<br>use std::num::ParseIntError;</p>
<p>&#x2F;&#x2F; TODO: update the return type of `main()` to make this compile.<br>fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {<br>    let pretend_user_input &#x3D; “42”;<br>    let x: i64 &#x3D; pretend_user_input.parse()?;<br>    println!(“output&#x3D;{:?}”, PositiveNonzeroInteger::new(x)?);<br>    Ok(())<br>}</p>
<p>&#x2F;&#x2F; Don’t change anything below this line.</p>
<p>#[derive(PartialEq, Debug)]<br>struct PositiveNonzeroInteger(u64);</p>
<p>#[derive(PartialEq, Debug)]<br>enum CreationError {<br>    Negative,<br>    Zero,<br>}</p>
<p>impl PositiveNonzeroInteger {<br>    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {<br>        match value {<br>            x if x &lt; 0 &#x3D;&gt; Err(CreationError::Negative),<br>            x if x &#x3D;&#x3D; 0 &#x3D;&gt; Err(CreationError::Zero),<br>            x &#x3D;&gt; Ok(PositiveNonzeroInteger(x as u64))<br>        }<br>    }<br>}</p>
<p>&#x2F;&#x2F; This is required so that `CreationError` can implement `error::Error`.<br>impl fmt::Display for CreationError {<br>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br>        let description &#x3D; match *self {<br>            CreationError::Negative &#x3D;&gt; “number is negative”,<br>            CreationError::Zero &#x3D;&gt; “number is zero”,<br>        };<br>        f.write_str(description)<br>    }<br>}</p>
<p>impl error::Error for CreationError {}</p>
<p>12-6</p>
<p>这一个就是在Err(E)中加了点手脚,就是Err(E)中E的类型也是一个Err类型.</p>
<p>这里是创建了一个新的Err类型,Err类型中有两种不同的枚举值.对于不同的枚举值代表两种不同的错误.</p>
<p>use std::num::ParseIntError;</p>
<p>&#x2F;&#x2F; This is a custom error type that we will be using in `parse_pos_nonzero()`.<br>#[derive(PartialEq, Debug)]<br>enum ParsePosNonzeroError {<br>    Creation(CreationError),<br>    ParseInt(ParseIntError)<br>}</p>
<p>上面就是错误的迭代,或者说嵌套…弄清楚错误是可以嵌套的,这道题就很好写了.</p>
<p>impl ParsePosNonzeroError {<br>    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {<br>        ParsePosNonzeroError::Creation(err)<br>    }<br>    fn from_parseint(err: ParseIntError) -&gt; ParsePosNonzeroError{<br>        ParsePosNonzeroError::ParseInt(err)<br>    }<br>    &#x2F;&#x2F; TODO: add another error conversion function here.<br>    &#x2F;&#x2F; fn from_parseint…<br>}</p>
<p>fn parse_pos_nonzero(s: &amp;str)<br>    -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt;<br>{<br>    &#x2F;&#x2F; TODO: change this to return an appropriate error instead of panicking<br>    &#x2F;&#x2F; when `parse()` returns an error.<br>    let x: i64 &#x3D; match s.parse(){<br>        Ok(T) &#x3D;&gt; T,<br>        Err(E) &#x3D;&gt; {<br>            return Err(ParsePosNonzeroError::from_parseint(E));<br>        },<br>    };<br>    PositiveNonzeroInteger::new(x)<br>        .map_err(ParsePosNonzeroError::from_creation)<br>}</p>
<p>13-1</p>
<p>返回一个Option枚举值,如果时间小于24,就返回Option<i32>,如果大于24,就是不对的值,要返回None.这一题教我们如何返回Option类型的值</p>
<p>fn maybe_icecream(time_of_day: u16) -&gt; Option<u16> {<br>    &#x2F;&#x2F; We use the 24-hour system here, so 10PM is a value of 22<br>    &#x2F;&#x2F; The Option output should gracefully handle cases where time_of_day &gt; 24.<br>    if time_of_day &gt; 24{<br>        None<br>    }<br>    else if time_of_day &gt; 12{<br>        Some(0)<br>    }<br>    else{<br>        Some(5)<br>    }<br>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn check\_icecream() &#123;
    assert\_eq!(maybe\_icecream(9), Some(5));
    assert\_eq!(maybe\_icecream(10), Some(5));
    assert\_eq!(maybe\_icecream(23), Some(0));
    assert\_eq!(maybe\_icecream(22), Some(0));
    assert\_eq!(maybe\_icecream(25), None);
&#125;

#\[test\]
fn raw\_value() &#123;
    // TODO: Fix this test. How do you get at the value contained in the Option?
    let icecreams = maybe\_icecream(12);
    assert\_eq!(icecreams, Some(5));
&#125;
</code></pre>
<p>}</p>
<p>13-2</p>
<p>这一题需要我们了解if-let和while-let的用法,if-let和while-let的核心用法就是匹配.</p>
<p>if let Some(i) &#x3D; 一个Option<T>值,当匹配的时候,产生一个新的变量i并且执行下面的操作.while-let也是如此</p>
<p>核心的思想就是Some(i) &#x3D; 一个Option值,然后这样可以巧妙地提取Option的内容并且避免冗杂的match表达式</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn simple\_option() &#123;
    let target = &quot;rustlings&quot;;
    let optional\_target = Some(target);

    // TODO: Make this an if let statement whose value is &quot;Some&quot; type
    if let Some(word) = optional\_target&#123;
        assert\_eq!(word, target);
    &#125;
&#125;

#\[test\]
fn layered\_option() &#123;
    let mut range = 10;
    let mut optional\_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();
    for i in 0..(range + 1) &#123;
        optional\_integers.push(Some(i));
    &#125;

    // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;
    // You can stack \`Option&lt;T&gt;\`&#39;s into while let and if let

    while let Some(Some(integer)) = optional\_integers.pop() &#123;
        assert\_eq!(integer, range);
        range -= 1;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>13-3</p>
<p>struct Point {<br>    x: i32,<br>    y: i32,<br>}</p>
<p>fn main() {<br>    let y: Option<Point> &#x3D; Some(Point { x: 100, y: 200 });</p>
<pre><code>match y &#123;
    Some(ref p) =&gt; println!(&quot;Co-ordinates are &#123;&#125;,&#123;&#125; &quot;, p.x, p.y),
    \_ =&gt; println!(&quot;no match&quot;),
&#125;
y; // Fix without deleting this line.
</code></pre>
<p>}</p>
<p>再取Option里面的结构体的时候,我们需要知道,结构体在option里面,所有权是归Option值的,后面又访问了一次Option值,所以说y还没有放弃所有权,只能通过引用去访问.(y没有放弃所有权,里面的结构体也是属于y的,y&#x3D; Some(p)来取数据是不对的)</p>
<p>14-1</p>
<p>Vec是一个带有泛型(参数是类型)类型的结构,我们声明的时候需要添加泛型参数.</p>
<p>fn main() {<br>    let mut shopping_list: Vec&lt;?&gt; &#x3D; Vec::new();<br>    shopping_list.push(“milk”);<br>}</p>
<p>?替换成String就好,因为需要声明为Vec<String>,因为Vec<String>是类型但是Vec&lt;&gt;不是类型.</p>
<p>14-2</p>
<p>将这个代码改成泛型,记住函数、结构体、impl块的泛型类型</p>
<p>struct Wrapper<T> {<br>    value: T,<br>}</p>
<p>impl<T> Wrapper<T> {<br>    pub fn new(value: T) -&gt; Self {<br>        Wrapper { value }<br>    }<br>}</p>
<p>15-1</p>
<p>完成代码,完成AppendBar这个trait,注意trait块里面的接口的返回值有可能是Self类型的,代表和本身是一个类型的.</p>
<p>trait AppendBar {<br>    fn append_bar(self) -&gt; Self;<br>}</p>
<p>impl AppendBar for String {<br>    &#x2F;&#x2F;Add your code here<br>    fn append_bar(mut self) -&gt; String{<br>        self.push_str(“Bar”);<br>        self<br>    }<br>}</p>
<p>fn main() {<br>    let s &#x3D; String::from(“Foo”);<br>    let s &#x3D; s.append_bar();<br>    println!(“s: {}”, s);<br>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn is\_foo\_bar() &#123;
    assert\_eq!(String::from(&quot;Foo&quot;).append\_bar(), String::from(&quot;FooBar&quot;));
&#125;

#\[test\]
fn is\_bar\_bar() &#123;
    assert\_eq!(
        String::from(&quot;&quot;).append\_bar().append\_bar(),
        String::from(&quot;BarBar&quot;)
    );
&#125;
</code></pre>
<p>}</p>
<p>15-2</p>
<p>trait AppendBar {<br>    fn append_bar(self) -&gt; Self;<br>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn is\_vec\_pop\_eq\_bar() &#123;
    let mut foo = vec!\[String::from(&quot;Foo&quot;)\].append\_bar();
    assert\_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));
    assert\_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));
&#125;
</code></pre>
<p>}</p>
<p>从题目中我们可以知道是要给Vec<String>实现AppendBar这个trait,语法和上面一样</p>
<p>impl AppendBar for Vec<String>{<br>    fn append_bar(mut self) -&gt; Vec<String>{<br>        self.push(“Bar”.to_string());<br>        self<br>    }<br>}</p>
<p>15-3</p>
<p>这一题需要我们修改trait里面方法的默认实现模式</p>
<p>改成这样:</p>
<p>pub trait Licensed {<br>pub trait Licensed {<br>    fn licensing_info(&amp;self) -&gt; String{<br>        “Some information”.to_string()<br>    }<br>}</p>
<p>struct SomeSoftware {<br>    version_number: i32,<br>}</p>
<p>struct OtherSoftware {<br>    version_number: String,<br>}</p>
<p>impl Licensed for SomeSoftware {} &#x2F;&#x2F; Don’t edit this line<br>impl Licensed for OtherSoftware {} &#x2F;&#x2F; Don’t edit this line</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn is\_licensing\_info\_the\_same() &#123;
    let licensing\_info = String::from(&quot;Some information&quot;);
    let some\_software = SomeSoftware &#123; version\_number: 1 &#125;;
    let other\_software = OtherSoftware &#123;
        version\_number: &quot;v2.0.0&quot;.to\_string(),
    &#125;;
    assert\_eq!(some\_software.licensing\_info(), licensing\_info);
    assert\_eq!(other\_software.licensing\_info(), licensing\_info);
&#125;
</code></pre>
<p>}</p>
<p>15-4</p>
<p>这里需要我们用trait和泛型配合,使得函数的传参只能传已经实现某种trait的结构体</p>
<p>pub trait Licensed {<br>    fn licensing_info(&amp;self) -&gt; String {<br>        “some information”.to_string()<br>    }<br>}</p>
<p>struct SomeSoftware {}</p>
<p>struct OtherSoftware {}</p>
<p>impl Licensed for SomeSoftware {}<br>impl Licensed for OtherSoftware {}</p>
<p>&#x2F;&#x2F; YOU MAY ONLY CHANGE THE NEXT LINE<br>fn compare_license_types(software: ??, software_two: ??) -&gt; bool {<br>    software.licensing_info() &#x3D;&#x3D; software_two.licensing_info()<br>}</p>
<p>#[cfg(test)]<br>mod tests {<br>    use super::*;</p>
<pre><code>#\[test\]
fn compare\_license\_information() &#123;
    let some\_software = SomeSoftware &#123;&#125;;
    let other\_software = OtherSoftware &#123;&#125;;

    assert!(compare\_license\_types(some\_software, other\_software));
&#125;

#\[test\]
fn compare\_license\_information\_backwards() &#123;
    let some\_software = SomeSoftware &#123;&#125;;
    let other\_software = OtherSoftware &#123;&#125;;

    assert!(compare\_license\_types(other\_software, some\_software));
&#125;
</code></pre>
<p>}</p>
<p>把函数签名改成<code>fn compare_license_types&lt;T : Licensed,E : Licensed&gt;(software: T, software_two: E) -&gt; bool</code>就好</p>
<p>15-5</p>
<p>这里需要我们再15-4的基础上再进一步,函数的传参只能传已经实现多种trait的结构体.</p>
<p>&#x2F;&#x2F; traits5.rs<br>&#x2F;&#x2F;<br>&#x2F;&#x2F; Your task is to replace the ‘??’ sections so the code compiles.<br>&#x2F;&#x2F; Don’t change any line other than the marked one.<br>&#x2F;&#x2F; Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.</p>
<p>&#x2F;&#x2F; I AM NOT DONE</p>
<p>pub trait SomeTrait {<br>    fn some_function(&amp;self) -&gt; bool {<br>        true<br>    }<br>}</p>
<p>pub trait OtherTrait {<br>    fn other_function(&amp;self) -&gt; bool {<br>        true<br>    }<br>}</p>
<p>struct SomeStruct {}<br>struct OtherStruct {}</p>
<p>impl SomeTrait for SomeStruct {}<br>impl OtherTrait for SomeStruct {}<br>impl SomeTrait for OtherStruct {}<br>impl OtherTrait for OtherStruct {}</p>
<p>&#x2F;&#x2F; YOU MAY ONLY CHANGE THE NEXT LINE<br>fn some_func(item: ??) -&gt; bool {<br>    item.some_function() &amp;&amp; item.other_function()<br>}</p>
<p>fn main() {<br>    some_func(SomeStruct {});<br>    some_func(OtherStruct {});<br>}</p>
<p>改成这样就好</p>
<p>16-1</p>
<p>assert!(表达式),如果表达式为true还好,表达式为false就panic</p>
<p>#[cfg(test)]<br>mod tests {<br>    #[test]<br>    fn you_can_assert() {<br>        assert!(1 &lt; 2);<br>    }<br>}</p>
<p>16-2</p>
<p>asserteq!(A,B),A&#x3D;B是没事,反之panic</p>
<p>#[cfg(test)]<br>mod tests {<br>    #[test]<br>    fn you_can_assert_eq() {<br>        assert_eq!(1,1);<br>    }<br>}</p>
<p>16-3</p>
<p>自己编写test,挺简单的.</p>
<p>17-1</p>
<p>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {<br>    if x.len() &gt; y.len() {<br>        x<br>    } else {<br>        y<br>    }<br>}</p>
<p>fn main() {<br>    let string1 &#x3D; String::from(“abcd”);<br>    let string2 &#x3D; “xyz”;</p>
<pre><code>let result = longest(string1.as\_str(), string2);
println!(&quot;The longest string is &#39;&#123;&#125;&#39;&quot;, result);
</code></pre>
<p>}</p>
<p>书本里的例子,作为函数要去判断传参和返回的引用符不符合生命周期的标准,也就是说传参的生命周期要和返回的生命周期匹配并且满足可以省略的要求,如果不满足可以省略的要求就需要标注生命周期标注</p>
<p>不满足隐藏的条件显示声明生命周期,统一成一样的.即<code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str</code></p>
<p>17-2</p>
<p>基于17-1,因为’a作为生命周期泛型,匹配传参中生命周期最短的生命周期,然后把这个生命周期返回出去,但是返回出去的生命周期不能支撑result.</p>
<p>fn main() {<br>    let string1 &#x3D; String::from(“long string is long”);<br>    let result;<br>    {<br>        let string2 &#x3D; String::from(“xyz”);<br>        result &#x3D; longest(string1.as_str(), string2.as_str());<br>    }<br>    println!(“The longest string is ‘{}’”, result);<br>}</p>
<p>改成这样:</p>
<p>fn main() {<br>    let string1 &#x3D; String::from(“long string is long”);<br>    {<br>        let string2 &#x3D; String::from(“xyz”);<br>        let result &#x3D; longest(string1.as_str(), string2.as_str());<br>        println!(“The longest string is ‘{}’”, result);<br>    }<br>}</p>
<p>17-3</p>
<p>结构体里面有引用,则需要保证结构体里面引用成员的生命周期要比结构体长.</p>
<p>所以说要配一个泛型参数,指定结构体的生命周期是所有引用成员里面最小的那个即可.这就是泛型参数的作用</p>
<p>struct Book {<br>    author: &amp;str,<br>    title: &amp;str,<br>}</p>
<p>fn main() {<br>    let name &#x3D; String::from(“Jill Smith”);<br>    let title &#x3D; String::from(“Fish Flying”);<br>    let book &#x3D; Book { author: &amp;name, title: &amp;title };</p>
<pre><code>println!(&quot;&#123;&#125; by &#123;&#125;&quot;, book.title, book.author);
</code></pre>
<p>}</p>
<p>生命周期是需要在类型后面加上’xxx的,注意一下’xxx的语法</p>
<p>struct Book&lt;’a&gt; {<br>    author: &amp;’a str,<br>    title: &amp;’a str,<br>}</p>
<p>fn main() {<br>    let name &#x3D; String::from(“Jill Smith”);<br>    let title &#x3D; String::from(“Fish Flying”);<br>    let book &#x3D; Book { author: &amp;name, title: &amp;title };</p>
<pre><code>println!(&quot;&#123;&#125; by &#123;&#125;&quot;, book.title, book.author);
</code></pre>
<p>}</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/project/">首页</a></li>
        
          <li><a href="/project/about/">关于</a></li>
        
          <li><a href="/project/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li>
        
      </ul>
    </div>

    
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&text=Rustilings 练习笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&is_video=false&description=Rustilings 练习笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Rustilings 练习笔记&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=Rustilings 练习笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&name=Rustilings 练习笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/project/2023/02/06/rustilings-%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/&t=Rustilings 练习笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    Sukuna
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/project/">首页</a></li><!--
     --><!--
       --><li><a href="/project/about/">关于</a></li><!--
     --><!--
       --><li><a href="/project/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/project/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
