<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Lab0.Warm Up1 Networking by hand这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.  Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequenc">
<meta property="og:type" content="article">
<meta property="og:title" content="Stanford CS144 Lab">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="Lab0.Warm Up1 Networking by hand这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.  Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequenc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-11.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-13-1024x445.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-14-1024x169.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-15-1024x135.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-16.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-17.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-18.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-20.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-21-812x1024.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-34-1024x579.png">
<meta property="og:image" content="http://tvax3.sinaimg.cn/large/007SD2TBly1gwtr4gx6o9j30hp05i0t4.jpg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-35-1024x948.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/04/6276FFC4517759B3003BA598E201AAC8-868x1024.jpg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/04/image-1-1024x469.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/05/047BB194343B645BC5E8BD8F479ABD03-1024x678.jpg">
<meta property="article:published_time" content="2023-02-06T02:50:55.000Z">
<meta property="article:modified_time" content="2024-02-27T05:01:50.135Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-11.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-192x192.png">
        
      
    
    <!-- title -->
    <title>Stanford CS144 Lab</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/02/06/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/02/06/cmu14-445-lab/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&text=Stanford CS144 Lab"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&is_video=false&description=Stanford CS144 Lab"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Stanford CS144 Lab&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&name=Stanford CS144 Lab&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&t=Stanford CS144 Lab"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab0-Warm-Up"><span class="toc-number">1.</span> <span class="toc-text">Lab0.Warm Up</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Networking-by-hand"><span class="toc-number"></span> <span class="toc-text">1 Networking by hand</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5"><span class="toc-number">1.</span> <span class="toc-text">1.1 获取一个网页.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5http-cs144-keithw-org-hello"><span class="toc-number">1.0.1.</span> <span class="toc-text">1)首先用浏览器打开网页http:&#x2F;&#x2F;cs144.keithw.org&#x2F;hello.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%A8telnet%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5-%E8%BE%93%E5%85%A5telnet-cs144-keithw-org-http"><span class="toc-number">1.0.2.</span> <span class="toc-text">2) 用telnet进行连接,输入telnet cs144.keithw.org http</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5GET-hello-HTTP-1-1"><span class="toc-number">1.0.3.</span> <span class="toc-text">3)输入GET &#x2F;hello HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%BE%93%E5%85%A5-Host-cs144-keithw-org"><span class="toc-number">1.0.4.</span> <span class="toc-text">4) 输入 Host: cs144.keithw.org</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%8E%B7%E5%BE%97sunsetid"><span class="toc-number">1.0.5.</span> <span class="toc-text">5) 获得sunsetid</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.2 给自己发送邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%BF%99%E9%87%8C%E8%A6%81%E4%BD%BF%E7%94%A8SMTP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1) 首先连接到服务器,这里要使用SMTP协议进行连接.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%93%E6%8B%9B%E5%91%BC"><span class="toc-number">1.1.2.</span> <span class="toc-text">2) 给服务器打招呼</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%99%BB%E9%99%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">3) 登陆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%86%99%E9%82%AE%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">4) 写邮件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%9B%91%E5%90%AC%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.3 监听服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8netcat-v-l-p-9090%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">1) 使用netcat -v -l -p 9090创建一个监听端口.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BA%E5%88%9B%E5%BB%BA%E7%9A%84%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3-telnet-localhost-9090"><span class="toc-number">1.2.2.</span> <span class="toc-text">2) 连接本机创建的监听端口:telnet localhost 9090</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%88%B6Socket"><span class="toc-number">1.3.</span> <span class="toc-text">2 自制Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%8C%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">3 缓冲区队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab1-stitching-substrings-into-a-byte-stream"><span class="toc-number">2.</span> <span class="toc-text">Lab1.stitching substrings into a byte stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab2-TCP-Reciever"><span class="toc-number">3.</span> <span class="toc-text">Lab2.TCP Reciever</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%BA%8F%E5%8F%B7%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">绝对序号和相对序号的转换:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementing-the-TCP-receiver"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing the TCP receiver</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab3-TCP-Sender"><span class="toc-number">4.</span> <span class="toc-text">Lab3 TCP Sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab4-TCP-Connnection"><span class="toc-number">5.</span> <span class="toc-text">Lab4 TCP Connnection</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Stanford CS144 Lab
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Sukuna</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-02-06T02:50:55.000Z" class="dt-published" itemprop="datePublished">2023-02-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/">实验记录</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h3 id="Lab0-Warm-Up"><a href="#Lab0-Warm-Up" class="headerlink" title="Lab0.Warm Up"></a>Lab0.Warm Up</h3><h2 id="1-Networking-by-hand"><a href="#1-Networking-by-hand" class="headerlink" title="1 Networking by hand"></a>1 Networking by hand</h2><p>这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.</p>
<blockquote>
<p>Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequence of bytes into the terminal, and the same sequence of bytes will eventually be delivered, in the same order, to a program running on another computer (a server). The server responds with its own sequence of bytes, delivered back to your terminal.</p>
</blockquote>
<p>在实验资料中给出的是这么一段话,这句话的意思就是所有的应用层协议都是由底层支撑的,这个底层可以理解成可靠的二进制比特流的传输,一方应用程序会产生比特流投入到传输通道中,另一方的应用程序会从传输通道中获取到比特流信息.这个传输通道就是Socket,套接字.</p>
<h3 id="1-1-获取一个网页"><a href="#1-1-获取一个网页" class="headerlink" title="1.1 获取一个网页."></a>1.1 获取一个网页.</h3><p>我们跟随着实验的步骤来进行执行.</p>
<h5 id="1-首先用浏览器打开网页http-cs144-keithw-org-hello"><a href="#1-首先用浏览器打开网页http-cs144-keithw-org-hello" class="headerlink" title="1)首先用浏览器打开网页http://cs144.keithw.org/hello."></a>1)首先用浏览器打开网页<a target="_blank" rel="noopener" href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a>.</h5><p>发现内容就是简短的一行字 Hello,CS144.</p>
<h5 id="2-用telnet进行连接-输入telnet-cs144-keithw-org-http"><a href="#2-用telnet进行连接-输入telnet-cs144-keithw-org-http" class="headerlink" title="2) 用telnet进行连接,输入telnet cs144.keithw.org http"></a>2) 用telnet进行连接,输入telnet cs144.keithw.org http</h5><p>这一步的做法就是在你的电脑和另一台电脑(域名为cs144.keithw.org)进行一个套接字连接,(原文:<em>a reliable byte stream between your computer and anothercomputer</em>),这个时候你的电脑和cs144.keithw.org(获取这个域名的IP需要通过DNS服务器进行)就连接上了.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-11.png"></p>
<h5 id="3-输入GET-hello-HTTP-1-1"><a href="#3-输入GET-hello-HTTP-1-1" class="headerlink" title="3)输入GET &#x2F;hello HTTP&#x2F;1.1"></a>3)输入GET &#x2F;hello HTTP&#x2F;1.1</h5><p>这个是HTTP协议的应用,HTTP协议的命令有GET和POST两种,其中POST一般就是投放一个表单到服务器上,GET就是从服务器获取资源.其中资源的名称是可以指定的,uri就是指定资源, 一般uri的组成就是 服务器的域名+资源在服务器的根目录的对应的文件位置.比如说hust.edu.cn&#x2F;1.jpg,就是在hust.edu.cn这个服务器根目录下的1.jpg这个文件.</p>
<p>这个命令就是用HTTP&#x2F;1.1的方式获取服务器的资源</p>
<h5 id="4-输入-Host-cs144-keithw-org"><a href="#4-输入-Host-cs144-keithw-org" class="headerlink" title="4) 输入 Host: cs144.keithw.org"></a>4) 输入 Host: cs144.keithw.org</h5><p>这个指定host的地址,因为一个uri的构成就是域名+文件位置.</p>
<p>上面几个做法就是利用telnet软件制作一个HTTP请求报文.请求报文分成头部和请求本身</p>
<p>这个时候就会返回一个HTTP响应报文:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 03 Mar 2022 07:53:25 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT</span><br><span class="line">ETag: &quot;e-57ce93446cb64&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 14</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Hello, CS144!</span><br></pre></td></tr></table></figure>

<p>其中分成第一行,首部和报文内容,第一行表示使用的HTTP版本,状态码和短语,我们可以利用状态码和短语来判断服务器是否正常响应了我们的请求:</p>
<p>首部就蕴含了一些控制信息,比如说报文长度和报文类型等.最后的就是报文内容,就是主体部分.</p>
<h5 id="5-获得sunsetid"><a href="#5-获得sunsetid" class="headerlink" title="5) 获得sunsetid"></a>5) 获得sunsetid</h5><p>如法炮制:构造请求报文和响应报文即可.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-13-1024x445.png"></p>
<h4 id="1-2-给自己发送邮件"><a href="#1-2-给自己发送邮件" class="headerlink" title="1.2 给自己发送邮件"></a>1.2 给自己发送邮件</h4><h5 id="1-首先连接到服务器-这里要使用SMTP协议进行连接"><a href="#1-首先连接到服务器-这里要使用SMTP协议进行连接" class="headerlink" title="1) 首先连接到服务器,这里要使用SMTP协议进行连接."></a>1) 首先连接到服务器,这里要使用SMTP协议进行连接.</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-14-1024x169.png"></p>
<h5 id="2-给服务器打招呼"><a href="#2-给服务器打招呼" class="headerlink" title="2) 给服务器打招呼"></a>2) 给服务器打招呼</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-15-1024x135.png"></p>
<h5 id="3-登陆"><a href="#3-登陆" class="headerlink" title="3) 登陆"></a>3) 登陆</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-16.png"></p>
<p>注意这里是BASE64编码的,第一行语句表示Username:,就输入你的邮箱地址,第二行语句表示授权码,把授权码转化成BASE64编码的即可.</p>
<h5 id="4-写邮件"><a href="#4-写邮件" class="headerlink" title="4) 写邮件"></a>4) 写邮件</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-17.png"></p>
<p>MAIL 命令,发件人</p>
<p>RCPT 命令,收件人</p>
<p>DATA表示开始书写新建内容</p>
<p>.表示书写结束</p>
<h4 id="1-3-监听服务器"><a href="#1-3-监听服务器" class="headerlink" title="1.3 监听服务器"></a>1.3 监听服务器</h4><h5 id="1-使用netcat-v-l-p-9090创建一个监听端口"><a href="#1-使用netcat-v-l-p-9090创建一个监听端口" class="headerlink" title="1) 使用netcat -v -l -p 9090创建一个监听端口."></a>1) 使用netcat -v -l -p 9090创建一个监听端口.</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-18.png"></p>
<h5 id="2-连接本机创建的监听端口-telnet-localhost-9090"><a href="#2-连接本机创建的监听端口-telnet-localhost-9090" class="headerlink" title="2) 连接本机创建的监听端口:telnet localhost 9090"></a>2) 连接本机创建的监听端口:telnet localhost 9090</h5><p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-20.png"></p>
<p>这个时候客户端和服务器连接上了.</p>
<p>HTTP的连接本质上是C&#x2F;S模型:客户-服务器模型,在上文我们提到了管道的观念,其实服务器一直在一个管道上监听信息,一旦监听到了信息就对应地往管道里面投放信息.</p>
<p>总的来说,就是客户端向服务器提出申请请求,服务器一直在监听客户端的申请请求,一有申请请求就立刻建立TCP连接.</p>
<h4 id="2-自制Socket"><a href="#2-自制Socket" class="headerlink" title="2 自制Socket"></a>2 自制Socket</h4><blockquote>
<p>This feature is known as a stream socket. To your program and to the Web server, the socket looks like an ordinary file descriptor (similar to a file on disk, or to the stdin or stdout I&#x2F;O streams). When two stream sockets are connected, any bytes written to one socket will eventually come out in the same order from the other socket on the other computer.</p>
</blockquote>
<p>Socket在Linux操作系统中本质上就是一个文件,一旦两个Socket相互连接,应用程序会往一个Socket递交数据,另外一个Socket就会原封不动地把数据传递过来.连接的方式在运输层有讲,客户端的一个网络端口创建一个Socket,往服务器的一个网络端口发送请求,这是第一次握手,接着服务器的网络端口传输ACK给客户端,这是第二次握手,接着客户端会传输一个最后的请求,这个叫三次握手.三次握手后,连接就完成了,这个时候两个Socket(可以理解成网络端口?)相互链接了.</p>
<p>需要注意的是,在应用层我们一般是注重逻辑通信,Socket是一个逻辑概念,应用程序把数据投给一个叫做Socket的东西,你可以理解成逻辑通信的一端,但是具体Socket往下是怎么做的不是应用程序需要关注的.</p>
<p>这个实验就需要我们模拟一个Socket应用,与一个服务器的端口建立连接.然后获取网页.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void get_URL(const string &amp;host, const string &amp;path) &#123;</span><br><span class="line">    // Your code here.</span><br><span class="line"></span><br><span class="line">    // You will need to connect to the &quot;http&quot; service on</span><br><span class="line">    // the computer whose name is in the &quot;host&quot; string,</span><br><span class="line">    // then request the URL path given in the &quot;path&quot; string.</span><br><span class="line"></span><br><span class="line">    // Then you&#x27;ll need to print out everything the server sends back,</span><br><span class="line">    // (not just one call to rearequestd() -- everything) until you reach</span><br><span class="line">    // the &quot;eof&quot; (end of file).</span><br><span class="line">    // create a TCPSocket</span><br><span class="line">    TCPSocket client_socket;</span><br><span class="line">    // connect with host. host is a parameter.</span><br><span class="line">    client_socket.connect(Address(host, &quot;http&quot;));</span><br><span class="line">    // send a request Message. the request is made of 2 sentences.</span><br><span class="line">    string request = &quot;GET &quot;+path+&quot; HTTP/1.1\r\n&quot;+&quot;Host: &quot;+host+&quot;\r\nConnection: close\r\n\r\n&quot;;</span><br><span class="line">    client_socket.write(request);</span><br><span class="line"></span><br><span class="line">    // get the Message</span><br><span class="line">    while(!client_socket.eof())&#123;</span><br><span class="line">        string reply = client_socket.read();</span><br><span class="line">        cout&lt;&lt;reply;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span><br><span class="line">    cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候先创建一个TCPSocket,首先先进行连接,然后像之前一样创建request,接着这个Socket就可以把request写进去.然后服务器会返回数据,这个数据是读取到Socket的,读数据一直读到EOF即可.</p>
<p>由于这个实验是面向初学者的,具体Socket怎么读怎么写我们没有考虑,我们只用调用教授已经写好的写,读操作.</p>
<h4 id="3-缓冲区队列"><a href="#3-缓冲区队列" class="headerlink" title="3 缓冲区队列"></a>3 缓冲区队列</h4><p>要求实现一个有序字节流类（in-order byte stream），使之支持读写、容量控制。这个字节流类似于一个带容量的队列，从一头读，从另一头写。当流中的数据达到容量上限时，便无法再写入新的数据。特别的，写操作被分为了peek和pop两步。peek为从头部开始读取指定数量的字节，pop为弹出指定数量的字节。</p>
<p>总的来说就是做一个桶,可以从下方获得内容,也可以从上方添加内容,当桶满的时候就不可以添加东西了</p>
<p>ByteStream具有一定的容量，最大允许存储该容量大小的数据；在读取端读出一部分数据后，它会释放掉已经被读出的内容，以腾出空间继续让写端写入数据。  </p>
<p>这个实验为我们后期实现TCP协议有着帮助.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-21-812x1024.png"></p>
<p>上面的是缓冲区队列的一些声明,对于读写两方,操作是不同的.</p>
<p>有个小提示,如果C++的构造函数可以使用像这样的方法进行初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class baba (const int abab) _abab(abab)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个本质上就是数据结构题,完成缓冲区队列罢了.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png"></p>
<h3 id="Lab1-stitching-substrings-into-a-byte-stream"><a href="#Lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Lab1.stitching substrings into a byte stream"></a>Lab1.stitching substrings into a byte stream</h3><p>该lab要求我们实现一个流重组类，可以将Sender发来的带索引号的字节碎片重组成有序的字节写入到byte_stream。接收端从发送端读取数据，调用流重组器，流重组器对数据进行排序，排序好后写入byte_stream。</p>
<p>流重组器也是有capasity的,也就是说流重组器也有一定的容量,一次性处理太多的信息会导致流重组器不能够正常地工作.同样的我们把流处理器当成一个双端队列即可.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-34-1024x579.png"></p>
<p>private类中还有一个ByteStream类型的变量,所有的内容都输出给ByteStream,还有一个容量变量.其中ByteStream中的bytes_read返回ByteStream处理了多少元素.</p>
<p><img src="http://tvax3.sinaimg.cn/large/007SD2TBly1gwtr4gx6o9j30hp05i0t4.jpg"></p>
<p>因为重组类的函数中,支持的index是first unread&#x3D;_output.bytes_read()(已经读取的元素)到first unacceptable的这一块区域,我们要保证输入的字节编号是在这个区域里面的.</p>
<p>在重组器类的函数中，push_substring函数完成重组工作。其参数有data(string),index(size_t),eof(bool),data是待排序的数据，index是数据首元素的序号，eof用于判断是否结束。结束后将不再有数据输入。</p>
<p>在重组的过程中，我们会遇到重复、丢包、重叠、乱序的现象。为了使乱序的数据找到有序的位置，我使用’\0’维护重组器中数据的相对序号，例如，第一次data为make,index为0,第二次data为great,index为13,而处于两组数据中间的数据未知，我们就用’\0’代替，即make\0\0\0\0\0\0\0\0\0great。这样就维护了已经进入重组器的数据的有序。当然，写入的data中也有可能含有\0,这是，我们就需要一个bool双端队列，来记录相应位置的数据是否有序，在上述例子中，队列的bool值为111100000000011111。</p>
<p>所以说我们在数据结构中添加几项,一个是_unassembled_byte,是一个<a href="std::deque">std::deque</a><char>,暂时存储还乱序的字符串,_check_byte是<a href="std::deque">std::deque</a><bool>,这个元素与_unassembled_byte一一对应,当un[i]存储着还没有发送的字符的时候,ch[I]&#x3D;true,否则为false,还有一个_lens_un,这个记录乱序的字符的长度.</p>
<p>程序的总体结构:</p>
<p>发送端的数据-&gt;流重组器(重组成有序的数据)-&gt;Bytestream(在Lab0就做好的队列)-&gt;TCP接收端.<br>流重组器需要做的是,把所有有序的数据写入到接收端.<br>其中字符的编号是从1一直往后延伸的,因为队列的首和尾都可以记录.TCP的发送端发送的数据也是(字符号、字符串)字符的编号一直往后延伸.</p>
<p>这个时候我们回忆一下对应数据的表示:</p>
<p><code>output.bytes_read()</code>:接收端从ByteStream获得的字符数量.</p>
<p><code>output.bytes_write()</code>:流重组器写入ByteStream的字符数量-1.而且是流重组器的有效数据中index最小的序号</p>
<p><code>_lens_un</code>指的还在流重组器里面的数据的长度.</p>
<p>其中:<code>output.bytes_read()+_capacity</code>是ByteStream可以接受的范围,<code>output.bytes_write()+_lens_un</code>是流重组器的有效数据中index最大的序号.</p>
<p>1.我们判断输入序号是否大于内存与已读取数据之和，也就是说，该数据是否属于unacceptable中的数据，如果是这样的数据，我们没有足够的内存写入，因为写入这样的数据需要添加\0，从而超过capasity的大小。代码如下：</p>
<p>1<br>2<br>3</p>
<p>if(index&gt;_output.bytes_read()+_capacity){<br>return;<br>}</p>
<p>2.字符串部分在区域内,但是部分在区域外,那就把区域外的内容舍弃,只读取区域内的内容.</p>
<p>我们需要判断data中最后一个数据的序号是否大于内存与已读取数据之和，如果大于，我们就要将能写入的部分写入，也就是按data的顺序尽可能地写入数据而不超过capasity,在写入的过程中，我们也会遇到两种情况，<strong>一种是序号index大于此时已经在流重组器的最后一个数据的序号</strong>，在这种情况下我们要在流重组器最后一个序号与index之间填入’\0′,同时将相应的bool双端队列(_check_byte)设置为false，做完这些工作后，才开始写入新的数据。<strong>另一种情况是index的小于或者等于流重组器最后一个数据的序号，我们需要弹出冲突的数据</strong>，举个例子就是，index序号为5,此时流重组器中的数据为stanford,我们就要从序号5的数据也就是o开始弹出，变成stanf,再写入data中的数据。代码如下：</p>
<p>if(index+data.length()&gt;_capacity+_output.bytes_read()){<br>    for(size_t i&#x3D;_lens_un+_output.bytes_written();i&lt;_capacity+_output.bytes_read();i++){<br>        if(i&lt;index){<br>            _unassembled_byte.push_back(‘\0’);<br>            _check_byte.push_back(false);</p>
<pre><code>    &#125;else&#123;
        \_unassembled\_byte.push\_back(data\[i-index\]);
        \_check\_byte.push\_back(true);

    &#125;
    \_lens\_un++;
&#125;
</code></pre>
<p>}</p>
<p>3.我们要判断index是否等于已经写入byte_stream(_output)中的数据，如果是的，我们就直接将data中的数据写入byte_stream,然后在重组器中弹出data.length()个数据，值得注意的是，当重组器中的数据个数小于data.length()，我们就全部弹出。但是后面的数据会被当成无效数据而不进行处理,代码如下：</p>
<p>if(index&#x3D;&#x3D;_output.bytes_written()){<br>&#x2F;&#x2F;直接写<br>    _output.write(data);<br>    size_t temp_len&#x3D;std::min(_lens_un,data.length());<br>    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);<br>    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);<br>    _lens_un-&#x3D;temp_len;<br>}</p>
<p>4.我们要判断index是否大于流重组器中的最后一个数据的序号和写入byte_stream中的数据个数之和，如果大于，我们就可以参考1的处理，代码如下：</p>
<p>if(index&gt;_output.bytes_written()+_lens_un){<br>    for(size_t i&#x3D;_output.bytes_written()+_lens_un;i&lt;index;i++){<br>        _unassembled_byte.push_back(‘\0’);<br>        _check_byte.push_back(false);<br>        _lens_un++;<br>    }<br>[原来的data][空][新的data]<br>    for(char i : data){<br>        _unassembled_byte.push_back(i);<br>        _lens_un++;<br>        _check_byte.push_back(true);<br>    }<br>}</p>
<p>5.我们要判断data中的数据是否已经被写入byte_stream，这个说法有些不准确，准确的说是相应序号的数据被写入，如果data中的所有数据都被写入了byte_stream，我们就直接返回，如果只是部分被写入，我们就将data中未被写入的部分写入。代码如下：</p>
<p>if(index&lt;_output.bytes_written()){<br>    if(_output.bytes_written()&gt;index+data.length()){<br>        return;<br>    }<br>&#x2F;&#x2F;[已经写入Byte_stream的][bytes_written()][新传来的data在bytes_written()之后的,入队][原来在_output.bytes_written()+_lens_un之后的data]<br>&#x2F;&#x2F;还是要写,一直写到data最后.<br>    std::string data_cut(data.begin()+_output.bytes_written()-index,data.end());<br>    _output.write(data_cut);<br>    size_t temp_len&#x3D;std::min(_lens_un,data_cut.length());<br>    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);<br>    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);<br>    _lens_un-&#x3D;temp_len;</p>
<p>6.不是任何情况:首先我们知道要把_output.bytes_written()~index这一部分的内容保存好,然后再把data加入进去即可</p>
<p>&#x2F;&#x2F;在中间插入元素<br>&#x2F;&#x2F;先弹出一部分数据保存到栈中<br>std::stack<char> temp;<br>std::stack<bool> temp_check;<br>for(size_t i&#x3D;0;i&lt;index-_output.bytes_written();i++){<br>    temp.push(_unassembled_byte.at(i));<br>    temp_check.push(_check_byte.at(i));<br>}<br>[原data,入队][index][新传来的data,入队][原来在_output.bytes_written()+_lens_un之后的data]<br>&#x2F;&#x2F;这里是看数据的最后一个index有没有达到_output.bytes_written()+_lens_un,达到的话后面的内容要保留,没达到就全部删除即可<br>size_t temp_len&#x3D;std::min(_lens_un,data.length()+index-_output.bytes_written());<br>_unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);<br>_check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);<br>_lens_un-&#x3D;temp_len;<br>for(int i&#x3D;data.length()-1;i&gt;&#x3D;0;i–){<br>    _unassembled_byte.push_front(data[i]);<br>    _check_byte.push_front(true);<br>    _lens_un++;<br>}<br>while(!temp.empty()){<br>    _unassembled_byte.push_front(temp.top());<br>    _check_byte.push_front(temp_check.top());<br>    _lens_un++;<br>    temp.pop();<br>    temp_check.pop();<br>}</p>
<p>7.输入字符串到ByteStream中:</p>
<pre><code>size\_t i=0;
while(i&lt;\_lens\_un)&#123;
    if(!\_check\_byte.at(i))&#123;
        break;
    &#125;
    i++;
&#125;
std::string n(\_unassembled\_byte.begin(),\_unassembled\_byte.begin()+i);
\_output.write(n);
\_unassembled\_byte.erase(\_unassembled\_byte.begin(),\_unassembled\_byte.begin()+i);
\_lens\_un-=i;
\_check\_byte.erase(\_check\_byte.begin(),\_check\_byte.begin()+i);
if(eof) input\_end\_index=index+data.length();
if(input\_end\_index==\_output.bytes\_written()) \_output.end\_input();
</code></pre>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-35-1024x948.png"></p>
<h3 id="Lab2-TCP-Reciever"><a href="#Lab2-TCP-Reciever" class="headerlink" title="Lab2.TCP Reciever"></a>Lab2.TCP Reciever</h3><h4 id="绝对序号和相对序号的转换"><a href="#绝对序号和相对序号的转换" class="headerlink" title="绝对序号和相对序号的转换:"></a>绝对序号和相对序号的转换:</h4><p>![image-20220418144818968](&#x2F;Users&#x2F;xupengzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220418144818968.png)</p>
<p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k,则该序号范围是。 在一个有限的序号范围内，所有涉及序号的运算必须使用模运算。（即序号空间可被看作是一个长度为 的环，其中序号紧挨着0）。上面论述的序号是相对序号(相对序号的开始值是),还有一种不模的运算就是绝对序号.</p>
<p>这个时候我们需要完成两个函数:</p>
<p>1.wrap(绝对序号转化为相对序号)</p>
<p>WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) {<br>  DUMMY_CODE(n, isn);<br>  WrappingInt32 res(n+isn.raw_value());<br>  return res;<br>}</p>
<p>这个函数调用了<code>WrappingInt32</code>类的构造函数,构造函数获得一个int类型的数(uint_64等类型)然后取模之后获得32位的整形数,存放到raw_value成员中.</p>
<p>2.unwrap(相对序号转绝对序号)</p>
<p>uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) {<br>    DUMMY_CODE(n, isn, checkpoint);<br>    uint64_t temp&#x3D;n.raw_value()-isn.raw_value();<br>    if(checkpoint&#x3D;&#x3D;0){<br>        return temp;<br>    }<br>    uint32_t div&#x3D;checkpoint&#x2F;(1ul&lt;&lt;32);<br>    uint32_t res&#x3D;checkpoint%(1ul&lt;&lt;32);<br>    if (res&lt;&#x3D;temp) {<br>        temp&#x3D;(checkpoint-temp-(div-1)*(1ul&lt;&lt;32))&lt;(temp+div*(1ul&lt;&lt;32)-checkpoint)?temp+(div-1)*(1ul&lt;&lt;32):temp+div*(1ul&lt;&lt;32);<br>    }else{<br>        temp&#x3D;(checkpoint-temp-div*(1ul&lt;&lt;32))&lt;(temp+(div+1)*(1ul&lt;&lt;32)-checkpoint)?temp+div*(1ul&lt;&lt;32):temp+(div+1)*(1ul&lt;&lt;32);<br>    }<br>    return temp;<br>}</p>
<p>给定checkpoint,找到最靠近checkpoint的那个temp,返回即可.</p>
<h4 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h4><p>首先我们看一看TCP报文包的定义:主要是由首部和其中的元素组成:其中可以调用serialize和parse方法转化,</p>
<p>class TCPSegment {<br>  private:<br>    TCPHeader _header{};<br>    Buffer _payload{};</p>
<p>  public:<br>    &#x2F;&#x2F;! \brief Parse the segment from a string<br>    ParseResult parse(const Buffer buffer, const uint32_t datagram_layer_checksum &#x3D; 0);</p>
<pre><code>//! \\brief Serialize the segment to a string
BufferList serialize(const uint32\_t datagram\_layer\_checksum = 0) const;

//! \\name Accessors
//!@&#123;
const TCPHeader &amp;header() const &#123; return \_header; &#125;
TCPHeader &amp;header() &#123; return \_header; &#125;

const Buffer &amp;payload() const &#123; return \_payload; &#125;
Buffer &amp;payload() &#123; return \_payload; &#125;
//!@&#125;

//! \\brief Segment&#39;s length in sequence space
//! \\note Equal to payload length plus one byte if SYN is set, plus one byte if FIN is set
size\_t length\_in\_sequence\_space() const;
</code></pre>
<p>};</p>
<p>接着我们来看一看TCP首部:首部的元素主要是:</p>
<ul>
<li>序号：seqno，占32位，用来标识从发送端到接收端的字节流；</li>
<li>确认号：ackno，占32位，只有ACK标志位为1时，确认号才有效，ackno&#x3D;seqno+1；</li>
<li>标志位：<ul>
<li>SYN：发起一个连接；</li>
<li>FIN：释放一个连接；</li>
<li>ACK：确认序号有效。</li>
</ul>
</li>
</ul>
<p>struct TCPHeader {<br>    static constexpr size_t LENGTH &#x3D; 20;  &#x2F;&#x2F;!&lt; [TCP](\ref rfc::rfc793) header length, not including options</p>
<pre><code>//! \\struct TCPHeader
//! ~~~&#123;.txt&#125;
//!   0                   1                   2                   3
//!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!            Source Port                 Destination Port        
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!                          Sequence Number                        
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!                      Acknowledgment Number                      
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!    Data            UAPRSF                               
//!   Offset Reserved  RCSSYI            Window             
//!                    GKHTNN                               
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!             Checksum                     Urgent Pointer        
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!                      Options                        Padding    
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//!                               data                              
//!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//! ~~~

//! \\name TCP Header fields
//!@&#123;
uint16\_t sport = 0;         //!&lt; source port
uint16\_t dport = 0;         //!&lt; destination port
WrappingInt32 seqno&#123;0&#125;;     //!&lt; sequence number
WrappingInt32 ackno&#123;0&#125;;     //!&lt; ack number
</code></pre>
<p>  uint8_t doff &#x3D; LENGTH &#x2F; 4;  &#x2F;&#x2F;!&lt; data offset<br>    bool urg &#x3D; false;           &#x2F;&#x2F;!&lt; urgent flag<br>    bool ack &#x3D; false;           &#x2F;&#x2F;!&lt; ack flag<br>    bool psh &#x3D; false;           &#x2F;&#x2F;!&lt; push flag<br>    bool rst &#x3D; false;           &#x2F;&#x2F;!&lt; rst flag<br>    bool syn &#x3D; false;           &#x2F;&#x2F;!&lt; syn flag<br>    bool fin &#x3D; false;           &#x2F;&#x2F;!&lt; fin flag<br>    uint16_t win &#x3D; 0;           &#x2F;&#x2F;!&lt; window size<br>    uint16_t cksum &#x3D; 0;         &#x2F;&#x2F;!&lt; checksum<br>    uint16_t uptr &#x3D; 0;          &#x2F;&#x2F;!&lt; urgent pointer<br>}</p>
<p>接着看一看TCP receiver的数据结构定义:</p>
<p>#ifndef SPONGE_LIBSPONGE_TCP_RECEIVER_HH<br>#define SPONGE_LIBSPONGE_TCP_RECEIVER_HH</p>
<p>#include “byte_stream.hh”<br>#include “stream_reassembler.hh”<br>#include “tcp_segment.hh”<br>#include “wrapping_integers.hh”</p>
<p>#include <optional></p>
<p>&#x2F;&#x2F;! \brief The “receiver” part of a TCP implementation.</p>
<p>&#x2F;&#x2F;! Receives and reassembles segments into a ByteStream, and computes<br>&#x2F;&#x2F;! the acknowledgment number and window size to advertise back to the<br>&#x2F;&#x2F;! remote TCPSender.<br>&#x2F;&#x2F;接收重组segments为 ByteStream，并计算确认号和窗口大小以通告回远程 TCPSender。<br>class TCPReceiver {<br>    &#x2F;&#x2F;! Our data structure for re-assembling bytes.<br>    &#x2F;&#x2F;我们用于重新组装字节的数据结构。<br>    StreamReassembler _reassembler;</p>
<pre><code>//! The maximum number of bytes we&#39;ll store.
//容量大小
size\_t \_capacity;
WrappingInt32 ISN;
bool syn\_flag;
</code></pre>
<p>  public:</p>
<pre><code>//! \\brief Construct a TCP receiver
//!
//! \\param capacity the maximum number of bytes that the receiver will
//!                 store in its buffers at any give time.
//构造函数，构造一个 TCP 接收器，容量接收器在任何给定时间将存储在其缓冲区中的最大字节数。
TCPReceiver(const size\_t capacity) : \_reassembler(capacity), \_capacity(capacity),ISN(0) ,syn\_flag(0)&#123;&#125;

//! \\name Accessors to provide feedback to the remote TCPSender
//!@&#123;

//! \\brief The ackno that should be sent to the peer
//! \\returns empty if no SYN has been received
//!
//! This is the beginning of the receiver&#39;s window, or in other words, the sequence number
//! of the first byte in the stream that the receiver hasn&#39;t received.
// 如果没有收到 SYN，则应发送给对等方的 ackno 为空
//这是接收器窗口的开始，否则，接收器未接收到的流中第一个字节的序列号。
std::optional&lt;WrappingInt32&gt; ackno() const;

//! \\brief The window size that should be sent to the peer
//!
//! Operationally: the capacity minus the number of bytes that the
//! TCPReceiver is holding in its byte stream (those that have been
//! reassembled, but not consumed).
//!
//! Formally: the difference between (a) the sequence number of
//! the first byte that falls after the window (and will not be
//! accepted by the receiver) and (b) the sequence number of the
//! beginning of the window (the ackno).
size\_t window\_size() const;
//!@&#125;

//! \\brief number of bytes stored but not yet reassembled
size\_t unassembled\_bytes() const &#123; return \_reassembler.unassembled\_bytes(); &#125;

//! \\brief handle an inbound segment
void segment\_received(const TCPSegment &amp;seg);

//! \\name &quot;Output&quot; interface for the reader
//!@&#123;
ByteStream &amp;stream\_out() &#123; return \_reassembler.stream\_out(); &#125;
const ByteStream &amp;stream\_out() const &#123; return \_reassembler.stream\_out(); &#125;
bool recv\_fin() const;
//!@&#125;
</code></pre>
<p>};</p>
<p>我们知道TCP需要接受一个叫做segment类型的数据,然后存储起来,送入到Lab1已经实现好的reassemble_stream中.并返回适合的ACK.</p>
<p>对于接受的数据:分成两种可能,一种是第一个序列,另外的就是普通的数据</p>
<p>void TCPReceiver::segment_received(const TCPSegment &amp;seg) {<br>    DUMMY_CODE(seg);<br>    &#x2F;&#x2F;代表第一个传过来的seg<br>    if(seg.header().syn){<br>        syn_flag&#x3D; true;<br>        &#x2F;&#x2F;窗口的左端<br>        ISN&#x3D;seg.header().seqno;<br>    } else if(!syn_flag){<br>        return;<br>    }<br>  &#x2F;&#x2F;推断数据包的序号,序号比较靠近上一个已经接收到的序号,然后塞进我们在Lab1已经写好的流重组器.<br>    uint64_t received_lens&#x3D;_reassembler.stream_out().bytes_written();<br>    size_t index&#x3D; unwrap(seg.header().seqno,ISN,received_lens);<br>    if(!seg.header().syn){<br>        index–;<br>    }<br>    &#x2F;&#x2F;进行重组<br>    _reassembler.push_substring(seg.payload().copy(),index,seg.header().fin);<br>}</p>
<p>ACK的返回也很简单,流重组器输入到Byte stream的个数就代表已经输入了多少个有序的序列,返回对应的ACK即可.但是对于结束的时候的ACK回应,我们还是需要分类讨论.</p>
<p>optional<WrappingInt32> TCPReceiver::ackno() const {<br>    if(!syn_flag){<br>        return std::nullopt;<br>    }else{<br>      &#x2F;&#x2F;判断是否是最后一个<br>        if(_reassembler.stream_out().input_ended()){<br>            return ISN+_reassembler.stream_out().bytes_written()+2;<br>        }else{<br>          &#x2F;&#x2F;返回的ACK的序号就是期望获得的下一个字符的数+1,流重组器的已连续写入的数据量就是最后一个有序的 &#x2F;&#x2F;字符<br>            return ISN+_reassembler.stream_out().bytes_written()+1;<br>        }<br>    }<br>}</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/04/6276FFC4517759B3003BA598E201AAC8-868x1024.jpg"></p>
<h3 id="Lab3-TCP-Sender"><a href="#Lab3-TCP-Sender" class="headerlink" title="Lab3 TCP Sender"></a>Lab3 TCP Sender</h3><p>这一次我们要实现TCP的发送方,这一次我把必要的注释写在代码里面了.</p>
<p>1.头文件:</p>
<p>class TCPSender {<br>  private:<br>    &#x2F;&#x2F;! our initial sequence number, the number for our SYN.<br>    WrappingInt32 _isn;<br>    uint64_t base{0};<br>    &#x2F;&#x2F;! outbound queue of segments that the TCPSender wants sent<br>    std::queue<TCPSegment> _segments_out{};<br>    &#x2F;&#x2F;cached TCPSegment.<br>    std::queue<TCPSegment> _segments_out_cached{};<br>    &#x2F;&#x2F;! retransmission timer for the connection<br>    unsigned int _initial_retransmission_timeout;</p>
<pre><code>//! outgoing stream of bytes that have not yet been sent
ByteStream \_stream;
//nextseq numbers as the absolute TCP number.
uint64\_t \_next\_seqnum&#123;0&#125;;
//slide windows size
uint16\_t \_curr\_window\_size;
//isfinished?
bool \_isfin;
size\_t \_times;
//ticking?
bool \_time\_waiting;
//remission times.
int \_consecutive\_remission;
// when is time out?
size\_t \_time\_out;
//empty windows?
bool \_window\_zero;
//! the (absolute) sequence number for the next byte to be sent
uint64\_t \_next\_seqno&#123;0&#125;;
</code></pre>
<p>  public:<br>    &#x2F;&#x2F;! Initialize a TCPSender<br>    TCPSender(const size_t capacity &#x3D; TCPConfig::DEFAULT_CAPACITY,<br>              const uint16_t retx_timeout &#x3D; TCPConfig::TIMEOUT_DFLT,<br>              const std::optional<WrappingInt32> fixed_isn &#x3D; {});</p>
<pre><code>//! \\name &quot;Input&quot; interface for the writer
//!@&#123;
ByteStream &amp;stream\_in() &#123; return \_stream; &#125;
const ByteStream &amp;stream\_in() const &#123; return \_stream; &#125;
//!@&#125;

//! \\name Methods that can cause the TCPSender to send a segment
//!@&#123;

//! \\brief A new acknowledgment was received
void ack\_received(const WrappingInt32 ackno, const uint16\_t window\_size);

//! \\brief Generate an empty-payload segment (useful for creating empty ACK segments)
void send\_empty\_segment();

//! \\brief create and send segments to fill as much of the window as possible
void fill\_window();

//! \\brief Notifies the TCPSender of the passage of time
void tick(const size\_t ms\_since\_last\_tick);
//!@&#125;

//! \\name Accessors
//!@&#123;

//! \\brief How many sequence numbers are occupied by segments sent but not yet acknowledged?
//! \\note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte
//! (see TCPSegment::length\_in\_sequence\_space())
size\_t bytes\_in\_flight() const;

//! \\brief Number of consecutive retransmissions that have occurred in a row
unsigned int consecutive\_retransmissions() const;

//! \\brief TCPSegments that the TCPSender has enqueued for transmission.
//! \\note These must be dequeued and sent by the TCPConnection,
//! which will need to fill in the fields that are set by the TCPReceiver
//! (ackno and window size) before sending.
std::queue&lt;TCPSegment&gt; &amp;segments\_out() &#123; return \_segments\_out; &#125;
//!@&#125;

//! \\name What is the next sequence number? (used for testing)
//!@&#123;

//! \\brief absolute seqno for the next byte to be sent
uint64\_t next\_seqno\_absolute() const &#123; return \_next\_seqno; &#125;

//! \\brief relative seqno for the next byte to be sent
WrappingInt32 next\_seqno() const &#123; return wrap(\_next\_seqno, \_isn); &#125;
//!@&#125;
</code></pre>
<p>};</p>
<p>2.发送数据函数:</p>
<p>void TCPSender::fill_window() {<br>    &#x2F;&#x2F; windows is full or the programe is finished.<br>    if(_curr_window_size&#x3D;&#x3D;0_isfin){<br>        return;<br>    }<br>    &#x2F;&#x2F;haven’t send any bytes.<br>    if(_next_seqno&#x3D;&#x3D;0){<br>        TCPSegment seg;<br>        &#x2F;&#x2F; the TCP transmission start from _isn.<br>        seg.header().seqno &#x3D; _isn;<br>        seg.header().syn &#x3D; true;<br>        &#x2F;&#x2F; the TCP first connection just send 1 bytes;<br>        _next_seqno &#x3D; 1;<br>        _curr_window_size–;<br>        _segments_out.push(seg);<br>        _segments_out_cached.push(seg);<br>    }<br>    &#x2F;&#x2F;the end of the file<br>    else if(_stream.eof()){<br>        &#x2F;&#x2F;set the finish flag to true;<br>        _isfin &#x3D; true;<br>        TCPSegment seg;<br>        seg.header().syn&#x3D;false;<br>        seg.header().fin&#x3D;true;<br>        &#x2F;&#x2F;convert the absolute TCP number to TCP number.<br>        seg.header().seqno &#x3D; wrap(_next_seqno,_isn);<br>        &#x2F;&#x2F;the fin packet only send a byte.<br>        _next_seqno++;<br>        _curr_window_size–;<br>        _segments_out.push(seg);<br>        _segments_out_cached.push(seg);<br>    }<br>    &#x2F;&#x2F;normal file<br>    else{<br>        &#x2F;&#x2F;make sure the windows is not full and there’s any data to convert.<br>        while(!_stream.buffer_empty()&amp;&amp;_curr_window_size&gt;0){<br>            &#x2F;&#x2F;decide the length of the TCP Segment.<br>            &#x2F;&#x2F;make sure the length of TCP segment is below the silde windows size and data length.<br>            uint64_t lens_byte&#x3D;std::min(_stream.buffer_size(),uint64_t (_curr_window_size));<br>            lens_byte&#x3D;std::min(lens_byte,TCPConfig::MAX_PAYLOAD_SIZE);<br>            TCPSegment seg;<br>            seg.header().seqno &#x3D; wrap(_next_seqno,_isn);<br>            seg.header().syn &#x3D; false;<br>            &#x2F;&#x2F;get the lens_byte data to the payload.<br>            seg.payload()&#x3D;_stream.read(lens_byte);<br>            &#x2F;&#x2F; increase the next seq_no;<br>            _next_seqno +&#x3D; lens_byte;<br>            _curr_window_size -&#x3D; lens_byte;<br>            &#x2F;&#x2F; get the end of the file.<br>            if(_stream.eof()&amp;&amp;_curr_window_size&gt;0){<br>                _isfin &#x3D; true;<br>                seg.header().fin&#x3D;true;<br>                &#x2F;&#x2F;the fin packet only send a byte.<br>                _next_seqno++;<br>                _curr_window_size–;<br>            }<br>            _segments_out.push(seg);<br>            _segments_out_cached.push(seg);<br>            if(_isfin){<br>                break;<br>            }<br>        }<br>    }<br>    &#x2F;&#x2F;start ticking…<br>    if(!_time_waiting){<br>        _time_out &#x3D; _initial_retransmission_timeout;<br>        _time_waiting &#x3D; true;<br>        _times &#x3D; 0;<br>    }<br>}</p>
<p>3.接受ACK:</p>
<p>&#x2F;&#x2F;! \param ackno The remote receiver’s ackno (acknowledgment number)<br>&#x2F;&#x2F;! \param window_size The remote receiver’s advertised window size<br>void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {<br>    DUMMY_CODE(ackno, window_size);<br>    &#x2F;&#x2F; get the absolute TCP number of ACK…<br>    uint64_t acknos &#x3D; unwrap(ackno,_isn,base);<br>    &#x2F;&#x2F;thrid connection…<br>    &#x2F;&#x2F;means the 0th bytes gets and desire to 1st bytes…<br>    if(base&#x3D;&#x3D;0&amp;&amp;acknos&#x3D;&#x3D;1){<br>        base&#x3D;1;<br>        _segments_out_cached.pop();<br>        _consecutive_remission&#x3D;0;<br>    }<br>    else if(acknos &gt; _next_seqno){<br>        return;<br>    }<br>    &#x2F;&#x2F;the ack number is bigger than first cached segment…<br>    &#x2F;&#x2F;means the cached data gets by the reciever…<br>    else if(!_segments_out_cached.empty() &amp;&amp; acknos &gt;&#x3D; base + _segments_out_cached.front().length_in_sequence_space()){<br>        &#x2F;&#x2F;first segment in cache, and get the seqno and length of the segment…<br>        uint64_t copy_seg_seqno &#x3D; unwrap(_segments_out_cached.front().header().seqno, _isn, base);<br>        uint64_t copy_seg_len &#x3D; _segments_out_cached.front().length_in_sequence_space();<br>        &#x2F;&#x2F;find the segments that acked by recevier…<br>        &#x2F;&#x2F;hint:if seqno+len&lt;&#x3D;ackno:means the data is acked by recevier…<br>        while(copy_seg_len+copy_seg_seqno&lt;&#x3D;acknos){<br>            &#x2F;&#x2F;move the base, base is the 1st bytes that nor acked…<br>            base +&#x3D; _segments_out_cached.front().length_in_sequence_space();<br>            _segments_out_cached.pop();<br>            if(_segments_out_cached.empty()) break;<br>            &#x2F;&#x2F; judge the 2nd segs…<br>            copy_seg_seqno &#x3D; unwrap(_segments_out_cached.front().header().seqno, _isn, base);<br>            copy_seg_len &#x3D; _segments_out_cached.front().length_in_sequence_space();<br>        }<br>        _time_out &#x3D; _initial_retransmission_timeout;<br>        _times &#x3D; 0;<br>        _consecutive_remission &#x3D; 0;<br>    }<br>    &#x2F;&#x2F; 3rd disconnection.<br>    else if(acknos &#x3D;&#x3D; _next_seqno &amp;&amp; _isfin){<br>        base &#x3D; acknos;<br>        _segments_out_cached.pop();<br>    }<br>    &#x2F;&#x2F;the windows is empty<br>    if(_next_seqno-base&#x3D;&#x3D;0){<br>        _time_waiting &#x3D; false;<br>    }<br>    &#x2F;&#x2F; 流量控制,发送方窗口不大于接受方窗口<br>    else if(_next_seqno-base&gt;&#x3D;window_size){<br>        _curr_window_size &#x3D; 0;<br>        return;<br>    }<br>    if(window_size&#x3D;&#x3D;0){<br>        _curr_window_size &#x3D; 1;<br>        _window_zero &#x3D; true;<br>    }<br>    else{<br>        _curr_window_size &#x3D; window_size;<br>        _window_zero &#x3D; false;<br>        _consecutive_remission &#x3D; 0;<br>    }<br>    fill_window();<br>}</p>
<p>4. 构造函数</p>
<p>&#x2F;&#x2F;! \param[in] capacity the capacity of the outgoing byte stream<br>&#x2F;&#x2F;! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment<br>&#x2F;&#x2F;! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)<br>TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional<WrappingInt32> fixed_isn)<br>    : _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))<br>    , base(0)<br>    , _initial_retransmission_timeout{retx_timeout}<br>    , _stream(capacity)<br>    , _curr_window_size(1)<br>    , _isfin(false)<br>    , _times(0)<br>    , _time_waiting(false)<br>    , _consecutive_remission(0)<br>    , _time_out(0)<br>    , _window_zero(false)<br>    {</p>
<pre><code>&#125;
</code></pre>
<p>5.超时处理:</p>
<p>&#x2F;&#x2F;! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method<br>void TCPSender::tick(const size_t ms_since_last_tick) {<br>    DUMMY_CODE(ms_since_last_tick);<br>    &#x2F;&#x2F; the times pased by<br>    _times +&#x3D; ms_since_last_tick;<br>    &#x2F;&#x2F;timeout and non-empty cache. resend…<br>    if(!_segments_out_cached.empty()&amp;&amp;_time_waiting&amp;&amp;_times&gt;&#x3D;_time_out){<br>        &#x2F;&#x2F;resend..<br>        _segments_out.push(_segments_out_cached.front());<br>        &#x2F;&#x2F; increase the time out times…<br>        if(!_window_zero){<br>            &#x2F;&#x2F;add remissions<br>            _consecutive_remission++;<br>            _time_out*&#x3D;2;<br>            _time_waiting &#x3D; true;<br>        }<br>        _times&#x3D;0;<br>    }<br>}</p>
<h3 id="Lab4-TCP-Connnection"><a href="#Lab4-TCP-Connnection" class="headerlink" title="Lab4 TCP Connnection"></a>Lab4 TCP Connnection</h3><p>在这里我们需要实现一个TCP连接类,在这个TCP连接类里面,我们需要组合之前已经写好的TCP发送端和接收端的函数来进行处理.</p>
<p>1、接受到segment的操作:</p>
<p>分成两种操作,一种是正常的交互,一种是握手的操作.握手又分成主动请求链接和被动链接,在这两种模式下接受握手信息的处理是不一样的.对于正常的交互,需要交付给Sender和Reciever.因为对于TCP来说,两者是相互统一的.两个主机之间也会互相传递信息,所以说交给发送端处理ACK,交给接收端返回给上层.实际的TCP协议并不是完全的类似于GBN和SR,具体的差异就在ACK的数据是相互传递的,换句话说就是连着兼有.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/04/image-1-1024x469.png"></p>
<p>void TCPConnection::segment_received(const TCPSegment &amp;seg) {<br>    DUMMY_CODE(seg);<br>    &#x2F;&#x2F; get the segment from IP level;<br>    if(!_active){<br>        return;<br>    }<br>    _time_since_last_segment_received&#x3D;0;<br>    &#x2F;&#x2F;not get segment no send ACK.<br>    &#x2F;&#x2F;passive connection…<br>    &#x2F;&#x2F;the ackno is null and no bytes is sent<br>    if(!_receiver.ackno().has_value()&amp;&amp;_sender.next_seqno_absolute()&#x3D;&#x3D;0){<br>        &#x2F;&#x2F;only recieve syn…<br>        if(!seg.header().syn) return;<br>        &#x2F;&#x2F;as the Service side,passive connected.<br>        _receiver.segment_received(seg);<br>        &#x2F;&#x2F;it’s OK to connect.<br>        connect();<br>        return;<br>    }<br>    &#x2F;&#x2F; active connected..<br>    &#x2F;&#x2F; first connection…<br>    if(_sender.next_seqno_absolute() &gt; 0 &amp;&amp; _sender.bytes_in_flight() &#x3D;&#x3D; _sender.next_seqno_absolute() &amp;&amp;<br>       !_receiver.ackno().has_value()){<br>        &#x2F;&#x2F; the length of payload is not 0<br>        if(seg.payload().size() ){<br>            return;<br>        }<br>        &#x2F;&#x2F; if ack is no<br>        &#x2F;&#x2F; the twoside wants to setup the connection at the same time.<br>        if(!seg.header().ack){<br>            if(seg.header().syn){<br>                _receiver.segment_received(seg);<br>                &#x2F;&#x2F; send empty ack to setup the connection.<br>                _sender.send_empty_segment();<br>            }<br>            return;<br>        }<br>        &#x2F;&#x2F; ifsyn&#x3D;1,ack&#x3D;1,rst&#x3D;1,then shut down.<br>        if(seg.header().rst){<br>            _receiver.stream_out().set_error();<br>            _sender.stream_in().set_error();<br>            _active &#x3D; false;<br>            return;<br>        }<br>    }<br>    &#x2F;&#x2F;otherwise…<br>    &#x2F;&#x2F;recieve the segment<br>    _receiver.segment_received(seg);<br>    _sender.ack_received(seg.header().ackno,seg.header().win);<br>    &#x2F;&#x2F; thrid connection<br>    if (_sender.stream_in().buffer_empty() &amp;&amp; seg.length_in_sequence_space())<br>        _sender.send_empty_segment();<br>    if (seg.header().rst) {<br>        _sender.send_empty_segment();<br>        unclean_shutdown();<br>        return;<br>    }<br>    send_sender_segments();<br>}</p>
<p>2、写seg.</p>
<p>将上层应用的数据写入到Bytestream中,提醒发送方发送.</p>
<p>size_t TCPConnection::write(const string &amp;data) {<br>    DUMMY_CODE(data);<br>    &#x2F;&#x2F; get the OS data… ready to be sent by TCP<br>    if(data.size()&#x3D;&#x3D;0){<br>        return 0;<br>    }<br>    size_t write_size &#x3D; _sender.stream_in().write(data);<br>    _sender.fill_window();<br>    send_sender_segments();<br>    return write_size;<br>}</p>
<p>3、时钟(操作系统不定期调用之)</p>
<p>提醒Sender处理时间,看看是不是超时了.记录一下time_since_last_segment_received.</p>
<p>&#x2F;&#x2F;! \param[in] ms_since_last_tick number of milliseconds since the last call to this method<br>void TCPConnection::tick(const size_t ms_since_last_tick) {<br>    DUMMY_CODE(ms_since_last_tick);<br>    if(!_active) return;<br>    &#x2F;&#x2F;count<br>    _time_since_last_segment_received +&#x3D; ms_since_last_tick;<br>    &#x2F;&#x2F; tell the sender to tick<br>    _sender.tick(ms_since_last_tick);<br>    if(_sender.consecutive_retransmissions()&gt;TCPConfig::MAX_RETX_ATTEMPTS){<br>        unclean_shutdown();<br>    }<br>    send_sender_segments();<br>}</p>
<p>4、真正的发送信息:读取sender中的消息缓存,然后加上ack和窗口信息信息,发送出去.</p>
<p>void TCPConnection::send_sender_segments (){<br>    &#x2F;&#x2F;travel the queue to set the ack and windows size.<br>    while(!_sender.segments_out().empty()){<br>        TCPSegment seg &#x3D; _sender.segments_out().front();<br>        _sender.segments_out().pop();<br>        &#x2F;&#x2F; the ack number is bot null<br>        if(_receiver.ackno().has_value()){<br>            seg.header().ack&#x3D;true;<br>            seg.header().ackno&#x3D;_receiver.ackno().value();<br>            seg.header().win&#x3D;_receiver.window_size();<br>        }<br>        _segments_out.push(seg);<br>    }<br>    &#x2F;&#x2F;every time send segment,we need to shutdown.<br>    clean_shutdown();<br>}</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/05/047BB194343B645BC5E8BD8F479ABD03-1024x678.jpg"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab0-Warm-Up"><span class="toc-number">1.</span> <span class="toc-text">Lab0.Warm Up</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Networking-by-hand"><span class="toc-number"></span> <span class="toc-text">1 Networking by hand</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5"><span class="toc-number">1.</span> <span class="toc-text">1.1 获取一个网页.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5http-cs144-keithw-org-hello"><span class="toc-number">1.0.1.</span> <span class="toc-text">1)首先用浏览器打开网页http:&#x2F;&#x2F;cs144.keithw.org&#x2F;hello.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%A8telnet%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5-%E8%BE%93%E5%85%A5telnet-cs144-keithw-org-http"><span class="toc-number">1.0.2.</span> <span class="toc-text">2) 用telnet进行连接,输入telnet cs144.keithw.org http</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5GET-hello-HTTP-1-1"><span class="toc-number">1.0.3.</span> <span class="toc-text">3)输入GET &#x2F;hello HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%BE%93%E5%85%A5-Host-cs144-keithw-org"><span class="toc-number">1.0.4.</span> <span class="toc-text">4) 输入 Host: cs144.keithw.org</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%8E%B7%E5%BE%97sunsetid"><span class="toc-number">1.0.5.</span> <span class="toc-text">5) 获得sunsetid</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.2 给自己发送邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%BF%99%E9%87%8C%E8%A6%81%E4%BD%BF%E7%94%A8SMTP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1) 首先连接到服务器,这里要使用SMTP协议进行连接.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%93%E6%8B%9B%E5%91%BC"><span class="toc-number">1.1.2.</span> <span class="toc-text">2) 给服务器打招呼</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%99%BB%E9%99%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">3) 登陆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%86%99%E9%82%AE%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">4) 写邮件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%9B%91%E5%90%AC%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.3 监听服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8netcat-v-l-p-9090%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">1) 使用netcat -v -l -p 9090创建一个监听端口.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BA%E5%88%9B%E5%BB%BA%E7%9A%84%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3-telnet-localhost-9090"><span class="toc-number">1.2.2.</span> <span class="toc-text">2) 连接本机创建的监听端口:telnet localhost 9090</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%88%B6Socket"><span class="toc-number">1.3.</span> <span class="toc-text">2 自制Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%8C%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">3 缓冲区队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab1-stitching-substrings-into-a-byte-stream"><span class="toc-number">2.</span> <span class="toc-text">Lab1.stitching substrings into a byte stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab2-TCP-Reciever"><span class="toc-number">3.</span> <span class="toc-text">Lab2.TCP Reciever</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%BA%8F%E5%8F%B7%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">绝对序号和相对序号的转换:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementing-the-TCP-receiver"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing the TCP receiver</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab3-TCP-Sender"><span class="toc-number">4.</span> <span class="toc-text">Lab3 TCP Sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab4-TCP-Connnection"><span class="toc-number">5.</span> <span class="toc-text">Lab4 TCP Connnection</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&text=Stanford CS144 Lab"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&is_video=false&description=Stanford CS144 Lab"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Stanford CS144 Lab&body=Check out this article: https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&title=Stanford CS144 Lab"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&name=Stanford CS144 Lab&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/&t=Stanford CS144 Lab"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2024
    Sukuna
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
