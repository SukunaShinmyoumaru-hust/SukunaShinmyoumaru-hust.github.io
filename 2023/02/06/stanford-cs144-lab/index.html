
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_tq6stt6tcg';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};</script>
  
  
  <title>
    Stanford CS144 Lab |
    
    Suwa shrine
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="Lab0.Warm Up1 Networking by hand这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.  Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequenc">
<meta property="og:type" content="article">
<meta property="og:title" content="Stanford CS144 Lab">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="Lab0.Warm Up1 Networking by hand这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.  Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequenc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png">
<meta property="article:published_time" content="2023-02-06T02:50:55.000Z">
<meta property="article:modified_time" content="2024-12-03T06:26:25.000Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png">
  
  
    <link rel="alternate" href="/atom.xml" title="Suwa shrine" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
</head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/picture">赠画感谢</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/source">资料下载</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/gbook">Sukuna冬令营</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    
      <img fetchpriority="high" src="/images/sukuna.png" alt="Stanford CS144 Lab">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">Stanford CS144 Lab</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content">
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab0-Warm-Up"><span class="toc-number">1.</span> <span class="toc-text">Lab0.Warm Up</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Networking-by-hand"><span class="toc-number">1.1.</span> <span class="toc-text">1 Networking by hand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%88%B6Socket"><span class="toc-number">1.2.</span> <span class="toc-text">2 自制Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%8C%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">3 缓冲区队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab1-stitching-substrings-into-a-byte-stream"><span class="toc-number">2.</span> <span class="toc-text">Lab1.stitching substrings into a byte stream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-TCP-Reciever"><span class="toc-number">3.</span> <span class="toc-text">Lab2.TCP Reciever</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%BA%8F%E5%8F%B7%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">绝对序号和相对序号的转换:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementing-the-TCP-receiver"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing the TCP receiver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab3-TCP-Sender"><span class="toc-number">4.</span> <span class="toc-text">Lab3 TCP Sender</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4-TCP-Connnection"><span class="toc-number">5.</span> <span class="toc-text">Lab4 TCP Connnection</span></a></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">30</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
  
</aside>

          
          <section id="main"><article id="post-stanford-cs144-lab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2023/02/06/stanford-cs144-lab/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2023-02-06T02:50:55.000Z" itemprop="datePublished">2023-02-06</time>
    <time style="display: none;" id="post-update-time">2024-12-03</time>
  </a>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" data-aos="zoom-in">实验记录</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="Lab0-Warm-Up"><a href="#Lab0-Warm-Up" class="headerlink" title="Lab0.Warm Up"></a>Lab0.Warm Up</h1><h2 id="1-Networking-by-hand"><a href="#1-Networking-by-hand" class="headerlink" title="1 Networking by hand"></a>1 Networking by hand</h2><p>这一个部分主要是体验一些基本的应用层协议,主要是HTTP协议和SMTP协议.</p>
<blockquote>
<p>Both of these tasks rely on a networking abstraction called a reliable bidirectional in-order byte stream: you’ll type a sequence of bytes into the terminal, and the same sequence of bytes will eventually be delivered, in the same order, to a program running on another computer (a server). The server responds with its own sequence of bytes, delivered back to your terminal.</p>
</blockquote>
<p>在实验资料中给出的是这么一段话,这句话的意思就是所有的应用层协议都是由底层支撑的,这个底层可以理解成可靠的二进制比特流的传输,一方应用程序会产生比特流投入到传输通道中,另一方的应用程序会从传输通道中获取到比特流信息.这个传输通道就是Socket,套接字.</p>
<h2 id="2-自制Socket"><a href="#2-自制Socket" class="headerlink" title="2 自制Socket"></a>2 自制Socket</h2><blockquote>
<p>This feature is known as a stream socket. To your program and to the Web server, the socket looks like an ordinary file descriptor (similar to a file on disk, or to the stdin or stdout I&#x2F;O streams). When two stream sockets are connected, any bytes written to one socket will eventually come out in the same order from the other socket on the other computer.</p>
</blockquote>
<p>Socket在Linux操作系统中本质上就是一个文件,一旦两个Socket相互连接,应用程序会往一个Socket递交数据,另外一个Socket就会原封不动地把数据传递过来.连接的方式在运输层有讲,客户端的一个网络端口创建一个Socket,往服务器的一个网络端口发送请求,这是第一次握手,接着服务器的网络端口传输ACK给客户端,这是第二次握手,接着客户端会传输一个最后的请求,这个叫三次握手.三次握手后,连接就完成了,这个时候两个Socket(可以理解成网络端口?)相互链接了.</p>
<p>需要注意的是,在应用层我们一般是注重逻辑通信,Socket是一个逻辑概念,应用程序把数据投给一个叫做Socket的东西,你可以理解成逻辑通信的一端,但是具体Socket往下是怎么做的不是应用程序需要关注的.</p>
<p>这个实验就需要我们模拟一个Socket应用,与一个服务器的端口建立连接.然后获取网页.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_URL</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;host, <span class="type">const</span> <span class="built_in">string</span> &amp;path)</span> &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to rearequestd() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line">    <span class="comment">// create a TCPSocket</span></span><br><span class="line">    TCPSocket client_socket;</span><br><span class="line">    <span class="comment">// connect with host. host is a parameter.</span></span><br><span class="line">    client_socket.connect(Address(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    <span class="comment">// send a request Message. the request is made of 2 sentences.</span></span><br><span class="line">    <span class="built_in">string</span> request = <span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\n&quot;</span>+<span class="string">&quot;Host: &quot;</span>+host+<span class="string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    client_socket.write(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the Message</span></span><br><span class="line">    <span class="keyword">while</span>(!client_socket.eof())&#123;</span><br><span class="line">        <span class="built_in">string</span> reply = client_socket.read();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;reply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候先创建一个TCPSocket,首先先进行连接,然后像之前一样创建request,接着这个Socket就可以把request写进去.然后服务器会返回数据,这个数据是读取到Socket的,读数据一直读到EOF即可.</p>
<p>由于这个实验是面向初学者的,具体Socket怎么读怎么写我们没有考虑,我们只用调用教授已经写好的写,读操作.</p>
<h2 id="3-缓冲区队列"><a href="#3-缓冲区队列" class="headerlink" title="3 缓冲区队列"></a>3 缓冲区队列</h2><p>要求实现一个有序字节流类（in-order byte stream），使之支持读写、容量控制。这个字节流类似于一个带容量的队列，从一头读，从另一头写。当流中的数据达到容量上限时，便无法再写入新的数据。特别的，写操作被分为了peek和pop两步。peek为从头部开始读取指定数量的字节，pop为弹出指定数量的字节。</p>
<p>总的来说就是做一个桶,可以从下方获得内容,也可以从上方添加内容,当桶满的时候就不可以添加东西了</p>
<p>ByteStream具有一定的容量，最大允许存储该容量大小的数据；在读取端读出一部分数据后，它会释放掉已经被读出的内容，以腾出空间继续让写端写入数据。  </p>
<p>这个实验为我们后期实现TCP协议有着帮助.</p>
<p>上面的是缓冲区队列的一些声明,对于读写两方,操作是不同的.</p>
<p>有个小提示,如果C++的构造函数可以使用像这样的方法进行初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class baba (const int abab) _abab(abab)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个本质上就是数据结构题,完成缓冲区队列罢了.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-22-1024x617.png"></p>
<h1 id="Lab1-stitching-substrings-into-a-byte-stream"><a href="#Lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Lab1.stitching substrings into a byte stream"></a>Lab1.stitching substrings into a byte stream</h1><p>该lab要求我们实现一个流重组类，可以将Sender发来的带索引号的字节碎片重组成有序的字节写入到byte_stream。接收端从发送端读取数据，调用流重组器，流重组器对数据进行排序，排序好后写入byte_stream。</p>
<p>流重组器也是有capasity的,也就是说流重组器也有一定的容量,一次性处理太多的信息会导致流重组器不能够正常地工作.同样的我们把流处理器当成一个双端队列即可.</p>
<p>private类中还有一个ByteStream类型的变量,所有的内容都输出给ByteStream,还有一个容量变量.其中ByteStream中的bytes_read返回ByteStream处理了多少元素.</p>
<p>因为重组类的函数中,支持的index是first unread&#x3D;_output.bytes_read()(已经读取的元素)到first unacceptable的这一块区域,我们要保证输入的字节编号是在这个区域里面的.</p>
<p>在重组器类的函数中，push_substring函数完成重组工作。其参数有data(string),index(size_t),eof(bool),data是待排序的数据，index是数据首元素的序号，eof用于判断是否结束。结束后将不再有数据输入。</p>
<p>在重组的过程中，我们会遇到重复、丢包、重叠、乱序的现象。为了使乱序的数据找到有序的位置，我使用’\0’维护重组器中数据的相对序号，例如，第一次data为make,index为0,第二次data为great,index为13,而处于两组数据中间的数据未知，我们就用’\0’代替，即make\0\0\0\0\0\0\0\0\0great。这样就维护了已经进入重组器的数据的有序。当然，写入的data中也有可能含有\0,这是，我们就需要一个bool双端队列，来记录相应位置的数据是否有序，在上述例子中，队列的bool值为111100000000011111。</p>
<p>所以说我们在数据结构中添加几项,一个是_unassembled_byte,是一个<a href="std::deque">std::deque</a><char>,暂时存储还乱序的字符串,_check_byte是<a href="std::deque">std::deque</a><bool>,这个元素与_unassembled_byte一一对应,当un[i]存储着还没有发送的字符的时候,ch[I]&#x3D;true,否则为false,还有一个_lens_un,这个记录乱序的字符的长度.</p>
<p>程序的总体结构:</p>
<p>发送端的数据-&gt;流重组器(重组成有序的数据)-&gt;Bytestream(在Lab0就做好的队列)-&gt;TCP接收端.<br>流重组器需要做的是,把所有有序的数据写入到接收端.<br>其中字符的编号是从1一直往后延伸的,因为队列的首和尾都可以记录.TCP的发送端发送的数据也是(字符号、字符串)字符的编号一直往后延伸.</p>
<p>这个时候我们回忆一下对应数据的表示:</p>
<p><code>output.bytes_read()</code>:接收端从ByteStream获得的字符数量.</p>
<p><code>output.bytes_write()</code>:流重组器写入ByteStream的字符数量-1.而且是流重组器的有效数据中index最小的序号</p>
<p><code>_lens_un</code>指的还在流重组器里面的数据的长度.</p>
<p>其中:<code>output.bytes_read()+_capacity</code>是ByteStream可以接受的范围,<code>output.bytes_write()+_lens_un</code>是流重组器的有效数据中index最大的序号.</p>
<p>1.我们判断输入序号是否大于内存与已读取数据之和，也就是说，该数据是否属于unacceptable中的数据，如果是这样的数据，我们没有足够的内存写入，因为写入这样的数据需要添加\0，从而超过capasity的大小。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(index&gt;_output.bytes_read()+_capacity)&#123;  </span><br><span class="line">return;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.字符串部分在区域内,但是部分在区域外,那就把区域外的内容舍弃,只读取区域内的内容.</p>
<p>我们需要判断data中最后一个数据的序号是否大于内存与已读取数据之和，如果大于，我们就要将能写入的部分写入，也就是按data的顺序尽可能地写入数据而不超过capasity,在写入的过程中，我们也会遇到两种情况，<strong>一种是序号index大于此时已经在流重组器的最后一个数据的序号</strong>，在这种情况下我们要在流重组器最后一个序号与index之间填入’\0′,同时将相应的bool双端队列(_check_byte)设置为false，做完这些工作后，才开始写入新的数据。<strong>另一种情况是index的小于或者等于流重组器最后一个数据的序号，我们需要弹出冲突的数据</strong>，举个例子就是，index序号为5,此时流重组器中的数据为stanford,我们就要从序号5的数据也就是o开始弹出，变成stanf,再写入data中的数据。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(index+data.length()&gt;_capacity+_output.bytes_read())&#123;</span><br><span class="line">    for(size_t i=_lens_un+_output.bytes_written();i&lt;_capacity+_output.bytes_read();i++)&#123;</span><br><span class="line">        if(i&lt;index)&#123;</span><br><span class="line">            _unassembled_byte.push_back(&#x27;\\0&#x27;);</span><br><span class="line">            _check_byte.push_back(false);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            _unassembled_byte.push_back(data[i-index]);</span><br><span class="line">            _check_byte.push_back(true);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        _lens_un++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.我们要判断index是否等于已经写入byte_stream(_output)中的数据，如果是的，我们就直接将data中的数据写入byte_stream,然后在重组器中弹出data.length()个数据，值得注意的是，当重组器中的数据个数小于data.length()，我们就全部弹出。但是后面的数据会被当成无效数据而不进行处理,代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(index==_output.bytes_written())&#123;</span><br><span class="line">//直接写</span><br><span class="line">    _output.write(data);</span><br><span class="line">    size_t temp_len=std::min(_lens_un,data.length());</span><br><span class="line">    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">    _lens_un-=temp_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.我们要判断index是否大于流重组器中的最后一个数据的序号和写入byte_stream中的数据个数之和，如果大于，我们就可以参考1的处理，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(index&gt;_output.bytes_written()+_lens_un)&#123;</span><br><span class="line">    for(size_t i=_output.bytes_written()+_lens_un;i&lt;index;i++)&#123;</span><br><span class="line">        _unassembled_byte.push_back(&#x27;\\0&#x27;);</span><br><span class="line">        _check_byte.push_back(false);</span><br><span class="line">        _lens_un++;</span><br><span class="line">    &#125;</span><br><span class="line">[原来的data][空][新的data]</span><br><span class="line">    for(char i : data)&#123;</span><br><span class="line">        _unassembled_byte.push_back(i);</span><br><span class="line">        _lens_un++;</span><br><span class="line">        _check_byte.push_back(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.我们要判断data中的数据是否已经被写入byte_stream，这个说法有些不准确，准确的说是相应序号的数据被写入，如果data中的所有数据都被写入了byte_stream，我们就直接返回，如果只是部分被写入，我们就将data中未被写入的部分写入。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(index&lt;_output.bytes_written())&#123;</span><br><span class="line">    if(_output.bytes_written()&gt;index+data.length())&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">//[已经写入Byte_stream的][bytes_written()][新传来的data在bytes_written()之后的,入队][原来在_output.bytes_written()+_lens_un之后的data]</span><br><span class="line">//还是要写,一直写到data最后.</span><br><span class="line">    std::string data_cut(data.begin()+_output.bytes_written()-index,data.end());</span><br><span class="line">    _output.write(data_cut);</span><br><span class="line">    size_t temp_len=std::min(_lens_un,data_cut.length());</span><br><span class="line">    _unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">    _check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">    _lens_un-=temp_len;</span><br></pre></td></tr></table></figure>
<p>6.不是任何情况:首先我们知道要把_output.bytes_written()~index这一部分的内容保存好,然后再把data加入进去即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//在中间插入元素</span><br><span class="line">//先弹出一部分数据保存到栈中</span><br><span class="line">std::stack&lt;char&gt; temp;</span><br><span class="line">std::stack&lt;bool&gt; temp_check;</span><br><span class="line">for(size_t i=0;i&lt;index-_output.bytes_written();i++)&#123;</span><br><span class="line">    temp.push(_unassembled_byte.at(i));</span><br><span class="line">    temp_check.push(_check_byte.at(i));</span><br><span class="line">&#125;</span><br><span class="line">[原data,入队][index][新传来的data,入队][原来在_output.bytes_written()+_lens_un之后的data]</span><br><span class="line">//这里是看数据的最后一个index有没有达到_output.bytes_written()+_lens_un,达到的话后面的内容要保留,没达到就全部删除即可</span><br><span class="line">size_t temp_len=std::min(_lens_un,data.length()+index-_output.bytes_written());</span><br><span class="line">_unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+temp_len);</span><br><span class="line">_check_byte.erase(_check_byte.begin(),_check_byte.begin()+temp_len);</span><br><span class="line">_lens_un-=temp_len;</span><br><span class="line">for(int i=data.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">    _unassembled_byte.push_front(data[i]);</span><br><span class="line">    _check_byte.push_front(true);</span><br><span class="line">    _lens_un++;</span><br><span class="line">&#125;</span><br><span class="line">while(!temp.empty())&#123;</span><br><span class="line">    _unassembled_byte.push_front(temp.top());</span><br><span class="line">    _check_byte.push_front(temp_check.top());</span><br><span class="line">    _lens_un++;</span><br><span class="line">    temp.pop();</span><br><span class="line">    temp_check.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.输入字符串到ByteStream中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t i=0;</span><br><span class="line">while(i&lt;_lens_un)&#123;</span><br><span class="line">    if(!_check_byte.at(i))&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">std::string n(_unassembled_byte.begin(),_unassembled_byte.begin()+i);</span><br><span class="line">_output.write(n);</span><br><span class="line">_unassembled_byte.erase(_unassembled_byte.begin(),_unassembled_byte.begin()+i);</span><br><span class="line">_lens_un-=i;</span><br><span class="line">_check_byte.erase(_check_byte.begin(),_check_byte.begin()+i);</span><br><span class="line">if(eof) input_end_index=index+data.length();</span><br><span class="line">if(input_end_index==_output.bytes_written()) _output.end_input();</span><br></pre></td></tr></table></figure>

<h1 id="Lab2-TCP-Reciever"><a href="#Lab2-TCP-Reciever" class="headerlink" title="Lab2.TCP Reciever"></a>Lab2.TCP Reciever</h1><h2 id="绝对序号和相对序号的转换"><a href="#绝对序号和相对序号的转换" class="headerlink" title="绝对序号和相对序号的转换:"></a>绝对序号和相对序号的转换:</h2><p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是k,则该序号范围是。 在一个有限的序号范围内，所有涉及序号的运算必须使用模运算。（即序号空间可被看作是一个长度为 的环，其中序号紧挨着0）。上面论述的序号是相对序号(相对序号的开始值是),还有一种不模的运算就是绝对序号.</p>
<p>这个时候我们需要完成两个函数:</p>
<p>1.wrap(绝对序号转化为相对序号)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) &#123;</span><br><span class="line">  DUMMY_CODE(n, isn);</span><br><span class="line">  WrappingInt32 res(n+isn.raw_value());</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数调用了<code>WrappingInt32</code>类的构造函数,构造函数获得一个int类型的数(uint_64等类型)然后取模之后获得32位的整形数,存放到raw_value成员中.</p>
<p>2.unwrap(相对序号转绝对序号)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) &#123;</span><br><span class="line">    DUMMY_CODE(n, isn, checkpoint);</span><br><span class="line">    uint64_t temp=n.raw_value()-isn.raw_value();</span><br><span class="line">    if(checkpoint==0)&#123;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t div=checkpoint/(1ul&lt;&lt;32);</span><br><span class="line">    uint32_t res=checkpoint%(1ul&lt;&lt;32);</span><br><span class="line">    if (res&lt;=temp) &#123;</span><br><span class="line">        temp=(checkpoint-temp-(div-1)\*(1ul&lt;&lt;32))&lt;(temp+div\*(1ul&lt;&lt;32)-checkpoint)?temp+(div-1)\*(1ul&lt;&lt;32):temp+div\*(1ul&lt;&lt;32);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        temp=(checkpoint-temp-div\*(1ul&lt;&lt;32))&lt;(temp+(div+1)\*(1ul&lt;&lt;32)-checkpoint)?temp+div\*(1ul&lt;&lt;32):temp+(div+1)\*(1ul&lt;&lt;32);</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定checkpoint,找到最靠近checkpoint的那个temp,返回即可.</p>
<h2 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h2><p>首先我们看一看TCP报文包的定义:主要是由首部和其中的元素组成:其中可以调用serialize和parse方法转化,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class TCPSegment &#123;</span><br><span class="line">  private:</span><br><span class="line">    TCPHeader _header&#123;&#125;;</span><br><span class="line">    Buffer _payload&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    //! \\brief Parse the segment from a string</span><br><span class="line">    ParseResult parse(const Buffer buffer, const uint32_t datagram_layer_checksum = 0);</span><br><span class="line"></span><br><span class="line">    //! \\brief Serialize the segment to a string</span><br><span class="line">    BufferList serialize(const uint32_t datagram_layer_checksum = 0) const;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors</span><br><span class="line">    //!@&#123;</span><br><span class="line">    const TCPHeader &amp;header() const &#123; return _header; &#125;</span><br><span class="line">    TCPHeader &amp;header() &#123; return _header; &#125;</span><br><span class="line"></span><br><span class="line">    const Buffer &amp;payload() const &#123; return _payload; &#125;</span><br><span class="line">    Buffer &amp;payload() &#123; return _payload; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief Segment&#x27;s length in sequence space</span><br><span class="line">    //! \\note Equal to payload length plus one byte if SYN is set, plus one byte if FIN is set</span><br><span class="line">    size_t length_in_sequence_space() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着我们来看一看TCP首部:首部的元素主要是:</p>
<ul>
<li>序号：seqno，占32位，用来标识从发送端到接收端的字节流；</li>
<li>确认号：ackno，占32位，只有ACK标志位为1时，确认号才有效，ackno&#x3D;seqno+1；</li>
<li>标志位：<ul>
<li>SYN：发起一个连接；</li>
<li>FIN：释放一个连接；</li>
<li>ACK：确认序号有效。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct TCPHeader &#123;</span><br><span class="line">    static constexpr size_t LENGTH = 20;  //!&lt; [TCP](\\ref rfc::rfc793) header length, not including options</span><br><span class="line"></span><br><span class="line">    //! \\struct TCPHeader</span><br><span class="line">    //! ~~~&#123;.txt&#125;</span><br><span class="line">    //!   0                   1                   2                   3</span><br><span class="line">    //!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!            Source Port                 Destination Port        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                          Sequence Number                        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                      Acknowledgment Number                      </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!    Data            UAPRSF                               </span><br><span class="line">    //!   Offset Reserved  RCSSYI            Window             </span><br><span class="line">    //!                    GKHTNN                               </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!             Checksum                     Urgent Pointer        </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                      Options                        Padding    </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //!                               data                              </span><br><span class="line">    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    //! ~~~</span><br><span class="line"></span><br><span class="line">    //! \\name TCP Header fields</span><br><span class="line">    //!@&#123;</span><br><span class="line">    uint16_t sport = 0;         //!&lt; source port</span><br><span class="line">    uint16_t dport = 0;         //!&lt; destination port</span><br><span class="line">    WrappingInt32 seqno&#123;0&#125;;     //!&lt; sequence number</span><br><span class="line">    WrappingInt32 ackno&#123;0&#125;;     //!&lt; ack number</span><br><span class="line">  uint8_t doff = LENGTH / 4;  //!&lt; data offset</span><br><span class="line">    bool urg = false;           //!&lt; urgent flag</span><br><span class="line">    bool ack = false;           //!&lt; ack flag</span><br><span class="line">    bool psh = false;           //!&lt; push flag</span><br><span class="line">    bool rst = false;           //!&lt; rst flag</span><br><span class="line">    bool syn = false;           //!&lt; syn flag</span><br><span class="line">    bool fin = false;           //!&lt; fin flag</span><br><span class="line">    uint16_t win = 0;           //!&lt; window size</span><br><span class="line">    uint16_t cksum = 0;         //!&lt; checksum</span><br><span class="line">    uint16_t uptr = 0;          //!&lt; urgent pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接着看一看TCP receiver的数据结构定义:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><span class="line">#define SPONGE_LIBSPONGE_TCP_RECEIVER_HH</span><br><span class="line"></span><br><span class="line">#include &quot;byte_stream.hh&quot;</span><br><span class="line">#include &quot;stream_reassembler.hh&quot;</span><br><span class="line">#include &quot;tcp_segment.hh&quot;</span><br><span class="line">#include &quot;wrapping_integers.hh&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;optional&gt;</span><br><span class="line"></span><br><span class="line">//! \\brief The &quot;receiver&quot; part of a TCP implementation.</span><br><span class="line"></span><br><span class="line">//! Receives and reassembles segments into a ByteStream, and computes</span><br><span class="line">//! the acknowledgment number and window size to advertise back to the</span><br><span class="line">//! remote TCPSender.</span><br><span class="line">//接收重组segments为 ByteStream，并计算确认号和窗口大小以通告回远程 TCPSender。</span><br><span class="line">class TCPReceiver &#123;</span><br><span class="line">    //! Our data structure for re-assembling bytes.</span><br><span class="line">    //我们用于重新组装字节的数据结构。</span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    //! The maximum number of bytes we&#x27;ll store.</span><br><span class="line">    //容量大小</span><br><span class="line">    size_t _capacity;</span><br><span class="line">    WrappingInt32 ISN;</span><br><span class="line">    bool syn_flag;</span><br><span class="line">  public:</span><br><span class="line"></span><br><span class="line">    //! \\brief Construct a TCP receiver</span><br><span class="line">    //!</span><br><span class="line">    //! \\param capacity the maximum number of bytes that the receiver will</span><br><span class="line">    //!                 store in its buffers at any give time.</span><br><span class="line">    //构造函数，构造一个 TCP 接收器，容量接收器在任何给定时间将存储在其缓冲区中的最大字节数。</span><br><span class="line">    TCPReceiver(const size_t capacity) : _reassembler(capacity), _capacity(capacity),ISN(0) ,syn_flag(0)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors to provide feedback to the remote TCPSender</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief The ackno that should be sent to the peer</span><br><span class="line">    //! \\returns empty if no SYN has been received</span><br><span class="line">    //!</span><br><span class="line">    //! This is the beginning of the receiver&#x27;s window, or in other words, the sequence number</span><br><span class="line">    //! of the first byte in the stream that the receiver hasn&#x27;t received.</span><br><span class="line">    // 如果没有收到 SYN，则应发送给对等方的 ackno 为空</span><br><span class="line">    //这是接收器窗口的开始，否则，接收器未接收到的流中第一个字节的序列号。</span><br><span class="line">    std::optional&lt;WrappingInt32&gt; ackno() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief The window size that should be sent to the peer</span><br><span class="line">    //!</span><br><span class="line">    //! Operationally: the capacity minus the number of bytes that the</span><br><span class="line">    //! TCPReceiver is holding in its byte stream (those that have been</span><br><span class="line">    //! reassembled, but not consumed).</span><br><span class="line">    //!</span><br><span class="line">    //! Formally: the difference between (a) the sequence number of</span><br><span class="line">    //! the first byte that falls after the window (and will not be</span><br><span class="line">    //! accepted by the receiver) and (b) the sequence number of the</span><br><span class="line">    //! beginning of the window (the ackno).</span><br><span class="line">    size_t window_size() const;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief number of bytes stored but not yet reassembled</span><br><span class="line">    size_t unassembled_bytes() const &#123; return _reassembler.unassembled_bytes(); &#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief handle an inbound segment</span><br><span class="line">    void segment_received(const TCPSegment &amp;seg);</span><br><span class="line"></span><br><span class="line">    //! \\name &quot;Output&quot; interface for the reader</span><br><span class="line">    //!@&#123;</span><br><span class="line">    ByteStream &amp;stream_out() &#123; return _reassembler.stream_out(); &#125;</span><br><span class="line">    const ByteStream &amp;stream_out() const &#123; return _reassembler.stream_out(); &#125;</span><br><span class="line">    bool recv_fin() const;</span><br><span class="line">    //!@&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们知道TCP需要接受一个叫做segment类型的数据,然后存储起来,送入到Lab1已经实现好的reassemble_stream中.并返回适合的ACK.</li>
</ul>
</li>
</ul>
<p>对于接受的数据:分成两种可能,一种是第一个序列,另外的就是普通的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void TCPReceiver::segment_received(const TCPSegment &amp;seg) &#123;</span><br><span class="line">    DUMMY_CODE(seg);</span><br><span class="line">    //代表第一个传过来的seg</span><br><span class="line">    if(seg.header().syn)&#123;</span><br><span class="line">        syn_flag= true;</span><br><span class="line">        //窗口的左端</span><br><span class="line">        ISN=seg.header().seqno;</span><br><span class="line">    &#125; else if(!syn_flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  //推断数据包的序号,序号比较靠近上一个已经接收到的序号,然后塞进我们在Lab1已经写好的流重组器.</span><br><span class="line">    uint64_t received_lens=_reassembler.stream_out().bytes_written();</span><br><span class="line">    size_t index= unwrap(seg.header().seqno,ISN,received_lens);</span><br><span class="line">    if(!seg.header().syn)&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    //进行重组</span><br><span class="line">    _reassembler.push_substring(seg.payload().copy(),index,seg.header().fin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ACK的返回也很简单,流重组器输入到Byte stream的个数就代表已经输入了多少个有序的序列,返回对应的ACK即可.但是对于结束的时候的ACK回应,我们还是需要分类讨论.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;WrappingInt32&gt; TCPReceiver::ackno() const &#123;</span><br><span class="line">    if(!syn_flag)&#123;</span><br><span class="line">        return std::nullopt;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //判断是否是最后一个</span><br><span class="line">        if(_reassembler.stream_out().input_ended())&#123;</span><br><span class="line">            return ISN+_reassembler.stream_out().bytes_written()+2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          //返回的ACK的序号就是期望获得的下一个字符的数+1,流重组器的已连续写入的数据量就是最后一个有序的 //字符</span><br><span class="line">            return ISN+_reassembler.stream_out().bytes_written()+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lab3-TCP-Sender"><a href="#Lab3-TCP-Sender" class="headerlink" title="Lab3 TCP Sender"></a>Lab3 TCP Sender</h1><p>这一次我们要实现TCP的发送方,这一次我把必要的注释写在代码里面了.</p>
<p>1.头文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class TCPSender &#123;</span><br><span class="line">  private:</span><br><span class="line">    //! our initial sequence number, the number for our SYN.</span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line">    uint64_t base&#123;0&#125;;</span><br><span class="line">    //! outbound queue of segments that the TCPSender wants sent</span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line">    //cached TCPSegment.</span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out_cached&#123;&#125;;</span><br><span class="line">    //! retransmission timer for the connection</span><br><span class="line">    unsigned int _initial_retransmission_timeout;</span><br><span class="line"></span><br><span class="line">    //! outgoing stream of bytes that have not yet been sent</span><br><span class="line">    ByteStream _stream;</span><br><span class="line">    //nextseq numbers as the absolute TCP number.</span><br><span class="line">    uint64_t _next_seqnum&#123;0&#125;;</span><br><span class="line">    //slide windows size</span><br><span class="line">    uint16_t _curr_window_size;</span><br><span class="line">    //isfinished?</span><br><span class="line">    bool _isfin;</span><br><span class="line">    size_t _times;</span><br><span class="line">    //ticking?</span><br><span class="line">    bool _time_waiting;</span><br><span class="line">    //remission times.</span><br><span class="line">    int _consecutive_remission;</span><br><span class="line">    // when is time out?</span><br><span class="line">    size_t _time_out;</span><br><span class="line">    //empty windows?</span><br><span class="line">    bool _window_zero;</span><br><span class="line">    //! the (absolute) sequence number for the next byte to be sent</span><br><span class="line">    uint64_t _next_seqno&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    //! Initialize a TCPSender</span><br><span class="line">    TCPSender(const size_t capacity = TCPConfig::DEFAULT_CAPACITY,</span><br><span class="line">              const uint16_t retx_timeout = TCPConfig::TIMEOUT_DFLT,</span><br><span class="line">              const std::optional&lt;WrappingInt32&gt; fixed_isn = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    //! \\name &quot;Input&quot; interface for the writer</span><br><span class="line">    //!@&#123;</span><br><span class="line">    ByteStream &amp;stream_in() &#123; return _stream; &#125;</span><br><span class="line">    const ByteStream &amp;stream_in() const &#123; return _stream; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Methods that can cause the TCPSender to send a segment</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief A new acknowledgment was received</span><br><span class="line">    void ack_received(const WrappingInt32 ackno, const uint16_t window_size);</span><br><span class="line"></span><br><span class="line">    //! \\brief Generate an empty-payload segment (useful for creating empty ACK segments)</span><br><span class="line">    void send_empty_segment();</span><br><span class="line"></span><br><span class="line">    //! \\brief create and send segments to fill as much of the window as possible</span><br><span class="line">    void fill_window();</span><br><span class="line"></span><br><span class="line">    //! \\brief Notifies the TCPSender of the passage of time</span><br><span class="line">    void tick(const size_t ms_since_last_tick);</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name Accessors</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief How many sequence numbers are occupied by segments sent but not yet acknowledged?</span><br><span class="line">    //! \\note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte</span><br><span class="line">    //! (see TCPSegment::length_in_sequence_space())</span><br><span class="line">    size_t bytes_in_flight() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief Number of consecutive retransmissions that have occurred in a row</span><br><span class="line">    unsigned int consecutive_retransmissions() const;</span><br><span class="line"></span><br><span class="line">    //! \\brief TCPSegments that the TCPSender has enqueued for transmission.</span><br><span class="line">    //! \\note These must be dequeued and sent by the TCPConnection,</span><br><span class="line">    //! which will need to fill in the fields that are set by the TCPReceiver</span><br><span class="line">    //! (ackno and window size) before sending.</span><br><span class="line">    std::queue&lt;TCPSegment&gt; &amp;segments_out() &#123; return _segments_out; &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line"></span><br><span class="line">    //! \\name What is the next sequence number? (used for testing)</span><br><span class="line">    //!@&#123;</span><br><span class="line"></span><br><span class="line">    //! \\brief absolute seqno for the next byte to be sent</span><br><span class="line">    uint64_t next_seqno_absolute() const &#123; return _next_seqno; &#125;</span><br><span class="line"></span><br><span class="line">    //! \\brief relative seqno for the next byte to be sent</span><br><span class="line">    WrappingInt32 next_seqno() const &#123; return wrap(_next_seqno, _isn); &#125;</span><br><span class="line">    //!@&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.发送数据函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">void TCPSender::fill_window() &#123;</span><br><span class="line">    // windows is full or the programe is finished.</span><br><span class="line">    if(_curr_window_size==0_isfin)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //haven&#x27;t send any bytes.</span><br><span class="line">    if(_next_seqno==0)&#123;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        // the TCP transmission start from _isn.</span><br><span class="line">        seg.header().seqno = _isn;</span><br><span class="line">        seg.header().syn = true;</span><br><span class="line">        // the TCP first connection just send 1 bytes;</span><br><span class="line">        _next_seqno = 1;</span><br><span class="line">        _curr_window_size--;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        _segments_out_cached.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //the end of the file</span><br><span class="line">    else if(_stream.eof())&#123;</span><br><span class="line">        //set the finish flag to true;</span><br><span class="line">        _isfin = true;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        seg.header().syn=false;</span><br><span class="line">        seg.header().fin=true;</span><br><span class="line">        //convert the absolute TCP number to TCP number.</span><br><span class="line">        seg.header().seqno = wrap(_next_seqno,_isn);</span><br><span class="line">        //the fin packet only send a byte.</span><br><span class="line">        _next_seqno++;</span><br><span class="line">        _curr_window_size--;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        _segments_out_cached.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //normal file</span><br><span class="line">    else&#123;</span><br><span class="line">        //make sure the windows is not full and there&#x27;s any data to convert.</span><br><span class="line">        while(!_stream.buffer_empty()&amp;&amp;_curr_window_size&gt;0)&#123;</span><br><span class="line">            //decide the length of the TCP Segment.</span><br><span class="line">            //make sure the length of TCP segment is below the silde windows size and data length.</span><br><span class="line">            uint64_t lens_byte=std::min(_stream.buffer_size(),uint64_t (_curr_window_size));</span><br><span class="line">            lens_byte=std::min(lens_byte,TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">            TCPSegment seg;</span><br><span class="line">            seg.header().seqno = wrap(_next_seqno,_isn);</span><br><span class="line">            seg.header().syn = false;</span><br><span class="line">            //get the lens_byte data to the payload.</span><br><span class="line">            seg.payload()=_stream.read(lens_byte);</span><br><span class="line">            // increase the next seq_no;</span><br><span class="line">            _next_seqno += lens_byte;</span><br><span class="line">            _curr_window_size -= lens_byte;</span><br><span class="line">            // get the end of the file.</span><br><span class="line">            if(_stream.eof()&amp;&amp;_curr_window_size&gt;0)&#123;</span><br><span class="line">                _isfin = true;</span><br><span class="line">                seg.header().fin=true;</span><br><span class="line">                //the fin packet only send a byte.</span><br><span class="line">                _next_seqno++;</span><br><span class="line">                _curr_window_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            _segments_out.push(seg);</span><br><span class="line">            _segments_out_cached.push(seg);</span><br><span class="line">            if(_isfin)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //start ticking...</span><br><span class="line">    if(!_time_waiting)&#123;</span><br><span class="line">        _time_out = _initial_retransmission_timeout;</span><br><span class="line">        _time_waiting = true;</span><br><span class="line">        _times = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.接受ACK:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//! \\param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="line">//! \\param window_size The remote receiver&#x27;s advertised window size</span><br><span class="line">void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) &#123; </span><br><span class="line">    DUMMY_CODE(ackno, window_size); </span><br><span class="line">    // get the absolute TCP number of ACK...</span><br><span class="line">    uint64_t acknos = unwrap(ackno,_isn,base);</span><br><span class="line">    //thrid connection...</span><br><span class="line">    //means the 0th bytes gets and desire to 1st bytes...</span><br><span class="line">    if(base==0&amp;&amp;acknos==1)&#123;</span><br><span class="line">        base=1;</span><br><span class="line">        _segments_out_cached.pop();</span><br><span class="line">        _consecutive_remission=0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(acknos &gt; _next_seqno)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //the ack number is bigger than first cached segment...</span><br><span class="line">    //means the cached data gets by the reciever...</span><br><span class="line">    else if(!_segments_out_cached.empty() &amp;&amp; acknos &gt;= base + _segments_out_cached.front().length_in_sequence_space())&#123;</span><br><span class="line">        //first segment in cache, and get the seqno and length of the segment...</span><br><span class="line">        uint64_t copy_seg_seqno = unwrap(_segments_out_cached.front().header().seqno, _isn, base);</span><br><span class="line">        uint64_t copy_seg_len = _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">        //find the segments that acked by recevier...</span><br><span class="line">        //hint:if seqno+len&lt;=ackno:means the data is acked by recevier...</span><br><span class="line">        while(copy_seg_len+copy_seg_seqno&lt;=acknos)&#123;</span><br><span class="line">            //move the base, base is the 1st bytes that nor acked...</span><br><span class="line">            base += _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">            _segments_out_cached.pop();</span><br><span class="line">            if(_segments_out_cached.empty()) break;</span><br><span class="line">            // judge the 2nd segs...</span><br><span class="line">            copy_seg_seqno = unwrap(_segments_out_cached.front().header().seqno, _isn, base);</span><br><span class="line">            copy_seg_len = _segments_out_cached.front().length_in_sequence_space();</span><br><span class="line">        &#125;</span><br><span class="line">        _time_out = _initial_retransmission_timeout;</span><br><span class="line">        _times = 0;</span><br><span class="line">        _consecutive_remission = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3rd disconnection.</span><br><span class="line">    else if(acknos == _next_seqno &amp;&amp; _isfin)&#123;</span><br><span class="line">        base = acknos;</span><br><span class="line">        _segments_out_cached.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //the windows is empty</span><br><span class="line">    if(_next_seqno-base==0)&#123;</span><br><span class="line">        _time_waiting = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 流量控制,发送方窗口不大于接受方窗口</span><br><span class="line">    else if(_next_seqno-base&gt;=window_size)&#123;</span><br><span class="line">        _curr_window_size = 0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(window_size==0)&#123;</span><br><span class="line">        _curr_window_size = 1;</span><br><span class="line">        _window_zero = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        _curr_window_size = window_size;</span><br><span class="line">        _window_zero = false;</span><br><span class="line">        _consecutive_remission = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    fill_window();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4. 构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] capacity the capacity of the outgoing byte stream</span><br><span class="line">//! \\param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span><br><span class="line">//! \\param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span><br><span class="line">TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.value_or(WrappingInt32&#123;random_device()()&#125;))</span><br><span class="line">    , base(0)</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity)</span><br><span class="line">    , _curr_window_size(1)</span><br><span class="line">    , _isfin(false)</span><br><span class="line">    , _times(0)</span><br><span class="line">    , _time_waiting(false)</span><br><span class="line">    , _consecutive_remission(0)</span><br><span class="line">    , _time_out(0)</span><br><span class="line">    , _window_zero(false)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>5.超时处理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="line">void TCPSender::tick(const size_t ms_since_last_tick) &#123; </span><br><span class="line">    DUMMY_CODE(ms_since_last_tick);</span><br><span class="line">    // the times pased by</span><br><span class="line">    _times += ms_since_last_tick;</span><br><span class="line">    //timeout and non-empty cache. resend...</span><br><span class="line">    if(!_segments_out_cached.empty()&amp;&amp;_time_waiting&amp;&amp;_times&gt;=_time_out)&#123;</span><br><span class="line">        //resend..</span><br><span class="line">        _segments_out.push(_segments_out_cached.front());</span><br><span class="line">        // increase the time out times...</span><br><span class="line">        if(!_window_zero)&#123;</span><br><span class="line">            //add remissions</span><br><span class="line">            _consecutive_remission++;</span><br><span class="line">            _time_out\*=2;</span><br><span class="line">            _time_waiting = true;</span><br><span class="line">        &#125;</span><br><span class="line">        _times=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lab4-TCP-Connnection"><a href="#Lab4-TCP-Connnection" class="headerlink" title="Lab4 TCP Connnection"></a>Lab4 TCP Connnection</h1><p>在这里我们需要实现一个TCP连接类,在这个TCP连接类里面,我们需要组合之前已经写好的TCP发送端和接收端的函数来进行处理.</p>
<p>1、接受到segment的操作:</p>
<p>分成两种操作,一种是正常的交互,一种是握手的操作.握手又分成主动请求链接和被动链接,在这两种模式下接受握手信息的处理是不一样的.对于正常的交互,需要交付给Sender和Reciever.因为对于TCP来说,两者是相互统一的.两个主机之间也会互相传递信息,所以说交给发送端处理ACK,交给接收端返回给上层.实际的TCP协议并不是完全的类似于GBN和SR,具体的差异就在ACK的数据是相互传递的,换句话说就是连着兼有.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void TCPConnection::segment_received(const TCPSegment &amp;seg) &#123; </span><br><span class="line">    DUMMY_CODE(seg); </span><br><span class="line">    // get the segment from IP level;</span><br><span class="line">    if(!_active)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _time_since_last_segment_received=0;</span><br><span class="line">    //not get segment no send ACK.</span><br><span class="line">    //passive connection...</span><br><span class="line">    //the ackno is null and no bytes is sent</span><br><span class="line">    if(!_receiver.ackno().has_value()&amp;&amp;_sender.next_seqno_absolute()==0)&#123;</span><br><span class="line">        //only recieve syn...</span><br><span class="line">        if(!seg.header().syn) return;</span><br><span class="line">        //as the Service side,passive connected.</span><br><span class="line">        _receiver.segment_received(seg);</span><br><span class="line">        //it&#x27;s OK to connect.</span><br><span class="line">        connect();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // active connected..</span><br><span class="line">    // first connection...</span><br><span class="line">    if(_sender.next_seqno_absolute() &gt; 0 &amp;&amp; _sender.bytes_in_flight() == _sender.next_seqno_absolute() &amp;&amp; </span><br><span class="line">       !_receiver.ackno().has_value())&#123;</span><br><span class="line">        // the length of payload is not 0</span><br><span class="line">        if(seg.payload().size() )&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // if ack is no</span><br><span class="line">        // the twoside wants to setup the connection at the same time.</span><br><span class="line">        if(!seg.header().ack)&#123;</span><br><span class="line">            if(seg.header().syn)&#123;</span><br><span class="line">                _receiver.segment_received(seg);</span><br><span class="line">                // send empty ack to setup the connection.</span><br><span class="line">                _sender.send_empty_segment();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // ifsyn=1,ack=1,rst=1,then shut down.</span><br><span class="line">        if(seg.header().rst)&#123;</span><br><span class="line">            _receiver.stream_out().set_error();</span><br><span class="line">            _sender.stream_in().set_error();</span><br><span class="line">            _active = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //otherwise...</span><br><span class="line">    //recieve the segment</span><br><span class="line">    _receiver.segment_received(seg);</span><br><span class="line">    _sender.ack_received(seg.header().ackno,seg.header().win);</span><br><span class="line">    // thrid connection</span><br><span class="line">    if (_sender.stream_in().buffer_empty() &amp;&amp; seg.length_in_sequence_space())</span><br><span class="line">        _sender.send_empty_segment();</span><br><span class="line">    if (seg.header().rst) &#123;</span><br><span class="line">        _sender.send_empty_segment();</span><br><span class="line">        unclean_shutdown();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    send_sender_segments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、写seg.</p>
<p>将上层应用的数据写入到Bytestream中,提醒发送方发送.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t TCPConnection::write(const string &amp;data) &#123;</span><br><span class="line">    DUMMY_CODE(data);</span><br><span class="line">    // get the OS data... ready to be sent by TCP</span><br><span class="line">    if(data.size()==0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t write_size = _sender.stream_in().write(data);</span><br><span class="line">    _sender.fill_window();</span><br><span class="line">    send_sender_segments();</span><br><span class="line">    return write_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、时钟(操作系统不定期调用之)</p>
<p>提醒Sender处理时间,看看是不是超时了.记录一下time_since_last_segment_received.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//! \\param[in] ms_since_last_tick number of milliseconds since the last call to this method</span><br><span class="line">void TCPConnection::tick(const size_t ms_since_last_tick) &#123; </span><br><span class="line">    DUMMY_CODE(ms_since_last_tick); </span><br><span class="line">    if(!_active) return;</span><br><span class="line">    //count</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    // tell the sender to tick</span><br><span class="line">    _sender.tick(ms_since_last_tick);</span><br><span class="line">    if(_sender.consecutive_retransmissions()&gt;TCPConfig::MAX_RETX_ATTEMPTS)&#123;</span><br><span class="line">        unclean_shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    send_sender_segments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、真正的发送信息:读取sender中的消息缓存,然后加上ack和窗口信息信息,发送出去.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void TCPConnection::send_sender_segments ()&#123;</span><br><span class="line">    //travel the queue to set the ack and windows size.</span><br><span class="line">    while(!_sender.segments_out().empty())&#123;</span><br><span class="line">        TCPSegment seg = _sender.segments_out().front();</span><br><span class="line">        _sender.segments_out().pop();</span><br><span class="line">        // the ack number is bot null</span><br><span class="line">        if(_receiver.ackno().has_value())&#123;</span><br><span class="line">            seg.header().ack=true;</span><br><span class="line">            seg.header().ackno=_receiver.ackno().value();</span><br><span class="line">            seg.header().win=_receiver.window_size();</span><br><span class="line">        &#125;</span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    //every time send segment,we need to shutdown.</span><br><span class="line">    clean_shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <blockquote class="article-copyright">
    <p><strong>本文作者：</strong>Sukuna @ Suwa shrine</p>
    <p><strong>本文链接：</strong><a href="https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/">https://sukunashinmyoumaru-hust.github.io/2023/02/06/stanford-cs144-lab/</a></p>
    
    
    
    <p><strong>本文版权：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener external nofollow noreferrer" target="_blank"><span class="icon-creative-commons"></span>BY-NC-SA</a> 许可协议。转载请注明出处！</p>
    <span class="icon-creative-commons article-copyright-bg"></span>
  </blockquote>
      
      
      
        <a data-aos="zoom-in" href="/2023/02/06/stanford-cs144-lab/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/06/stanford-cs144-lab/" itemprop="commentCount"></span>
          留言
        </a>
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/97c3cfc23ec60f4c.jpg" data-sizes="auto" alt="CMU14-445 Lab" class="lazyload">
          
        
        <a href="/2023/02/07/cmu14-445-lab/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            CMU14-445 Lab
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/97c3cfc23ec60f4c.jpg" data-sizes="auto" alt="Rustilings 练习笔记" class="lazyload">
        
      
      <a href="/2023/02/06/rustilings/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          Rustilings 练习笔记
        
      </h3>
    </div>
    
  </nav>


</article>

  <section id="comments" class="vcomment" data-aos="fade-up"></section>






</section>
          
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false"></div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2025
      <span class="footer-info-sep rotate"></span>
      Sukuna
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        254.3k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        17:23
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
  
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab0-Warm-Up"><span class="toc-number">1.</span> <span class="toc-text">Lab0.Warm Up</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Networking-by-hand"><span class="toc-number">1.1.</span> <span class="toc-text">1 Networking by hand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%88%B6Socket"><span class="toc-number">1.2.</span> <span class="toc-text">2 自制Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%8C%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">3 缓冲区队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab1-stitching-substrings-into-a-byte-stream"><span class="toc-number">2.</span> <span class="toc-text">Lab1.stitching substrings into a byte stream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-TCP-Reciever"><span class="toc-number">3.</span> <span class="toc-text">Lab2.TCP Reciever</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%AF%B9%E5%BA%8F%E5%8F%B7%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">绝对序号和相对序号的转换:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementing-the-TCP-receiver"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing the TCP receiver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab3-TCP-Sender"><span class="toc-number">4.</span> <span class="toc-text">Lab3 TCP Sender</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4-TCP-Connnection"><span class="toc-number">5.</span> <span class="toc-text">Lab4 TCP Connnection</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">30</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>



  
<script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js" integrity="sha384-xneY1WY8hOfUzswrE4CrYq35N4BdVcxqxwHPr9zawE&#x2F;jMSCxD+jAPU55x&#x2F;jj3wlf" crossorigin="anonymous"></script>

  <script>
    function loadScripts(scripts, index) {
      if (index < scripts.length) {
        const script = scripts[index];
        const src = script.getAttribute('src');

        const loadScript = (scriptContent) => {
          const scriptElement = document.createElement('script');
          if (script.type) {
            scriptElement.type = script.type;
          }
          scriptElement.text = scriptContent;
          document.head.appendChild(scriptElement);
          loadScripts(scripts, index + 1);
        }

        if (src) {
          fetch(src)
            .then(response => {
              if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
              }
              return response.text();
            })
            .then(scriptContent => {
              loadScript(scriptContent);
            })
            .catch(error => {
              console.error('Failed to load script:', src, error);
            });
        } else {
          loadScript(script.text);
        }
      }
    }
    window.Pjax && new window.Pjax({
      selectors: [
        "#header img",
        "#header picture",
        "head title",
        "#header-title",
        "#subtitle-wrap",
        "#content",
        '#mobile-nav',
        '#lazy-script'
      ],
      switches: {
        "#header-title": Pjax.switches.outerHTML,
        "#subtitle-wrap": Pjax.switches.outerHTML,
        "#content": function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.outerHTML = newEl.outerHTML
          this.onSwitch()
        },
        "#mobile-nav": Pjax.switches.outerHTML,
        '#lazy-script': function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.innerHTML = newEl.innerHTML
          this.onSwitch()
        },
      },
      cacheBust: false
    })
  </script>
  
<script src="/js/pjax.js"></script>




  <script>
    function initLive2d() {
      live2d.init("https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/", {themeTipsPath: ""});
    }
  </script>
  
<script src="https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/js/live2d-autoload.js" onload="initLive2d &amp;&amp; initLive2d()" async></script>





<div id="lazy-script">
  <div>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
  
<script src="https://npm.webcache.cn/valine@1.5.1/dist/Valine.min.js" integrity="sha384-3ma91AExDeMAZ1rjTjaP8V2A2obQE+s5ltKRwYlwdpArz9xVbp0tF3b0VV2ACNPn" crossorigin="anonymous" data-pjax></script>

  <script data-pjax>
    var GUEST_INFO = ['nick', 'mail', 'link'];
    var guest_info = 'SukunaFans'.split(',').filter((item) => {
      return GUEST_INFO.indexOf(item) > -1
    });
    var recordIP = JSON.parse('true');
    var highlight = JSON.parse('true');
    var visitor = JSON.parse('false');

    new Valine({
      el: '.vcomment',
      appId: "xR5C19oD9KiPnawzBUJNSD64-gzGzoHsz",
      appKey: "BuHN9ATTBOcwMxGPy9IxuI8b",
      placeholder: "留下你的留言吧",
      pageSize: '10',
      avatar: 'mp',
      lang: 'zh-cn',
      recordIP: recordIP,
      highlight: highlight,
      visitor: visitor,
      requiredFields: guest_info,
      path: window.location.pathname
    });
  </script>









    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.0.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  
    
<script src="https://npm.webcache.cn/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6&#x2F;1Nxveei" crossorigin="anonymous" defer data-pjax></script>

    <script data-pjax>
      window.MathJax = {"tex":{"tags":"ams","useLabelIds":true,"inlineMath":[["$","$"],["\\\\(","\\\\)"]],"displayMath":[["$$","$$"],["\\\\[","\\\\]"]],"processEscapes":true,"processEnvironments":true,"autoload":{"color":[],"colorv2":["color"]},"packages":{"[+]":["noerrors"]}},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"ignoreHtmlClass":"tex2jax_ignore","processHtmlClass":"tex2jax_process"},"loader":{"load":["input/asciimath","[tex]/noerrors"]}};
    </script>
  


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
  </html>

