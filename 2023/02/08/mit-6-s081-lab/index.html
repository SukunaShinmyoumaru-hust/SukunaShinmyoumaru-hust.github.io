
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_tq6stt6tcg';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};</script>
  
  
  <title>
    MIT_6.s081_Lab |
    
    Suwa shrine
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="1:Xv6 and Unix utilities运行环境:Ubuntu 20.04 qemu 在做6.s081的实验之前我们首先要先下载Xv6操作系统以及qemu虚拟机: 1sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-li">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT_6.s081_Lab">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/2023/02/08/mit-6-s081-lab/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="1:Xv6 and Unix utilities运行环境:Ubuntu 20.04 qemu 在做6.s081的实验之前我们首先要先下载Xv6操作系统以及qemu虚拟机: 1sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-li">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdn.net/20161223173958916">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-cfd5f86fa2495b79eabf8bdaa24925f2_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-9930748a73415bd511e4fe27f81de13d_1440w.jpg">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2022/03/image-29-1024x488.png">
<meta property="article:published_time" content="2023-02-08T03:02:54.000Z">
<meta property="article:modified_time" content="2024-03-25T01:34:55.130Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20161223173958916">
  
  
    <link rel="alternate" href="/atom.xml" title="Suwa shrine" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
</head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/picture">赠画感谢</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/source">资料下载</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/travel">旅行日志</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/gbook">Sukuna冬令营</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    
      <img fetchpriority="high" src="/images/sukuna.png" alt="MIT_6.s081_Lab">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">MIT_6.s081_Lab</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content">
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Xv6-and-Unix-utilities"><span class="toc-number">1.</span> <span class="toc-text">1:Xv6 and Unix utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-1-Boot-xv6"><span class="toc-number">1.1.</span> <span class="toc-text">Lab1_1:Boot xv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-2-sleep"><span class="toc-number">1.2.</span> <span class="toc-text">Lab1_2 sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-3-pingpong"><span class="toc-number">1.3.</span> <span class="toc-text">Lab1_3 pingpong</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-4-prime"><span class="toc-number">1.4.</span> <span class="toc-text">Lab1_4 prime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-5-find"><span class="toc-number">1.5.</span> <span class="toc-text">Lab1_5 find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-6-xargs"><span class="toc-number">1.6.</span> <span class="toc-text">Lab1_6 xargs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Xv6-and-Syscall"><span class="toc-number">2.</span> <span class="toc-text">2:Xv6 and Syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-1-Trace"><span class="toc-number">2.1.</span> <span class="toc-text">Lab2_1 Trace.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8user-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Etrace%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.1.0.0.1.</span> <span class="toc-text">1) 在user.h中添加对于trace函数的支持.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAentry%E5%9C%A8user-pl%E9%87%8C%E9%9D%A2"><span class="toc-number">2.1.0.0.2.</span> <span class="toc-text">2) 添加一个entry在user.pl里面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8syscall-h%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7"><span class="toc-number">2.1.0.0.3.</span> <span class="toc-text">3) 在syscall.h添加系统调用号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8proc%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAmask%E6%88%90%E5%91%98-%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E8%A6%81trace%E5%93%AA%E7%A7%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.0.0.4.</span> <span class="toc-text">4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8kernel-sysproc-c%E9%87%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%85%B7%E4%BD%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BC%9A%E4%BF%9D%E5%AD%98%E5%9C%A8%E8%BF%99%E9%87%8C"><span class="toc-number">2.1.0.0.5.</span> <span class="toc-text">5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9B%B4%E6%94%B9fork%E5%87%BD%E6%95%B0-%E6%B7%BB%E5%8A%A0mask%E7%9A%84%E5%A4%8D%E5%88%B6-np-mask-p-mask"><span class="toc-number">2.1.0.0.6.</span> <span class="toc-text">6) 更改fork函数,添加mask的复制.np-&gt;mask &#x3D; p-&gt;mask;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%B7%BB%E5%8A%A0syscall-c%E4%B8%AD%E5%85%B3%E4%BA%8Etrace%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.1.0.0.7.</span> <span class="toc-text">7) 添加syscall.c中关于trace函数的支持.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%9B%B4%E6%94%B9syscall-c%E7%9A%84syscall%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.0.0.8.</span> <span class="toc-text">8) 更改syscall.c的syscall函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-2-sys-info"><span class="toc-number">3.</span> <span class="toc-text">Lab2_2 sys info</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8makefile-user-pl%E5%92%8Cuser-h%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Esysinfo%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81-%E4%B8%8D%E6%87%82%E7%9A%84%E8%AF%B7%E7%BF%BB%E9%98%85%E4%B8%8A%E9%9D%A2"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%9F%E8%AE%A1%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%95%B0-%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0proc-size-%E5%9C%A8proc-h%E4%B8%AD"><span class="toc-number">3.0.0.0.2.</span> <span class="toc-text">2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1%E5%BD%93%E5%89%8D%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0-%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0freememory-%E5%9C%A8kalloc-h%E4%B8%AD"><span class="toc-number">3.0.0.0.3.</span> <span class="toc-text">3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AE%8C%E6%88%90sysinfo%E7%9A%84%E6%93%8D%E4%BD%9C-%E6%B3%A8%E6%84%8F2-%E5%92%8C3-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E8%A6%81%E5%A3%B0%E6%98%8E%E5%9C%A8def-h%E4%B8%AD"><span class="toc-number">3.0.0.0.4.</span> <span class="toc-text">4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在def.h中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%83%8F%E4%B8%8A%E4%B8%AA%E5%AE%9E%E9%AA%8C%E4%B8%80%E6%A0%B7%E5%AE%8C%E6%88%90syscall-h-syscall-c%E7%9A%84%E6%94%AF%E6%8C%81%E5%8D%B3%E5%8F%AF"><span class="toc-number">3.0.0.0.5.</span> <span class="toc-text">5) 像上个实验一样完成syscall.h,syscall.c的支持即可.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Xv6-and-PageTable"><span class="toc-number">3.0.1.</span> <span class="toc-text">3:Xv6 and PageTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab3-1-Speed-Up-the-system-calls"><span class="toc-number">3.0.2.</span> <span class="toc-text">Lab3_1 Speed Up the system calls</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A1%AE%E8%AE%A4usyscall%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88-%E5%85%B6%E5%AE%9E%E5%AD%98%E5%82%A8%E7%9A%84%E5%B0%B1%E6%98%AFpid"><span class="toc-number">3.0.2.0.1.</span> <span class="toc-text">1) 确认usyscall的结构体是什么,其实存储的就是pid.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E6%B7%BB%E5%8A%A0usyscall%E7%9A%84%E5%85%83%E7%B4%A0-%E8%BF%99%E4%B8%AA%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%A1%B5%E9%87%8C%E9%9D%A2"><span class="toc-number">3.0.2.0.2.</span> <span class="toc-text">2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%93%E5%BC%80proc-c-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E7%BB%99usyscall%E7%BB%93%E6%9E%84%E4%BD%93%E7%94%B3%E8%AF%B7%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.0.2.0.3.</span> <span class="toc-text">3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BE%9D%E6%8D%AE%E6%8F%90%E7%A4%BA-%E6%88%91%E4%BB%AC%E5%9C%A8proc-pagetable%E4%B8%AD%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84-%E6%B3%A8%E6%84%8F-%E5%A6%82%E6%9E%9C%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5%E6%98%AF%E8%A6%81%E6%8A%8A%E4%B9%8B%E5%89%8D%E4%BF%A9%E9%83%BD%E7%BB%99%E5%8F%96%E6%B6%88%E6%8E%89"><span class="toc-number">3.0.2.0.4.</span> <span class="toc-text">4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96usyscall%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.2.0.5.</span> <span class="toc-text">5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E7%9A%84%E6%97%B6%E5%80%99-free%E6%8E%89%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%8A%E8%BF%99%E4%B8%80%E9%A1%B5%E4%B9%9Ffree%E6%8E%89"><span class="toc-number">3.0.2.0.6.</span> <span class="toc-text">6) 进程结束的时候,free掉进程的时候把这一页也free掉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E7%9A%84%E6%97%B6%E5%80%99-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E6%8A%8A%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%BB%99%E5%8F%96%E6%B6%88%E6%8E%89"><span class="toc-number">3.0.2.0.7.</span> <span class="toc-text">7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-2-Print-a-page-table"><span class="toc-number">3.1.</span> <span class="toc-text">Lab3_2 Print a page table</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA-%E5%9C%A8exec%E7%9A%84return-argc%E4%B9%8B%E5%89%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AE%B5"><span class="toc-number">3.1.0.0.1.</span> <span class="toc-text">1) 根据提示,在exec的return argc之前添加一段:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8def-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Evmprint%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.0.0.2.</span> <span class="toc-text">2) 在def.h中添加对于vmprint的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9vm-c-%E4%BB%BF%E7%85%A7freewalk%E6%94%B9%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.0.3.</span> <span class="toc-text">3) 修改vm.c,仿照freewalk改造函数.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-3-Detecting-which-pages-have-been-accessed"><span class="toc-number">3.2.</span> <span class="toc-text">Lab3_3 Detecting which pages have been accessed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%82%E9%98%85RISC-V%E6%89%8B%E5%86%8C-%E7%A1%AE%E5%AE%9APTE-A%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.0.0.1.</span> <span class="toc-text">1) 参阅RISC-V手册,确定PTE_A是什么.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%8C%E6%88%90sys-pgaccess-%E5%9C%A8%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0-%E5%88%A9%E7%94%A8argaddr%E5%92%8Cargint%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.0.0.2.</span> <span class="toc-text">2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96%E5%BD%93%E5%89%8D%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0-walk"><span class="toc-number">3.2.0.0.3.</span> <span class="toc-text">3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%BB%E5%8F%96%E6%8E%A5%E7%9D%80%E6%A0%B9%E6%8D%AEpte%E8%A1%A8%E9%A1%B9-%E6%89%BE%E5%88%B0PTE-A%E4%BD%8D"><span class="toc-number">3.2.0.0.4.</span> <span class="toc-text">4) 读取接着根据pte表项,找到PTE_A位.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Xv6-and-Trap"><span class="toc-number">4.</span> <span class="toc-text">4:Xv6 and Trap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-1-RISC-V-Assembly"><span class="toc-number">4.1.</span> <span class="toc-text">Lab4_1 RISC-V Assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-2-BackTrace"><span class="toc-number">4.2.</span> <span class="toc-text">Lab4_2 BackTrace</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8def-h%E6%B7%BB%E5%8A%A0backtrace-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.0.0.1.</span> <span class="toc-text">1) 在def.h添加backtrace()函数的声明.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-GCC-%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E5%BD%93%E5%89%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%A7%E6%8C%87%E9%92%88%E5%AD%98%E5%82%A8%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8s0%E4%B8%AD-s0%E5%B0%B1%E5%AF%B9%E5%BA%94%E4%B8%8A%E9%9D%A2%E7%9A%84fp%E6%8C%87%E9%92%88"><span class="toc-number">4.2.0.0.2.</span> <span class="toc-text">2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%88%90backtrace"><span class="toc-number">4.2.0.0.3.</span> <span class="toc-text">3) 完成backtrace()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-3-Alarm"><span class="toc-number">4.3.</span> <span class="toc-text">Lab4_3 Alarm</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#test0%EF%BC%9A%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.0.0.1.</span> <span class="toc-text">test0：调用处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#test1-test2-%E6%81%A2%E5%A4%8D%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.0.0.2.</span> <span class="toc-text">test1&#x2F;test2(): 恢复中断的代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8user-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.0.0.3.</span> <span class="toc-text">1) 在user.h中添加声明:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8user-pl%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E4%BB%A5%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.0.0.4.</span> <span class="toc-text">2) 在user.pl添加函数入口以生成汇编代码.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8syscall-h%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7-1"><span class="toc-number">4.3.0.0.5.</span> <span class="toc-text">3) 在syscall.h添加系统调用号.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8syscall-c%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.0.0.6.</span> <span class="toc-text">4) 在syscall.c中添加关于这两个系统调用的声明.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8proc%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98-%E4%BF%9D%E5%AD%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%AD%E6%96%AD-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88-%E8%BF%87%E5%A4%9A%E4%B9%85%E5%B0%B1%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E4%B8%AD%E6%96%AD-%E8%BF%98%E4%BF%9D%E5%AD%98%E4%B8%AD%E6%96%AD%E7%9A%84%E6%97%B6%E5%80%99%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88%E5%92%8C%E4%BF%9D%E5%AD%98%E7%9A%84%E6%A0%88%E5%B8%A7"><span class="toc-number">4.3.0.0.7.</span> <span class="toc-text">5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%9C%A8allocproc%E5%87%BD%E6%95%B0%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%99%E4%BA%9B%E6%88%90%E5%91%98"><span class="toc-number">4.3.0.0.8.</span> <span class="toc-text">6) 在allocproc函数中初始化这些成员.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%AE%8C%E6%88%90sigalarm%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E5%81%9A%E6%B3%95%E5%B0%B1%E6%98%AF%E4%BB%8E%E5%AF%84%E5%AD%98%E5%99%A8%E8%8E%B7%E5%BE%97%E5%8F%82%E6%95%B0%E7%84%B6%E5%90%8E%E8%B5%8B%E5%80%BC%E7%BB%99proc%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AD"><span class="toc-number">4.3.0.0.9.</span> <span class="toc-text">7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%AE%8C%E6%88%90%E6%97%B6%E9%92%9F"><span class="toc-number">4.3.0.0.10.</span> <span class="toc-text">8) 完成时钟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%AE%8C%E6%88%90%E8%BF%94%E5%9B%9E%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.0.0.11.</span> <span class="toc-text">9) 完成返回的操作.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Xv6-and-MultiThread"><span class="toc-number">5.</span> <span class="toc-text">6:Xv6 and MultiThread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-1-Uthread-switching-between-threads"><span class="toc-number">5.1.</span> <span class="toc-text">Lab6_1 Uthread: switching between threads</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9thread-switch%E7%9A%84%E4%BB%A3%E7%A0%81-%E6%B7%BB%E5%8A%A0%E4%B8%8A%E5%85%B3%E4%BA%8Ethread-switch-%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%8F%AA%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%98-%E6%81%A2%E5%A4%8Dcallee-save-register"><span class="toc-number">5.1.0.0.1.</span> <span class="toc-text">1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8Thread%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.0.0.2.</span> <span class="toc-text">2) 在Thread的数据结构中添加寄存器信息.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%AF%B9ra%E5%92%8Csp%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%85%B6%E4%B8%ADra%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%96%AD%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80-%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-%E5%BD%93%E8%BF%99%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%BB%8E%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C-%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99ra"><span class="toc-number">5.1.0.0.3.</span> <span class="toc-text">3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8switch%E5%87%BD%E6%95%B0-%E5%88%87%E6%8D%A2-%E5%85%B6%E4%B8%ADt%E6%98%AF%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B-next-thread%E6%98%AF%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.0.0.4.</span> <span class="toc-text">4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-2-Using-Thread"><span class="toc-number">5.2.</span> <span class="toc-text">Lab6_2 Using Thread.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-3-Barrier"><span class="toc-number">5.3.</span> <span class="toc-text">Lab6_3 Barrier</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Xv6-and-Networking"><span class="toc-number">6.</span> <span class="toc-text">7:Xv6 and Networking</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.0.0.0.2.</span> <span class="toc-text">你的工作.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">6.0.0.0.3.</span> <span class="toc-text">提示</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Xv6-and-Lock"><span class="toc-number">7.</span> <span class="toc-text">8:Xv6 and Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab8-1-Memory-Access"><span class="toc-number">7.1.</span> <span class="toc-text">Lab8_1 Memory Access.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8C%89%E7%85%A7%E6%8F%90%E7%A4%BA-%E6%9B%B4%E6%94%B9%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84-%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E5%86%85%E5%AD%98%E5%9D%97%E9%83%BD%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E9%94%81-%E6%98%AF%E6%AF%8F%E4%B8%AACPU%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E9%94%81"><span class="toc-number">7.1.0.0.1.</span> <span class="toc-text">1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%94%B9%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E9%94%81"><span class="toc-number">7.1.0.0.2.</span> <span class="toc-text">2) 改为初始化所有锁.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96CPU%E7%9A%84id-%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%9C%B0%E6%96%B9%E8%8E%B7%E5%8F%96id%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E5%85%B3%E4%B8%AD%E6%96%AD-%E9%98%B2%E6%AD%A2%E5%9B%A0%E4%B8%BA%E4%B8%AD%E6%96%AD%E5%88%86%E9%85%8D%E7%BB%99%E5%85%B6%E4%BB%96CPU%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E4%BA%86"><span class="toc-number">7.1.0.0.3.</span> <span class="toc-text">3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%B9%E4%BA%8Ekalloc%E5%92%8Ckfree%E7%9A%84%E9%94%81%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BF%9B%E5%85%A5%E6%94%B9%E6%88%90%E5%AF%B9%E4%BA%8ECPU%E4%B8%BAid%E7%9A%84%E9%82%A3%E4%B8%AA%E9%94%81"><span class="toc-number">7.1.0.0.4.</span> <span class="toc-text">4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8if-r-%E7%9A%84%E5%90%8E%E9%9D%A2%E6%B7%BB%E5%8A%A0else-%E4%BB%A3%E8%A1%A8%E5%A6%82%E6%9E%9C%E5%AF%BB%E6%89%BE%E5%A4%B1%E8%B4%A5-%E5%B0%B1%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E6%A0%B8%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">7.1.0.0.5.</span> <span class="toc-text">5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Xv6-File-System"><span class="toc-number">8.</span> <span class="toc-text">9:Xv6 &amp; File System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab-9-1-Large-files"><span class="toc-number">8.1.</span> <span class="toc-text">Lab 9_1 Large files</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">8.1.0.0.1.</span> <span class="toc-text">1) 修改直接映射的数量.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E5%BA%94%E7%9A%84file-h%E7%9A%84inode%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%9F%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%94%B9"><span class="toc-number">8.1.0.0.2.</span> <span class="toc-text">2) 对应的file.h的inode结构体也要进行更改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%98%85%E8%AF%BBbmap%E7%9A%84%E4%BB%A3%E7%A0%81-0-NDIRECT-1-%E7%9B%B4%E6%8E%A5-NDIRECT-NDIRECT-NINDIRECT-1-%E4%B8%80%E7%BA%A7%E9%97%B4%E6%8E%A5"><span class="toc-number">8.1.0.0.3.</span> <span class="toc-text">3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E4%BD%9C%E5%87%BA%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">8.1.0.0.4.</span> <span class="toc-text">4) 依葫芦画瓢作出二级索引.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%8C%E6%88%90%E7%B4%A2%E5%BC%95%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">8.1.0.0.5.</span> <span class="toc-text">5) 完成索引的释放.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab9-2-Symbolic-links"><span class="toc-number">8.2.</span> <span class="toc-text">Lab9_2 Symbolic links</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E7%95%A5"><span class="toc-number">8.2.0.0.1.</span> <span class="toc-text">1) 添加系统调用.(略)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8C%89%E7%85%A7%E5%AE%9E%E9%AA%8C%E6%8F%90%E7%A4%BA%E7%9A%84%E4%BF%A1%E6%81%AF-%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%8F-%E7%95%A5"><span class="toc-number">8.2.0.0.2.</span> <span class="toc-text">2) 按照实验提示的信息,添加两个新的宏.(略)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%88%90symlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.2.0.0.3.</span> <span class="toc-text">3) 完成symlink系统调用.</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
  
</aside>

          
          <section id="main"><article id="post-mit-6-s081-lab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2023/02/08/mit-6-s081-lab/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2023-02-08T03:02:54.000Z" itemprop="datePublished">2023-02-08</time>
    <time style="display: none;" id="post-update-time">2024-03-25</time>
  </a>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" data-aos="zoom-in">实验记录</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="1-Xv6-and-Unix-utilities"><a href="#1-Xv6-and-Unix-utilities" class="headerlink" title="1:Xv6 and Unix utilities"></a>1:Xv6 and Unix utilities</h1><p>运行环境:Ubuntu 20.04 qemu</p>
<p>在做6.s081的实验之前我们首先要先下载Xv6操作系统以及qemu虚拟机:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<h2 id="Lab1-1-Boot-xv6"><a href="#Lab1-1-Boot-xv6" class="headerlink" title="Lab1_1:Boot xv6"></a>Lab1_1:Boot xv6</h2><p>运行并安全退出xv6系统:</p>
<p>运行的方法很简单:cd进xv6的文件夹里面,然后输入`make qemu`即可,输入完之后就是进入了xv6的系统里面了</p>
<p>退出的方法就是,先Ctrl+A,再输入x即可.</p>
<h2 id="Lab1-2-sleep"><a href="#Lab1-2-sleep" class="headerlink" title="Lab1_2 sleep"></a>Lab1_2 sleep</h2><p>本实验要为 xv6 实现 UNIX 程序 sleep； 您的睡眠应暂停用户指定的滴答数。 滴答是 xv6 内核定义的时间概念，即来自定时器芯片的两次中断之间的时间。</p>
<p>一些提示：</p>
<ul>
<li>在开始编码之前，请阅读<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 书籍</a>第 1 章。（中文版<a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1QmK2EgNgYEniHJnn2jidtNsK1uclZ9KM/view?usp=sharing">xv6 书籍</a>)</li>
<li>查看<code>user/</code>中的其他一些程序 （例如，<code>user/echo.c</code>、<code>user/grep.c</code>和<code>user/rm.c</code>）以了解如何获取传递给程序的命令行参数。</li>
<li>如果用户忘记传递参数， sleep 应该打印错误消息。</li>
<li>命令行参数作为字符串传递；您可以使用<code>atoi</code>将其转换为整数（请参阅 user&#x2F;ulib.c）。</li>
<li>使用系统调用<code>sleep</code>。</li>
<li>确保<code>main</code>调用<code>exit()</code>以退出您的程序。</li>
<li>将你的<code>睡眠</code>程序添加到Makefile 中的<code>UPROGS</code>；完成后，<code>make qemu</code>将编译您的程序，您将能够从 xv6 shell 运行它。</li>
<li>查看 Kernighan 和 Ritchie 的书*The C programming language (second edition)*（K&amp;R）以了解 C。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc,char \*argv[])&#123;</span><br><span class="line">  for(int i=0;!argv[i];i++)&#123;</span><br><span class="line">    if(argv[1][i]&gt;&#x27;9&#x27;argv[1][i]&lt;&#x27;0&#x27;)&#123;</span><br><span class="line">      write(1, &quot;error\\n&quot;, 6);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int times=atoi(argv[1]);</span><br><span class="line">  sleep(times);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先我们知道在C语言中argc代表传入的参数数,argv是传入的参数.</li>
</ul>
<p>第一个for循环就是判断这个是不是一个正常的数字(什么时候结束循环呢?),第二步用atoi函数转化成数字,最后执行系统调用sleep.</p>
<h2 id="Lab1-3-pingpong"><a href="#Lab1-3-pingpong" class="headerlink" title="Lab1_3 pingpong"></a>Lab1_3 pingpong</h2><p>编写一个程序，使用 UNIX 系统调用在两个进程之间通过一对管道“乒乓”一个字节，每个管道一个。 父母应该向孩子发送一个字节； 子进程应该打印“: received ping”，其中 是它的进程 ID，将管道上的字节写入父进程，然后退出； 父母应该从孩子那里读取字节，打印“: received pong”，然后退出。</p>
<p>一些提示：</p>
<ul>
<li>使用管道创建管道。</li>
<li>使用 fork 创建一个孩子。</li>
<li>使用 read 从管道读取，并使用 write 写入管道。</li>
<li>使用 getpid 查找调用进程的进程 ID。</li>
<li>将程序添加到 Makefile 中的 UPROGS。</li>
<li>xv6 上的用户程序有一组有限的库函数可供它们使用。 可以在 user&#x2F;user.h 中看到列表； 源（系统调用除外）位于 user&#x2F;ulib.c、user&#x2F;printf.c 和 user&#x2F;umalloc.c。</li>
</ul>
<p>我们可以认为pipe是一个Linux进程间通讯的一种方式,一个管道以一个两位的int类型数组构成,其中第一个元素是读端的接口编号,第二个元素是写端的接口编号.然后可以使用read和write来进行读取,注意管道的端口有读端口和写端口之分,读的时候只能从读端口读数据,写的时候只能从写的端口写数据.</p>
<p>有点像我们之前操作系统课上面学到的缓冲区的结构,缓冲区有两端,一端读一端写.</p>
<p>系统调用:<br>可以使用pipe(一个二位的数组)来初始化一个管道.经过pipe了之后,第一个元素就是一个读取的端口,第二个元素就是对应写入的端口,<br>可以使用read(读端口,读出来的元素写在哪里,长度)来从一个读的端口读出元素<br>可以使用write(写端口,写出来的元素写在哪里,长度)来把元素写进一个端口.</p>
<p>fork函数就是一次调用,两次返回,调用之后父进程和子进程都从获得函数的返回值开始继续往下运行,就像一条河流,遇到了一个分叉口,河流分成了两叉,这两叉都从分叉口开始继续往下流.在这里分叉口就像fork()调用,调用生成了两个分叉,两个分叉都从fork()调用结束后继续往下走.</p>
<p><img src="https://img-blog.csdn.net/20161223173958916"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int p_filedes[2],s_filedes[2];</span><br><span class="line">  pipe(p_filedes);</span><br><span class="line">  pipe(s_filedes);</span><br><span class="line">  char buf[4];</span><br><span class="line">  if(fork()==0)&#123;</span><br><span class="line">    read(p_filedes[0],buf,4);</span><br><span class="line">    printf(&quot;%d: received %s\\n&quot;,getpid(),buf);</span><br><span class="line">    write(s_filedes[1],&quot;pong&quot;,4);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    write(p_filedes[1],&quot;ping&quot;,4);</span><br><span class="line">    read(s_filedes[0],buf,4);</span><br><span class="line">    printf(&quot;%d: received %s\\n&quot;,getpid(),buf);</span><br><span class="line">  &#125;</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的思路就是先初始化两根管道,接着父进程先read再写,子进程先写再read.</p>
<h2 id="Lab1-4-prime"><a href="#Lab1-4-prime" class="headerlink" title="Lab1_4 prime"></a>Lab1_4 prime</h2><p>编写一个程序,完成一个并发版本的prime初筛,第一个进程负责把2-35范围内的素数输入进管道,对于每一个素数,我们都需要fork一个进程来接受管道的数字然后输出出来.</p>
<ul>
<li>关闭进程不需要的文件描述符，否则你的程序将在第一个进程达到 35 之前耗尽 xv6 的资源。</li>
<li>一旦第一个进程达到 35，它应该等到整个管道终止，包括所有子、孙等。因此，主素数进程应该只在所有输出都被打印出来，并且在所有其他素数进程都退出之后才退出。</li>
<li>当管道的写端关闭时，read 返回零。</li>
<li>将 32 位（4 字节）整数直接写入管道是最简单的，而不是使用格式化的 ASCII I&#x2F;O。</li>
<li>您应该仅在需要时在管道中创建流程。</li>
<li>将程序添加到 Makefile 中的 UPROGS。</li>
</ul>
<p>基本的思路在下面,每一个进程对应一个素数,主进程负责传输2-34的数据给子进程们,每个进程对应一个素数,如果这个数%这个素数不为0的话就可以传给下一级的进程,如果没有下一级的进程那么fork一个新的进程,这个数一定是素数,这个进程就会接着处理来自左边邻居的数据,处理的方式.这样子每一个进程就像一个筛子,筛选不可能是素数的数.</p>
<p>总的来说主进程的数据首先从左到右到第一个子进程,判断能不能被2除,不可以就继续从左到右交给下一个子进程,判断能不能被3除…,如果下一个子进程是不存在的,那么新建一个进程,这个进程就代表对应数.</p>
<p><img src="https://pic3.zhimg.com/80/v2-cfd5f86fa2495b79eabf8bdaa24925f2_1440w.jpg"></p>
<h2 id="Lab1-5-find"><a href="#Lab1-5-find" class="headerlink" title="Lab1_5 find"></a>Lab1_5 find</h2><p>编写一个简单版本的 UNIX 查找程序：查找目录树中具有特定名称的所有文件。给定对应的文件名以及文件名在目录,找到文件名的位置.</p>
<ul>
<li>查看 user&#x2F;ls.c 以了解如何读取目录。</li>
<li>使用递归允许 find 访问到子目录。</li>
<li>不要递归到“.” 和 ”..”。</li>
<li>对文件系统的更改在 qemu 运行中持续存在； 要获得一个干净的文件系统，请运行 make clean 然后 make qemu。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct dirent &#123;</span><br><span class="line">  ushort inum;</span><br><span class="line">  char name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面是文件系统中关于目录文件内容的说明,inum说明这个文件占用了几个inode.该操作系统类似于Linux系统,磁盘分成磁盘块,磁盘块的一些相关控制信息就储存在存放在内存中的inode.文件系统获得文件,先找到文件的file结构,根据file结构找到inode,再根据inode找到磁盘块.</li>
</ul>
<p>说白了目录文件存储的就是一堆dirent类型的结构体.</p>
<p>下面就是stat信息,stat信息存放了文件的一些控制信息,比如说链接信息,大小和类型之类的.在我们利用open打开文件后,open函数会返回一个数字,我们再利用fstat这个调用找到stat控制块.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">  int dev;     // File system&#x27;s disk device</span><br><span class="line">  uint ino;    // Inode number</span><br><span class="line">  short type;  // Type of file</span><br><span class="line">  short nlink; // Number of links to file</span><br><span class="line">  uint64 size; // Size of file in bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先来看看xv6是如何完成对ls指令的支持的?</p>
<p>首先第一个函数:根据文件的的路径名提取出文件的名字,就是从后往前遍历,找到第一个‘&#x2F;’,这之间的那一部分就是文件的名字.</p>
<p>接着就是ls函数,ls函数中只需要提供当前的path,找到path里面的所有文件即可.首先先打开当前path对应的文件(Linux内部目录文件和普通的文件都是文件),再利用fstat系统调用找到stat的值.由于目录文件里面就是连续地存储了一堆dirent类型的结构体,那我们可以把目录文件的内容当成一个struct dirent<a href="%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84,%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%8E%BB%E8%AF%BB">MAX</a></p>
<p>最后就是main函数,就是看看输入的指令罢了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/stat.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line">#include &quot;kernel/fs.h&quot;</span><br><span class="line"></span><br><span class="line">char\* fmtname(char \*path)</span><br><span class="line">&#123;</span><br><span class="line">  static char buf[DIRSIZ+1];</span><br><span class="line">  char \*p;</span><br><span class="line"></span><br><span class="line">  // Find first character after last slash.</span><br><span class="line">  for(p=path+strlen(path); p &gt;= path &amp;&amp; \*p != &#x27;/&#x27;; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  // Return blank-padded name.</span><br><span class="line">  if(strlen(p) &gt;= DIRSIZ)</span><br><span class="line">    return p;</span><br><span class="line">  memmove(buf, p, strlen(p));</span><br><span class="line">  memset(buf+strlen(p), &#x27; &#x27;, DIRSIZ-strlen(p));</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ls(char \*path)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[512], \*p;</span><br><span class="line">  int fd;</span><br><span class="line">  struct dirent de;</span><br><span class="line">  struct stat st;</span><br><span class="line"></span><br><span class="line">  if((fd = open(path, 0)) &lt; 0)&#123;</span><br><span class="line">    fprintf(2, &quot;ls: cannot open %s\\n&quot;, path);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(fstat(fd, &amp;st) &lt; 0)&#123;</span><br><span class="line">    fprintf(2, &quot;ls: cannot stat %s\\n&quot;, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch(st.type)&#123;</span><br><span class="line">  case T_FILE:</span><br><span class="line">    printf(&quot;%s %d %d %l\\n&quot;, fmtname(path), st.type, st.ino, st.size);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  case T_DIR:</span><br><span class="line">    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;</span><br><span class="line">      printf(&quot;ls: path too long\\n&quot;);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    strcpy(buf, path);</span><br><span class="line">    p = buf+strlen(buf);</span><br><span class="line">    \*p++ = &#x27;/&#x27;;</span><br><span class="line">    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;</span><br><span class="line">      if(de.inum == 0)</span><br><span class="line">        continue;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = 0;</span><br><span class="line">      if(stat(buf, &amp;st) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;ls: cannot stat %s\\n&quot;, buf);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;%s %d %d %d\\n&quot;, fmtname(buf), st.type, st.ino, st.size);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char \*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  if(argc &lt; 2)&#123;</span><br><span class="line">    ls(&quot;.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  for(i=1; i&lt;argc; i++)</span><br><span class="line">    ls(argv[i]);</span><br><span class="line">  exit(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们就可以对ls指令稍微修改修改,ls只用找当前目录第一层的所有文件,那么我们也是找当前目录的所有文件,对于目录文件,我们继续往下搜索这个目录,对于普通文件,我们只用看名字是否匹配即可.</p>
<h2 id="Lab1-6-xargs"><a href="#Lab1-6-xargs" class="headerlink" title="Lab1_6 xargs"></a>Lab1_6 xargs</h2><p>这个指令就是我们要把若干条指令合并在一块进行执行.其中前面指令的standard out会作为下一条的指令一个输入来进行执行.</p>
<p>举个例子:前面指令的hello too作为standard out作为下一条指令的输入.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello too  xargs echo bye</span><br><span class="line">$ bye hello too</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 fork 和 exec 对每一行输入调用命令。 在父级中使用 wait 等待子级完成命令。</li>
<li>要读取单行输入，请一次读取一个字符，直到出现换行符 (‘\n’)。</li>
<li>kernel&#x2F;param.h 声明了 MAXARG，如果您需要声明 argv 数组，这可能很有用。</li>
<li>对文件系统的更改在 qemu 运行中持续存在； 要获得一个干净的文件系统，请运行 make clean 然后 make qemu。</li>
<li>将程序添加到 Makefile 中的 UPROGS。</li>
</ul>
<p>首先第一步把指令xargs给删除掉:然后把标准输出(来源:0)获取下来,放入最后一个参数中进行执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel/types.h&quot;</span><br><span class="line">#include &quot;kernel/param.h&quot;</span><br><span class="line">#include &quot;user/user.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char \*argv[])&#123;</span><br><span class="line">    char\* argvs[MAXARG];</span><br><span class="line">    for(int i=1;i&lt;argc;i++)&#123;</span><br><span class="line">        argvs[i-1]=argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[512];</span><br><span class="line">    int index;</span><br><span class="line">    int read_len;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        index = -1;</span><br><span class="line">        do&#123;</span><br><span class="line">            index++;</span><br><span class="line">            read_len=read(0,&amp;buf[index],sizeof(char));</span><br><span class="line">        &#125;while(read_len&gt;0&amp;&amp;buf[index]!=&#x27;\\n&#x27;);</span><br><span class="line">        if(read_len==0&amp;&amp;index==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[index]=&#x27;\\0&#x27;;</span><br><span class="line">        argvs[argc-1]=buf;</span><br><span class="line">         if (fork() == 0) &#123;</span><br><span class="line">            exec(argvs[0], argvs);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Xv6-and-Syscall"><a href="#2-Xv6-and-Syscall" class="headerlink" title="2:Xv6 and Syscall"></a>2:Xv6 and Syscall</h1><h2 id="Lab2-1-Trace"><a href="#Lab2-1-Trace" class="headerlink" title="Lab2_1 Trace."></a>Lab2_1 Trace.</h2><p>实验2_1主要是完成一个新的系统调用,这个系统调用主要的功能就是追踪,主要就是创建一个新的跟踪系统调用来控制跟踪,它应该采用一个参数,一个整数“掩码”,其位指定要跟踪的系统调用.比如说跟踪fork系统调用就会调用trace(1&lt;&lt;SYS_USER_FORK).我们需要修改 xv6 内核以在每个系统调用即将返回时打印出一行.该行应包含进程id、系统调用的名称和返回值,我们还必须对这个进程以及所有子进程进行跟踪.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//trace.c</span><br><span class="line">int main(int argc, char \*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  char \*nargv[MAXARG];</span><br><span class="line"></span><br><span class="line">  if(argc &lt; 3  (argv[1][0] &lt; &#x27;0&#x27;  argv[1][0] &gt; &#x27;9&#x27;))&#123;</span><br><span class="line">    fprintf(2, &quot;Usage: %s mask command\\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (trace(atoi(argv[1])) &lt; 0) &#123;</span><br><span class="line">    fprintf(2, &quot;%s: trace failed\\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">    nargv[i-2] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[0], nargv);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在调用trace的时候,首先判断输入参数的合法性,然后再进行trace操作,接着再执行剩下的操作.这个时候trace就是一个系统调用,我们需要完成系统调用.</p>
<p>现在我们开始实验:</p>
<h5 id="1-在user-h中添加对于trace函数的支持"><a href="#1-在user-h中添加对于trace函数的支持" class="headerlink" title="1) 在user.h中添加对于trace函数的支持."></a>1) 在user.h中添加对于trace函数的支持.</h5><p>这里面存储了所有user函数会调用的系统调用.</p>
<h5 id="2-添加一个entry在user-pl里面"><a href="#2-添加一个entry在user-pl里面" class="headerlink" title="2) 添加一个entry在user.pl里面"></a>2) 添加一个entry在user.pl里面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/perl -w</span><br><span class="line"></span><br><span class="line"># Generate usys.S, the stubs for syscalls.</span><br><span class="line"></span><br><span class="line">print &quot;# generated by usys.pl - do not edit\\n&quot;;</span><br><span class="line"></span><br><span class="line">print &quot;#include \\&quot;kernel/syscall.h\\&quot;\\n&quot;;</span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print &quot;.global $name\\n&quot;;</span><br><span class="line">    print &quot;$&#123;name&#125;:\\n&quot;;</span><br><span class="line">    print &quot; li a7, SYS_$&#123;name&#125;\\n&quot;;</span><br><span class="line">    print &quot; ecall\\n&quot;;</span><br><span class="line">    print &quot; ret\\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">entry(&quot;fork&quot;);</span><br><span class="line">entry(&quot;exit&quot;);</span><br><span class="line">entry(&quot;wait&quot;);</span><br><span class="line">entry(&quot;pipe&quot;);</span><br><span class="line">entry(&quot;read&quot;);</span><br><span class="line">entry(&quot;write&quot;);</span><br><span class="line">entry(&quot;close&quot;);</span><br><span class="line">entry(&quot;kill&quot;);</span><br><span class="line">entry(&quot;exec&quot;);</span><br><span class="line">entry(&quot;open&quot;);</span><br><span class="line">entry(&quot;mknod&quot;);</span><br><span class="line">entry(&quot;unlink&quot;);</span><br><span class="line">entry(&quot;fstat&quot;);</span><br><span class="line">entry(&quot;link&quot;);</span><br><span class="line">entry(&quot;mkdir&quot;);</span><br><span class="line">entry(&quot;chdir&quot;);</span><br><span class="line">entry(&quot;dup&quot;);</span><br><span class="line">entry(&quot;getpid&quot;);</span><br><span class="line">entry(&quot;sbrk&quot;);</span><br><span class="line">entry(&quot;sleep&quot;);</span><br><span class="line">entry(&quot;uptime&quot;);</span><br><span class="line">entry(&quot;trace&quot;);</span><br></pre></td></tr></table></figure>
<p>这个user.pl负责输出汇编代码,这个汇编代码就是user文件夹里面的代码调用系统调用之后由U态进入到S态的过渡代码,主要是构建参数的代码和ecall组成.</p>
<p>执行顺序:调用系统调用-&gt;user.pl生成的代码(U态进入到S态)-&gt;S态的系统调用.</p>
<h5 id="3-在syscall-h添加系统调用号"><a href="#3-在syscall-h添加系统调用号" class="headerlink" title="3) 在syscall.h添加系统调用号"></a>3) 在syscall.h添加系统调用号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// System call numbers</span><br><span class="line">#define SYS_fork    1</span><br><span class="line">#define SYS_exit    2</span><br><span class="line">#define SYS_wait    3</span><br><span class="line">#define SYS_pipe    4</span><br><span class="line">#define SYS_read    5</span><br><span class="line">#define SYS_kill    6</span><br><span class="line">#define SYS_exec    7</span><br><span class="line">#define SYS_fstat   8</span><br><span class="line">#define SYS_chdir   9</span><br><span class="line">#define SYS_dup    10</span><br><span class="line">#define SYS_getpid 11</span><br><span class="line">#define SYS_sbrk   12</span><br><span class="line">#define SYS_sleep  13</span><br><span class="line">#define SYS_uptime 14</span><br><span class="line">#define SYS_open   15</span><br><span class="line">#define SYS_write  16</span><br><span class="line">#define SYS_mknod  17</span><br><span class="line">#define SYS_unlink 18</span><br><span class="line">#define SYS_link   19</span><br><span class="line">#define SYS_mkdir  20</span><br><span class="line">#define SYS_close  21</span><br><span class="line">#define SYS_trace  22</span><br></pre></td></tr></table></figure>
<p>这个文件里面存储了系统调用的调用调用号,在后面这些宏就负责替换为编号.</p>
<h5 id="4-在proc结构体里面添加一个mask成员-用来记录要trace哪种系统调用"><a href="#4-在proc结构体里面添加一个mask成员-用来记录要trace哪种系统调用" class="headerlink" title="4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用."></a>4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用.</h5><h5 id="5-在kernel-sysproc-c里面实现具体的系统调用-在这里你会发现系统调用的实现会保存在这里"><a href="#5-在kernel-sysproc-c里面实现具体的系统调用-在这里你会发现系统调用的实现会保存在这里" class="headerlink" title="5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里."></a>5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_trace(void)</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  if (argint(0, &amp;n) &lt; 0) // get the number of argv[1].</span><br><span class="line">    return -1;</span><br><span class="line">  myproc()-&gt;mask = n;    // save in the mask.</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候可以通过argint系统调用来获得栈帧中保存的寄存器值.然后把寄存器的值保存到mask元素中.</p>
<h5 id="6-更改fork函数-添加mask的复制-np-mask-p-mask"><a href="#6-更改fork函数-添加mask的复制-np-mask-p-mask" class="headerlink" title="6) 更改fork函数,添加mask的复制.np-&gt;mask = p-&gt;mask;"></a>6) 更改fork函数,添加mask的复制.<code>np-&gt;mask = p-&gt;mask;</code></h5><p>这一步的目的就是为了让子进程执行系统调用也可以完成.</p>
<h5 id="7-添加syscall-c中关于trace函数的支持"><a href="#7-添加syscall-c中关于trace函数的支持" class="headerlink" title="7) 添加syscall.c中关于trace函数的支持."></a>7) 添加syscall.c中关于trace函数的支持.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在syscall的函数数组中添加即可.</span><br><span class="line">......</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line">//添加函数声明.</span><br><span class="line">extern uint64 sys_trace(void);</span><br></pre></td></tr></table></figure>
<h5 id="8-更改syscall-c的syscall函数"><a href="#8-更改syscall-c的syscall函数" class="headerlink" title="8) 更改syscall.c的syscall函数"></a>8) 更改syscall.c的syscall函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void)</span><br><span class="line">&#123;</span><br><span class="line">  int num;</span><br><span class="line">  struct proc \*p = myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    if (p-&gt;mask &amp; (1 &lt;&lt; num))</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;%d %s: unknown sys call %d\\n&quot;,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加关于追踪的函数,追踪的方法很简单,因为要追踪的mask是处于第几位的,只需要求一个与看看是不是0即可.</p>
<p>全部过关</p>
<h1 id="Lab2-2-sys-info"><a href="#Lab2-2-sys-info" class="headerlink" title="Lab2_2 sys info"></a>Lab2_2 sys info</h1><p>我们需要完成一个系统调用,给定一个struct sysinfo的指针,然后可以输出当前系统的可用进程数和可用内存数.</p>
<h5 id="1-在makefile-user-pl和user-h添加对于sysinfo系统调用的支持-不懂的请翻阅上面"><a href="#1-在makefile-user-pl和user-h添加对于sysinfo系统调用的支持-不懂的请翻阅上面" class="headerlink" title="1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)"></a>1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)</h5><h5 id="2-统计当前正在使用进程数-定义新函数proc-size-在proc-h中"><a href="#2-统计当前正在使用进程数-定义新函数proc-size-在proc-h中" class="headerlink" title="2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中"></a>2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//return: the proc that are occupied.</span><br><span class="line">int</span><br><span class="line">proc_size()</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  int n = 0;</span><br><span class="line">  for (i = 0; i &lt; NPROC; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (proc[i].state != UNUSED) n++;</span><br><span class="line">  &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法就是对于所有进程(NPROC)进行一遍遍历,如果不是UNUSED,就代表已经使用了</p>
<h5 id="3-统计当前的内存数-定义新函数freememory-在kalloc-h中"><a href="#3-统计当前的内存数-定义新函数freememory-在kalloc-h中" class="headerlink" title="3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中."></a>3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line">freememory()</span><br><span class="line">&#123;</span><br><span class="line">  struct run\* p = kmem.freelist;</span><br><span class="line">  uint64 num = 0;</span><br><span class="line">  while (p)</span><br><span class="line">  &#123;</span><br><span class="line">    num ++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return num \* PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得freelist(物理内存中没有分配的块),然后对链表进行一遍遍历,找到有几个块没有分配,乘以一个块的数量即可.</p>
<h5 id="4-完成sysinfo的操作-注意2-和3-定义的函数要声明在def-h中"><a href="#4-完成sysinfo的操作-注意2-和3-定义的函数要声明在def-h中" class="headerlink" title="4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在def.h中"></a>4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在<code>def.h</code>中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sysinfo(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct sysinfo info;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  // get the the address of the sysinfo structure.</span><br><span class="line">  if (argaddr(0, &amp;addr) &lt; 0) </span><br><span class="line">    return -1;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  //get freemem</span><br><span class="line">  info.freemem = freememory();</span><br><span class="line">  //get the proc</span><br><span class="line">  info.nproc = proc_size();</span><br><span class="line">  // copyto the structure.</span><br><span class="line">  if (copyout(p-&gt;pagetable, addr, (char\*)&amp;info, sizeof(info)) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作主要是,用户会传递指针来,这个指针就指向了sysinfo的结构体,所以说我们需要在内核态获得信息构造一个新的结构体传回去就可以了.</p>
<h5 id="5-像上个实验一样完成syscall-h-syscall-c的支持即可"><a href="#5-像上个实验一样完成syscall-h-syscall-c的支持即可" class="headerlink" title="5) 像上个实验一样完成syscall.h,syscall.c的支持即可."></a>5) 像上个实验一样完成syscall.h,syscall.c的支持即可.</h5><h3 id="3-Xv6-and-PageTable"><a href="#3-Xv6-and-PageTable" class="headerlink" title="3:Xv6 and PageTable"></a>3:Xv6 and PageTable</h3><h3 id="Lab3-1-Speed-Up-the-system-calls"><a href="#Lab3-1-Speed-Up-the-system-calls" class="headerlink" title="Lab3_1 Speed Up the system calls"></a>Lab3_1 Speed Up the system calls</h3><p>一些操作系统（例如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加速某些系统调用。 这消除了在执行这些系统调用时对内核交叉的需要。</p>
<p>创建每个进程时，在 USYSCALL（memlayout.h 中定义的 VA）映射一个只读页面。 在这个页面的开始，存储一个struct ussyscall（也在memlayout.h中定义），并初始化它来存储当前进程的PID。</p>
<ul>
<li>可以在 kernel&#x2F;proc.c 中的 proc_pagetable() 中执行映射。</li>
<li>只读的权限位要确保正确</li>
<li>mappages() 是一个有用的实用程序。</li>
<li>不要忘记在 allocproc() 中分配和初始化页面。</li>
<li>确保在 freeproc() 中释放页面。</li>
</ul>
<h5 id="1-确认usyscall的结构体是什么-其实存储的就是pid"><a href="#1-确认usyscall的结构体是什么-其实存储的就是pid" class="headerlink" title="1) 确认usyscall的结构体是什么,其实存储的就是pid."></a>1) 确认usyscall的结构体是什么,其实存储的就是pid.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct usyscall &#123;</span><br><span class="line">  int pid;  // Process ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-为每个进程结构添加usyscall的元素-这个结构存储在一个新的页里面"><a href="#2-为每个进程结构添加usyscall的元素-这个结构存储在一个新的页里面" class="headerlink" title="2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面."></a>2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面.</h5><h5 id="3-打开proc-c-依葫芦画瓢给usyscall结构体申请一个页面"><a href="#3-打开proc-c-依葫芦画瓢给usyscall结构体申请一个页面" class="headerlink" title="3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面."></a>3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// alloc a page that store usyscall proc</span><br><span class="line">  if((p-&gt;usyss = (struct usyscall \*)kalloc()) == 0)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-依据提示-我们在proc-pagetable中依葫芦画瓢来进行地址的映射-注意-如果映射失败是要把之前俩都给取消掉"><a href="#4-依据提示-我们在proc-pagetable中依葫芦画瓢来进行地址的映射-注意-如果映射失败是要把之前俩都给取消掉" class="headerlink" title="4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉"></a>4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall),</span><br><span class="line">             PTE_R  PTE_U) &lt; 0) &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><br><span class="line">    uvmfree(pagetable, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中mappages(表,虚拟地址,页大小,物理地址,权限)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_V (1L &lt;&lt; 0) // valid</span><br><span class="line">#define PTE_R (1L &lt;&lt; 1)</span><br><span class="line">#define PTE_W (1L &lt;&lt; 2)</span><br><span class="line">#define PTE_X (1L &lt;&lt; 3)</span><br><span class="line">#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br></pre></td></tr></table></figure>
<p>权限的编码有几种方式,分别用五位0-1表示,从左到右都是可运行,可读,可写,只可以内核用,用户可以用.</p>
<h5 id="5-在进程初始化的时候添加初始化的代码-初始化usyscall的结构"><a href="#5-在进程初始化的时候添加初始化的代码-初始化usyscall的结构" class="headerlink" title="5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构."></a>5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构.</h5><p>p-&gt;usyscall-&gt;pid &#x3D; p-&gt;pid;</p>
<h5 id="6-进程结束的时候-free掉进程的时候把这一页也free掉"><a href="#6-进程结束的时候-free掉进程的时候把这一页也free掉" class="headerlink" title="6) 进程结束的时候,free掉进程的时候把这一页也free掉"></a>6) 进程结束的时候,free掉进程的时候把这一页也free掉</h5><p>if (p-&gt;usyss) kfree((void *)p-&gt;usyss);<br>p-&gt;usyss &#x3D; 0;</p>
<h5 id="7-进程结束的时候-依葫芦画瓢把映射关系给取消掉"><a href="#7-进程结束的时候-依葫芦画瓢把映射关系给取消掉" class="headerlink" title="7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉."></a>7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉.</h5><p>uvmunmap(pagetable, USYSCALL, 1, 0);</p>
<h2 id="Lab3-2-Print-a-page-table"><a href="#Lab3-2-Print-a-page-table" class="headerlink" title="Lab3_2 Print a page table"></a>Lab3_2 Print a page table</h2><p>在这部分实验中，您将向 xv6 添加一个新功能，该功能通过检查 RISC-V 页表中的访问位来检测并向用户空间报告此信息。定义一个名为 vmprint() 的函数。 它应该接受一个 pagetable_t 参数，并以下面描述的格式打印该页表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000//二级页表</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000//二级页表的表项,进入一级页表</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000//一级页表的表项,进入页表</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>
<p>在exec.c中的_return argc;<em>之前插入_if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable)</em> 语句来输出第一个进程的页表.</p>
<p>首先要确定的第一点就是,这个页表其实实际上是一种多级页表的结构,就是二级页表存储的表项(PPN)其实是一级页表的第一个PTE的地址,一级页表的表项才是pa.具体的多级页表的解释可以参考我其他的博客或者翻阅操作系统或者组员书.</p>
<p>首先我们知道,PTE是一个长度为64的整数而已.其中存储了各种各样的信息,这些信息可以通过调用宏来实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10</span><br><span class="line">#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span><br><span class="line">#define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span><br></pre></td></tr></table></figure>
<p>其实本质上来说,就是xv6系统的PTE除去后10位和前12位就是pa.</p>
<p>所以说这个东西就可以转化为基本的递归.对于二级页表,对于每一个表项就进入到一级页表再遍历.所以说本质上这就是一个树,二级页表作为根,有若干个儿子,也就是一级页表,一级页表也有若干个儿子…那遍历树怎么遍历,一般来说就是用递归的手段</p>
<p>● 可以将vmprint( )放在kernel&#x2F;vm.c中。<br>● 使用kernel&#x2F;riscv.h文件末尾的宏。<br>● 函数freewalk可能是鼓舞人心的（可以仿照该函数来写vmprint）。<br>● 在kernel&#x2F;defs.h中定义vmprint的原型，以便可以从exec.c调用它。<br>● 在printf调用中使用%p输出完整的64位十六进制PTE和地址，如示例所示。</p>
<h5 id="1-根据提示-在exec的return-argc之前添加一段"><a href="#1-根据提示-在exec的return-argc之前添加一段" class="headerlink" title="1) 根据提示,在exec的return argc之前添加一段:"></a>1) 根据提示,在exec的return argc之前添加一段:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-pid==1)&#123;</span><br><span class="line">  vmprint(p-&gt;pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-在def-h中添加对于vmprint的定义"><a href="#2-在def-h中添加对于vmprint的定义" class="headerlink" title="2) 在def.h中添加对于vmprint的定义"></a>2) 在def.h中添加对于vmprint的定义</h5><h5 id="3-修改vm-c-仿照freewalk改造函数"><a href="#3-修改vm-c-仿照freewalk改造函数" class="headerlink" title="3) 修改vm.c,仿照freewalk改造函数."></a>3) 修改vm.c,仿照freewalk改造函数.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void vmprintlevel(pagetable_t pt, int level) &#123;</span><br><span class="line">    char \*delim = 0;</span><br><span class="line">    if (level == 2) delim = &quot;..&quot;;</span><br><span class="line">    if (level == 1) delim = &quot;.. ..&quot;;</span><br><span class="line">    if (level == 0) delim = &quot;.. .. ..&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 512; i++) &#123;</span><br><span class="line">        pte_t pte = pt[i];</span><br><span class="line">        if ((pte &amp; PTE_V)) &#123;</span><br><span class="line">            //  this PTE points to a lower level page table.</span><br><span class="line">            printf(&quot;%s%d: pte %p pa %p\\n&quot;, delim, i, pte, PTE2PA(pte));</span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            if ((pte &amp; (PTE_RPTE_WPTE_X)) == 0) &#123;</span><br><span class="line">                vmprintlevel((pagetable_t)child, level - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vmprint(pagetable_t pt) &#123;</span><br><span class="line">    printf(&quot;page table %p\\n&quot;, pt);</span><br><span class="line">    vmprintlevel(pt, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思想就是递归,递归获得下一级的地址,本质上是一个DFS.有下一级的页表就进入下一级进行遍历.</p>
<h2 id="Lab3-3-Detecting-which-pages-have-been-accessed"><a href="#Lab3-3-Detecting-which-pages-have-been-accessed" class="headerlink" title="Lab3_3 Detecting which pages have been accessed"></a>Lab3_3 Detecting which pages have been accessed</h2><p>在本部分的实验中，你将向xv6添加一个新特性，通过检查RISC-V页表中的访问位来获取信息并向用户空间报告这些信息。</p>
<p>实现pgaccess()函数，它是一个系统调用,会返回哪些页面已经被访问.其中第一个参数就是从哪个虚拟地址开始检查,第二个参数就是检查几个页面,结果传递给第三个参数,第三个参数是位掩码,其中第几位为1表示第几个页面已经被访问了.</p>
<p>● 首先在kernel&#x2F;sysproc.c中实现sys_pgaccess( )。<br>● 你需要使用argaddr()和argint()解析参数。<br>● 对于输出位掩码，在内核中存储一个临时缓冲区并在填充正确的位后将其复制给用户（通过copyout()）更容易。<br>● 可以设置可扫描页数的上限。<br>● kernel&#x2F;vm.c中的walk()对于查找正确的PTE非常有用。<br>● 你需要在kernel&#x2F;riscv.h中定义PTE_A，即访问位。请参阅RISC-V手册以确定其值。<br>● 如果PTE_A已设置，在检查后务必清除它。否则，将无法确定自上次调用pgaccess()以来是否访问了页面（即，该位将被永久设置）。<br>● 利用vmprint()可方便地调试页表。</p>
<h5 id="1-参阅RISC-V手册-确定PTE-A是什么"><a href="#1-参阅RISC-V手册-确定PTE-A是什么" class="headerlink" title="1) 参阅RISC-V手册,确定PTE_A是什么."></a>1) 参阅RISC-V手册,确定PTE_A是什么.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_A (1L &lt;&lt; 6)</span><br></pre></td></tr></table></figure>
<h5 id="2-完成sys-pgaccess-在这里主要是处理参数-利用argaddr和argint处理参数"><a href="#2-完成sys-pgaccess-在这里主要是处理参数-利用argaddr和argint处理参数" class="headerlink" title="2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数."></a>2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_pgaccess(void) &#123;</span><br><span class="line">    // lab pgtbl: your code here.</span><br><span class="line">    // get argument</span><br><span class="line">    uint64 buf;</span><br><span class="line">    int number;</span><br><span class="line">    uint64 ans;</span><br><span class="line">    if (argaddr(0, &amp;buf) &lt; 0) return -1;</span><br><span class="line">    if (argint(1, &amp;number) &lt; 0) return -1;</span><br><span class="line">    if (argaddr(2, &amp;ans) &lt; 0) return -1;</span><br><span class="line">    return pgaccess((void\*)buf, number, (void\*)ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-读取当前虚拟地址-找到对应的页表项目的函数找到-walk"><a href="#3-读取当前虚拟地址-找到对应的页表项目的函数找到-walk" class="headerlink" title="3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk"></a>3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk</h5><p>使用方法:<code>te = (pte_t*)walk(pagetable, ((uint64)pg) + (uint64)PGSIZE * i, 0);</code></p>
<h5 id="4-读取接着根据pte表项-找到PTE-A位"><a href="#4-读取接着根据pte表项-找到PTE-A位" class="headerlink" title="4) 读取接着根据pte表项,找到PTE_A位."></a>4) 读取接着根据pte表项,找到PTE_A位.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64 pgaccess(void \*pg, int number, void \*store) &#123;</span><br><span class="line">    struct proc \*p = myproc();</span><br><span class="line">    if (p == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    pagetable_t pagetable = p-&gt;pagetable;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; number; i++) &#123;</span><br><span class="line">        pte_t\* pte;</span><br><span class="line">        pte = (pte_t\*)walk(pagetable, ((uint64)pg) + (uint64)PGSIZE \* i, 0);</span><br><span class="line">        if (pte != 0 &amp;&amp; ((\*pte) &amp; PTE_A)) &#123;</span><br><span class="line">            ans = 1 &lt;&lt; i;</span><br><span class="line">            \*pte ^= PTE_A;  // clear PTE_A</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // copyout</span><br><span class="line">    return copyout(pagetable, (uint64)store, (char \*)&amp;ans, sizeof(int));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Xv6-and-Trap"><a href="#4-Xv6-and-Trap" class="headerlink" title="4:Xv6 and Trap"></a>4:Xv6 and Trap</h1><h2 id="Lab4-1-RISC-V-Assembly"><a href="#Lab4-1-RISC-V-Assembly" class="headerlink" title="Lab4_1 RISC-V Assembly"></a>Lab4_1 RISC-V Assembly</h2><p>我们需要运行对call.c这份代码的编译,然后回答一些问题</p>
<p>make fs.img编译之后我们可以找到下面的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:1141                addisp,sp,-16</span><br><span class="line">   2:e422                sds0,8(sp)</span><br><span class="line">   4:0800                addis0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:250d                addiwa0,a0,3</span><br><span class="line">   8:6422                lds0,8(sp)</span><br><span class="line">   a:0141                addisp,sp,16</span><br><span class="line">   c:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:1141                addisp,sp,-16</span><br><span class="line">  10:e422                sds0,8(sp)</span><br><span class="line">  12:0800                addis0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:250d                addiwa0,a0,3</span><br><span class="line">  16:6422                lds0,8(sp)</span><br><span class="line">  18:0141                addisp,sp,16</span><br><span class="line">  1a:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:1141                addisp,sp,-16</span><br><span class="line">  1e:e406                sdra,8(sp)</span><br><span class="line">  20:e022                sds0,0(sp)</span><br><span class="line">  22:0800                addis0,sp,16</span><br><span class="line">  printf(&quot;%d %d\\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:4635                lia2,13</span><br><span class="line">  26:45b1                lia1,12</span><br><span class="line">  28:00000517          auipca0,0x0</span><br><span class="line">  2c:7b050513          addia0,a0,1968 # 7d8 &lt;malloc+0xea&gt;</span><br><span class="line">  30:00000097          auipcra,0x0</span><br><span class="line">  34:600080e7          jalr1536(ra) # 630 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:4501                lia0,0</span><br><span class="line">  3a:00000097          auipcra,0x0</span><br><span class="line">  3e:27e080e7          jalr638(ra) # 2b8 &lt;exit&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.Q:Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<br>哪些寄存器存储了函数的参数?比如说调用printf的时候13存在哪个寄存器里面?</p>
<p>A:a0~a7共8个参数,其中调用printf的时候13就存在a2这个寄存器里面</p>
<p>2.Q:Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)<br>汇编代码中哪一部分出现了对函数f的调用,函数g呢?</p>
<p>A:其实并没有,编译器把g函数内联到f函数里面,再把f函数内联到main里面</p>
<p>3.Q:At what address is the function printf located?<br>printf的入口地址在哪里?</p>
<p>A:根据<code>jalr 1536(ra)</code>可以知道printf的地址在0x630这个里面</p>
<p>4.Q:What value is in the register ra just after the jalr to printf in main?<br>printf执行完返回到main的时候ra寄存器的值是多少?</p>
<p>显然ra中应是jalr下一条指令的地址，即0x38。</p>
<p>5.Q:Run the following code.</p>
<p>unsigned int i &#x3D; 0x00646c72;<br>printf(“H%x Wo%s”, 57616, &amp;i);</p>
<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change<code>57616</code> to a different value?<br>输出是什么?RISC-V是小端存储的.如果是大端存储的呢?</p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
<p><strong>输出”HE110 World”. 57616&#x3D;0xe110。RISC-V 是 little-endian，&amp;i处存储的字节依次为0x72:r, 0x6c:l, 0x64:d，0x00:Null char (空字符)。</strong></p>
<p><strong>如果 RISC-V 是 big-endian，则i &#x3D; 0x726c6400;. 57616不需改变，因为不管怎样它的十六进制形式都不会变。</strong></p>
<p>6.Q:In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?<br>执行下一条语句,会输出y&#x3D;多少呢?</p>
<p>printf(“x&#x3D;%d y&#x3D;%d”, 3);</p>
<p>因为函数a0~a7都存着参数,所以说对应的输出第二个参数的内容,也就是a1寄存器的内容.</p>
<h2 id="Lab4-2-BackTrace"><a href="#Lab4-2-BackTrace" class="headerlink" title="Lab4_2 BackTrace"></a>Lab4_2 BackTrace</h2><p>添加一个新的功能,打印函数调用栈.在这个机器中,我们知道有一个结构叫做栈帧,可以保存当前函数调用某个函数之前的一些寄存器,返回地址和一些局部变量的信息,比如说C语言的main函数,main函数调用一个函数f1(),在进入f1()函数的执行之前,编译器会帮我们把main函数的一些寄存器、局部变量的信息保存在栈帧中放入堆栈.其中栈帧中有一个特别的元素就是上一个栈帧的地址.</p>
<p><img src="https://pic2.zhimg.com/80/v2-9930748a73415bd511e4fe27f81de13d_1440w.jpg"></p>
<p>本实验的要求就是在kernel&#x2F;printf.c 中实现backtrace()函数。在sys_sleep中插入对该函数的调用。然后运行bttest，它调用sys_sleep。输出应如下：</p>
<h5 id="1-在def-h添加backtrace-函数的声明"><a href="#1-在def-h添加backtrace-函数的声明" class="headerlink" title="1) 在def.h添加backtrace()函数的声明."></a>1) 在def.h添加backtrace()函数的声明.</h5><h5 id="2-GCC-编译器将当前执行的函数的帧指针存储在寄存器s0中-s0就对应上面的fp指针"><a href="#2-GCC-编译器将当前执行的函数的帧指针存储在寄存器s0中-s0就对应上面的fp指针" class="headerlink" title="2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针."></a>2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-完成backtrace"><a href="#3-完成backtrace" class="headerlink" title="3) 完成backtrace()"></a>3) 完成backtrace()</h5><p>我们知道fp指针往下走两个字节就存储的上一个函数的栈帧的最高地址,所以说我们可以循环一下,每一次循环就取上一个函数的栈帧最高地址,输出返回地址即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">backtrace(void)&#123;</span><br><span class="line">  uint64 fp = r_fp(), top = PGROUNDUP(fp);</span><br><span class="line">  printf(&quot;backtrace:\\n&quot;);</span><br><span class="line">  for(;fp&lt;top;fp=\*(uint64\*)(fp-16))&#123;</span><br><span class="line">    printf(&quot;%p\\n&quot;, \*((uint64\*)(fp-8)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab4-3-Alarm"><a href="#Lab4-3-Alarm" class="headerlink" title="Lab4_3 Alarm"></a>Lab4_3 Alarm</h2><p>在本练习中，您将向xv6添加一项功能，该功能会在使用CPU时间的情况下定期向进程发出警报。这对于想要限制消耗多少CPU时间的计算密集型进程，或者对于想要进行计算但还希望采取一些定期操作的进程很有用。</p>
<p>您应该添加一个新的sigalarm(interval,handler)系统调用。 如果应用程序调用sigalarm(n,fn)，则在程序每消耗n个“ tick” CPU时间之后，内核应导致调用应用程序函数fn。 当fn返回时，应用程序应从中断处恢复。 滴答是xv6中相当随意的时间单位，由硬件计时器产生中断的频率决定。 如果应用程序调用sigalarm(0,0)，则内核应停止生成定期警报调用。</p>
<h5 id="test0：调用处理程序"><a href="#test0：调用处理程序" class="headerlink" title="test0：调用处理程序"></a>test0：调用处理程序</h5><p>1.修改Makefile，为sigalarm和sigreturn系统调用添加桩代码。<br>2.现在，sys_sigreturn应该只返回零。<br>3.sys_sigalarm()应该将nl和handler存储在proc结构的新字段中（在kernel&#x2F;proc.h 中）。<br>4.您需要跟踪该进程自上次调用alarm handler以来已经过去了多少ticks。为此，您还需要struct proc中的一个新字段。您可以在proc.c的allocproc() 中初始化这个字段。<br>5.每当tick时，硬件时钟都会强制中断，该中断在kernel&#x2F;trap.c的usertrap()中处理。<br>6.时钟中断是：if(which_dev &#x3D;&#x3D; 2) …<br>7.您需要修改usertrap()以在进程的警报间隔到期时，用户进程执行handler。</p>
<h5 id="test1-test2-恢复中断的代码"><a href="#test1-test2-恢复中断的代码" class="headerlink" title="test1&#x2F;test2(): 恢复中断的代码"></a>test1&#x2F;test2(): 恢复中断的代码</h5><p>8.handler完成后，控制权返回到用户程序最初被中断的指令。必须确保寄存器内容恢复，以及重置警报计数器。以便定期调用handler。<br>9.user alarm handler需要在完成后调用sigreturn系统调用。这意味着您可以将代码添加到usertrap和sys_sigreturn中，它们会协同工作以使用户进程在处理完警报后正确恢复。<br>10.确保正确地保存和恢复寄存器。<br>11.当计时器到期时，让 usertrap 在 struct proc 中保存足够的状态，以便sigreturn可以正确返回 到被中断的用户代码。<br>12.防止对处理程序的重入调用——如果处理程序尚未返回，内核不应再次调用它。</p>
<p>首先就是把添加系统调用的路子走一遍.</p>
<h5 id="1-在user-h中添加声明"><a href="#1-在user-h中添加声明" class="headerlink" title="1) 在user.h中添加声明:"></a>1) 在user.h中添加声明:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sigalarm(int ticks, void (\*handler)());</span><br><span class="line">int sigreturn(void);</span><br></pre></td></tr></table></figure>
<h5 id="2-在user-pl添加函数入口以生成汇编代码"><a href="#2-在user-pl添加函数入口以生成汇编代码" class="headerlink" title="2) 在user.pl添加函数入口以生成汇编代码."></a>2) 在user.pl添加函数入口以生成汇编代码.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(&quot;sigalarm&quot;);</span><br><span class="line">entry(&quot;sigreturn&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="3-在syscall-h添加系统调用号-1"><a href="#3-在syscall-h添加系统调用号-1" class="headerlink" title="3) 在syscall.h添加系统调用号."></a>3) 在syscall.h添加系统调用号.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SYS_sigalarm  22</span><br><span class="line">#define SYS_sigreturn 23</span><br></pre></td></tr></table></figure>
<h5 id="4-在syscall-c中添加关于这两个系统调用的声明"><a href="#4-在syscall-c中添加关于这两个系统调用的声明" class="headerlink" title="4) 在syscall.c中添加关于这两个系统调用的声明."></a>4) 在syscall.c中添加关于这两个系统调用的声明.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">extern uint64 sys_sigalarm(void);</span><br><span class="line">extern uint64 sys_sigreturn(void);</span><br><span class="line">......</span><br><span class="line">[SYS_sigalarm]  sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br></pre></td></tr></table></figure>
<h5 id="5-在proc的进程结构体中添加成员-保存什么时候中断-中断执行什么-过多久就进行一次中断-还保存中断的时候栈顶指针和保存的栈帧"><a href="#5-在proc的进程结构体中添加成员-保存什么时候中断-中断执行什么-过多久就进行一次中断-还保存中断的时候栈顶指针和保存的栈帧" class="headerlink" title="5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧."></a>5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int interval;// interupt count</span><br><span class="line">void (\*handler)(); //handle programme</span><br><span class="line">int count; //tick interupt count</span><br><span class="line">uint64 interrupt_ra; //trapframe pointer.</span><br><span class="line">struct trapframe \*saved_trapframe;//saved_trapframe</span><br><span class="line">int isworking;</span><br></pre></td></tr></table></figure>
<h5 id="6-在allocproc函数中初始化这些成员"><a href="#6-在allocproc函数中初始化这些成员" class="headerlink" title="6) 在allocproc函数中初始化这些成员."></a>6) 在allocproc函数中初始化这些成员.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;interval = 0;</span><br><span class="line">p-&gt;handler = 0;</span><br><span class="line">p-&gt;count = 0;</span><br><span class="line">p-&gt;is working = 0;</span><br></pre></td></tr></table></figure>
<h5 id="7-完成sigalarm的系统调用-做法就是从寄存器获得参数然后赋值给proc的元素中"><a href="#7-完成sigalarm的系统调用-做法就是从寄存器获得参数然后赋值给proc的元素中" class="headerlink" title="7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中."></a>7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sigalarm(void)&#123;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  int in;</span><br><span class="line">  uint ft;</span><br><span class="line">  int interval;</span><br><span class="line">    uint64 pt;</span><br><span class="line">    if(argint(0, &amp;in) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">    if(argaddr(1, &amp;ft) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line"></span><br><span class="line">    p-&gt;interval=in;</span><br><span class="line">    p-&gt;handler=(void\*)ft;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-完成时钟"><a href="#8-完成时钟" class="headerlink" title="8) 完成时钟"></a>8) 完成时钟</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if(which_dev == 2)&#123;</span><br><span class="line">    //the proc no call the sysalaram.</span><br><span class="line">    if(p-&gt;interval==0p-&gt;working)</span><br><span class="line">    &#123;</span><br><span class="line">      yield();</span><br><span class="line">      usertrapret();</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      p-&gt;count++; </span><br><span class="line">      if(p-&gt;count==p-&gt;interval)</span><br><span class="line">      &#123;</span><br><span class="line">        //save the trapframe.</span><br><span class="line">        p-&gt;saved_trapframe=(struct trapframe\*)kalloc();</span><br><span class="line">        memmove(p-&gt;saved_trapframe,p-&gt;trapframe,PGSIZE);</span><br><span class="line">        </span><br><span class="line">        //save the trapped address</span><br><span class="line">        p-&gt;interrupt_ra=p-&gt;trapframe-&gt;epc;</span><br><span class="line">        //the programme will start at handler.</span><br><span class="line">        p-&gt;trapframe-&gt;epc=(uint64)p-&gt;handler;</span><br><span class="line">        usertrapret();</span><br><span class="line">        yield();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>处理的方式是分类,如果之前没有调用过sigalarm的话,interval为0,就和原来一样,如果不是的话就代表调用过.接着count++,如果count和interval一样的话就代表要跳转了,保存当前的trapframe以及当前被中断的指令的地址,修改epc进行跳转.还有就是要记录working,如果这个函数已经被打断了就不要再重新打断一次.</p>
<h5 id="9-完成返回的操作"><a href="#9-完成返回的操作" class="headerlink" title="9) 完成返回的操作."></a>9) 完成返回的操作.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_sigreturn(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc\* p = myproc();</span><br><span class="line">  p-&gt;count=0;</span><br><span class="line">  p-&gt;trapframe-&gt;epc=p-&gt;interrupt_ra;</span><br><span class="line">  memmove(p-&gt;trapframe,p-&gt;saved_trapframe,PGSIZE);</span><br><span class="line">  p-&gt;isworking = 0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把之前保存的断点地址和栈帧读出来,清空时钟即可.</p>
<h1 id="6-Xv6-and-MultiThread"><a href="#6-Xv6-and-MultiThread" class="headerlink" title="6:Xv6 and MultiThread"></a>6:Xv6 and MultiThread</h1><h2 id="Lab6-1-Uthread-switching-between-threads"><a href="#Lab6-1-Uthread-switching-between-threads" class="headerlink" title="Lab6_1 Uthread: switching between threads"></a>Lab6_1 Uthread: switching between threads</h2><p>在本实验中，您将为用户级线程系统设计上下文切换机制，然后实现它。你的 xv6 有两个文件 user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S，以及 Makefile 中的一个规则来构建一个 uthread 程序。uthread.c 包含大部分用户级线程包，以及三个测试线程的代码。但线程包中缺少一些用于<strong>创建线程</strong>和<strong>线程间切换</strong>的代码。</p>
<p>您需要创建一个函数,这个函数可以创建一个进程,在切换进程的时候保存和恢复寄存器.</p>
<p>您需要在 user&#x2F;uthread.c 中的<strong>thread_create()<strong>和</strong>thread_schedule()<strong>以及user&#x2F;uthread_switch.S中的</strong>thread_switch</strong>中添加代码。</p>
<p>一个目标是<strong>确保当thread_schedule()第一次运行给定线程时，该线程在自己的堆栈上执行传递给thread_create()的函数</strong>(这个函数作为一个参数传递给thread_create()函数调用)。换句话说,就是创建线程的时候,有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.</p>
<p>另一个目标是<strong>确保thread_switch保存被切换的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后一个线程的指令中上次停止的点</strong>。您必须决定<strong>在哪里保存&#x2F;恢复寄存器</strong>；<strong>修改struct thread以保存寄存器是一个不错的计划</strong>。</p>
<p>您需要<strong>在thread_schedule中添加对thread_switch的调用</strong>；您可以将所需的任何参数传递给thread_switch，但目的是从线程t切换到next_thread。</p>
<p>thread_switch 只需要保存&#x2F;恢复callee-save registers。</p>
<p>要测试您的代码，使用riscv64-linux-gnu-gdb单步执行thread_switch可能会有所帮助。 您可以通过以下方式开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure>
<p>这将在uthread.c的第60行设置一个断点。 甚至在运行uthread之前，可能会（或可能不会）触发断点。 一旦您的xv6 shell运行，键入“ uthread”，gdb将在第60行中断。现在，您可以键入以下命令来检查uthread的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x \*next_thread</span><br></pre></td></tr></table></figure>
<p>使用“ x”，您可以检查存储位置的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x next_thread-&gt;stack</span><br></pre></td></tr></table></figure>
<p>您可以跳到thread_switch的开头，这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b thread_switch</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
<p>您可以使用以下步骤进行单步组装说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure>
<p>ni是下一条汇编语句,n是下一条C语言语句.</p>
<h5 id="1-修改thread-switch的代码-添加上关于thread-switch-的代码-只需要保存-恢复callee-save-register"><a href="#1-修改thread-switch的代码-添加上关于thread-switch-的代码-只需要保存-恢复callee-save-register" class="headerlink" title="1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:"></a>1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sd ra, 0(a0)</span><br><span class="line">sd sp, 8(a0)</span><br><span class="line">sd s0, 16(a0)</span><br><span class="line">sd s1, 24(a0)</span><br><span class="line">sd s2, 32(a0)</span><br><span class="line">sd s3, 40(a0)</span><br><span class="line">sd s4, 48(a0)</span><br><span class="line">sd s5, 56(a0)</span><br><span class="line">sd s6, 64(a0)</span><br><span class="line">sd s7, 72(a0)</span><br><span class="line">sd s8, 80(a0)</span><br><span class="line">sd s9, 88(a0)</span><br><span class="line">sd s10, 96(a0)</span><br><span class="line">sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">ld ra, 0(a1)</span><br><span class="line">ld sp, 8(a1)</span><br><span class="line">ld s0, 16(a1)</span><br><span class="line">ld s1, 24(a1)</span><br><span class="line">ld s2, 32(a1)</span><br><span class="line">ld s3, 40(a1)</span><br><span class="line">ld s4, 48(a1)</span><br><span class="line">ld s5, 56(a1)</span><br><span class="line">ld s6, 64(a1)</span><br><span class="line">ld s7, 72(a1)</span><br><span class="line">ld s8, 80(a1)</span><br><span class="line">ld s9, 88(a1)</span><br><span class="line">ld s10, 96(a1)</span><br><span class="line">ld s11, 104(a1)</span><br></pre></td></tr></table></figure>
<p>其中a0代表了被打断的线程的栈帧,a1代表了要切换到的线程的栈帧.其中栈帧就是相对于thread的结构体的偏移.</p>
<h5 id="2-在Thread的数据结构中添加寄存器信息"><a href="#2-在Thread的数据结构中添加寄存器信息" class="headerlink" title="2) 在Thread的数据结构中添加寄存器信息."></a>2) 在Thread的数据结构中添加寄存器信息.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line">  // callee-saved</span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">//修改后</span><br><span class="line">thread&#123;</span><br><span class="line">  栈帧</span><br><span class="line">  栈</span><br><span class="line">  状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-修改创建进程的代码-对ra和sp寄存器进行初始化-其中ra本质上就是断点寄存器-有一个参数就是一个地址-这个地址指向一个函数-当这个线程第一次启动的时候就从这个地址对应的指令开始执行-把这个参数传递给ra"><a href="#3-修改创建进程的代码-对ra和sp寄存器进行初始化-其中ra本质上就是断点寄存器-有一个参数就是一个地址-这个地址指向一个函数-当这个线程第一次启动的时候就从这个地址对应的指令开始执行-把这个参数传递给ra" class="headerlink" title="3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra"></a>3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;ra=(uint64)func;</span><br><span class="line">t-&gt;sp=(uint64)&amp;t-&gt;stack[STACK_SIZE-1];</span><br></pre></td></tr></table></figure>
<p>其中栈是从高到低的,所以说初始的栈顶指针是指向最高的地址的.</p>
<h5 id="4-调用switch函数-切换-其中t是当前进程-next-thread是下一个进程"><a href="#4-调用switch函数-切换-其中t是当前进程-next-thread是下一个进程" class="headerlink" title="4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程."></a>4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)t,(uint64)next_thread);</span><br></pre></td></tr></table></figure>
<h2 id="Lab6-2-Using-Thread"><a href="#Lab6-2-Using-Thread" class="headerlink" title="Lab6_2 Using Thread."></a>Lab6_2 Using Thread.</h2><p>文件notxv6 &#x2F; ph.c包含一个简单的哈希表，该哈希表从单个线程使用时是正确的，但从多个线程使用时则是错误的。 在您的主要xv6目录（可能是〜&#x2F; xv6-labs-2020）中，键入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make ph</span><br><span class="line">$ ./ph 1</span><br></pre></td></tr></table></figure>
<p>请注意，要生成ph，Makefile使用操作系统的gcc，而不是6.S081工具。 ph的参数指定在哈希表上执行放置和获取操作的线程数。 </p>
<p>ph运行两个基准。 首先，它通过调用put（）向哈希表添加很多键，并输出每秒达到的puts速率。 它使用get（）从哈希表中获取密钥。 它打印由于puts而应在哈希表中但丢失的数字键（在这种情况下为零），并打印每秒获得的获取次数。</p>
<p>您可以通过给它一个大于1的参数来告诉ph同时使用多个线程的哈希表。 尝试ph 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./ph 2</span><br><span class="line">100000 puts, 1.885 seconds, 53044 puts/second</span><br><span class="line">1: 16579 keys missing</span><br><span class="line">0: 16579 keys missing</span><br><span class="line">200000 gets, 4.322 seconds, 46274 gets/second</span><br></pre></td></tr></table></figure>
<p>此ph 2输出的第一行表明，当两个线程同时向哈希表添加条目时，它们每秒的总插入率为53,044。 这大约是运行ph 1时单线程的速度的两倍。这是大约2倍的出色“并行加速”，这是人们可能希望的（即两倍的内核，每单位时间产生两倍的工作量）。</p>
<p>但是，两行说缺少16579键，表明哈希表中不应该存在大量键。 就是说，puts应该将这些键添加到哈希表中，但是出了点问题。 看一下notxv6 &#x2F; ph.c，尤其是put（）和insert（）。</p>
<p>为什么缺少2个线程而不是1个线程的键？ 用2个线程标识一系列事件，这些事件可能导致键丢失。 提交您的序列，并在answer-thread.txt中提供简短解释。为避免发生此序列的事件，请在putx和get.not.v6 &#x2F; ph.c中插入lock和unlock语句，以便两个线程始终缺少0的键数。 相关的pthread调用为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock;            // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL); // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);       // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);     // release lock</span><br></pre></td></tr></table></figure>
<p>其实本质上,线程之间也会有互斥的关系,两个线程不能同时访问同一个缓冲区,如果同时当文同一个缓冲区的同一个位置就导致了写重复的问题,就需要对访问缓冲区的代码块上锁,只允许一个线程访问缓冲区.也就是只允许一个进程访问数组的某一个位置.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t locks[NBUCKET];</span><br><span class="line"></span><br><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  // is the key already present?</span><br><span class="line">  struct entry \*e = 0;</span><br><span class="line">  for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">    if (e-&gt;key == key)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  if(e)&#123;</span><br><span class="line">    // update the existing key.</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // the new is new.</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟我们学过的操作系统一样,线程在进入访问缓冲区的代码之前上锁,线程离开访问缓冲区的代码后解锁.</p>
<h2 id="Lab6-3-Barrier"><a href="#Lab6-3-Barrier" class="headerlink" title="Lab6_3 Barrier"></a>Lab6_3 Barrier</h2><p>在此分配中，您将实现一个障碍：应用程序中的一个点，所有参与线程必须在该点等待，直到所有其他参与线程也都到达该点。 您将使用pthread条件变量，这是一种类似于xv6的睡眠和唤醒的序列协调技术。</p>
<p>文件notxv6 &#x2F; barrier.c。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make barrier</span><br><span class="line">$ ./barrier 2</span><br><span class="line">barrier: notxv6/barrier.c:42: thread: Assertion \`i == t&#x27; failed.</span><br></pre></td></tr></table></figure>
<p>2指定在屏障上同步的线程数（barrier.c中的nthread）。 每个线程执行一个循环。 在每个循环迭代中，线程都会调用barrier（），然后睡眠随机数微秒。 断言触发，因为一个线程在另一线程到达屏障之前就离开了屏障。 理想的行为是每个线程都在barrier（）中阻塞，直到它们的所有nthread都调用了barrier（）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread+=1;pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">  if(bstate.nthread&lt;nthread)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);//go to sleep on cond,releasing lock mutes acquirint upon wake up</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    bstate.round+=1;//next round</span><br><span class="line">    bstate.nthread=0;//the thread that have entered the barrier() function -&gt; 0 </span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br></pre></td></tr></table></figure>
<p>因为要修改临界量nthread,所以说进入之前所以要加上锁.如果没到就停止,释放锁,如果到了的话就nthread&#x3D;0,round+1,调用broadcast函数即可.</p>
<p><img src="https://sukunahust.com/wp-content/uploads/2022/03/image-29-1024x488.png"></p>
<h1 id="7-Xv6-and-Networking"><a href="#7-Xv6-and-Networking" class="headerlink" title="7:Xv6 and Networking"></a>7:Xv6 and Networking</h1><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>您将使用称为 E1000 的网络设备来处理网络通信。 对于 xv6（以及您编写的驱动程序），E1000 看起来像是连接到真实以太网局域网 (LAN) 的真实硬件。 实际上，您的驱动程序将与之通信的 E1000 是由 qemu 提供的仿真，连接到同样由 qemu 仿真的 LAN。 在这个模拟 LAN 上，xv6（“guest”）的 IP 地址为 10.0.2.15。 Qemu 还安排运行 qemu 的计算机出现在 IP 地址为 10.0.2.2 的 LAN 上。 当 xv6 使用 E1000 向 10.0.2.2 发送数据包时，qemu 会将数据包传送到您正在运行 qemu（“主机”）的（真实）计算机上的适当应用程序。(就是qemu模拟器传递数据到真实的计算机中)</p>
<p>你将会用到QEMU的 “用户态网络栈”。QEMU的文档中由很多关于用户态栈的描述。我们已经更新了 Makefile，打开了QEMU的用户态网络栈以及E1000网卡。</p>
<p>Makefile 设置了 QEMU记录所有的进出数据包到文件 packets.pcap。这可能对于检查接收发送的数据包是有用的。展现记录的数据包：</p>
<p>tcpdump -XXnr packets.pcap</p>
<h5 id="你的工作"><a href="#你的工作" class="headerlink" title="你的工作."></a>你的工作.</h5><p>我们已经添加了一些文件到xv6上了。文件kernel&#x2F;e1000.c包含了E1000的初始化代码以及空的传输和接收数据包的函数，这些是需要你去完成的。kernel&#x2F;e1000_dev.h包含了寄存器和标志位的定义，这些在Intel E1000的文档有描述。kernel&#x2F;net.c和kernel&#x2F;net.h包含了一个简单的包含IP、UDP、ARP协议的网络栈。这些文件页包含了一个灵活的数据结构来持有数据包，叫做mbuf。最后，kernel&#x2F;pci.c包含了在xv6启动时，在PCI总线上查找一个E1000网卡的代码.</p>
<p>我们在 e1000.c 中为您提供的 e1000_init() 函数将 E1000 配置为读取要从 RAM 传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，用于直接内存访问，指的是 E1000 硬件直接从 RAM 写入和读取数据包这一事实。</p>
<p>因为数据包的爆发可能比驱动程序处理它们的速度更快，所以 e1000_init() 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入其中。 E1000 要求这些缓冲区由 RAM 中的“描述符”数组描述；每个描述符都包含 RAM 中的一个地址，E1000 可以在其中写入接收到的数据包。 struct rx_desc 描述描述符格式。描述符数组称为接收环或接收队列。从某种意义上说，它是一个圆环，当卡或驱动程序到达阵列的末端时，它会回到起点。 e1000_init() 使用 mbufalloc() 将 E1000 的 mbuf 数据包缓冲区分配给 DMA 。还有一个传输环，驱动程序将它希望 E1000 发送的数据包放入其中。 e1000_init() 将两个环配置为具有大小 RX_RING_SIZE 和 TX_RING_SIZE。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct tx_desc</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint16 length;</span><br><span class="line">  uint8 cso;</span><br><span class="line">  uint8 cmd;</span><br><span class="line">  uint8 status;</span><br><span class="line">  uint8 css;</span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br><span class="line">#define TX_RING_SIZE 16</span><br><span class="line">static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));</span><br><span class="line">static struct mbuf \*tx_mbufs[TX_RING_SIZE];</span><br><span class="line"></span><br><span class="line">// [E1000 3.2.3]</span><br><span class="line">struct rx_desc</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;       /\* Address of the descriptor&#x27;s data buffer \*/</span><br><span class="line">  uint16 length;     /\* Length of data DMAed into data buffer \*/</span><br><span class="line">  uint16 csum;       /\* Packet checksum \*/</span><br><span class="line">  uint8 status;      /\* Descriptor status \*/</span><br><span class="line">  uint8 errors;      /\* Descriptor Errors \*/</span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define RX_RING_SIZE 16</span><br><span class="line">static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));</span><br><span class="line">static struct mbuf \*rx_mbufs[RX_RING_SIZE];</span><br><span class="line"></span><br><span class="line">struct mbuf &#123;</span><br><span class="line">  struct mbuf  \*next; // the next mbuf in the chain</span><br><span class="line">  char         \*head; // the current start position of the buffer</span><br><span class="line">  unsigned int len;   // the length of the buffer</span><br><span class="line">  char         buf[MBUF_SIZE]; // the backing store</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中,tx_ring和tx_mbufs是一一对应的.</p>
<p>当 net.c 中的网络堆栈需要发送数据包时，它会调用 e1000_transmit() 并使用 mbuf 保存要发送的数据包。您的传输代码必须在 TX（传输）环的描述符中放置一个指向数据包数据的指针。 struct tx_desc 描述描述符格式。您需要确保每个 mbuf 最终都被释放，但只有在 E1000 完成数据包传输之后（E1000 设置描述符中的 E1000_TXD_STAT_DD 位来指示这一点）。</p>
<p>当 E1000 从以太网接收到每个数据包时，它首先将数据包 DMA 到下一个 RX（接收）环描述符指向的 mbuf，然后产生中断。您的 e1000_recv() 代码必须扫描 RX 环并通过调用 net_rx() 将每个新数据包的 mbuf 传送到网络堆栈（在 net.c 中）。然后，您需要分配一个新的 mbuf 并将其放入描述符中，以便当 E1000 再次到达 RX 环中的那个点时，它会找到一个新的缓冲区来 DMA 一个新的数据包。</p>
<p>除了在 RAM 中读取和写入描述符环之外，您的驱动程序还需要通过其内存映射控制寄存器与 E1000 交互，以检测接收到的数据包何时可用，并通知 E1000 驱动程序已填写一些 TX 描述符与要发送的数据包。全局变量 regs 持有指向 E1000 的第一个控制寄存器的指针；您的驱动程序可以通过将 regs 索引为数组来获取其他寄存器。您需要特别使用索引 E1000_RDT 和 E1000_TDT。</p>
<p>要测试您的驱动程序，请在一个窗口中运行 make server，在另一个窗口中运行 make qemu，然后在 xv6 中运行 nettests。 nettests 中的第一个测试尝试向主机操作系统发送一个 UDP 数据包，地址是使服务器运行的程序。如果您还没有完成实验，E1000 驱动程序实际上不会发送数据包，也不会发生任何事情。</p>
<p>完成实验后，E1000 驱动程序会发送数据包，qemu 会将数据包传送到您的主机，make server 会看到它，它会发送响应数据包，然后 E1000 驱动程序和 nettests 会看到响应数据包.然而，在主机发送回复之前，它会向 xv6 发送一个“ARP”请求包以查找其 48 位以太网地址，并期望 xv6 以 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，kernel&#x2F;net.c 就会处理这个问题。如果一切顺利，nettests 将打印 testing ping: OK，并且 make server 将打印一条来自 xv6! 的消息。</p>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>首先将打印语句添加到 e1000_transmit() 和 e1000_recv()，然后运行 ​​make server 和（在 xv6 中）nettests。您应该从您的打印语句中看到 nettests 生成了对 e1000_transmit 的调用。</p>
<p>实现 e1000_transmit 的一些提示：</p>
<p>首先通过读取 E1000_TDT 控制寄存器向 E1000 询问它期待下一个数据包的 TX 环索引。<br>然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则说明 E1000 还没有完成对应的上一个传输请求，因此返回错误。<br>否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。<br>然后填写描述符。 m-&gt;head 指向包在内存中的内容，m-&gt;len 是包的长度。设置必要的 cmd 标志（查看 E1000 手册中的第 3.3 节）并隐藏指向 mbuf 的指针以供以后释放。<br>最后，通过将 E1000_TDT 模 TX_RING_SIZE 加一来更新环位置。<br>如果 e1000_transmit() 成功地将 mbuf 添加到环中，则返回 0。失败时（例如，没有可用于传输 mbuf 的描述符），返回 -1 以便调用者知道释放 mbuf。</p>
<p>实现 e1000_recv 的一些提示：</p>
<p>首先通过获取 E1000_RDT 控制寄存器并加一个模 RX_RING_SIZE，向 E1000 询问下一个等待接收的数据包（如果有）所在的环索引。<br>然后通过检查描述符状态部分中的 E1000_RXD_STAT_DD 位来检查新数据包是否可用。如果没有，请停止。<br>否则，将 mbuf 的 m-&gt;len 更新为描述符中报告的长度。使用 net_rx() 将 mbuf 传送到网络堆栈。<br>然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。<br>最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。<br>e1000_init() 用 mbufs 初始化 RX 环，你会想看看它是如何做到的，也许还需要借用代码。<br>在某些时候，已经到达的数据包总数将超过环大小（16）；确保您的代码可以处理。<br>您将需要锁来应对 xv6 可能从多个进程使用 E1000 的可能性，或者当中断到达时可能在内核线程中使用 E1000。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">e1000_transmit(struct mbuf \*m)</span><br><span class="line">&#123;</span><br><span class="line">  //</span><br><span class="line">  // Your code here.</span><br><span class="line">  //</span><br><span class="line">  // the mbuf contains an ethernet frame; program it into</span><br><span class="line">  // the TX descriptor ring so that the e1000 sends it. Stash</span><br><span class="line">  // a pointer so that it can be freed after sending.</span><br><span class="line">  //</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  //首先通过读取 E1000_TDT 控制寄存器向 E1000 询问它期待下一个数据包的 TX 环索引。</span><br><span class="line">  uint reg_tdt = regs[E1000_TDT];</span><br><span class="line">  //然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则说明 E1000 还没有完成对应的上一个传输请求，因此返回错误。</span><br><span class="line">  if((tx_ring[reg_tdt].status &amp; E1000_TXD_STAT_DD) == 0)&#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  //否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。</span><br><span class="line">  if(tx_mbufs[reg_tdt] != 0)</span><br><span class="line">    mbuffree(tx_mbufs[reg_tdt]);</span><br><span class="line"></span><br><span class="line">  //然后填写描述符。 m-&gt;head 指向包在内存中的内容，m-&gt;len 是包的长度。设置必要的 cmd 标志</span><br><span class="line">  tx_mbufs[reg_tdt] = m;</span><br><span class="line">  tx_ring[reg_tdt].length = m-&gt;len;</span><br><span class="line">  tx_ring[reg_tdt].addr = (uint64)(m-&gt;head);</span><br><span class="line">  tx_ring[reg_tdt].cmd = 9;</span><br><span class="line"></span><br><span class="line">  //最后，通过将 E1000_TDT 模 TX_RING_SIZE 加一来更新环位置。</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">e1000_recv(void)</span><br><span class="line">&#123;</span><br><span class="line">  //</span><br><span class="line">  // Your code here.</span><br><span class="line">  //</span><br><span class="line">  // Check for packets that have arrived from the e1000</span><br><span class="line">  // Create and deliver an mbuf for each packet (using net_rx()).</span><br><span class="line">  //首先通过获取 E1000_RDT 控制寄存器并加一个模 RX_RING_SIZE，向 E1000 询问下一个等待接收的数据包（如果有）所在的环索引。</span><br><span class="line">  uint reg_rdt = regs[E1000_RDT];</span><br><span class="line">  int i = (reg_rdt + 1)%RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  //然后通过检查描述符状态部分中的 E1000_RXD_STAT_DD 位来检查新数据包是否可用。如果没有，请停止。</span><br><span class="line">  //否则，将 mbuf 的 m-&gt;len 更新为描述符中报告的长度。使用 net_rx() 将 mbuf 传送到网络堆栈。</span><br><span class="line">   while(rx_ring[i].status &amp; E1000_RXD_STAT_DD)&#123;</span><br><span class="line">      rx_mbufs[i]-&gt;len = rx_ring[i].length;</span><br><span class="line">      net_rx(rx_mbufs[i]);</span><br><span class="line">      //然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。</span><br><span class="line">      if((rx_mbufs[i] = mbufalloc(0)) == 0)</span><br><span class="line">          panic(&quot;e1000&quot;);</span><br><span class="line">      rx_ring[i].addr = (uint64)rx_mbufs[i]-&gt;head;</span><br><span class="line">      rx_ring[i].status = 0;</span><br><span class="line">      i = (i + 1) % RX_RING_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  //最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。</span><br><span class="line">  regs[E1000_RDT] = (i - 1) % RX_RING_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-Xv6-and-Lock"><a href="#8-Xv6-and-Lock" class="headerlink" title="8:Xv6 and Lock"></a>8:Xv6 and Lock</h1><h2 id="Lab8-1-Memory-Access"><a href="#Lab8-1-Memory-Access" class="headerlink" title="Lab8_1 Memory Access."></a>Lab8_1 Memory Access.</h2><p>在这个部分的测试中,三个进程频繁地调度kalloc和kfree.</p>
<p>对于每个锁，acquire 维护对该锁的调用计数，以及获取中的循环尝试但未能设置锁的次数。 kalloctest 调用一个系统调用，使内核打印 kmem 和 bcache 锁（这是本实验的重点）和 5 个最争用次数最多锁的计数。如果存在锁争用，获取循环迭代的次数将会很大。系统调用返回 kmem 和 bcache 锁的循环迭代次数的总和。</p>
<p>对于本实验，您必须使用具有多核的专用机器。如果您使用一台正在做其他事情的机器，那么 kalloctest 打印的计数将是无稽之谈。</p>
<p>kalloctest 中锁争用的根本原因是 kalloc() 有一个空闲列表，由一个锁保护。要消除锁争用，您必须重新设计内存分配器以不使用一个锁和列表。基本思想是为每个 CPU 维护一个空闲列表，每个列表都有自己的锁。不同 CPU 上的分配和释放可以并行运行，因为每个 CPU 将在不同的列表上运行。主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有空闲内存的情况；在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的空闲列表的一部分。窃取可能会引入锁争用，但希望这种情况很少见。(这个叫“负载均衡”)</p>
<p>你的工作是实现每个 CPU 的空闲列表(就是对于每个CPU的核维护一个空闲列表,这个列表就是kmem)，并在 CPU 的空闲列表为空时进行读取。 您必须为所有以“kmem”开头的锁命名。 也就是说，您应该为每个锁调用 initlock，并传递一个以“kmem”开头的名称。 运行 kalloctest 以查看您的实现是否减少了锁争用。 要检查它是否仍然可以分配所有内存，请运行 usertests sbrkmuch。 您的输出将类似于下图所示，kmem 锁的争用总量大大减少，尽管具体数字会有所不同。 确保 usertests 中的所有测试都通过。 make Grade 应该说 kalloctests 通过了。</p>
<h5 id="1-按照提示-更改内存块的结构-不是所有内存块都共享一个锁-是每个CPU都有一个独立的锁"><a href="#1-按照提示-更改内存块的结构-不是所有内存块都共享一个锁-是每个CPU都有一个独立的锁" class="headerlink" title="1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁."></a>1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct run \*freelist;</span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>
<h5 id="2-改为初始化所有锁"><a href="#2-改为初始化所有锁" class="headerlink" title="2) 改为初始化所有锁."></a>2) 改为初始化所有锁.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; NCPU; i++)</span><br><span class="line">    initlock(&amp;kmem[i].lock, &quot;kmem&quot;);</span><br><span class="line">  freerange(end, (void\*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-获取CPU的id-在这个地方获取id的时候要关中断-防止因为中断分配给其他CPU来进行处理了"><a href="#3-获取CPU的id-在这个地方获取id的时候要关中断-防止因为中断分配给其他CPU来进行处理了" class="headerlink" title="3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了."></a>3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push_off();</span><br><span class="line">int id = cpuid();</span><br><span class="line">pop_off();</span><br></pre></td></tr></table></figure>
<h5 id="4-对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁"><a href="#4-对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁" class="headerlink" title="4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁"></a>4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁</h5><p><code>acquire(&amp;kmem.lock)-&gt;acquire(&amp;kmem[id].lock)</code></p>
<h5 id="5-在if-r-的后面添加else-代表如果寻找失败-就到其他的核中获取"><a href="#5-在if-r-的后面添加else-代表如果寻找失败-就到其他的核中获取" class="headerlink" title="5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取."></a>5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">  for (int i = 0; i &lt; NCPU; i++) &#123;</span><br><span class="line">    if (i == id) continue;</span><br><span class="line">    acquire(&amp;kmem[i].lock);</span><br><span class="line">    r = kmem[i].freelist;</span><br><span class="line">    if(r)</span><br><span class="line">      kmem[i].freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem[i].lock);</span><br><span class="line">    if(r) break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-Xv6-File-System"><a href="#9-Xv6-File-System" class="headerlink" title="9:Xv6 &amp; File System"></a>9:Xv6 &amp; File System</h1><h2 id="Lab-9-1-Large-files"><a href="#Lab-9-1-Large-files" class="headerlink" title="Lab 9_1 Large files"></a>Lab 9_1 Large files</h2><p>在这个实验中,你会拓展文件系统中文件的最大大小,其中一开始文件是12个直接连接块,1个一级索引块,一共16*16+12&#x3D;268个块,这个时候我们要修改一下改成11个直接相连,1个一级索引块,1个二级索引块,一共256*256+256+11&#x3D;65536+256+11个块.</p>
<p>其中xv6把文件系统映射到fs.img中,这个一共有二十万个块,其中70个保存块信息的meta块,剩下的都是数据.完成这个实验你需要关注磁盘 inode 的格式,这个由 fs.h 中的 struct dinode 定义。 您对 NDIRECT、NINDIRECT、MAXFILE 和结构 dinode 的 addrs[] 元素特别感兴趣。 查看 xv6 文本中的图 8.3 以了解标准 xv6 inode 的图表。<br>在磁盘上查找文件数据的代码在 fs.c 的 bmap() 中。 看看它，确保你明白它在做什么。 bmap() 在读取和写入文件时都会被调用。 写入时，bmap() 会根据需要分配新块来保存文件内容，并在需要时分配间接块来保存块地址。<br>bmap() 处理两种块号。 bn 参数是一个“逻辑块号”——文件中的块号，相对于文件的开头。 ip-&gt;addrs[] 中的块号和 bread() 的参数是磁盘块号。 您可以将 bmap() 视为将文件的逻辑块号映射到磁盘块号。</p>
<p>修改 bmap() ，使其除了直接块和单间接块外，还实现双重间接块。 你只需要 11 个直接块，而不是 12 个，就可以为新的双重间接块腾出空间； 您不能更改磁盘 inode 的大小。 ip-&gt;addrs[] 的前 11 个元素应该是直接块； 第 12 个应该是一个单独的间接块（就像现在的块一样）； 第 13 个应该是你新的双重间接块。</p>
<h5 id="1-修改直接映射的数量"><a href="#1-修改直接映射的数量" class="headerlink" title="1) 修改直接映射的数量."></a>1) 修改直接映射的数量.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NDIRECT 11#define NDIRECT 11</span><br><span class="line">uint addrs[NDIRECT+2];</span><br><span class="line">#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLE)//文件最大值也要改变</span><br></pre></td></tr></table></figure>
<p>其中直接映射的数量由原来的12个改为11个.</p>
<h5 id="2-对应的file-h的inode结构体也要进行更改"><a href="#2-对应的file-h的inode结构体也要进行更改" class="headerlink" title="2) 对应的file.h的inode结构体也要进行更改"></a>2) 对应的file.h的inode结构体也要进行更改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  struct sleeplock lock; // protects everything below here</span><br><span class="line">  int valid;          // inode has been read from disk?</span><br><span class="line"></span><br><span class="line">  short type;         // copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="3-阅读bmap的代码-0-NDIRECT-1-直接-NDIRECT-NDIRECT-NINDIRECT-1-一级间接"><a href="#3-阅读bmap的代码-0-NDIRECT-1-直接-NDIRECT-NDIRECT-NINDIRECT-1-一级间接" class="headerlink" title="3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接"></a>3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//bn:the number the blocks.</span><br><span class="line">  if(bn &lt; NDIRECT)&#123;</span><br><span class="line">    if((addr = ip-&gt;addrs[bn]) == 0)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  if(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    // Load indirect block, allocating if necessary.</span><br><span class="line">    if((addr = ip-&gt;addrs[NDIRECT]) == 0)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint\*)bp-&gt;data;</span><br><span class="line">    if((addr = a[bn]) == 0)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>有个大前提,就是如果索引为0就代表这个磁盘为空,需要申请一个返回一个磁盘块号</p>
<p>首先第一部分,就是直接映射的部分,如果寻找的逻辑地址是在NDIRECT以内的,就可以直接访问磁盘块.</p>
<p>第二部分就是一级间接映射,首先先把一级映射的映射表找到,读出来,如果没有映射表就新建一个.映射表我们之前在操作系统学过就是一个int类型数组,这个时候我们就可以把映射表解释称int类型数组,然后根据索引值,也就是bn-NDIRECT来寻找,寻找就是寻找数组里面的东西.</p>
<h5 id="4-依葫芦画瓢作出二级索引"><a href="#4-依葫芦画瓢作出二级索引" class="headerlink" title="4) 依葫芦画瓢作出二级索引."></a>4) 依葫芦画瓢作出二级索引.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">if(bn &lt; NDOUBLE)&#123;</span><br><span class="line">  if((addr = ip-&gt;addrs[NDIRECT+1]) == 0)</span><br><span class="line">    ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint\*)bp-&gt;data;</span><br><span class="line">  int bn1 = bn / NINDIRECT,bn2 = bn % NINDIRECT;</span><br><span class="line">  //first suoyin</span><br><span class="line">  if((addr = a[bn1]) == 0)&#123;</span><br><span class="line">   a[bn1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">   log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  //second suoyin</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bp=bread(ip-&gt;dev,addr);</span><br><span class="line">  a=(uint\*)bp-&gt;data;</span><br><span class="line">  if((addr=a[bn2])==0)</span><br><span class="line">  &#123;</span><br><span class="line">      a[bn2]=addr=balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二级索引需要两个索引值,一个是除得来的结果,一个是%得来的结果,首先先读一次,获得一级索引表,做法和上面是一样的,接着再读,根据一级索引表得来的结果就是对应二级索引表的位置,所以说根据一级索引表的结果打开二级索引表,找到最后属于我们的索引值.</p>
<h5 id="5-完成索引的释放"><a href="#5-完成索引的释放" class="headerlink" title="5) 完成索引的释放."></a>5) 完成索引的释放.</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(ip-&gt;addrs[NDIRECT+1]) &#123;</span><br><span class="line">  bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);</span><br><span class="line">  a = (uint\*)bp-&gt;data;</span><br><span class="line">  for(j = 0; j &lt; NINDIRECT; j++) &#123;</span><br><span class="line">    if(a[j]) &#123;</span><br><span class="line">      bp2 = bread(ip-&gt;dev, a[j]);</span><br><span class="line">      a2 = (uint\*)bp2-&gt;data;</span><br><span class="line">      for(i = 0; i &lt; NINDIRECT; i++) &#123;</span><br><span class="line">        if(a2[i]) bfree(ip-&gt;dev, a2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      brelse(bp2);</span><br><span class="line">      bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      a[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);</span><br><span class="line">  ip-&gt;addrs[NDIRECT] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是先读取数组的第13项,构造一个二重循环,先进入到第一个一级索引的第一个二级索引陆续地释放所有的块.再进入到第一个一级索引的第二个二级索引…第一个一级索引的第256个二级索引….第256个二级索引的第256个一级索引…</p>
<h2 id="Lab9-2-Symbolic-links"><a href="#Lab9-2-Symbolic-links" class="headerlink" title="Lab9_2 Symbolic links"></a>Lab9_2 Symbolic links</h2><p>您将实现 symlink(char *target, char *path) 系统调用，它会在 path 处创建一个新的符号链接，该链接引用由 target 命名的文件。</p>
<p>首先，为symlink创建一个新的系统调用号，在user&#x2F;usys.pl，user&#x2F;user.h中添加一个入口，在kernel&#x2F;sysfile.c中实现一个空的sys_symlink。<br>将新文件类型 (T_SYMLINK) 添加到 kernel&#x2F;stat.h 以表示符号链接。<br>向 kernel&#x2F;fcntl.h 添加一个新标志 (O_NOFOLLOW)，可与 open 系统调用一起使用。请注意，传递给 open 的标志是使用按位 OR 运算符组合的，因此您的新标志不应与任何现有标志重叠。这将让您在将 user&#x2F;symlinktest.c 添加到 Makefile 后编译它。<br>实现 symlink(target, path) 系统调用以在指向目标的路径上创建一个新的符号链接。请注意，系统调用成功时不需要存在目标。您将需要选择某个位置来存储符号链接的目标路径，例如，在 inode 的数据块中。 symlink 应该返回一个表示成功 (0) 或失败 (-1) 的整数，类似于链接和取消链接。<br>修改 open 系统调用以处理路径引用符号链接的情况。如果文件不存在，则打开必须失败。当进程在要打开的标志中指定 O_NOFOLLOW 时， open 应该打开符号链接（而不是跟随符号链接）。<br>如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件。如果链接形成循环，则必须返回错误代码。如果链接的深度达到某个阈值（例如，10），您可以通过返回错误代码来近似此值。<br>其他系统调用（例如，链接和取消链接）不得遵循符号链接；这些系统调用对符号链接本身进行操作。<br>对于本实验，您不必处理指向目录的符号链接。</p>
<h5 id="1-添加系统调用-略"><a href="#1-添加系统调用-略" class="headerlink" title="1) 添加系统调用.(略)"></a>1) 添加系统调用.(略)</h5><h5 id="2-按照实验提示的信息-添加两个新的宏-略"><a href="#2-按照实验提示的信息-添加两个新的宏-略" class="headerlink" title="2) 按照实验提示的信息,添加两个新的宏.(略)"></a>2) 按照实验提示的信息,添加两个新的宏.(略)</h5><h5 id="3-完成symlink系统调用"><a href="#3-完成symlink系统调用" class="headerlink" title="3) 完成symlink系统调用."></a>3) 完成symlink系统调用.</h5><p>首先第一点,我们发现,在sysfile.c的系统调用是需要提交事务的,我们也模仿这一点进行更改,处理的思路就是获取参数,创建一个新的inode,把符号连接的文件路径写进inode里面,然后提交即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_symlink(void)</span><br><span class="line">&#123;  </span><br><span class="line">  char path[MAXPATH], target[MAXPATH];</span><br><span class="line">  struct inode \*ip;</span><br><span class="line">  // get parameter</span><br><span class="line">  if(argstr(0, target, MAXPATH) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  if(argstr(1, path, MAXPATH) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  begin_op();</span><br><span class="line">  // create a inode</span><br><span class="line">  if((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  // write the path of the file to the inode.</span><br><span class="line">  if(writei(ip, 0, (uint64)target, 0, MAXPATH) &lt; MAXPATH) &#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <blockquote class="article-copyright">
    <p><strong>本文作者：</strong>Sukuna @ Suwa shrine</p>
    <p><strong>本文链接：</strong><a href="https://sukunashinmyoumaru-hust.github.io/2023/02/08/mit-6-s081-lab/">https://sukunashinmyoumaru-hust.github.io/2023/02/08/mit-6-s081-lab/</a></p>
    
    
    
    <p><strong>本文版权：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener external nofollow noreferrer" target="_blank"><span class="icon-creative-commons"></span>BY-NC-SA</a> 许可协议。转载请注明出处！</p>
    <span class="icon-creative-commons article-copyright-bg"></span>
  </blockquote>
      
      
      
        <a data-aos="zoom-in" href="/2023/02/08/mit-6-s081-lab/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2023/02/08/mit-6-s081-lab/" itemprop="commentCount"></span>
          留言
        </a>
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/c10853f5c9aee06c.jpg" data-sizes="auto" alt="MIT_6.S081_xv6.Information 集合" class="lazyload">
          
        
        <a href="/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            MIT_6.S081_xv6.Information 集合
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/8d1e248fe0f62130.jpg" data-sizes="auto" alt="CMU14-445 Lab" class="lazyload">
        
      
      <a href="/2023/02/07/cmu14-445-lab/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          CMU14-445 Lab
        
      </h3>
    </div>
    
  </nav>


</article>

  <section id="comments" class="vcomment" data-aos="fade-up"></section>






</section>
          
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false"></div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2025
      <span class="footer-info-sep rotate"></span>
      Sukuna
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        211k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        14:35
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
  
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Xv6-and-Unix-utilities"><span class="toc-number">1.</span> <span class="toc-text">1:Xv6 and Unix utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-1-Boot-xv6"><span class="toc-number">1.1.</span> <span class="toc-text">Lab1_1:Boot xv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-2-sleep"><span class="toc-number">1.2.</span> <span class="toc-text">Lab1_2 sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-3-pingpong"><span class="toc-number">1.3.</span> <span class="toc-text">Lab1_3 pingpong</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-4-prime"><span class="toc-number">1.4.</span> <span class="toc-text">Lab1_4 prime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-5-find"><span class="toc-number">1.5.</span> <span class="toc-text">Lab1_5 find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab1-6-xargs"><span class="toc-number">1.6.</span> <span class="toc-text">Lab1_6 xargs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Xv6-and-Syscall"><span class="toc-number">2.</span> <span class="toc-text">2:Xv6 and Syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-1-Trace"><span class="toc-number">2.1.</span> <span class="toc-text">Lab2_1 Trace.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8user-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Etrace%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.1.0.0.1.</span> <span class="toc-text">1) 在user.h中添加对于trace函数的支持.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAentry%E5%9C%A8user-pl%E9%87%8C%E9%9D%A2"><span class="toc-number">2.1.0.0.2.</span> <span class="toc-text">2) 添加一个entry在user.pl里面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8syscall-h%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7"><span class="toc-number">2.1.0.0.3.</span> <span class="toc-text">3) 在syscall.h添加系统调用号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8proc%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAmask%E6%88%90%E5%91%98-%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E8%A6%81trace%E5%93%AA%E7%A7%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.0.0.4.</span> <span class="toc-text">4) 在proc结构体里面添加一个mask成员,用来记录要trace哪种系统调用.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8kernel-sysproc-c%E9%87%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%85%B7%E4%BD%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BC%9A%E4%BF%9D%E5%AD%98%E5%9C%A8%E8%BF%99%E9%87%8C"><span class="toc-number">2.1.0.0.5.</span> <span class="toc-text">5) 在kernel&#x2F;sysproc.c里面实现具体的系统调用,在这里你会发现系统调用的实现会保存在这里.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9B%B4%E6%94%B9fork%E5%87%BD%E6%95%B0-%E6%B7%BB%E5%8A%A0mask%E7%9A%84%E5%A4%8D%E5%88%B6-np-mask-p-mask"><span class="toc-number">2.1.0.0.6.</span> <span class="toc-text">6) 更改fork函数,添加mask的复制.np-&gt;mask &#x3D; p-&gt;mask;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%B7%BB%E5%8A%A0syscall-c%E4%B8%AD%E5%85%B3%E4%BA%8Etrace%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.1.0.0.7.</span> <span class="toc-text">7) 添加syscall.c中关于trace函数的支持.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%9B%B4%E6%94%B9syscall-c%E7%9A%84syscall%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.0.0.8.</span> <span class="toc-text">8) 更改syscall.c的syscall函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-2-sys-info"><span class="toc-number">3.</span> <span class="toc-text">Lab2_2 sys info</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8makefile-user-pl%E5%92%8Cuser-h%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Esysinfo%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81-%E4%B8%8D%E6%87%82%E7%9A%84%E8%AF%B7%E7%BF%BB%E9%98%85%E4%B8%8A%E9%9D%A2"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">1) 在makefile,user.pl和user.h添加对于sysinfo系统调用的支持.(不懂的请翻阅上面)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%9F%E8%AE%A1%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%95%B0-%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0proc-size-%E5%9C%A8proc-h%E4%B8%AD"><span class="toc-number">3.0.0.0.2.</span> <span class="toc-text">2) 统计当前正在使用进程数.定义新函数proc_size(),在proc.h中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1%E5%BD%93%E5%89%8D%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0-%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0freememory-%E5%9C%A8kalloc-h%E4%B8%AD"><span class="toc-number">3.0.0.0.3.</span> <span class="toc-text">3) 统计当前的内存数,定义新函数freememory(),在kalloc.h中.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AE%8C%E6%88%90sysinfo%E7%9A%84%E6%93%8D%E4%BD%9C-%E6%B3%A8%E6%84%8F2-%E5%92%8C3-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E8%A6%81%E5%A3%B0%E6%98%8E%E5%9C%A8def-h%E4%B8%AD"><span class="toc-number">3.0.0.0.4.</span> <span class="toc-text">4) 完成sysinfo的操作.注意2)和3)定义的函数要声明在def.h中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%83%8F%E4%B8%8A%E4%B8%AA%E5%AE%9E%E9%AA%8C%E4%B8%80%E6%A0%B7%E5%AE%8C%E6%88%90syscall-h-syscall-c%E7%9A%84%E6%94%AF%E6%8C%81%E5%8D%B3%E5%8F%AF"><span class="toc-number">3.0.0.0.5.</span> <span class="toc-text">5) 像上个实验一样完成syscall.h,syscall.c的支持即可.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Xv6-and-PageTable"><span class="toc-number">3.0.1.</span> <span class="toc-text">3:Xv6 and PageTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab3-1-Speed-Up-the-system-calls"><span class="toc-number">3.0.2.</span> <span class="toc-text">Lab3_1 Speed Up the system calls</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A1%AE%E8%AE%A4usyscall%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88-%E5%85%B6%E5%AE%9E%E5%AD%98%E5%82%A8%E7%9A%84%E5%B0%B1%E6%98%AFpid"><span class="toc-number">3.0.2.0.1.</span> <span class="toc-text">1) 确认usyscall的结构体是什么,其实存储的就是pid.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E6%B7%BB%E5%8A%A0usyscall%E7%9A%84%E5%85%83%E7%B4%A0-%E8%BF%99%E4%B8%AA%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%A1%B5%E9%87%8C%E9%9D%A2"><span class="toc-number">3.0.2.0.2.</span> <span class="toc-text">2) 为每个进程结构添加usyscall的元素,这个结构存储在一个新的页里面.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%93%E5%BC%80proc-c-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E7%BB%99usyscall%E7%BB%93%E6%9E%84%E4%BD%93%E7%94%B3%E8%AF%B7%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.0.2.0.3.</span> <span class="toc-text">3) 打开proc.c,依葫芦画瓢给usyscall结构体申请一个页面.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BE%9D%E6%8D%AE%E6%8F%90%E7%A4%BA-%E6%88%91%E4%BB%AC%E5%9C%A8proc-pagetable%E4%B8%AD%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84-%E6%B3%A8%E6%84%8F-%E5%A6%82%E6%9E%9C%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5%E6%98%AF%E8%A6%81%E6%8A%8A%E4%B9%8B%E5%89%8D%E4%BF%A9%E9%83%BD%E7%BB%99%E5%8F%96%E6%B6%88%E6%8E%89"><span class="toc-number">3.0.2.0.4.</span> <span class="toc-text">4) 依据提示,我们在proc_pagetable中依葫芦画瓢来进行地址的映射,注意,如果映射失败是要把之前俩都给取消掉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96usyscall%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.2.0.5.</span> <span class="toc-text">5) 在进程初始化的时候添加初始化的代码.初始化usyscall的结构.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E7%9A%84%E6%97%B6%E5%80%99-free%E6%8E%89%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%8A%E8%BF%99%E4%B8%80%E9%A1%B5%E4%B9%9Ffree%E6%8E%89"><span class="toc-number">3.0.2.0.6.</span> <span class="toc-text">6) 进程结束的时候,free掉进程的时候把这一页也free掉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E7%9A%84%E6%97%B6%E5%80%99-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E6%8A%8A%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%BB%99%E5%8F%96%E6%B6%88%E6%8E%89"><span class="toc-number">3.0.2.0.7.</span> <span class="toc-text">7) 进程结束的时候,依葫芦画瓢把映射关系给取消掉.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-2-Print-a-page-table"><span class="toc-number">3.1.</span> <span class="toc-text">Lab3_2 Print a page table</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%B9%E6%8D%AE%E6%8F%90%E7%A4%BA-%E5%9C%A8exec%E7%9A%84return-argc%E4%B9%8B%E5%89%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AE%B5"><span class="toc-number">3.1.0.0.1.</span> <span class="toc-text">1) 根据提示,在exec的return argc之前添加一段:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8def-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%B9%E4%BA%8Evmprint%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.0.0.2.</span> <span class="toc-text">2) 在def.h中添加对于vmprint的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9vm-c-%E4%BB%BF%E7%85%A7freewalk%E6%94%B9%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.0.3.</span> <span class="toc-text">3) 修改vm.c,仿照freewalk改造函数.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-3-Detecting-which-pages-have-been-accessed"><span class="toc-number">3.2.</span> <span class="toc-text">Lab3_3 Detecting which pages have been accessed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%82%E9%98%85RISC-V%E6%89%8B%E5%86%8C-%E7%A1%AE%E5%AE%9APTE-A%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.0.0.1.</span> <span class="toc-text">1) 参阅RISC-V手册,确定PTE_A是什么.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%8C%E6%88%90sys-pgaccess-%E5%9C%A8%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0-%E5%88%A9%E7%94%A8argaddr%E5%92%8Cargint%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.0.0.2.</span> <span class="toc-text">2) 完成sys_pgaccess,在这里主要是处理参数.利用argaddr和argint处理参数.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96%E5%BD%93%E5%89%8D%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0-walk"><span class="toc-number">3.2.0.0.3.</span> <span class="toc-text">3) 读取当前虚拟地址,找到对应的页表项目的函数找到:walk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%BB%E5%8F%96%E6%8E%A5%E7%9D%80%E6%A0%B9%E6%8D%AEpte%E8%A1%A8%E9%A1%B9-%E6%89%BE%E5%88%B0PTE-A%E4%BD%8D"><span class="toc-number">3.2.0.0.4.</span> <span class="toc-text">4) 读取接着根据pte表项,找到PTE_A位.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Xv6-and-Trap"><span class="toc-number">4.</span> <span class="toc-text">4:Xv6 and Trap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-1-RISC-V-Assembly"><span class="toc-number">4.1.</span> <span class="toc-text">Lab4_1 RISC-V Assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-2-BackTrace"><span class="toc-number">4.2.</span> <span class="toc-text">Lab4_2 BackTrace</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8def-h%E6%B7%BB%E5%8A%A0backtrace-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.0.0.1.</span> <span class="toc-text">1) 在def.h添加backtrace()函数的声明.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-GCC-%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E5%BD%93%E5%89%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%A7%E6%8C%87%E9%92%88%E5%AD%98%E5%82%A8%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8s0%E4%B8%AD-s0%E5%B0%B1%E5%AF%B9%E5%BA%94%E4%B8%8A%E9%9D%A2%E7%9A%84fp%E6%8C%87%E9%92%88"><span class="toc-number">4.2.0.0.2.</span> <span class="toc-text">2) GCC 编译器将当前执行的函数的帧指针存储在寄存器s0中,s0就对应上面的fp指针.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%88%90backtrace"><span class="toc-number">4.2.0.0.3.</span> <span class="toc-text">3) 完成backtrace()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-3-Alarm"><span class="toc-number">4.3.</span> <span class="toc-text">Lab4_3 Alarm</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#test0%EF%BC%9A%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.0.0.1.</span> <span class="toc-text">test0：调用处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#test1-test2-%E6%81%A2%E5%A4%8D%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.0.0.2.</span> <span class="toc-text">test1&#x2F;test2(): 恢复中断的代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8user-h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.0.0.3.</span> <span class="toc-text">1) 在user.h中添加声明:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8user-pl%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E4%BB%A5%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.0.0.4.</span> <span class="toc-text">2) 在user.pl添加函数入口以生成汇编代码.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8syscall-h%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7-1"><span class="toc-number">4.3.0.0.5.</span> <span class="toc-text">3) 在syscall.h添加系统调用号.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8syscall-c%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.0.0.6.</span> <span class="toc-text">4) 在syscall.c中添加关于这两个系统调用的声明.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8proc%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98-%E4%BF%9D%E5%AD%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%AD%E6%96%AD-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88-%E8%BF%87%E5%A4%9A%E4%B9%85%E5%B0%B1%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E4%B8%AD%E6%96%AD-%E8%BF%98%E4%BF%9D%E5%AD%98%E4%B8%AD%E6%96%AD%E7%9A%84%E6%97%B6%E5%80%99%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88%E5%92%8C%E4%BF%9D%E5%AD%98%E7%9A%84%E6%A0%88%E5%B8%A7"><span class="toc-number">4.3.0.0.7.</span> <span class="toc-text">5) 在proc的进程结构体中添加成员,保存什么时候中断,中断执行什么,过多久就进行一次中断,还保存中断的时候栈顶指针和保存的栈帧.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%9C%A8allocproc%E5%87%BD%E6%95%B0%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%99%E4%BA%9B%E6%88%90%E5%91%98"><span class="toc-number">4.3.0.0.8.</span> <span class="toc-text">6) 在allocproc函数中初始化这些成员.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%AE%8C%E6%88%90sigalarm%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E5%81%9A%E6%B3%95%E5%B0%B1%E6%98%AF%E4%BB%8E%E5%AF%84%E5%AD%98%E5%99%A8%E8%8E%B7%E5%BE%97%E5%8F%82%E6%95%B0%E7%84%B6%E5%90%8E%E8%B5%8B%E5%80%BC%E7%BB%99proc%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AD"><span class="toc-number">4.3.0.0.9.</span> <span class="toc-text">7) 完成sigalarm的系统调用,做法就是从寄存器获得参数然后赋值给proc的元素中.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%AE%8C%E6%88%90%E6%97%B6%E9%92%9F"><span class="toc-number">4.3.0.0.10.</span> <span class="toc-text">8) 完成时钟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%AE%8C%E6%88%90%E8%BF%94%E5%9B%9E%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.0.0.11.</span> <span class="toc-text">9) 完成返回的操作.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Xv6-and-MultiThread"><span class="toc-number">5.</span> <span class="toc-text">6:Xv6 and MultiThread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-1-Uthread-switching-between-threads"><span class="toc-number">5.1.</span> <span class="toc-text">Lab6_1 Uthread: switching between threads</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9thread-switch%E7%9A%84%E4%BB%A3%E7%A0%81-%E6%B7%BB%E5%8A%A0%E4%B8%8A%E5%85%B3%E4%BA%8Ethread-switch-%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%8F%AA%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%98-%E6%81%A2%E5%A4%8Dcallee-save-register"><span class="toc-number">5.1.0.0.1.</span> <span class="toc-text">1) 修改thread_switch的代码,添加上关于thread_switch 的代码,只需要保存&#x2F;恢复callee-save register:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8Thread%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.0.0.2.</span> <span class="toc-text">2) 在Thread的数据结构中添加寄存器信息.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81-%E5%AF%B9ra%E5%92%8Csp%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%85%B6%E4%B8%ADra%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%96%AD%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80-%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-%E5%BD%93%E8%BF%99%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%BB%8E%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C-%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99ra"><span class="toc-number">5.1.0.0.3.</span> <span class="toc-text">3) 修改创建进程的代码.对ra和sp寄存器进行初始化.其中ra本质上就是断点寄存器.有一个参数就是一个地址,这个地址指向一个函数,当这个线程第一次启动的时候就从这个地址对应的指令开始执行.把这个参数传递给ra</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8switch%E5%87%BD%E6%95%B0-%E5%88%87%E6%8D%A2-%E5%85%B6%E4%B8%ADt%E6%98%AF%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B-next-thread%E6%98%AF%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.0.0.4.</span> <span class="toc-text">4) 调用switch函数,切换.其中t是当前进程,next_thread是下一个进程.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-2-Using-Thread"><span class="toc-number">5.2.</span> <span class="toc-text">Lab6_2 Using Thread.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-3-Barrier"><span class="toc-number">5.3.</span> <span class="toc-text">Lab6_3 Barrier</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Xv6-and-Networking"><span class="toc-number">6.</span> <span class="toc-text">7:Xv6 and Networking</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.0.0.0.2.</span> <span class="toc-text">你的工作.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">6.0.0.0.3.</span> <span class="toc-text">提示</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Xv6-and-Lock"><span class="toc-number">7.</span> <span class="toc-text">8:Xv6 and Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab8-1-Memory-Access"><span class="toc-number">7.1.</span> <span class="toc-text">Lab8_1 Memory Access.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8C%89%E7%85%A7%E6%8F%90%E7%A4%BA-%E6%9B%B4%E6%94%B9%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84-%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E5%86%85%E5%AD%98%E5%9D%97%E9%83%BD%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E9%94%81-%E6%98%AF%E6%AF%8F%E4%B8%AACPU%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E9%94%81"><span class="toc-number">7.1.0.0.1.</span> <span class="toc-text">1) 按照提示,更改内存块的结构.不是所有内存块都共享一个锁,是每个CPU都有一个独立的锁.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%94%B9%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E9%94%81"><span class="toc-number">7.1.0.0.2.</span> <span class="toc-text">2) 改为初始化所有锁.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96CPU%E7%9A%84id-%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%9C%B0%E6%96%B9%E8%8E%B7%E5%8F%96id%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E5%85%B3%E4%B8%AD%E6%96%AD-%E9%98%B2%E6%AD%A2%E5%9B%A0%E4%B8%BA%E4%B8%AD%E6%96%AD%E5%88%86%E9%85%8D%E7%BB%99%E5%85%B6%E4%BB%96CPU%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E4%BA%86"><span class="toc-number">7.1.0.0.3.</span> <span class="toc-text">3) 获取CPU的id,在这个地方获取id的时候要关中断,防止因为中断分配给其他CPU来进行处理了.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%B9%E4%BA%8Ekalloc%E5%92%8Ckfree%E7%9A%84%E9%94%81%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BF%9B%E5%85%A5%E6%94%B9%E6%88%90%E5%AF%B9%E4%BA%8ECPU%E4%B8%BAid%E7%9A%84%E9%82%A3%E4%B8%AA%E9%94%81"><span class="toc-number">7.1.0.0.4.</span> <span class="toc-text">4) 对于kalloc和kfree的锁获取和进入改成对于CPU为id的那个锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%A8if-r-%E7%9A%84%E5%90%8E%E9%9D%A2%E6%B7%BB%E5%8A%A0else-%E4%BB%A3%E8%A1%A8%E5%A6%82%E6%9E%9C%E5%AF%BB%E6%89%BE%E5%A4%B1%E8%B4%A5-%E5%B0%B1%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E6%A0%B8%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">7.1.0.0.5.</span> <span class="toc-text">5) 在if(r)的后面添加else,代表如果寻找失败,就到其他的核中获取.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Xv6-File-System"><span class="toc-number">8.</span> <span class="toc-text">9:Xv6 &amp; File System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab-9-1-Large-files"><span class="toc-number">8.1.</span> <span class="toc-text">Lab 9_1 Large files</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">8.1.0.0.1.</span> <span class="toc-text">1) 修改直接映射的数量.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E5%BA%94%E7%9A%84file-h%E7%9A%84inode%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%9F%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%94%B9"><span class="toc-number">8.1.0.0.2.</span> <span class="toc-text">2) 对应的file.h的inode结构体也要进行更改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%98%85%E8%AF%BBbmap%E7%9A%84%E4%BB%A3%E7%A0%81-0-NDIRECT-1-%E7%9B%B4%E6%8E%A5-NDIRECT-NDIRECT-NINDIRECT-1-%E4%B8%80%E7%BA%A7%E9%97%B4%E6%8E%A5"><span class="toc-number">8.1.0.0.3.</span> <span class="toc-text">3) 阅读bmap的代码: 0-NDIRECT-1 :直接 ,NDIRECT,NDIRECT+NINDIRECT-1:一级间接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BE%9D%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E4%BD%9C%E5%87%BA%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">8.1.0.0.4.</span> <span class="toc-text">4) 依葫芦画瓢作出二级索引.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%8C%E6%88%90%E7%B4%A2%E5%BC%95%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">8.1.0.0.5.</span> <span class="toc-text">5) 完成索引的释放.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab9-2-Symbolic-links"><span class="toc-number">8.2.</span> <span class="toc-text">Lab9_2 Symbolic links</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E7%95%A5"><span class="toc-number">8.2.0.0.1.</span> <span class="toc-text">1) 添加系统调用.(略)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8C%89%E7%85%A7%E5%AE%9E%E9%AA%8C%E6%8F%90%E7%A4%BA%E7%9A%84%E4%BF%A1%E6%81%AF-%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%8F-%E7%95%A5"><span class="toc-number">8.2.0.0.2.</span> <span class="toc-text">2) 按照实验提示的信息,添加两个新的宏.(略)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%8C%E6%88%90symlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.2.0.0.3.</span> <span class="toc-text">3) 完成symlink系统调用.</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>



  
<script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js" integrity="sha384-xneY1WY8hOfUzswrE4CrYq35N4BdVcxqxwHPr9zawE&#x2F;jMSCxD+jAPU55x&#x2F;jj3wlf" crossorigin="anonymous"></script>

  <script>
    function loadScripts(scripts, index) {
      if (index < scripts.length) {
        const script = scripts[index];
        const src = script.getAttribute('src');

        const loadScript = (scriptContent) => {
          const scriptElement = document.createElement('script');
          if (script.type) {
            scriptElement.type = script.type;
          }
          scriptElement.text = scriptContent;
          document.head.appendChild(scriptElement);
          loadScripts(scripts, index + 1);
        }

        if (src) {
          fetch(src)
            .then(response => {
              if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
              }
              return response.text();
            })
            .then(scriptContent => {
              loadScript(scriptContent);
            })
            .catch(error => {
              console.error('Failed to load script:', src, error);
            });
        } else {
          loadScript(script.text);
        }
      }
    }
    window.Pjax && new window.Pjax({
      selectors: [
        "#header img",
        "#header picture",
        "head title",
        "#header-title",
        "#subtitle-wrap",
        "#content",
        '#mobile-nav',
        '#lazy-script'
      ],
      switches: {
        "#header-title": Pjax.switches.outerHTML,
        "#subtitle-wrap": Pjax.switches.outerHTML,
        "#content": function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.outerHTML = newEl.outerHTML
          this.onSwitch()
        },
        "#mobile-nav": Pjax.switches.outerHTML,
        '#lazy-script': function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.innerHTML = newEl.innerHTML
          this.onSwitch()
        },
      },
      cacheBust: false
    })
  </script>
  
<script src="/js/pjax.js"></script>




  <script>
    function initLive2d() {
      live2d.init("https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/", {themeTipsPath: ""});
    }
  </script>
  
<script src="https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/js/live2d-autoload.js" onload="initLive2d &amp;&amp; initLive2d()" async></script>





<div id="lazy-script">
  <div>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
  
<script src="https://npm.webcache.cn/valine@1.5.1/dist/Valine.min.js" integrity="sha384-3ma91AExDeMAZ1rjTjaP8V2A2obQE+s5ltKRwYlwdpArz9xVbp0tF3b0VV2ACNPn" crossorigin="anonymous" data-pjax></script>

  <script data-pjax>
    var GUEST_INFO = ['nick', 'mail', 'link'];
    var guest_info = 'SukunaFans'.split(',').filter((item) => {
      return GUEST_INFO.indexOf(item) > -1
    });
    var recordIP = JSON.parse('true');
    var highlight = JSON.parse('true');
    var visitor = JSON.parse('false');

    new Valine({
      el: '.vcomment',
      appId: "xR5C19oD9KiPnawzBUJNSD64-gzGzoHsz",
      appKey: "BuHN9ATTBOcwMxGPy9IxuI8b",
      placeholder: "留下你的留言吧",
      pageSize: '10',
      avatar: 'mp',
      lang: 'zh-cn',
      recordIP: recordIP,
      highlight: highlight,
      visitor: visitor,
      requiredFields: guest_info,
      path: window.location.pathname
    });
  </script>









    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.0.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  
    
<script src="https://npm.webcache.cn/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6&#x2F;1Nxveei" crossorigin="anonymous" defer data-pjax></script>

    <script data-pjax>
      window.MathJax = {"tex":{"tags":"ams","useLabelIds":true,"inlineMath":[["$","$"],["\\\\(","\\\\)"]],"displayMath":[["$$","$$"],["\\\\[","\\\\]"]],"processEscapes":true,"processEnvironments":true,"autoload":{"color":[],"colorv2":["color"]},"packages":{"[+]":["noerrors"]}},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"ignoreHtmlClass":"tex2jax_ignore","processHtmlClass":"tex2jax_process"},"loader":{"load":["input/asciimath","[tex]/noerrors"]}};
    </script>
  


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
  </html>

