



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="灵山之上神风起" href="https://sukunashinmyoumaru-hust.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://sukunashinmyoumaru-hust.github.io/2022/02/26/oschallengelab/">



  <title>
华中科技大学操作系统挑战实验(PKE)基础解析 - 实验记录 |
Suwa shrine = 灵山之上神风起 = Sukuna_wireless</title>
<meta name="generator" content="Hexo 7.1.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">华中科技大学操作系统挑战实验(PKE)基础解析
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2022-02-26 17:34:26">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2022-02-26T17:34:26+08:00">2022-02-26</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>30k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>27 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Suwa shrine</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://s2.loli.net/2024/03/21/N7AWrf8Xs9VTL4P.jpg"></li>
          <li class="item" data-background-image="https://i.loli.net/2020/10/30/Z5W6r2BSoiThHG1.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2024/03/21/etuIv2DAC8wpdKs.png"></li>
          <li class="item" data-background-image="https://s2.loli.net/2024/03/21/MEKc7eqDtPGHWBp.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2024/03/21/8PBD6GfINvWY5tU.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2024/03/21/KgXYlCHOW4jSdoL.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" itemprop="item" rel="index" title="分类于 实验记录"><span itemprop="name">实验记录</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://sukunashinmyoumaru-hust.github.io/2022/02/26/oschallengelab/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/IMG_1335.PNG">
    <meta itemprop="name" content="Sukuna">
    <meta itemprop="description" content="Sukuna_wireless, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="灵山之上神风起">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="lab1-challenge1-打印用户程序调用栈（难度：★★☆☆☆）"><a href="#lab1-challenge1-打印用户程序调用栈（难度：★★☆☆☆）" class="headerlink" title="lab1_challenge1 打印用户程序调用栈（难度：★★☆☆☆）"></a>lab1_challenge1 打印用户程序调用栈（难度：★★☆☆☆）</h2><h4 id="给定应用"><a href="#给定应用" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTM="></span><strong>给定应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_print_backtrace.c</span><br><span class="line"></span><br><span class="line">  1 /\*</span><br><span class="line">  2  \* Below is the given application for lab1_challenge1_backtrace.</span><br><span class="line">  3  \* This app prints all functions before calling print_backtrace().</span><br><span class="line">  4  \*/</span><br><span class="line">  5</span><br><span class="line">  6 #include &quot;user_lib.h&quot;</span><br><span class="line">  7 #include &quot;util/types.h&quot;</span><br><span class="line">  8</span><br><span class="line">  9 **void** **f8**() &#123; print_backtrace(7); &#125;</span><br><span class="line"> 10 **void** **f7**() &#123; f8(); &#125;</span><br><span class="line"> 11 **void** **f6**() &#123; f7(); &#125;</span><br><span class="line"> 12 **void** **f5**() &#123; f6(); &#125;</span><br><span class="line"> 13 **void** **f4**() &#123; f5(); &#125;</span><br><span class="line"> 14 **void** **f3**() &#123; f4(); &#125;</span><br><span class="line"> 15 **void** **f2**() &#123; f3(); &#125;</span><br><span class="line"> 16 **void** **f1**() &#123; f2(); &#125;</span><br><span class="line"> 17</span><br><span class="line"> 18 **int** **main**(**void**) &#123;</span><br><span class="line"> 19   printu(&quot;back trace the user app in the following:\\n&quot;);</span><br><span class="line"> 20   f1();</span><br><span class="line"> 21   exit(0);</span><br><span class="line"> 22   **return** 0;</span><br><span class="line"> 23 &#125;</span><br></pre></td></tr></table></figure>
<p>以上程序在真正调用系统调用print_backtrace(7)之前的函数调用关系比复杂，图示起来有以下关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main -&gt; f1 -&gt; f2 -&gt; f3 -&gt; f4 -&gt; f5 -&gt; f6 -&gt; f7 -&gt; f8</span><br></pre></td></tr></table></figure>
<p>print_backtrace(7)的作用是将以上用户程序的函数调用关系，从最后的f8向上打印7层，预期的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: obj/app_print_backtrace</span><br><span class="line">Application program entry point (virtual address): 0x0000000081000072</span><br><span class="line">Switching to user mode...</span><br><span class="line">back trace the user app **in** the following:</span><br><span class="line">f8</span><br><span class="line">f7</span><br><span class="line">f6</span><br><span class="line">f5</span><br><span class="line">f4</span><br><span class="line">f3</span><br><span class="line">f2</span><br><span class="line">User exit with code:0.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTM="></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab1_3完成后的代码：</p>
<ul>
<li>（先提交lab1_3的答案，然后）切换到lab1_challenge1_backtrace、继承lab1_3中所做修改：</li>
</ul>
<p>&#x2F;&#x2F;切换到lab1_challenge1_backtrace<br>$ git checkout lab1_challenge1_backtrace </p>
<p>&#x2F;&#x2F;继承lab1_3以及之前的答案<br>$ git merge lab1_3_irq -m “continue to work on lab1_challenge1”</p>
<p>注意：**不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。**例如，由于以上的用户代码中print_backtrace()系统调用并未实现，所以构造时就会报错。同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：</li>
</ul>
<p>通过修改PKE内核，来实现从给定应用（user&#x2F;app_print_backtrace.c）到预期输出的转换。</p>
<p>对于print_backtrace()函数的实现要求：</p>
<p>应用程序调用print_backtrace()时，应能够通过控制输入的参数（如例子user&#x2F;app_print_backtrace.c中的7）控制回溯的层数。例如，如果调用print_backtrace(5)则只输出5层回溯；如果调用print_backtrace(100)，则应只回溯到main函数就停止回溯（因为调用的深度小于100）。</p>
<h4 id="实验指导"><a href="#实验指导" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTM="></span>实验指导</h4><p>为完成该挑战，PKE内核的完善应包含以下内容：</p>
<ul>
<li>系统调用路径上的完善，可参见<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjc3lzY2FsbA==">3.2</span>中的知识；</li>
<li>在操作系统内核中获取用户程序的栈。这里需要注意的是，PKE系统中当用户程序通过系统调用陷入到内核时，会切换到S模式的“用户内核”栈，而不是在用户栈上继续操作。我们的print_backtrace()函数的设计目标是回溯并打印用户进程的函数调用情况，所以，进入操作系统内核后，需要找到用户进程的用户态栈来开始回溯；</li>
<li>找到用户态栈后，我们需要了解用户态栈的结构。实际上，这一点在我们的第一章就有<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjFfcmlzY3YubWQjY2FsbF9zdGFja19zdHJ1Y3R1cmU=">举例</span>来说明，读者可以回顾一下第一章的例子；</li>
<li>通过用户栈找到函数的返回地址后，需要将虚拟地址转换为源程序中的符号。这一点，读者需要了解ELF文件中的符号节（.symtab section），以及字符串节（.strtab section）的相关知识，了解这两个节（section）里存储的内容以及存储的格式等内容。对ELF的这两个节，网上有大量的介绍，例如<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vkb25saWkvYXJ0aWNsZS9kZXRhaWxzLzg3NzkwNzU=">这里</span>，或阅读<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuNS9lbGYuNS5odG1s">Linux Man Page</span>。</li>
</ul>
<p>提示：</p>
<p>理论上，我们希望你了解函数调用时栈帧的结构，通过fp寄存器(s0)寻找各个栈帧；然而，编译器一般会优化掉fp，使得它的值始终为0，在发生函数调用时也不保存这个寄存器，实验的Makefile已经使用<code>-fno-omit-frame-pointer</code>禁止了此项优化。</p>
<p>第一章中的 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjFfcmlzY3YubWQjY2FsbF9zdGFja19zdHJ1Y3R1cmU=">举例</span> 程序中，函数调用的栈帧（此时 bar 函数作为叶子调用函数）类似下图：</p>
<p><img data-src="https://gitee.com/hustos/pke-doc/raw/master/pictures/fig1_2.png" alt="fig1_2"></p>
<p>注意，函数调用的叶子结点一般不会将ra保存到栈中；</p>
<p>如果你发现使用fp追踪栈底难度太大，可以假设用户程序的函数调用产生的栈帧总是定长的；为了获得这个长度，你可以：</p>
<p>$ riscv64-unknown-elf-objdump -d obj&#x2F;app_print_backtrace</p>
<p>观察<code>f1</code>~ <code>f8</code>开始时的汇编代码，特别注意用户态函数<code>do_user_call</code>，它的栈帧与<code>f1</code> 等略有不同。</p>
<p>使用这种方法虽然在局部变量太多，或者函数参数较多时无法正确实现 backtrace 功能，也不是我们预期的做法，但我们进行测试时确实会使用简单的测试用例（没有参数，局部变量），因此可以通过 :)</p>
<h4 id="实验解析"><a href="#实验解析" class="headerlink" title="实验解析"></a>实验解析</h4><p>首先最基本的,我们要了解ELF文件的基本组成.</p>
<p>ELF文件主要是由两个视角组成,一个是链接时的视角,还有一个执行时的视角,两个视角组成不同的两种组成</p>
<p><img data-src="https://img-blog.csdn.net/20160521110434854" alt="这里写图片描述"></p>
<p>在这个时候我们发现有三个非常关键的结构,一个是总结全部的ELF头部,还有一个程序头部表,用来指导如何创建一个新的进程来进行执行.节区头部表用来记录程序静态的链接信息.</p>
<p>首先是总的ELF头部信息.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf_header_t &#123;</span><br><span class="line">  uint32 magic;</span><br><span class="line">  uint8 elf[12];</span><br><span class="line">  uint16 type;      /\* Object file type \*/</span><br><span class="line">  uint16 machine;   /\* Architecture \*/</span><br><span class="line">  uint32 version;   /\* Object file version \*/</span><br><span class="line">  uint64 entry;     /\* Entry point virtual address \*/</span><br><span class="line">  uint64 phoff;     /\* Program header table file offset \*/</span><br><span class="line">  uint64 shoff;     /\* Section header table file offset \*/</span><br><span class="line">  uint32 flags;     /\* Processor-specific flags \*/</span><br><span class="line">  uint16 ehsize;    /\* ELF header size in bytes \*/</span><br><span class="line">  uint16 phentsize; /\* Program header table entry size \*/</span><br><span class="line">  uint16 phnum;     /\* Program header table entry count \*/</span><br><span class="line">  uint16 shentsize; /\* Section header table entry size \*/</span><br><span class="line">  uint16 shnum;     /\* Section header table entry count \*/</span><br><span class="line">  uint16 shstrndx;  /\* Section header string table index \*/</span><br><span class="line">&#125; elf_header;</span><br></pre></td></tr></table></figure>
<p>我们首先解释一下成员信息:</p>
<p>1、e_entry表示程序入口地址</p>
<p>2、e_ehsize：ELF Header结构大小</p>
<p>3、e_phoff、e_phentsize、e_phnum：描述Program Header Table的偏移、大小、结构(有多少个段首部)。</p>
<p>4、e_shoff、e_shentsize、e_shnum：描述Section Header Table的偏移、大小、数量(有多少个节首部)。</p>
<p>5、 e_shstrndx：这一项描述的是字符串表在Section Header Table中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）。一般等于e_shnum - 1</p>
<p>6、编译后比较固定的字段：e_ident 、 e_machine 、e_version 、e_entry 、e_flags 、e_ehsize</p>
<p>7、目前e_ehsize &#x3D; 52字节，e_shentsize &#x3D; 40字节，e_phentsize &#x3D; 32字节，这些值都是固定值，某些加固会修改这些值造成静态解析失败，可以修改回这些固定值</p>
<p>一个ELF文件中到底有哪些具体的 sections，由包含在这个ELF文件中的 section head table(SHT)决定。在SHT中，针对每一个section，都设置有一个条目（entry），用来描述对应的这个section，其内容主要包括该 section 的名称、类型、大小以及在整个ELF文件中的字节偏移位置等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// elf section header</span><br><span class="line">typedef struct elf_sect_header_t&#123;</span><br><span class="line">  uint32 name;</span><br><span class="line">  uint32 type;</span><br><span class="line">  uint64 flags;</span><br><span class="line">  uint64 addr; /*the first byte of the section.*/</span><br><span class="line">  uint64 offset;/*此成员的取值给出节区的第一个字节与文件头之间的偏移*/</span><br><span class="line">  uint64 size;</span><br><span class="line">  uint32 link;</span><br><span class="line">  uint32 info;</span><br><span class="line">  uint64 addralign;</span><br><span class="line">  uint64 entsize;</span><br><span class="line">&#125; elf_sect_header;</span><br></pre></td></tr></table></figure>

<p>一个程序里面有许许多多的节(段),在这个实验里面我们要关注两个段,一个是.symtab,还有就是.strtab段.</p>
<p>了解了基本的ELF文件信息,这个时候我们做的第一步就是更改ELF文件的加载方式.首先在ELF头文件中我们了解到有一个成员叫做shstrndx,这个表示了字符串表是第几个section,这个时候我们可以根据字符串表是第几个section获得其SHT的数据,如下面程序所示:因为我们知道找到section table是连续存放的,我们可以根据section table的连续性找到字符串表所在的位置.</p>
<p>总的地址:第一个SHT的地址+它是第几个SHT*一个SHT的内容(sh_addr是之前已经定义好的一个section_table的类型变量)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>我们找到了字符串表的头结构,顺理成章地可以根据offset成员获得字符串表本身的结构.用下面的程序获得之,并存入到elf_shstrtab里面.其中elf_shstrtab存放着这个section所有的内容.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>String table sections 保存着以 NULL 终止的一系列字符，一般我们称为字符串。object 文件使用这些字符串来描绘符号和 section 名。一个字符串的参考是一个 string table section 的索引。第一个字节，即索引 0，被定义保存着一个 NULL 字符。同样的，一个 string table 的最后一个字节保存着一个NULL 字符，所有的字符串都是以 NULL 终止。索引 0 的字符串是没有名字或者说是 NULL，它的解释依靠上下文。一个空的 string table section 是允许的；它的 section header 的成员 sh_size 将为 0。对空的 string table 来说，非 0 的索引是没有用的。</p>
<p>查阅资料发现SHT的name保存着该section的名字,但是设计ELF的人用一种很巧妙的方式保存了下来,所有的数据都放在String table sections这个段里面,name就是表示这个节的名字对于String table section这个节的偏移.就是地址可以用下面的公式表示:</p>
<p>地址&#x3D;String table节的首地址+SHT的name字段(SHT的name字段存储了这个节的名字对于String table节的首地址的偏移)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">00000000</span><br><span class="line">0000001b</span><br><span class="line">.text</span><br><span class="line">00000021</span><br><span class="line">.rodata</span><br><span class="line">00000029</span><br><span class="line">.rodata.str1.8</span><br><span class="line">00000038</span><br><span class="line">.debug_info</span><br><span class="line">00000044</span><br><span class="line">.debug_abbrev</span><br><span class="line">00000052</span><br><span class="line">.debug_loc</span><br><span class="line">0000005d</span><br><span class="line">.debug_aranges</span><br><span class="line">0000006c</span><br><span class="line">.debug_line</span><br><span class="line">00000078</span><br><span class="line">.debug_str</span><br><span class="line">00000083</span><br><span class="line">.comment</span><br><span class="line">0000008c</span><br><span class="line">.riscv.attributes</span><br><span class="line">0000009e</span><br><span class="line">.debug_frame</span><br><span class="line">000000ab</span><br><span class="line">.debug_ranges</span><br><span class="line">00000001</span><br><span class="line">.symtab</span><br><span class="line">00000009</span><br><span class="line">.strtab</span><br><span class="line">00000011</span><br><span class="line">.shstrtab</span><br></pre></td></tr></table></figure>

<p>我们找到了字段的名字这个时候就可以根据名字找到symtab字段和strtab字段了.用下面的程序,遍历一遍所有的section,找到匹配的即可.elf_symtab存放symtab的内容,elf_strtab存放strtab的内容.</p>
<p>做法就是遍历所有section,找到每个section的名字比较即可.找到了对应的Section就把Section的首地址拿出来,取整个Section的内容.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>加载完毕了之后我们就可以利用这些信息来找符号了.</p>
<p>我们已经知道了符号表的基本结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Word st_name;</span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line">    unsigned char st_info;</span><br><span class="line">    unsigned char st_other;</span><br><span class="line">    Elf32_Half st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>每一个符号都可以用一个结构表示,结构之间是线性地址分配的.</p>
<p>其中st_name的形式和之前SHT的name形式一样,也是这个符号对应的字符串对于strtab内容的第一个字节的字节地址的偏移,所以说名字就是strtab+name</p>
<p>st_value存储的是符号值,一般是地址.</p>
<p>st_info是当前符号的值.可以用下面的宏来进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ELF32_ST_BIND(i) ((i)&gt;&gt;4)</span><br><span class="line">#define ELF32_ST_TYPE(i) ((i)&amp;0xf)</span><br><span class="line">#define ELF32_ST_INFO(b, t) (((b)&lt;&lt;4)+((t)&amp;0xf))</span><br></pre></td></tr></table></figure>

<p>了解了这个结构之后我们就可以把这个Section的内容解释称一个Symbol结构的数组.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint64 sym_num = symtab_size / sizeof(elf_sym);</span><br><span class="line">elf_sym* symbols = (elf_sym*)elf_symtab;</span><br></pre></td></tr></table></figure>

<p>我们再来看看函数调用的时候的结构吧,我们这个实验函数是没有形式参数的,所以说函数在压栈的时候是只压两个元素的.</p>
<p>这个时候我们把符号表打印出来:其中第一项是函数的符号地址,第二项就是函数在栈中的大小,最后一个就是函数的名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">810002e0 car</span><br><span class="line">810002ca print</span><br><span class="line">810002e0 20 car</span><br><span class="line">810002ca 22 print</span><br><span class="line">810000c6 516 vsnprintf</span><br><span class="line">810000a0 38 print_backtrace</span><br><span class="line">8100031c 40 main</span><br><span class="line">81000000 24 do_user_call</span><br><span class="line">81000308 20 foo</span><br><span class="line">81000018 98 printu</span><br><span class="line">8100007a 38 exit</span><br><span class="line">810002f4 20 bar</span><br></pre></td></tr></table></figure>

<p>这个时候我们找到栈顶地址,栈顶地址可以通过栈帧进行获得,就是s0.我们知道函数调用层级越低占堆栈地址越高,比如说main-&gt;foo-&gt;bar-&gt;car-&gt;print</p>
<p>我们不需要考虑内核栈.</p>
<p>首先是找到栈帧中栈顶寄存器的值,就是s0,然后经过推算找到对应函数的值,一开始首先要把tf+8来抵消depth这个元素来进行处理.接着我们就可以根据地址元素和每个符号对应元素的大小进行输出了.输出的方式如下:遍历符号表然后找到target匹配的结果输出即可.(当target与符号表里面的元素值大致一样即可.)</p>
<p>其中STT_FUNC是一种特别的宏,这个代表这个符号是函数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>基本的处理方式就是这样子的,在user_lib.c中实现函数,实现的方式就是进行系统调用,然后在sys_call里面完善do_syscall,就是加一个case而已,然后再syscall函数里面进行处理,这个时候交付给vmm.c,process.c都可以.</p>
<h2 id="lab1-challenge2-打印异常代码行（难度：★★★★☆）"><a href="#lab1-challenge2-打印异常代码行（难度：★★★★☆）" class="headerlink" title="lab1_challenge2 打印异常代码行（难度：★★★★☆）"></a>lab1_challenge2 打印异常代码行（难度：★★★★☆）</h2><h4 id="给定应用-1"><a href="#给定应用-1" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTQ="></span><strong>给定应用</strong></h4><ul>
<li>user&#x2F;app_errorline.c（和lab1_2的应用一致）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1 /\*                                                                             </span><br><span class="line"> 2  \* Below is the given application for lab1_challenge2 (same as lab1_2).</span><br><span class="line"> 3  \* This app attempts to issue M-mode instruction in U-mode, and consequently raises an exception.</span><br><span class="line"> 4  \*/</span><br><span class="line"> 5 </span><br><span class="line"> 6 #include &quot;user_lib.h&quot;</span><br><span class="line"> 7 #include &quot;util/types.h&quot;</span><br><span class="line"> 8 </span><br><span class="line"> 9 **int** **main**(**void**) &#123;</span><br><span class="line">10   printu(&quot;Going to hack the system by running privilege instructions.\\n&quot;);</span><br><span class="line">11   // we are now in U(user)-mode, but the &quot;csrw&quot; instruction requires M-mode privilege.</span><br><span class="line">12   // Attempting to execute such instruction will raise illegal instruction exception.</span><br><span class="line">13   asm **volatile**(&quot;csrw sscratch, 0&quot;);</span><br><span class="line">14   exit(0);</span><br><span class="line">15 &#125;</span><br><span class="line">16 </span><br></pre></td></tr></table></figure>
以上程序试图在用户态读取在内核态才能读取的寄存器sscratch，因此此处会触发illegal instruction异常，你的任务是<strong>修改内核（包括machine文件夹下）的代码，使得用户程序在发生异常时，内核能够输出触发异常的用户程序的源文件名和对应代码行</strong>，如上面的应用预期输出如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: obj/app_errorline</span><br><span class="line">Application program entry point (virtual address): 0x0000000081000000</span><br><span class="line">Switch to user mode...</span><br><span class="line">Going to hack the system by running privilege instructions.</span><br><span class="line">Runtime error at user/app_errorline.c:13</span><br><span class="line">  asm volatile(&quot;csrw sscratch, 0&quot;);</span><br><span class="line">Illegal instruction!</span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTQ="></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab1_3完成后的代码：</p>
<ul>
<li>（先提交lab1_3的答案，然后）切换到lab1_challenge2_errorline、继承<strong>lab1_3</strong>（注意，不是继承lab1_challenge1_backtrace！<strong>PKE的挑战实验之间无继承关联</strong>）中所做修改：</li>
</ul>
<p>&#x2F;&#x2F;切换到lab1_challenge2_errorline<br>$ git checkout lab1_challenge2_errorline</p>
<p>&#x2F;&#x2F;继承lab1_3以及之前的答案<br>$ git merge lab1_3_irq -m “continue to work on lab1_challenge1”</p>
<p>注意：**不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。**同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：通过修改PKE内核（包括machine文件夹下的代码），使得用户程序在发生异常时，内核能够输出触发异常的用户程序的源文件名和对应代码行。</li>
<li>注意：虽然在示例的app_errorline.c中只触发了非法指令异常，但最终测试时你的内核也应能够对其他会导致panic的异常和其他源文件输出正确的结果。</li>
<li>文件名规范：需要包含路径，如果是用户源程序发生的错误，路径为相对路径，如果是调用的标准库内发生的错误，路径为绝对路径。</li>
<li>为了降低挑战的难度，本实验在elf.c中给出了debug_line段的解析函数make_addr_line。这个函数接受三个参数，ctx为elf文件的上下文指针，这个可以参考文件中的其他函数；debug_line为指向.debug_line段数据的指针，你需要读取elf文件中名为.debug_line的段保存到缓冲区中，然后将缓冲区指针传入这个参数；length为.debug_line段数据的长度。</li>
<li>函数调用结束后，process结构体的dir、file、line三个指针会各指向一个数组，dir数组存储所有代码文件的文件夹路径字符串指针，如&#x2F;home&#x2F;abc&#x2F;bcd的文件夹路径为&#x2F;home&#x2F;abc，本项目user文件夹下的app_errorline.c文件夹路径为user；file数组存储所有代码文件的文件名字符串指针以及其文件夹路径在dir数组中的索引；line数组存储所有指令地址，代码行号，文件名在file数组中的索引三者的映射关系。如某文件第3行为a &#x3D; 0，被编译成地址为0x1234处的汇编代码li ax, 0和0x1238处的汇编代码sd 0(s0), ax。那么file数组中就包含两项，addr属性分别为0x1234和0x1238，line属性为3，file属性为“某文件”的文件名在file数组中的索引。</li>
<li>注意：dir、file、line三个数组会依次存储在debug_line数据缓冲区之后，dir数组和file数组的大小为64。所以如果你用静态数组来存储debug_line段数据，那么这个数组必须足够大；或者你也可以把debug_line直接放在程序所有需映射的段数据之后，这样可以保证有足够大的动态空间。</li>
</ul>
<h4 id="实验指导-1"><a href="#实验指导-1" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvYmxvYi9tYXN0ZXIvY2hhcHRlcjNfdHJhcHMubWQjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTQ="></span>实验指导</h4><ul>
<li>为完成该挑战，需要利用用户程序编译时产生的<strong>调试信息</strong>，目前最广泛使用的调试信息格式是DWARF，可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGluaz90YXJnZXQ9aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9EV0FSRg==">这里</span>了解其格式，该网站的参考文献中也给出了DWARF的完整文档地址，必要时可参考。</li>
<li>你对内核代码的修改可能包含以下内容：<ul>
<li>修改读取elf文件的代码，找到包含调试信息的段，将其内容保存起来（可以保存在用户程序的地址空间中）</li>
<li>在适当的位置调用debug_line段解析函数，对调试信息进行解析，构造指令地址-源代码行号-源代码文件名的对应表，注意，连续行号对应的不一定是连续的地址，因为一条源代码可以对应多条指令。</li>
<li>在异常中断处理函数中，通过相应寄存器找到触发异常的指令地址，然后在上述表中查找地址对应的源代码行号和文件名输出</li>
</ul>
</li>
</ul>
<h4 id="实验解析-1"><a href="#实验解析-1" class="headerlink" title="实验解析"></a>实验解析</h4><p>首先我们观察一下process的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// code file struct, including directory index and file name char pointer</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    uint64 dir; char *file;</span><br><span class="line">&#125; code_file;</span><br><span class="line">// address-line number-file name table</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    uint64 addr, line, file;</span><br><span class="line">&#125; addr_line;</span><br><span class="line"></span><br><span class="line">// the extremely simple definition of process, used for begining labs of PKE</span><br><span class="line">typedef struct process &#123;</span><br><span class="line">  // pointing to the stack used in trap handling.</span><br><span class="line">  uint64 kstack;</span><br><span class="line">  // trapframe storing the context of a (User mode) process.</span><br><span class="line">  trapframe* trapframe;</span><br><span class="line">  char *debugline; char **dir; code_file *file; addr_line *line; int line_ind;</span><br><span class="line">&#125;process;</span><br></pre></td></tr></table></figure>

<p>多出来五个元素,一个是debugline,一个是dir,一个是code_file,一个是line,最后就是line_ind,了解这五个元素非常有必要.</p>
<p>首先就是debugline,其实本质上就是.debugline这个section的所有内容.</p>
<p>所以说函数的第一步就是找到debugline这个段的内容.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1   if (!strcmp(elf_shstrtab + sh_addr.name, &quot;.debugline&quot;)) &#123;</span><br><span class="line">2     if (elf_fpread(ctx, elf_debug_line, sh_addr.size, sh_addr.offset) != sh_addr.size)</span><br><span class="line">3       return EL_EIO;</span><br><span class="line">4     break;</span><br><span class="line">5   &#125;</span><br></pre></td></tr></table></figure>

<p>还是和lab1_1一样的做法,找到”.debugline”的存在,把所有的东西塞给老师提供的make_addr_size()函数里面.</p>
<p>首先是dir,dir是一个二级指针,指向了一个存放指针的数组,这些数组的元素是指针,指向了一个字符串,存储的都是所有代码文件可能存在的文件夹的名字.</p>
<p>举个例子,比如说我们的PKE.*dir可能指向user ,*(dir+1)可能指向kernel.</p>
<p>code_file就是存储了所有代码文件的信息,有多少个.c和.h文件,code_file这个数组就有多少元素.每个代码文件所对应的结构体保存了所在的文件夹的信息(索引),还保留了代码文件本身的信息.</p>
<p>addr_line就是保存了所有指令的指令地址,代码行号和这一行代码对应着哪一个文件里面的(具体在哪一行.c,.h)可以通过file和line两个元素确定这个指令对于哪个文件的哪一行.</p>
<p>接着就是处理中断了,这一次处理的中断是在M态下进行处理,我们对Illegal instructions的中断进行一个更改,添加一个对于print_error函数的调用,实现print_error就非常重要</p>
<p>下面介绍思路:</p>
<p>首先第一步,使用read_csr函数找到断点,断点的位置就是在mepc这个地方.</p>
<p>第二步就是找到断点这条指令对应的addr_line结构体,用while循环即可.</p>
<p>找到了结构体就可以知道了文件夹的名字,代码的名字(因为存的是索引地址),这个时候就可以构造出path了,就是文件的名字,已知addr_line,可以找到对应的code_file结构体,根据code_file结构体就可以找到dir的位置.(path是一个char型数组)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t dir_len = strlen((char*)current-&gt;dir[current-&gt;file[illegal_addr_line-&gt;file].dir]);</span><br><span class="line">size_t file_name_len = strlen((char*)current-&gt;file[illegal_addr_line-&gt;file].file);</span><br><span class="line">size_t path_len = dir_len + file_name_len + 1;</span><br><span class="line">char path[path_len + 1];</span><br><span class="line">strcpy(path, current-&gt;dir[current-&gt;file[illegal_addr_line-&gt;file].dir]);</span><br><span class="line">path[dir_len] = &#x27;/&#x27;;</span><br><span class="line">strcpy(path + dir_len + 1, current-&gt;file[illegal_addr_line-&gt;file].file);</span><br><span class="line">path[path_len] = &#x27;\0&#x27;;</span><br></pre></td></tr></table></figure>

<p>接着就是找到对应的代码了,这个时候我们可以使用spike_file相关操作来进行文件读取(因为已经知道路径了)</p>
<p>这个时候就可以用下面俩函数</p>
<p><strong>spike_file</strong>_t* <strong>spike_file_open</strong>(path, <strong>O_RDONLY</strong>, 0);&#x2F;&#x2F;打开文件</p>
<p>读了多长 <strong>spike_file_pread</strong>(读取文件的文件指针,读到哪里,最长读多长,从哪里开始读)</p>
<p>由于我们赖皮地知道了代码在第几行,所以说打开这个文件,读前面n-1行的元素,找到偏移地址就好了.(有多赖皮呢?我们甚至可以找到check的程序,我嫖下来给大家观看)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;user_lib.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  printu(&quot;Going to hack the system by running privilege instructions.\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // we are now in U(user)-mode, but the &quot;csrw&quot; instruction requires M-mode privilege.</span><br><span class="line">  // Attempting to execute such instruction will raise illegal instruction exception.</span><br><span class="line">  asm volatile(&quot;csrw sscratch, 0&quot;);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21</span><br><span class="line">0</span><br><span class="line">16</span><br><span class="line">74</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">86</span><br><span class="line">85</span><br><span class="line">35</span><br></pre></td></tr></table></figure>

<p>还输出每一行代码的ASCII含量,具体怎么统计的,请看下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>首先我们先用pread函数读取127个元素,然后用while循环处理掉这一行的代码,这样就少了一行,下一次读取就从这一行的’\n’的下一个ASCII开始读(程序中inner_off就代表这一行除了’\n’有几个字符),那么下一次读取就从inner_off+1个字符后开始,刚好处理一行.</p>
<p>比如说第一次处理code就是这个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>下一次处理code就变成了这个,整体往前前进了一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>到了这一步,前面的line-1行已经全部被处理了,那么我就只要第line行的字符就可以啦,处理方法如下:(处理到这一步code的内容已经整体前进了line-1行,现在code的第一个字符是异常代码的第一个ASCII,简单点说就是前面line-1行的元素已经全部处理完了),处理的方式就是利用offset</p>
<p>这里有代码,但是被ban了</p>
<h2 id="lab2-challenge1-复杂缺页异常（难度：★☆☆☆☆）"><a href="#lab2-challenge1-复杂缺页异常（难度：★☆☆☆☆）" class="headerlink" title="lab2_challenge1 复杂缺页异常（难度：★☆☆☆☆）"></a>lab2_challenge1 复杂缺页异常（难度：★☆☆☆☆）</h2><h4 id="给定应用-2"><a href="#给定应用-2" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvIyVFNyVCQiU5OSVFNSVBRSU5QSVFNSVCQSU5NCVFNyU5NCVBOC0z"></span>给定应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_sum_sequence.c</span><br><span class="line"></span><br><span class="line">1/\*</span><br><span class="line">2 \* The application of lab2_4.</span><br><span class="line">3 \* Based on application of lab2_3.</span><br><span class="line">4 \*/</span><br><span class="line">5</span><br><span class="line">6#include &quot;user_lib.h&quot;</span><br><span class="line">7#include &quot;util/types.h&quot;</span><br><span class="line">8</span><br><span class="line">9//</span><br><span class="line">10// compute the summation of an arithmetic sequence. for a given &quot;n&quot;, compute</span><br><span class="line">11// result = n + (n-1) + (n-2) + ... + 0</span><br><span class="line">12// sum_sequence() calls itself recursively till 0. The recursive call, however,</span><br><span class="line">13// may consume more memory (from stack) than a physical 4KB page, leading to a page fault.</span><br><span class="line">14// PKE kernel needs to improved to handle such page fault by expanding the stack.</span><br><span class="line">15//</span><br><span class="line">16uint64 **sum_sequence**(uint64 n, **int** \*p) &#123;</span><br><span class="line">17  **if** (n == 0)</span><br><span class="line">18    **return** 0;</span><br><span class="line">19  **else**</span><br><span class="line">20    **return** \*p=sum_sequence( n-1, p+1 ) + n;</span><br><span class="line">21&#125;</span><br><span class="line">22</span><br><span class="line">23**int** **main**(**void**) &#123;</span><br><span class="line">24  // FIRST, we need a large enough &quot;n&quot; to trigger pagefaults in the user stack</span><br><span class="line">25  uint64 n = 1024;</span><br><span class="line">26</span><br><span class="line">27  // alloc a page size array(int) to store the result of every step</span><br><span class="line">28  // the max limit of the number is 4kB/4 = 1024</span><br><span class="line">29</span><br><span class="line">30  // SECOND, we use array out of bound to trigger pagefaults in an invalid address</span><br><span class="line">31  **int** \*ans = (**int** \*)naive_malloc();</span><br><span class="line">32</span><br><span class="line">33  printu(&quot;Summation of an arithmetic sequence from 0 to %ld is: %ld \\n&quot;, n, sum_sequence(n+1, ans) );</span><br><span class="line">34</span><br><span class="line">35  exit(0);</span><br><span class="line">36&#125;</span><br></pre></td></tr></table></figure>
<p>程序思路基本同lab2_3一致，对给定n计算0到n的和，但要求将每一步递归的结果保存在数组ans中。创建数组时，我们使用了当前的malloc函数申请了一个页面（4KB）的大小，对应可以存储的个数上限为1024。在函数调用时，我们试图计算1025求和，首先由于n足够大，所以在函数递归执行时会触发用户栈的缺页，你需要对其进行正确处理，确保程序正确运行；其次，1025在最后一次计算时会访问数组越界地址，由于该处虚拟地址尚未有对应的物理地址映射，因此属于非法地址的访问，这是不被允许的，对于这种缺页异常，应该提示用户并退出程序执行。如上的应用预期输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x000000008000e000, PKE kernel size: 0x000000000000e000 .</span><br><span class="line">free physical memory address: [0x000000008000e000, 0x0000000087ffffff] </span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080004000</span><br><span class="line">kernel page table is on </span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000 </span><br><span class="line">Application: ./obj/app_sum_sequence</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100da</span><br><span class="line">Switching to user mode...</span><br><span class="line">handle_page_fault: 000000007fffdff8</span><br><span class="line">handle_page_fault: 000000007fffcff8</span><br><span class="line">handle_page_fault: 000000007fffbff8</span><br><span class="line">handle_page_fault: 000000007fffaff8</span><br><span class="line">handle_page_fault: 000000007fff9ff8</span><br><span class="line">handle_page_fault: 000000007fff8ff8</span><br><span class="line">handle_page_fault: 000000007fff7ff8</span><br><span class="line">handle_page_fault: 000000007fff6ff8</span><br><span class="line">handle_page_fault: 0000000000401000</span><br><span class="line">this address is not available!</span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure>
<p>根据结果可以看出：前八个缺页是由于函数递归调用引起的，而最后一个缺页是对动态申请的数组进行越界访问造成的，访问非法地址，程序报错并退出。</p>
<h4 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvIyVFNSVBRSU5RSVFOSVBQSU4QyVFNSU4NiU4NSVFNSVBRSVCOS0z"></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab2_3完成后的代码：</p>
<ul>
<li>（先提交lab2_3的答案，然后）切换到lab2_challenge1_pagefaults、继承lab2_3中所做修改：</li>
</ul>
<p>&#x2F;&#x2F;切换到lab2_challenge1_pagefault<br>$ git checkout lab2_challenge1_pagefaults</p>
<p>&#x2F;&#x2F;继承lab2_3以及之前的答案<br>$ git merge lab2_3_pagefault -m “continue to work on lab2_challenge1”</p>
<p>注意：**不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。**同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：通过修改PKE内核（包括machine文件夹下的代码），使得对于不同情况的缺页异常进行不同的处理。</li>
<li>文件名规范：需要包含路径，如果是用户源程序发生的错误，路径为相对路径，如果是调用的标准库内发生的错误，路径为绝对路径。</li>
</ul>
<h4 id="实验指导-2"><a href="#实验指导-2" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvIyVFNSVBRSU5RSVFOSVBQSU4QyVFNiU4QyU4NyVFNSVBRiVCQy0z"></span>实验指导</h4><ul>
<li>你对内核代码的修改可能包含以下内容：<ul>
<li>修改进程的数据结构以对虚拟地址空间进行监控。</li>
<li>修改kernel&#x2F;strap.c中的异常处理函数。对于合理的缺页异常，扩大内核栈大小并为其映射物理块；对于非法地址缺页，报错并退出程序。</li>
</ul>
</li>
</ul>
<h4 id="实验解析-2"><a href="#实验解析-2" class="headerlink" title="实验解析"></a>实验解析</h4><p>根据实验解析我们可以知道:我们首先要对虚拟地址空间进行监控,这个时候我们设置一个数据元素,假设为malloc_stack_pages来代表我们申请了多少块页.(这个元素一开始为0,每发生一次缺页中断我们就申请一块页)</p>
<p>如果是正常的缺页中断,那么我们可以根据lab2_3的指示进行处理.</p>
<p>如果是数组越界,那么编译器得到的访问地址必定相差很大,那么我们可以这样做,判断当前出现缺页中断的虚地址的地址是不是在可控的范围内,如果可控就进行中断,如果不可控就不做,那么我们只需要在处理缺页中断的地方添加上一段就可以:</p>
<p>就这么简单.</p>
<h2 id="lab2-challenge2-堆空间管理-（难度：★★★★☆）"><a href="#lab2-challenge2-堆空间管理-（难度：★★★★☆）" class="headerlink" title="lab2_challenge2 堆空间管理 （难度：★★★★☆）"></a>lab2_challenge2 堆空间管理 （难度：★★★★☆）</h2><h4 id="给定应用-3"><a href="#给定应用-3" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvdHJlZS9tYXN0ZXIjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTQ="></span>给定应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_singlepageheap.c</span><br><span class="line"></span><br><span class="line"> 1/\*</span><br><span class="line">2 \* Below is the given application for lab2_challenge2_singlepageheap.</span><br><span class="line">3 \* This app performs malloc memory.</span><br><span class="line">4 \*/</span><br><span class="line">5</span><br><span class="line">6#include &quot;user_lib.h&quot;</span><br><span class="line">7#include &quot;util/types.h&quot;</span><br><span class="line">8#include &quot;util/string.h&quot;</span><br><span class="line">9**int** **main**(**void**) &#123;</span><br><span class="line">10  </span><br><span class="line">11  **char** str[20] = &quot;hello world.&quot;;</span><br><span class="line">12  **char** \*m = (**char** \*)better_malloc(100);</span><br><span class="line">13  **char** \*p = (**char** \*)better_malloc(50);</span><br><span class="line">14  **if**((uint64)p - (uint64)m &gt; 512 )&#123;</span><br><span class="line">15    printu(&quot;you need to manage the vm space precisely!&quot;);</span><br><span class="line">16    exit(-1);</span><br><span class="line">17  &#125;</span><br><span class="line">18  better_free((**void** \*)m);</span><br><span class="line">19</span><br><span class="line">20  strcpy(p,str);</span><br><span class="line">21  printu(&quot;%s\\n&quot;,p);</span><br><span class="line">22  exit(0);</span><br><span class="line">23  **return** 0;</span><br><span class="line">24&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序先利用better_malloc分别申请100和50个字节的一个物理页的内存，然后使用better_free释放掉100个字节，向50个字节中复制一串字符串，进行输出。原本的pke中malloc的实现是非常简化的（一次直接分配一个页面），你的挑战任务是<strong>修改内核(包括machine文件夹下)的代码，使得应用程序的malloc能够在一个物理页中分配，并对各申请块进行合理的管理</strong>，如上面的应用预期输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x0000000080008000, PKE kernel size: 0x0000000000008000 .</span><br><span class="line">free physical memory address: [0x0000000080008000, 0x0000000087ffffff]</span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080005000</span><br><span class="line">kernel page table is on</span><br><span class="line">User application is loading.</span><br><span class="line">user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000</span><br><span class="line">Application: obj/app_singlepageheap</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100b0</span><br><span class="line">Switch to user mode...</span><br><span class="line">hello world.</span><br><span class="line">User exit with code:0.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<p>通过应用程序和对应的预期结果可以看出：两次申请的空间在同一页面，并且释放第一块时，不会释放整个页面，所以需要你设计合适的数据结构对各块进行管理，使得better_malloc申请的空间更加“紧凑”。</p>
<h4 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvdHJlZS9tYXN0ZXIjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTQ="></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab2_challenge1完成后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   （先提交lab2_3的答案，然后）切换到lab2_challenge2、继承lab2_3中所做修改：</span><br><span class="line"></span><br><span class="line">//切换到lab2_challenge2_singlepageheap</span><br><span class="line">$ git checkout lab2_challenge2_singlepageheap</span><br><span class="line"></span><br><span class="line">//继承lab2_challenge1以及之前的答案</span><br><span class="line">$ git merge lab2_3_pagefault -m &quot;continue to work on lab2_challenge2&quot;</span><br></pre></td></tr></table></figure>
<p>注意：**不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。**同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：通过修改PKE内核（包括machine文件下的代码），实现优化后的malloc函数，使得应用程序两次申请块在同一页面，并且能够正常输出存入第二块中的字符串”hello world”。</li>
<li>文件名规范：需要包含路径，如果是用户源程序发生的错误，路径为相对路径，如果是调用的标准库内发生的错误，路径为绝对路径。</li>
</ul>
<h4 id="实验指导-3"><a href="#实验指导-3" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MvdHJlZS9tYXN0ZXIjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTQ="></span>实验指导</h4><ul>
<li>为完成该挑战，你需要对进程的虚拟地址空间进行管理，建议参考Linux的内存分配策略从而实现malloc。</li>
<li>你对内核代码的修改可能包含以下内容：<ul>
<li>增加内存控制块数据结构对分配的内存块进行管理。</li>
<li>修改process的数据结构以扩展对虚拟地址空间的管理，后续对于heap的扩展，需要对新增的虚拟地址添加对应的物理地址映射。</li>
<li>设计函数对进程的虚拟地址空间进行管理，借助以上内容具体实现heap扩展。</li>
<li>设计malloc函数和free函数对内存块进行管理。</li>
</ul>
</li>
</ul>
<h4 id="实验解析-3"><a href="#实验解析-3" class="headerlink" title="实验解析"></a>实验解析</h4><p>实验要求我们每一次malloc不是申请一个页,每一次malloc都检查一遍目前该进程已经有的内存空间,在这个内存空间中进行地址分配.</p>
<p>首先我们知道这个是分块内存,所以说我们可以申明块的结构和存储一堆块的数组结构.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct mem_block&#123;</span><br><span class="line">  int start;</span><br><span class="line">  int end;</span><br><span class="line">&#125;mem_block;</span><br><span class="line"></span><br><span class="line">mem_block mem_blocks[16];</span><br><span class="line"></span><br><span class="line">mem_blocks[0].start//当前分块的第一个虚拟地址</span><br><span class="line">mem_blocks[0].end//最后一个地址</span><br><span class="line">mem_blocks_numbers++;//几个块</span><br></pre></td></tr></table></figure>

<p>这个时候由于只有一个进程,这个数据结构就只有一个,设置在进程块也可以,设置在vmm.h也可以.</p>
<p>如果是申明的第一个块,首先先申请需要的物理块,接着初始化mem_blocks数组的第一个元素(这里偷懒了,只申请了一个块)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>这里是用最佳适应算法,如果一个块是最小的,就要把这个块放在第一个位置,然后把其他的块都往后移动一格.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>如果不是最小的,就找到最适合这个块放置的位置,找到位置就是前面比我小,后面比我大,后面的先往后移动一位,这个块就放在这个空出来的位置上.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>最后先判断一下有没有越界,没有越界就继续做,如果越界的话就要继续申请物理块然后把块页转化信息写进页表中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>接着就是到达最后了,最后的情况就是这个是最大的块,就直接插入到最后一个.反正插入到最后一个是最简单的,直接默默地走在最后一个即可.</p>
<p>接着就是free,我们需要通过二分查找找到传进来的free地址是否能和某一个块的首地址匹配上.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>如果匹配不上就panic,如果匹配上了就做接下来的free操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>首先第一步,看看free之后是不是能够空出一整个页来,如果能空出一整页的话,这一整页就可以释放了,接着就是把这一个内存块从数组中抽出来,后面的元素一一往前移动.</p>
<p>由于数据集太弱了,狗都能过,所以说不代表我这个方法一定正确.</p>
<h2 id="lab3-challenge1-进程等待和数据段复制（难度：★★☆☆☆）"><a href="#lab3-challenge1-进程等待和数据段复制（难度：★★☆☆☆）" class="headerlink" title="lab3_challenge1 进程等待和数据段复制（难度：★★☆☆☆）"></a>lab3_challenge1 进程等待和数据段复制（难度：★★☆☆☆）</h2><h4 id="给定应用-4"><a href="#给定应用-4" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTM="></span><strong>给定应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_wait.c</span><br><span class="line"></span><br><span class="line">  1 /\*                                                                             </span><br><span class="line">  2  \* This app fork a child process, and the child process fork a grandchild process.</span><br><span class="line">  3  \* every process waits for its own child exit then prints.                     </span><br><span class="line">  4  \* Three processes also write their own global variables &quot;flag&quot;</span><br><span class="line">  5  \* to different values.</span><br><span class="line">  6  \*/</span><br><span class="line">  7 </span><br><span class="line">  8 #include &quot;user/user_lib.h&quot;</span><br><span class="line">  9 #include &quot;util/types.h&quot;</span><br><span class="line"> 10 </span><br><span class="line"> 11 **int** flag;</span><br><span class="line"> 12 **int** **main**(**void**) &#123;</span><br><span class="line"> 13     flag = 0;</span><br><span class="line"> 14     **int** pid = fork();</span><br><span class="line"> 15     **if** (pid == 0) &#123;</span><br><span class="line"> 16         flag = 1;</span><br><span class="line"> 17         pid = fork();</span><br><span class="line"> 18         **if** (pid == 0) &#123;</span><br><span class="line"> 19             flag = 2;</span><br><span class="line"> 20             printu(&quot;Grandchild process end, flag = %d.\\n&quot;, flag);</span><br><span class="line"> 21         &#125; **else** &#123;</span><br><span class="line"> 22             wait(pid);</span><br><span class="line"> 23             printu(&quot;Child process end, flag = %d.\\n&quot;, flag);</span><br><span class="line"> 24         &#125;</span><br><span class="line"> 25     &#125; **else** &#123;</span><br><span class="line"> 26         wait(-1);</span><br><span class="line"> 27         printu(&quot;Parent process end, flag = %d.\\n&quot;, flag);</span><br><span class="line"> 28     &#125;</span><br><span class="line"> 29     exit(0);</span><br><span class="line"> 30     **return** 0;</span><br><span class="line"> 31 &#125;</span><br></pre></td></tr></table></figure>
<p>wait系统调用是进程管理中一个非常重要的系统调用，它主要有两大功能：</p>
<ul>
<li>当一个进程退出之后，它所占用的资源并不一定能够立即回收，比如该进程的内核栈目前就正用来进行系统调用处理。对于这种问题，一种典型的做法是当进程退出的时候内核立即回收一部分资源并将该进程标记为僵尸进程。由父进程调用wait函数的时候再回收该进程的其他资源。</li>
<li>父进程的有些操作需要子进程运行结束后获得结果才能继续执行，这时wait函数起到进程同步的作用。</li>
</ul>
<p>在以上程序中，父进程把flag变量赋值为0，然后fork生成一个子进程，接着通过wait函数等待子进程的退出。子进程把自己的变量flag赋值为1，然后fork生成孙子进程，接着通过wait函数等待孙子进程的退出。孙子进程给自己的变量flag赋值为2并在退出时输出信息，然后子进程退出时输出信息，最后父进程退出时输出信息。由于fork之后父子进程的数据段相互独立（同一虚拟地址对应不同的物理地址），子进程对全局变量的赋值不影响父进程全局变量的值，因此结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x0000000080009000, PKE kernel size: 0x0000000000009000 .</span><br><span class="line">free physical memory address: [0x0000000080009000, 0x0000000087ffffff] </span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080005000</span><br><span class="line">kernel page table is on </span><br><span class="line">Switch to user mode...</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000 </span><br><span class="line">User application is loading.</span><br><span class="line">Application: obj/app_wait</span><br><span class="line">CODE_SEGMENT added at mapped info offset:3</span><br><span class="line">DATA_SEGMENT added at mapped info offset:4</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100b0</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">User call fork.</span><br><span class="line">will fork a child from parent 0.</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fae000, user stack 0x000000007ffff000, user kstack 0x0000000087fad000 </span><br><span class="line">do_fork map code segment at pa:0000000087fb2000 of parent to child at va:0000000000010000.</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">User call fork.</span><br><span class="line">will fork a child from parent 1.</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fa1000, user stack 0x000000007ffff000, user kstack 0x0000000087fa0000 </span><br><span class="line">do_fork map code segment at pa:0000000087fb2000 of parent to child at va:0000000000010000.</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Grandchild process end, flag = 2.</span><br><span class="line">User exit with code:0.</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child process end, flag = 1.</span><br><span class="line">User exit with code:0.</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent process end, flag = 0.</span><br><span class="line">User exit with code:0.</span><br><span class="line">no more ready processes, system shutdown now.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<h4 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTM="></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab3_3完成后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   （先提交lab3_3的答案，然后）切换到lab3_challenge1_wait、继承lab3_3中所做修改：</span><br><span class="line"></span><br><span class="line">//切换到lab3_challenge1_wait</span><br><span class="line">$ git checkout lab3_challenge1_wait</span><br><span class="line"></span><br><span class="line">//继承lab3_3以及之前的答案</span><br><span class="line">$ git merge lab3_3_rrsched -m &quot;continue to work on lab3_challenge1&quot;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。</strong> 同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：<ul>
<li>通过修改PKE内核和系统调用，为用户程序提供wait函数的功能，wait函数接受一个参数pid：<ul>
<li>当pid为-1时，父进程等待任意一个子进程退出即返回子进程的pid；</li>
<li>当pid大于0时，父进程等待进程号为pid的子进程退出即返回子进程的pid；</li>
<li>如果pid不合法或pid大于0且pid对应的进程不是当前进程的子进程，返回-1。</li>
</ul>
</li>
<li>补充do_fork函数，实验3_1实现了代码段的复制，你需要继续实现数据段的复制并保证fork后父子进程的数据段相互独立。</li>
</ul>
</li>
<li>注意：最终测试程序可能和给出的用户程序不同，但都只涉及wait函数、fork函数和全局变量读写的相关操作。</li>
</ul>
<h4 id="实验指导-4"><a href="#实验指导-4" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTM="></span>实验指导</h4><ul>
<li>你对内核代码的修改可能包含添加系统调用、在内核中实现wait函数的功能以及对do_fork函数的完善。</li>
</ul>
<h4 id="实验解析-4"><a href="#实验解析-4" class="headerlink" title="实验解析"></a>实验解析</h4><p>首先第一步,我们要在do_fork函数中添加关于数据段的支持,那么在复制的时候只需要添加case DATA_SEGMENT的处理就可以.</p>
<p>对于代码段,我们是直接进行复制,虚拟地址直接合并的,如下面程序所示.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>就直接在子进程的虚地址转换表中添加父进程的代码段首地址和父进程的代码段首地址对应的实地址之间的映射,把父进程的实地址复制给子进程</p>
<p>但是对于数据段,父进程和子进程是不共享的,所以说要生成申请一个新的页给子进程.所以说虚地址是互通的,但是实地址不是互通的.改正成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>对于等待的处理.我们首先先判断是指定一个儿子还是指定所有的儿子.</p>
<p>这个时候我们在process数据结构里面定义一个新的元素,这个元素就是blockmap,就是等待谁结束停止阻塞,由于一个进程可以等待多个进程,我们做一个处理,就是第26位为1代表这个进程在等待pid&#x3D;&#x3D;26的进程结束.</p>
<p>所以说我们可以利用parent的结构来进行blockmap的处理,当某个进程的parent是当前进程,代表这个进程是你的儿子,所以说我们就可以指定,(blockmap一定程度上记录着儿子的信息.) 可以是blockmap &#x3D; 1&lt;&lt;pid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>

<p>那对于所有的进程呢?一样的的嘛,不过少了特判和break</p>
<p>那么对于exit也要进行改变,当一个进程结束的时候有可能会通知给其他进程.?代表这个进程是某个进程的儿子,某个进程正在等待您结束呢?用位运算就可以完成.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (?) != 0 &amp;&amp; proc-&gt;parent-&gt;pid == procs[i].pid &amp;&amp; procs[i].status == BLOCKED) &#123;</span><br><span class="line">  procs[i].status = READY;</span><br><span class="line">  insert_to_ready_queue(&amp;procs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lab3-challenge2-实现信号量（难度：★★★☆☆）"><a href="#lab3-challenge2-实现信号量（难度：★★★☆☆）" class="headerlink" title="lab3_challenge2 实现信号量（难度：★★★☆☆）"></a>lab3_challenge2 实现信号量（难度：★★★☆☆）</h2><h4 id="给定应用-5"><a href="#给定应用-5" class="headerlink" title="给定应用"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU3JUJCJTk5JUU1JUFFJTlBJUU1JUJBJTk0JUU3JTk0JUE4LTQ="></span><strong>给定应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">*   user/app_semaphore.c</span><br><span class="line"></span><br><span class="line">  1 /\*                                                                                                                                       </span><br><span class="line">  2 \* This app create two child process.</span><br><span class="line">  3 \* Use semaphores to control the order of</span><br><span class="line">  4 \* the main process and two child processes print info. </span><br><span class="line">  5 \*/</span><br><span class="line">  6 #include &quot;user/user_lib.h&quot;</span><br><span class="line">  7 #include &quot;util/types.h&quot;</span><br><span class="line">  8 </span><br><span class="line">  9 **int** **main**(**void**) &#123;</span><br><span class="line"> 10     **int** main_sem, child_sem[2];</span><br><span class="line"> 11     main_sem = sem_new(1);</span><br><span class="line"> 12     **for** (**int** i = 0; i &lt; 2; i++) child_sem[i] = sem_new(0);</span><br><span class="line"> 13     **int** pid = fork();</span><br><span class="line"> 14     **if** (pid == 0) &#123;</span><br><span class="line"> 15         pid = fork();</span><br><span class="line"> 16         **for** (**int** i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"> 17             sem_P(child_sem[pid == 0]);</span><br><span class="line"> 18             printu(&quot;Child%d print %d\\n&quot;, pid == 0, i);</span><br><span class="line"> 19             **if** (pid != 0) sem_V(child_sem[1]); **else** sem_V(main_sem);</span><br><span class="line"> 20         &#125;</span><br><span class="line"> 21     &#125; **else** &#123;</span><br><span class="line"> 22         **for** (**int** i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"> 23             sem_P(main_sem);</span><br><span class="line"> 24             printu(&quot;Parent print %d\\n&quot;, i);</span><br><span class="line"> 25             sem_V(child_sem[0]);</span><br><span class="line"> 26         &#125;</span><br><span class="line"> 27     &#125;</span><br><span class="line"> 28     exit(0);</span><br><span class="line"> 29     **return** 0;</span><br><span class="line"> 30 &#125;</span><br></pre></td></tr></table></figure>
<p>以上程序通过信号量的增减，控制主进程和两个子进程的输出按主进程，第一个子进程，第二个子进程，主进程，第一个子进程，第二个子进程……这样的顺序轮流输出，如上面的应用预期输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">PKE kernel start 0x0000000080000000, PKE kernel end: 0x0000000080009000, PKE kernel size: 0x0000000000009000 .</span><br><span class="line">free physical memory address: [0x0000000080009000, 0x0000000087ffffff] </span><br><span class="line">kernel memory manager is initializing ...</span><br><span class="line">KERN_BASE 0x0000000080000000</span><br><span class="line">physical address of _etext is: 0x0000000080005000</span><br><span class="line">kernel page table is on </span><br><span class="line">Switch to user mode...</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fbc000, user stack 0x000000007ffff000, user kstack 0x0000000087fbb000 </span><br><span class="line">User application is loading.</span><br><span class="line">Application: obj/app_semaphore</span><br><span class="line">CODE_SEGMENT added at mapped info offset:3</span><br><span class="line">DATA_SEGMENT added at mapped info offset:4</span><br><span class="line">Application program entry point (virtual address): 0x00000000000100b0</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">User call fork.</span><br><span class="line">will fork a child from parent 0.</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fae000, user stack 0x000000007ffff000, user kstack 0x0000000087fad000 </span><br><span class="line">do_fork map code segment at pa:0000000087fb2000 of parent to child at va:0000000000010000.</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">Parent print 0</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">User call fork.</span><br><span class="line">will fork a child from parent 1.</span><br><span class="line">**in** alloc_proc. user frame 0x0000000087fa2000, user stack 0x000000007ffff000, user kstack 0x0000000087fa1000 </span><br><span class="line">do_fork map code segment at pa:0000000087fb2000 of parent to child at va:0000000000010000.</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">Child0 print 0</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 0</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 1</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 1</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 1</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 2</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 2</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 2</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 3</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 3</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 3</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 4</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 4</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 4</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 5</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 5</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 5</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 6</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 6</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 6</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 7</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 7</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 7</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 8</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 8</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 8</span><br><span class="line">going to insert process 0 to ready queue.</span><br><span class="line">going to schedule process 0 to run.</span><br><span class="line">Parent print 9</span><br><span class="line">going to insert process 1 to ready queue.</span><br><span class="line">User exit with code:0.</span><br><span class="line">going to schedule process 1 to run.</span><br><span class="line">Child0 print 9</span><br><span class="line">going to insert process 2 to ready queue.</span><br><span class="line">User exit with code:0.</span><br><span class="line">going to schedule process 2 to run.</span><br><span class="line">Child1 print 9</span><br><span class="line">User exit with code:0.</span><br><span class="line">no more ready processes, system shutdown now.</span><br><span class="line">System is shutting down with exit code 0.</span><br></pre></td></tr></table></figure>
<h4 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU1JTg2JTg1JUU1JUFFJUI5LTQ="></span>实验内容</h4><p>本实验为挑战实验，基础代码将继承和使用lab3_3完成后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   （先提交lab3_3的答案，然后）切换到lab3_challenge2_semaphore、继承lab3_3中所做修改：</span><br><span class="line"></span><br><span class="line">//切换到lab3_challenge2_semaphore</span><br><span class="line">$ git checkout lab3_challenge2_semaphore</span><br><span class="line"></span><br><span class="line">//继承lab3_3以及之前的答案</span><br><span class="line">$ git merge lab3_3_rrsched -m &quot;continue to work on lab3_challenge1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意：不同于基础实验，挑战实验的基础代码具有更大的不完整性，可能无法直接通过构造过程。</strong> 同样，不同于基础实验，我们在代码中也并未专门地哪些地方的代码需要填写，哪些地方的代码无须填写。这样，我们留给读者更大的“想象空间”。</p>
<ul>
<li>本实验的具体要求为：通过修改PKE内核和系统调用，为用户程序提供信号量功能。</li>
<li>注意：最终测试程序可能和给出的用户程序不同，但都只涉及信号量的相关操作。</li>
</ul>
<h4 id="实验指导-5"><a href="#实验指导-5" class="headerlink" title="实验指导"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaHVzdG9zL3BrZS1kb2MjJUU1JUFFJTlFJUU5JUFBJThDJUU2JThDJTg3JUU1JUFGJUJDLTQ="></span>实验指导</h4><ul>
<li>你对内核代码的修改可能包含以下内容：<ul>
<li>添加系统调用，使得用户对信号量的操作可以在内核态处理</li>
<li>在内核中实现信号量的分配、释放和PV操作，当P操作处于等待状态时能够触发进程调度</li>
</ul>
</li>
</ul>
<h4 id="实验解析-5"><a href="#实验解析-5" class="headerlink" title="实验解析"></a>实验解析</h4><p>我觉得lab3_1比lab3_2难一点,因为3_2就是一个模拟题.</p>
<p>在主程序中用编号来模拟信号灯的序号,我们在程序中也同样做.</p>
<p>首先用一个数组来代表信号灯的值,再用一个数组来代表等待队列尾(上学期学过信号灯&#x3D;值+一个等待队列.)</p>
<p>如果新建一个新的信号灯,那么就是初始化等待队列而已(判断初值不能为负),并且维护一个值,代表当前已经生成的信号灯的数量.(方便我们对数组的某一个元素初始化).</p>
<p>P操作:就是先-1,如果小于0的话,就让这个进程阻塞,放入到等待队列队首</p>
<p>V操作:先+1,如果等待队列不为空的话就让等待队列队首投入就绪状态.(出队)</p>
<p>由于process结构体有一个元素就是等待队列下一个元素,所以说我们可以进行模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有代码,但是被ban了</span><br></pre></td></tr></table></figure>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-02-29 15:20:21" itemprop="dateModified" datetime="2024-02-29T15:20:21+08:00">2024-02-29</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.jpg" alt="Sukuna 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.jpg" alt="Sukuna 支付宝">
        <p>支付宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Sukuna <i class="ic i-at"><em>@</em></i>灵山之上神风起
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://sukunashinmyoumaru-hust.github.io/2022/02/26/oschallengelab/" title="华中科技大学操作系统挑战实验(PKE)基础解析">https://sukunashinmyoumaru-hust.github.io/2022/02/26/oschallengelab/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/12/18/oslab2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;03&#x2F;21&#x2F;etuIv2DAC8wpdKs.png" title="华中科技大学OS实验解析(Lab2)">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 实验记录</span>
  <h3>华中科技大学OS实验解析(Lab2)</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/03/30/splay/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;03&#x2F;21&#x2F;N7AWrf8Xs9VTL4P.jpg" title="Splay模版:P3369[模版&#x2F;普通平衡树]">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 算法题</span>
  <h3>Splay模版:P3369[模版/普通平衡树]</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#lab1-challenge1-%E6%89%93%E5%8D%B0%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">lab1_challenge1 打印用户程序调用栈（难度：★★☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC"><span class="toc-number">1.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">1.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab1-challenge2-%E6%89%93%E5%8D%B0%E5%BC%82%E5%B8%B8%E4%BB%A3%E7%A0%81%E8%A1%8C%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">lab1_challenge2 打印异常代码行（难度：★★★★☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-1"><span class="toc-number">2.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-1"><span class="toc-number">2.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab2-challenge1-%E5%A4%8D%E6%9D%82%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%86%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">lab2_challenge1 复杂缺页异常（难度：★☆☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-2"><span class="toc-number">3.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-2"><span class="toc-number">3.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-2"><span class="toc-number">3.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90-2"><span class="toc-number">3.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab2-challenge2-%E5%A0%86%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">lab2_challenge2 堆空间管理 （难度：★★★★☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-3"><span class="toc-number">4.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-3"><span class="toc-number">4.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-3"><span class="toc-number">4.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90-3"><span class="toc-number">4.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab3-challenge1-%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%A4%8D%E5%88%B6%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">lab3_challenge1 进程等待和数据段复制（难度：★★☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-4"><span class="toc-number">5.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-4"><span class="toc-number">5.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-4"><span class="toc-number">5.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90-4"><span class="toc-number">5.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab3-challenge2-%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%9A%BE%E5%BA%A6%EF%BC%9A%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">lab3_challenge2 实现信号量（难度：★★★☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%94%E7%94%A8-5"><span class="toc-number">6.0.1.</span> <span class="toc-text">给定应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-5"><span class="toc-number">6.0.2.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC-5"><span class="toc-number">6.0.3.</span> <span class="toc-text">实验指导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90-5"><span class="toc-number">6.0.4.</span> <span class="toc-text">实验解析</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2021/04/25/verilog/" rel="bookmark" title="华中科技大学Verilog实验解析">华中科技大学Verilog实验解析</a></li><li><a href="/2021/12/18/oslab1/" rel="bookmark" title="华中科技大学OS实验解析(Lab1)">华中科技大学OS实验解析(Lab1)</a></li><li><a href="/2021/12/18/oslab2/" rel="bookmark" title="华中科技大学OS实验解析(Lab2)">华中科技大学OS实验解析(Lab2)</a></li><li class="active"><a href="/2022/02/26/oschallengelab/" rel="bookmark" title="华中科技大学操作系统挑战实验(PKE)基础解析">华中科技大学操作系统挑战实验(PKE)基础解析</a></li><li><a href="/2023/02/06/rustilings/" rel="bookmark" title="Rustilings 练习笔记">Rustilings 练习笔记</a></li><li><a href="/2023/02/06/stanford-cs144-lab/" rel="bookmark" title="Stanford CS144 Lab">Stanford CS144 Lab</a></li><li><a href="/2023/02/07/cmu14-445-lab/" rel="bookmark" title="CMU14-445 Lab">CMU14-445 Lab</a></li><li><a href="/2023/02/08/mit-6-s081-lab/" rel="bookmark" title="MIT_6.s081_Lab">MIT_6.s081_Lab</a></li><li><a href="/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/" rel="bookmark" title="MIT_6.S081_xv6.Information 集合">MIT_6.S081_xv6.Information 集合</a></li><li><a href="/2023/09/13/nju-pa/" rel="bookmark" title="南大pa">南大pa</a></li><li><a href="/2024/04/17/stanford-cs143-PA/" rel="bookmark" title="Stanford CS143 PA">Stanford CS143 PA</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Sukuna"
      data-src="/images/IMG_1335.PNG">
  <p class="name" itemprop="name">Sukuna</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">18</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">3</span>
        <span class="name">分类</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1a3VuYXNoaW5teW91bWFydS1odXN0" title="https:&#x2F;&#x2F;github.com&#x2F;Sukunashinmyoumaru-hust"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zdWt1bmFfd2lyZWxlc3M=" title="https:&#x2F;&#x2F;twitter.com&#x2F;sukuna_wireless"><i class="ic i-twitter"></i></span>
      <a href="/sukuna@hust.edu.cn" title="sukuna@hust.edu.cn" class="item email"><i class="ic i-envelope"></i></a>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friend/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1a3VuYVNoaW5teW91bWFydS1odXN0L0h1c3Qtb3BlbnNvdXJjZS1YdWVqaWU="><i class="ic i-github"></i>HUST-学解</span>
  </li>

    
  <li class="item">
    <a href="/picture/" rel="section"><i class="ic i-magic"></i>赠画感谢</a>
  </li>

    
  <li class="item">
    <a href="/source/" rel="section"><i class="ic i-address-card"></i>资料下载</a>
  </li>

    
  <li class="item">
    <a href="/travel/" rel="section"><i class="ic i-heart"></i>旅行日志</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/12/18/oslab2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/03/30/splay/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2023/02/09/mit-6-s081-xv6-information-%E9%9B%86%E5%90%88/" title="MIT_6.S081_xv6.Information 集合">MIT_6.S081_xv6.Information 集合</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2021/04/25/verilog/" title="华中科技大学Verilog实验解析">华中科技大学Verilog实验解析</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2023/02/06/rustilings/" title="Rustilings 练习笔记">Rustilings 练习笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2021/12/18/oslab1/" title="华中科技大学OS实验解析(Lab1)">华中科技大学OS实验解析(Lab1)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2024/04/17/stanford-cs143-PA/" title="Stanford CS143 PA">Stanford CS143 PA</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E8%AE%B0/" title="分类于 杂记">杂记</a>
</div>

    <span><a href="/2020/05/02/setup/" title="建站">建站</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E8%AE%B0/" title="分类于 杂记">杂记</a>
</div>

    <span><a href="/2020/10/11/cmd/" title="(烂活)用cmd窗口输出图画">(烂活)用cmd窗口输出图画</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E8%AE%B0/" title="分类于 杂记">杂记</a>
</div>

    <span><a href="/2022/04/17/luogu-al/" title="做算法题综合">做算法题综合</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2023/02/06/stanford-cs144-lab/" title="Stanford CS144 Lab">Stanford CS144 Lab</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" title="分类于 实验记录">实验记录</a>
</div>

    <span><a href="/2023/02/07/cmu14-445-lab/" title="CMU14-445 Lab">CMU14-445 Lab</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sukuna @ Suwa shrine</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">408k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">6:11</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/02/26/oschallengelab/',
    favicon: {
      show: "（●´3｀●）あややややや～",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
