
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_tq6stt6tcg';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};</script>
  
  
  <title>
    做算法题综合 |
    
    Suwa shrine
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="洛谷刷题记录(2022)P2367 语文成绩(差分前缀和)题目描述 语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？ 输入格式 首先我们需要做一个差分数组,差分数组是数组的两个元素之间的差值.然后对每一个区间做加减运算的时候,我们只需要在首尾处对差分树组进行操作.进行操作.然后再进行合并即可.合并的操作就是给定数组">
<meta property="og:type" content="article">
<meta property="og:title" content="做算法题综合">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/2022/04/17/luogu-al/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="洛谷刷题记录(2022)P2367 语文成绩(差分前缀和)题目描述 语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？ 输入格式 首先我们需要做一个差分数组,差分数组是数组的两个元素之间的差值.然后对每一个区间做加减运算的时候,我们只需要在首尾处对差分树组进行操作.进行操作.然后再进行合并即可.合并的操作就是给定数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-1024x916.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-1-1006x1024.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-2-1024x941.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-4-1024x795.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-5-1024x841.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-6-1024x415.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-12-1024x719.png">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-c34b52deeb305f9413f534b570f9fed7_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-131d0c2aa952b43d45bba07dfc407e81_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-dbe284a90142f25d096bec9394436c2a_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-076590b86ba207ce143e94b2e823ad03_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8c01feeb7f41da7bdd5ef7afa96f778d_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-062b76d533174cda72c813758355544f_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-259b6415756adf3480ea5e8a80d1d578_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-73e0257639a78306bcf13ad0c68fcbdb_l3.svg">
<meta property="og:image" content="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-85ca23a1e42ccdfafecd1cf9622b44c3_l3.svg">
<meta property="article:published_time" content="2022-04-17T13:10:37.000Z">
<meta property="article:modified_time" content="2024-03-25T01:16:56.336Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sukunahust.com/wp-content/uploads/2021/11/image-1024x916.png">
  
  
    <link rel="alternate" href="/atom.xml" title="Suwa shrine" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
</head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/picture">赠画感谢</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/source">资料下载</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/travel">旅行日志</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/gbook">Sukuna冬令营</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    
      <img fetchpriority="high" src="/images/sukuna.png" alt="做算法题综合">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">做算法题综合</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content">
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-2022"><span class="toc-number">1.</span> <span class="toc-text">洛谷刷题记录(2022)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P2367-%E8%AF%AD%E6%96%87%E6%88%90%E7%BB%A9-%E5%B7%AE%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">P2367 语文成绩(差分前缀和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-CF44C-Holiday-%E5%B7%AE%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">双倍经验:CF44C Holiday (差分前缀和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1160-%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92-%E9%98%9F%E5%88%97%E6%A8%A1%E7%89%88%E9%A2%98-%E5%8C%85%E5%90%AB%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">P1160 队列安排(队列模版题,包含队列的添加和删除操作)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1044-%E6%A0%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">P1044 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P1449-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%A0%88%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">P1449 后缀表达式(栈的经典问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-P1981-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">(双倍经验) P1981 表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1165-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">P1165 日志分析(模拟栈)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P5788-%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">P5788 单调栈模版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">P1886 滑动窗口&#x2F;单调队列模版.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UVA540-%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">UVA540 团体队列(队列模拟)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%90%9C"><span class="toc-number">1.0.2.</span> <span class="toc-text">P1162 填涂颜色(简单深搜)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P1042-%E4%B9%92%E4%B9%93%E7%90%83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">P1042 乒乓球(字符串小模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1553-%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E5%8D%87%E7%BA%A7%E7%89%88-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">P1553 数字反转升级版(字符串小模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1332-Logo%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%92%E5%BD%92"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">P1332 Logo语言(字符串递归)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3375-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">P3375 KMP字符串匹配(KMP模版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1030-%E7%BB%99%E5%AE%9A%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%B1%82%E5%85%88%E5%BA%8F-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8CP1827-%E7%BE%8E%E5%9B%BD%E8%A1%80%E7%BB%9F"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">P1030 给定中序后序求先序(双倍经验P1827 美国血统)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1087-FBI%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0%E5%92%8C%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">P1087 FBI树(二叉树递归构造和模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3884-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98-LCA%E2%80%93%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">P3884 二叉树问题(LCA–最近公共祖先,树链剖分)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P4913-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">P4913 二叉树深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P5318-%E6%9F%A5%E6%89%BE%E6%96%87%E7%8C%AE-BFS%E5%92%8CDFS"><span class="toc-number">1.0.2.9.</span> <span class="toc-text">P5318 查找文献(BFS和DFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3371-%E5%8D%95%E5%85%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%89%88%E6%9C%AC"><span class="toc-number">1.0.2.10.</span> <span class="toc-text">P3371 单元最短路径(邻接表版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P2910-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%89%88%E6%9C%AC"><span class="toc-number">1.0.2.11.</span> <span class="toc-text">P2910 双倍经验(邻接矩阵版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3367-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%BE%80%E4%B8%8A%E6%90%9C%E7%B4%A2%E7%9A%84%E6%A0%91"><span class="toc-number">1.0.2.12.</span> <span class="toc-text">P3367 并查集(往上搜索的树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3366-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.0.2.13.</span> <span class="toc-text">P3366 最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3370-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.0.2.14.</span> <span class="toc-text">P3370 字符串哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1908-%E9%80%86%E5%BA%8F%E5%AF%B9-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.2.15.</span> <span class="toc-text">P1908 逆序对(归并排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1309-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.0.2.16.</span> <span class="toc-text">P1309 (双倍经验) 逆序对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="toc-number">1.0.2.17.</span> <span class="toc-text">P1090 合并果子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1138-%E6%9C%80k%E5%B0%8F%E6%95%B4%E6%95%B0"><span class="toc-number">1.0.2.18.</span> <span class="toc-text">P1138 最k小整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1918-%E4%BF%9D%E9%BE%84%E7%90%83"><span class="toc-number">1.0.2.19.</span> <span class="toc-text">P1918 保龄球</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P6510-%E5%A5%B6%E7%89%9B%E6%8E%92%E9%98%9F"><span class="toc-number">1.0.2.20.</span> <span class="toc-text">P6510 奶牛排队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3719-rexp"><span class="toc-number">1.0.2.21.</span> <span class="toc-text">P3719 rexp.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1185-%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.2.22.</span> <span class="toc-text">P1185 绘制二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3956-%E6%A3%8B%E7%9B%98"><span class="toc-number">1.0.2.23.</span> <span class="toc-text">P3956 棋盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1983-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.2.24.</span> <span class="toc-text">P1983 车站分级(拓扑排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1038-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.0.2.25.</span> <span class="toc-text">P1038 神经网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1381-%E5%8D%95%E8%AF%8D%E8%83%8C%E8%AF%B5"><span class="toc-number">1.0.2.26.</span> <span class="toc-text">P1381 单词背诵</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92"><span class="toc-number">2.</span> <span class="toc-text">P1002 [NOIP2002 普及组] 过河卒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1095-NOIP2007-%E6%99%AE%E5%8F%8A%E7%BB%84-%E5%AE%88%E6%9C%9B%E8%80%85%E7%9A%84%E9%80%83%E7%A6%BB"><span class="toc-number">3.</span> <span class="toc-text">P1095 [NOIP2007 普及组] 守望者的逃离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1048-NOIP2005-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%87%87%E8%8D%AF"><span class="toc-number">5.</span> <span class="toc-text">P1048 [NOIP2005 普及组] 采药</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF"><span class="toc-number">6.</span> <span class="toc-text">P1616 疯狂的采药</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">线性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1091-NOIP2004-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2"><span class="toc-number">8.</span> <span class="toc-text">P1091 [NOIP2004 提高组] 合唱队形</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1439-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">P1439 【模板】最长公共子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1880-NOI1995-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">10.</span> <span class="toc-text">P1880 [NOI1995] 石子合并</span></a></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
  
</aside>

          
          <section id="main"><article id="post-luogu-al" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2022/04/17/luogu-al/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2022-04-17T13:10:37.000Z" itemprop="datePublished">2022-04-17</time>
    <time style="display: none;" id="post-update-time">2024-03-25</time>
  </a>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/" data-aos="zoom-in">杂记</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="洛谷刷题记录-2022"><a href="#洛谷刷题记录-2022" class="headerlink" title="洛谷刷题记录(2022)"></a>洛谷刷题记录(2022)</h1><h4 id="P2367-语文成绩-差分前缀和"><a href="#P2367-语文成绩-差分前缀和" class="headerlink" title="P2367 语文成绩(差分前缀和)"></a>P2367 语文成绩(差分前缀和)</h4><p><strong>题目描述</strong></p>
<p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p>
<p><strong>输入格式</strong></p>
<p>首先我们需要做一个差分数组,差分数组是数组的两个元素之间的差值.然后对每一个区间做加减运算的时候,我们只需要在首尾处对差分树组进行操作.进行操作.然后再进行合并即可.合并的操作就是给定数组的第一个元素,根据差分数组的定义进行加即可.</p>
<p>1、首先构造差分数组.</p>
<p>2、接着对每一次小区间加减进行操作.</p>
<p>3、然后合并差分数组.</p>
<p>&#x2F;&#x2F;这个时候还不会stl,甚至还没有养成用宏来开数组的习惯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,p,a[5000005],f[5000005],ans=9999999,sum;</span><br><span class="line">int min(int a,int b)&#123;</span><br><span class="line">    return a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        f[i]=a[i]-a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        f[x]+=z;</span><br><span class="line">        f[y+1]-=z;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=f[i];</span><br><span class="line">        a[i]=sum;</span><br><span class="line">        ans=min(ans,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双倍经验-CF44C-Holiday-差分前缀和"><a href="#双倍经验-CF44C-Holiday-差分前缀和" class="headerlink" title="双倍经验:CF44C Holiday (差分前缀和)"></a>双倍经验:CF44C Holiday (差分前缀和)</h4><p><strong>对于有若干个区间,求一个点被多少个区间覆盖的问题就可以使用差分前缀和的思想.因为答案数组是全0的,对应的差分数组也是全0,输入每一个区间就相当于在这个区间做加1操作.然后合并即可</strong></p>
<p>那么差分是怎么做的,下面看题:</p>
<p>天假期，安排个人来浇花，第i个人负责天，问花是否可以每天都被浇水且不重复。 可以的话输出“OK”，不可以的话输出最早出问题的那天的天号以及那天花被浇了多少次水。</p>
<p>这道题就是有若干个区间,你需要找到每个点被多少个区间覆盖.那么我们可以进行差分,每一次进行+1操作即可,由于一开始数组取值为0,所以说初始的构造差分数组的步骤可以省略&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int a[N];</span><br><span class="line">int b[N];</span><br><span class="line">int k[N];</span><br><span class="line">int n,m;</span><br><span class="line">int flag;</span><br><span class="line">int i;</span><br><span class="line">int ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">        k[a[i]]++;</span><br><span class="line">        k[b[i]+1]--;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        k[i]+=k[i-1];</span><br><span class="line">        if(k[i]!=1)&#123;</span><br><span class="line">            printf(&quot;%d %d&quot;,i,k[i]);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1160-队列安排-队列模版题-包含队列的添加和删除操作"><a href="#P1160-队列安排-队列模版题-包含队列的添加和删除操作" class="headerlink" title="P1160 队列安排(队列模版题,包含队列的添加和删除操作)"></a>P1160 队列安排(队列模版题,包含队列的添加和删除操作)</h4><p>这道题就是一个纯粹的队列的模拟问题,我们可以采用数组模拟链表的策略,就是记录两个数组和,来记录左边和右边的人是谁,就是在i右边的人,是i左边的人是谁,添加的时候先判断是左边还是右边,插入的方法和删除的方法不需要多说了,<strong>这就是一个双向队列的模版</strong>.插入的时候注意插入的顺序即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=2,k,p;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;k,&amp;p);</span><br><span class="line">        if(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            int before=be[k];</span><br><span class="line">            nex[before]=i;nex[i]=k;            </span><br><span class="line">            be[k]=i;be[i]=before;</span><br><span class="line">            if(k==head)    head=i;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            nex[i]=nex[k];nex[k]=i;    </span><br><span class="line">            be[nex[i]]=i;be[i]=k;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    for(int i=1,c;i&lt;=m;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c),t[c]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!t[head])    printf(&quot;%d &quot;,head);</span><br><span class="line">        head=nex[head];</span><br><span class="line">    &#125;</span><br><span class="line">//better delete.</span><br><span class="line">//int be=be[i];</span><br><span class="line">//int nex=nex[i];</span><br><span class="line">//nex[be]=nex;</span><br><span class="line">//be[nex]=be;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1044-栈"><a href="#P1044-栈" class="headerlink" title="P1044 栈"></a>P1044 栈</h3><p>给定一个数,入栈序列一共有多少个出栈序列.</p>
<p>本质上是数学题,但是在计算机中比较难以计算.所以说用卡特兰数的定义是直接RE.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int computeCMN(int m, int n) &#123;</span><br><span class="line">if (n == 0  m == n) return 1;</span><br><span class="line">int c1 = computeCMN(m - 1, n);</span><br><span class="line">int c2 = computeCMN(m - 1, n - 1);</span><br><span class="line">return c1 + c2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d&quot;,computeCMN(2\*n,n)-computeCMN(2\*n,n-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们怎么办呢?我们这个时候还知道卡特兰序列有这么一个性质:</p>
<p>这个时候我们就可以进行递推就可以得到啦!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int n,m,nex[100010],be[100010],t[100010];</span><br><span class="line">int head=1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    nex[0]=1;</span><br><span class="line">    nex[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            nex[i]+=nex[j]\*nex[i-j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,nex[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然还有一种更加巧妙的.</p>
<h4 id="P1449-后缀表达式-栈的经典问题"><a href="#P1449-后缀表达式-栈的经典问题" class="headerlink" title="P1449 后缀表达式(栈的经典问题)"></a>P1449 后缀表达式(栈的经典问题)</h4><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p>
<p>如：对应的后缀表达式为：．．．．。’@’为表达式的结束符号。‘.’为操作数的结束符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char s[100005];</span><br><span class="line">int stack[100005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int top=0,i=0,x;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    while(s[i]!=&#x27;@&#x27;)&#123;</span><br><span class="line">        switch (s[i])</span><br><span class="line">        &#123;</span><br><span class="line">        case &#x27;+&#x27;:stack[--top]+=stack[top+1];break;//出栈之后再进栈</span><br><span class="line">        case &#x27;-&#x27;:stack[--top]-=stack[top+1];break;</span><br><span class="line">        case &#x27;\*&#x27;:stack[--top]\*=stack[top+1];break;</span><br><span class="line">        case &#x27;/&#x27;:stack[--top]/=stack[top+1];break;       </span><br><span class="line">        default:</span><br><span class="line">            x=0;</span><br><span class="line">            while(s[i]!=&#x27;.&#x27;)&#123;</span><br><span class="line">                x=x\*10+s[i++]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top]=x;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,stack[top]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历整个字符串,如果是基本的数字的话就把数字计算(计算方式和C语言学过的一模一样,数字字符串转数字的方法)出来然后入栈.如果是运算符就把栈顶的两个数字取出来做运算符对应的运算然后再放回栈中.</p>
<h4 id="双倍经验-P1981-表达式求值"><a href="#双倍经验-P1981-表达式求值" class="headerlink" title="(双倍经验) P1981 表达式求值"></a>(双倍经验) P1981 表达式求值</h4><p>给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。</p>
<p>先输入一个符号然后输入一个数字,然后判断符号的类型,如果是乘的话,优先级最高,就可以先做.取一个数然后乘,如果是加的话就直接把这个数字push进去就好了,因为只用处理乘,剩下的堆栈中存放的就是加法的加数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">int main()&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    int number;</span><br><span class="line">    int n1,n2;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;number);</span><br><span class="line">    num.push(number);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        if(ch==&#x27;\\n&#x27;) break;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;number);</span><br><span class="line">        if(ch==&#x27;\*&#x27;)&#123;</span><br><span class="line">            n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            num.push((n1%MOD)\*(number%MOD));</span><br><span class="line">        &#125;</span><br><span class="line">        if(ch==&#x27;+&#x27;)&#123;</span><br><span class="line">            num.push(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (!num.empty()) &#123;</span><br><span class="line">        sum += num.top();</span><br><span class="line">        sum %= 10000;</span><br><span class="line">        num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1165-日志分析-模拟栈"><a href="#P1165-日志分析-模拟栈" class="headerlink" title="P1165 日志分析(模拟栈)"></a>P1165 日志分析(模拟栈)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int n,p,now,maxn;</span><br><span class="line">int s[200005];</span><br><span class="line">int top=-1;</span><br><span class="line">int max(int x,int y)&#123;</span><br><span class="line">    return x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p);</span><br><span class="line">        if(p==0)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;s[++top]);</span><br><span class="line">            s[top]=max(s[top],s[top-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(top==-1)continue;</span><br><span class="line">            s[top--]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p==2)</span><br><span class="line">            printf(&quot;%d\\n&quot;,s[top]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>操作0（集装箱进库操作，相当于进栈），如果输入的数小于之前的最大值，就仍然存储原来的最大值因为后进先出，当前的如果小，永远不可能被操作2询问到，所以存了也没用，不然入栈，栈顶+1.栈f,就是从到元素的最大值.</li>
<li>操作1（集装箱出库操作，相当于出栈），直接栈顶-1.因为我们不需要知道最近入栈的元素是什么.所以说我们只需要知道当前所有元素的最大值就好了,一个元素的出栈就是我们不需要再讨论包含它的最大值,仅此而已.栈顶就是少了刚入栈的最大值即可.</li>
<li>操作2（集装箱询问操作，由于此时的栈顶是最大值，可以直接输出）</li>
</ol>
<h4 id="P5788-单调栈模版"><a href="#P5788-单调栈模版" class="headerlink" title="P5788 单调栈模版"></a>P5788 单调栈模版</h4><p>定义函数为第i个元素之后第一个大于的下标,求</p>
<p>举一个生活中的例子,就是对于若干个人排队,往后看,你可以看到第一个比你高的人,比你矮的人你全部都看不见,会被遮住,所以说这些点我们也不需要考虑了.</p>
<p>所以我们可以从后往前扫描并且维护一个栈,在栈中小于等于的要删掉,<strong>那么栈顶的就是第一个比大的下标</strong>.因为堆栈具有单调性质,在栈底的下标最大,在栈顶的下标最小.那我们从下标最小的栈顶往下走,找到第一个满足题目条件的下标.不满足题目条件的下标由于之后肯定用不到所以说可以删除.</p>
<p>最后一步就是这个数入栈.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define N = 3000005;</span><br><span class="line">int a[N], st[N], ans[N];</span><br><span class="line">int top;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">for(int i=n;i&gt;=1;i--) &#123;</span><br><span class="line">while(top&amp;&amp;a[st[top]]&lt;=a[i])top--;</span><br><span class="line">ans[i]=st[top];</span><br><span class="line">st[++top]=i;</span><br><span class="line">&#125; </span><br><span class="line">for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1886-滑动窗口-单调队列模版"><a href="#P1886-滑动窗口-单调队列模版" class="headerlink" title="P1886 滑动窗口&#x2F;单调队列模版."></a>P1886 滑动窗口&#x2F;单调队列模版.</h4><p>有一个长为  的序列，以及一个大小为的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p>首先是样例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<p>下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。</p>
<ol>
<li>由于此时队中没有一个元素，我们直接令1进队。此时，q&#x3D;{1},p&#x3D;{1}。</li>
<li>现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q&#x3D;{1,3},p&#x3D;{1,2}</li>
<li>下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从<strong>队尾</strong>出队。同理，1从队尾出队。最后-1进队，此时q&#x3D;{-1},p&#x3D;{3} 输出-1</li>
<li>出现-3，同上面分析，-1&gt;-3，-1从队尾出队,-3从队尾进队。q&#x3D;{-3}，p&#x3D;{4}。 输出-3</li>
<li>出现5，因为5&gt;-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q&#x3D;{-3,5},p&#x3D;{4,5} 输出-3</li>
<li>出现3。3先与队尾的5比较，3&lt;5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q&#x3D;{-3,3},p&#x3D;{4,6}输出-3</li>
<li>出现6。6与3比较，因为3&lt;6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从<strong>队首</strong>出队。此时，q&#x3D;{3,6},p&#x3D;{6,7} 输出3</li>
<li>出现7。队尾元素6小于7，7进队。此时，q&#x3D;{3,6,7},p&#x3D;{6,7,8}。 输出3</li>
</ol>
<p>总结一下: 假设入队从后往前比较:</p>
<p>(1)如果:</p>
<p>入队</p>
<p>(2)如果</p>
<p>出队,继续比较,知道队列没有元素或者有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">//stack&lt;int&gt; num;</span><br><span class="line">//stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int xianxu[1000];</span><br><span class="line">int a[10000005],value[100000005],queue1[100000005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    int h=1,t=1;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        //维护单调队列</span><br><span class="line">        while(h&lt;t&amp;&amp;value[t-1]&gt;a[i])t--;</span><br><span class="line">        value[t]=a[i];</span><br><span class="line">        queue1[t++]=i;</span><br><span class="line">        if(i-queue1[h]&gt;=k)h++;</span><br><span class="line">        if(i&gt;=k) printf(&quot;%d &quot;,value[h]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    h=1,t=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(h&lt;t&amp;&amp;value[t-1]&lt;a[i])t--;</span><br><span class="line">        value[t]=a[i];</span><br><span class="line">        queue1[t++]=i;</span><br><span class="line">        if(i-queue1[h]&gt;=k)h++;</span><br><span class="line">        if(i&gt;=k) printf(&quot;%d &quot;,value[h]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UVA540-团体队列-队列模拟"><a href="#UVA540-团体队列-队列模拟" class="headerlink" title="UVA540 团体队列(队列模拟)"></a>UVA540 团体队列(队列模拟)</h4><p>有 个团队的人正在排长队。每有一个新来的人时，他会从队首开始向后搜寻，如果发现有队友正在排队，他就会插队到他队友的身后；如果没有发现任何一个队友排队，他就只好站在长队的队尾。输入每个团队中所有队员的编号，要求支持如下  种指令：<code>ENQUEUE x</code>：编号为 x 的人进入长队。<code>DEQUEUE</code>：长队的队首出队。<code>STOP</code>：停止模拟。对于每个 <code>DEQUEUE</code> 指令，输出出队的人的编号。</p>
<p>这道题也是一个队列的模拟题,这一道题的难点就是在如何找到队友并插入.构建一个二维数组太慢了,不如我们用一下stl吧,这个stl叫做map,这个map可以帮我们做哈希映射,我们可以在很快的时间内找到序号和对应的分组.</p>
<p>就是说我们可以首次调用map[x]&#x3D;y,建立的映射,这个映射的查找是的,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MOD 10000</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int t,number=0;</span><br><span class="line">char\* str;</span><br><span class="line">int x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    str=(char\*)malloc(50);</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;t)==1&amp;&amp;t&gt;0)&#123;</span><br><span class="line">        map&lt;int ,int&gt; team;</span><br><span class="line">        printf(&quot;Scenario #%d\\n&quot;,++number);</span><br><span class="line">        for(int i=0;i&lt;t;i++)&#123;</span><br><span class="line">            int n;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">            int code;</span><br><span class="line">            while(n--)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;code);</span><br><span class="line">                team[code]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q,q_sup[100005];</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,str);</span><br><span class="line">            if(\*str==&#x27;S&#x27;) break;</span><br><span class="line">            else if(\*str==&#x27;D&#x27;)&#123;</span><br><span class="line">                x=q.front();</span><br><span class="line">                printf(&quot;%d\\n&quot;,q_sup[x].front());</span><br><span class="line">                q_sup[x].pop();</span><br><span class="line">                if(q_sup[x].empty()) q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else if(\*str==&#x27;E&#x27;)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">                int t=team[x];</span><br><span class="line">                if(q_sup[t].empty())q.push(t);</span><br><span class="line">                q_sup[t].push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始先建立map的映射关系,然后进行操作的时候我们维护一个主队列,主队列里面存储着小组的顺序,然后维护一个小组队列,存储着小组里面有什么人,由于插入的时候只会插入到每个小组的人后面,所以说出队也是按照小组的顺序出队,只有这个小组的所有人都出队了(判断方法,小组队列为空),才轮到另外一个小组出队.所以说入队的时候看看你是不是小组第一个,如果是的话就在主队列排一个队.出队的时候看看你是不是小组最后一个,如果是的话,就出主队列.总之由于出队一定是一个队一个队的顺序出队的,我们只需要记录队与队之间的顺序和队内部的顺序就好了.</p>
<h3 id="P1162-填涂颜色-简单深搜"><a href="#P1162-填涂颜色-简单深搜" class="headerlink" title="P1162 填涂颜色(简单深搜)"></a>P1162 填涂颜色(简单深搜)</h3><p>由数字组成的方阵中，有一任意形状闭合圈，闭合圈由数字构成，围圈时只走上下左右个方向。现要求把闭合圈内的所有空间都填写成.例如：的方阵（），涂色前和涂色后的方阵如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 1 1 1 1</span><br><span class="line">0 1 1 0 0 1</span><br><span class="line">1 1 0 0 0 1</span><br><span class="line">1 0 0 0 0 1</span><br><span class="line">1 1 1 1 1 1 </span><br><span class="line"></span><br><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 1 1 1 1</span><br><span class="line">0 1 1 2 2 1</span><br><span class="line">1 1 2 2 2 1</span><br><span class="line">1 2 2 2 2 1</span><br><span class="line">1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//char s[100005];</span><br><span class="line">//int stack[100005];</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line">#define MOD 10000</span><br><span class="line">int N,a[100][100];</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">    if(a[x][y]!=0)return ;</span><br><span class="line">    a[x][y]=-1;</span><br><span class="line">    if(x+1&lt;=N)dfs(x+1,y);</span><br><span class="line">    if(x-1&gt;=1)dfs(x-1,y);</span><br><span class="line">    if(y+1&lt;=N)dfs(x,y+1);</span><br><span class="line">    if(y-1&gt;=1)dfs(x,y-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        if(a[1][i]==0)dfs(1,i);</span><br><span class="line">        else if(a[N][i]==0)dfs(N,i);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        if(a[i][1]==0)dfs(i,1);</span><br><span class="line">        else if(a[i][N]==0)dfs(i,N);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i][1]==-1)printf(&quot;0&quot;);</span><br><span class="line">        else if(a[i][1]==0)printf(&quot;2&quot;);</span><br><span class="line">        else printf(&quot;1&quot;);</span><br><span class="line">        for(int j=2;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i][j]==-1)printf(&quot; 0&quot;);</span><br><span class="line">            else if(a[i][j]==0)printf(&quot; 2&quot;);</span><br><span class="line">            else printf(&quot; 1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是深度优先搜索,从边界开始进行搜索,遇到了可用的点就先进行标记,完后往上下左右搜索,遇到不可用的点(墙)就停止,这个时候没搜索到的就是被墙围起来的那部分.</p>
<h4 id="P1042-乒乓球-字符串小模拟"><a href="#P1042-乒乓球-字符串小模拟" class="headerlink" title="P1042 乒乓球(字符串小模拟)"></a>P1042 乒乓球(字符串小模拟)</h4><p>![image-20220410195828465](&#x2F;Users&#x2F;xupengzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220410195828465.png)</p>
<p>不贴代码了,这道题就是模拟题,我们就依次读取,维护两组元素,分别是11分下的胜负和21分下的胜负,用一个数组存储胜负的信息.a[N][0]存储的就是第N局的信息.判断每一局结束的标准就是分数是否超过了11(21)分并且两位选手的分差是不是大于2.</p>
<h4 id="P1553-数字反转升级版-字符串小模拟"><a href="#P1553-数字反转升级版-字符串小模拟" class="headerlink" title="P1553 数字反转升级版(字符串小模拟)"></a>P1553 数字反转升级版(字符串小模拟)</h4><p>给定一个数，请将该数各个位上数字反转得到一个新数。</p>
<p>这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为0（除非小数部分除了0没有别的数，那么只保留1个0）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为0），本次没有负数。</p>
<p>给定一个数，请将该数各个位上数字反转得到一个新数。</p>
<p>这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。</p>
<ul>
<li>整数反转是将所有数位对调。</li>
<li>小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。</li>
<li>分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。</li>
<li>百分数的分子一定是整数，百分数只改变数字部分。</li>
</ul>
<p>这次我们来了解一下string的一些操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;iostream&gt;</span><br><span class="line"># include&lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">bool isZero(string s)</span><br><span class="line">&#123;</span><br><span class="line">int j = 0;</span><br><span class="line">for(int i = 0;s[i];++i)</span><br><span class="line">if(s[i] == &#x27;0&#x27;)</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line">if(j == s.length())</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//倒置 </span><br><span class="line">void transpos(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = s1.length()-1,j = 0;i &gt;= 0;--i)</span><br><span class="line">s2 += s1[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//去除前导0</span><br><span class="line">void dePreZero(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">while(s1[i] == &#x27;0&#x27;)</span><br><span class="line">i++;</span><br><span class="line">s2.assign(s1,i,s1.npos);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//去除后缀0</span><br><span class="line">void  deSufZero(string s1,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">int i = s1.length()-1;</span><br><span class="line">while(s1[i] == &#x27;0&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">s2.assign(s1,0,i+1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s,ans,tmp;</span><br><span class="line">int idx;//特殊符号的位置 </span><br><span class="line"></span><br><span class="line">getline(cin,s);</span><br><span class="line">if(s.find(&#x27;.&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;.&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">cout &lt;&lt; &#x27;.&#x27;;</span><br><span class="line">tmp.clear();</span><br><span class="line">ans.clear();</span><br><span class="line">tmp.assign(s,idx+1,s.npos);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">deSufZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans; </span><br><span class="line">&#125;</span><br><span class="line">else if(s.find(&#x27;/&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;/&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; &quot;/&quot;;</span><br><span class="line">tmp.clear();</span><br><span class="line">ans.clear();</span><br><span class="line">tmp.assign(s,idx+1,s.npos);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans; </span><br><span class="line">&#125;</span><br><span class="line">else if(s.find(&#x27;%&#x27;,0) != -1)</span><br><span class="line">&#123;</span><br><span class="line">idx = s.find(&#x27;%&#x27;,0);</span><br><span class="line">tmp.assign(s,0,idx);</span><br><span class="line">if(isZero(tmp))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(tmp,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; &#x27;%&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(isZero(s))</span><br><span class="line">ans.assign(&quot;0&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">transpos(s,ans);</span><br><span class="line">dePreZero(ans,ans);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是前面几个辅助的函数,函数的声明里面有一个代表函数对这个变量的修改也会顺便引起对主程序里面变量的修改(和传指针一样).首先是转置函数,从后往前把字符串的值添加到中,由于已经做好了运算符重载,所以我们可以直接用+来进行添加元素的操作.接着就是去除前导0和后置0的,无非就是从前往后遍历和从后往前遍历而已.</p>
<p>那就分成几种就好办了,第一种就是小数,我们找到小数点,然后把小数点前面的值做一次翻转,去掉前面的0,然后小数点后面的值做一次翻转,去掉后面的0.就可以了 分数也是一样,找到分数符号,下亦同. 百分号,从1~s.length()-1处理即可.去掉前缀0. 整数最简单.</p>
<h4 id="P1332-Logo语言-字符串递归"><a href="#P1332-Logo语言-字符串递归" class="headerlink" title="P1332 Logo语言(字符串递归)"></a>P1332 Logo语言(字符串递归)</h4><p>Logo 语言命令可以指挥海龟在屏幕中爬行。本问题只使用 Logo 语言的三个语句：前进 <code>FD</code>，倒退 <code>BK</code>和重复 <code>REPEAT</code>，因此，海龟只在一条直线上来回爬行。输入一行 logo 的命令行，输出海龟在屏幕中离开原来位子的距离（假设屏幕很大，可以让海龟移开 1000000010000000 的距离）。</p>
<p>例如：</p>
<ul>
<li>输入 <code>FD 100</code> ，输出：100。</li>
<li>输入 <code>FD 100 BK 150</code>， 输出：50。</li>
<li>输入 <code>REPEAT 5[FD 100 BK 50]</code>， 输出：250。</li>
<li>输入 <code>REPEAT 5[ FD 50 REPEAT 10[FD 100]]</code>， 输出：5250。</li>
</ul>
<p>一般来说,遇到带括号的式子,朴素的想法就是递归.对于括号的处理往往是系数*括号内的内容值,括号内的内容也可以理解为一个式子的值,递归的基本条件也达成了.那我们就通过cin来处理字符串,(当然你用一个函数参数表示现在处理到什么位置也可以,或者用一个全局变量也可以).这道题用printf感觉不太行,就用cin了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 100005</span><br><span class="line">#define ll long long</span><br><span class="line">int handle()&#123;</span><br><span class="line">    char ch,x;string a;int n,ans=0;</span><br><span class="line">    while (cin&gt;&gt;ch)&#123;</span><br><span class="line">        if (ch==&#x27;]&#x27;) break;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;n;</span><br><span class="line">        if (ch==&#x27;R&#x27;)&#123;</span><br><span class="line">          //读入‘[’</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans+=n\*handle();</span><br><span class="line">          //读入空格</span><br><span class="line">            x=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        if (ch==&#x27;F&#x27;)&#123;</span><br><span class="line">          //读入空格</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ch==&#x27;B&#x27;)&#123;</span><br><span class="line">            x=getchar();</span><br><span class="line">            ans-=n;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x==&#x27;]&#x27;) break;</span><br><span class="line">    &#125;  </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout&lt;&lt;abs(handle());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先读取一下第一个指令的字符,反正只有几种,一个是FD前进,BK后退和REPEAT重复.那就每一次读取都读取一个字符串(输入剩下来的字符,比如说“EPEAT”,“D”,“K”等).还有一个数字,然后根据功能进入到不同的值中,(如果遇到了]就代表这一层括号已经结束了,可以返回递归的结果).(需要处理括号然后求出括号内的值的就需要用到递归,递归地求出值然后传给主函数)</p>
<h4 id="P3375-KMP字符串匹配-KMP模版"><a href="#P3375-KMP字符串匹配-KMP模版" class="headerlink" title="P3375 KMP字符串匹配(KMP模版)"></a>P3375 KMP字符串匹配(KMP模版)</h4><p>用字符串匹配就用KMP最好不过了2333</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 1000000+5</span><br><span class="line">using namespace std;</span><br><span class="line">char a[N];</span><br><span class="line">char b[N];</span><br><span class="line">int kmp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,a+1);</span><br><span class="line">    scanf(&quot;%s&quot;,b+1);</span><br><span class="line">    int a_length=strlen(a+1);</span><br><span class="line">    int b_length=strlen(b+1);</span><br><span class="line">    int p;</span><br><span class="line">    for(int i=2;i&lt;=b_length;i++)&#123;</span><br><span class="line">        p=kmp[i-1];</span><br><span class="line">        while(p&amp;&amp;b[p+1]!=b[i])&#123;</span><br><span class="line">            p=kmp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        if(b[p+1]==b[i]) kmp[i]=p+1;</span><br><span class="line">    &#125;</span><br><span class="line">    p=0;</span><br><span class="line">    for(int i=1;i&lt;=a_length;i++)&#123;</span><br><span class="line">        if(b[p+1]==a[i]) p++;</span><br><span class="line">        else&#123;</span><br><span class="line">            while(p &amp;&amp; b[p+1]!=a[i])p=kmp[p];</span><br><span class="line">            if(b[p+1]==a[i])p++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==b_length)printf(&quot;%d\\n&quot;,i-b_length+1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=b_length;i++)printf(&quot;%d &quot;,kmp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先就是KMP数组.就是字符串的前位组成的子串种前j位和后j位一样,比如说””.其中,就是这个字符串前5位的前3位和后3位都是””</p>
<p>然后就是匹配,不匹配就直接从重新开始,就酱紫…</p>
<h4 id="P1030-给定中序后序求先序-双倍经验P1827-美国血统"><a href="#P1030-给定中序后序求先序-双倍经验P1827-美国血统" class="headerlink" title="P1030 给定中序后序求先序(双倍经验P1827 美国血统)"></a>P1030 给定中序后序求先序(双倍经验P1827 美国血统)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define N 10</span><br><span class="line">char houxu[N];</span><br><span class="line">char zhongxu[N];</span><br><span class="line">int find(char ch)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(zhongxu[i]!=ch)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int l1,int r1,int l2,int r2)&#123;</span><br><span class="line">    char ch = houxu[r2];</span><br><span class="line">    printf(&quot;%c&quot;,ch);</span><br><span class="line">    int m = find(ch);</span><br><span class="line">    if(m&gt;l1) DFS(l1, m-1,l2,r2-r1+m-1);//r1-m是右子树的数目</span><br><span class="line">    if(m&lt;r1) DFS(m+1, r1, l2-l1+m, r2-1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,zhongxu);</span><br><span class="line">    scanf(&quot;%s&quot;,houxu);</span><br><span class="line">    int len=strlen(zhongxu);</span><br><span class="line">    DFS(0,len-1,0,len-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们在数据结构课中做这种题就是先找到后序遍历中找到根结点.然后根据根结点把中序遍历序列分成两部分.左中右,然后在搜索左子树和右子树.即可,搜索的函数就是(中序遍历首,中序遍历尾,后序遍历首,后序遍历尾).分成左右两个子树进行搜索即可.</p>
<p>中序:左中右 后序:左右中 然后按照这个规则进行切割,切割出左子树的部分和右子树的部分即可.</p>
<h4 id="P1087-FBI树-二叉树递归构造和模拟"><a href="#P1087-FBI树-二叉树递归构造和模拟" class="headerlink" title="P1087 FBI树(二叉树递归构造和模拟)"></a>P1087 FBI树(二叉树递归构造和模拟)</h4><p>![image-20220410211808841](&#x2F;Users&#x2F;xupengzhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220410211808841.png)</p>
<p>我们递归判断的时候可以这么做,如果这个树长度只有1,那么我们可以通过这个树的本身来判断究竟是B还是I树.如果这个树的长度比较长,那我们判断左子树和右子树的类型来判断这个树是FBI中的哪一种.进行遍历就好了,所以说甚至建树都不用建,用一个dfs打一个搜索就好啦!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 2000</span><br><span class="line">char str[N];</span><br><span class="line">int n;</span><br><span class="line">int tree(int l,int r)&#123;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        if(str[l]==&#x27;1&#x27;) &#123;</span><br><span class="line">            printf(&quot;I&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;B&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int le,ri;</span><br><span class="line">    if(l&lt;r)&#123;</span><br><span class="line">        le=tree(l,mid);</span><br><span class="line">        ri=tree(mid+1,r);</span><br><span class="line">    &#125;</span><br><span class="line">    if(le==0&amp;&amp;ri==0) &#123;</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(le==1&amp;&amp;ri==1)&#123;</span><br><span class="line">        printf(&quot;I&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;F&quot;);</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    scanf(&quot;%s&quot;,str+1);</span><br><span class="line">    tree(1,pow(2,n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P3884-二叉树问题-LCA–最近公共祖先-树链剖分"><a href="#P3884-二叉树问题-LCA–最近公共祖先-树链剖分" class="headerlink" title="P3884 二叉树问题(LCA–最近公共祖先,树链剖分)"></a>P3884 二叉树问题(LCA–最近公共祖先,树链剖分)</h4><p><strong>输入格式</strong></p>
<p>输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。</p>
<p><strong>输出格式</strong></p>
<p>三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离.</p>
<p>注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2， 与由根向叶结点方向（下行方向）时的边数之和。</p>
<p>这个是非常经典的树的问题:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int father[N],depth[N],width[N],son[N],parent[N];</span><br><span class="line">int n;</span><br><span class="line">int x,y;</span><br><span class="line">int find_father(int x,int y)&#123;</span><br><span class="line">    if(x==y) return x;</span><br><span class="line">    if(depth[x]==depth[y]) return find_father(parent[x], parent[y]);</span><br><span class="line">    else if(depth[x]&lt;depth[y]) return find_father(x, parent[y]);</span><br><span class="line">    else return find_father(parent[x], y);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    depth[1]=1;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;father[i],&amp;son[i]);</span><br><span class="line">        parent[son[i]]=father[i];</span><br><span class="line">        depth[son[i]]=depth[father[i]]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">    //depth</span><br><span class="line">    int max_depth=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_depth=std::max(max_depth,depth[i]);</span><br><span class="line">        width[depth[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,max_depth);</span><br><span class="line">    int max_width=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_width=std::max(max_width,width[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,max_width);</span><br><span class="line">    int fa=find_father(x,y);</span><br><span class="line">    printf(&quot;%d\\n&quot;,(depth[x]-depth[fa])\*2+(depth[y]-depth[fa]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个问题就是求深度,由于保证输入的时候按照序号顺序输入的,所以说可以用上面的方法.如果乱序的话还是要遍历一遍树的.求深度的时候用depth[i]表示i结点的深度是depth[i],然后再把每个深度有多少个结点保存起来,这样求宽度也求好了.</p>
<p>最关键的就是求两个点的距离了.求两个点的距离就是要找到最近的公共祖先,假设祖先为z,首先要从x往上走找到公共祖先,然后再从公共祖先往下走即可,走的步数可以直接用深度差表示.公共祖先找法是,先保持深度一样.然后再往上找,直到父亲是一样的为止.</p>
<h4 id="P4913-二叉树深度"><a href="#P4913-二叉树深度" class="headerlink" title="P4913 二叉树深度"></a>P4913 二叉树深度</h4><p>求二叉树的深度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 1000005</span><br><span class="line">struct BiTree&#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">&#125;;</span><br><span class="line">struct BiTree tr[N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int se(int root)&#123;</span><br><span class="line">    if(tr[root].l==0&amp;&amp;tr[root].r==0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=0;</span><br><span class="line">    if(tr[root].l)</span><br><span class="line">        l = se(tr[root].l)+1;</span><br><span class="line">    if(tr[root].r)</span><br><span class="line">        r = se(tr[root].r)+1;</span><br><span class="line">    return max(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;tr[i].l,&amp;tr[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    int s = se(1);</span><br><span class="line">    printf(&quot;%d&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用数组来模拟二叉树.Br[l]代表结点号为l的二叉树,成员中l为左子树结点,r为右子树结点.那就是经典前序遍历,检查本结点,遍历左子树和右子树,然后找最大值即可.</p>
<h4 id="P5318-查找文献-BFS和DFS"><a href="#P5318-查找文献-BFS和DFS" class="headerlink" title="P5318 查找文献(BFS和DFS)"></a>P5318 查找文献(BFS和DFS)</h4><p>给定一个图,寻找DFS和BFS序列.</p>
<p>在搜索之前我们先排序,因为对于图来说,优先输出数字比较小的元素,将比较小的元素放前面也有助我们排序.然后就是构建一个边的集合,在构建一个链接表,链接表LinkNodes[i]存储着所有起点为i的边的边号.</p>
<p>接着就是DFS和BFS了,对于BFS,就是维护一个队列,每一次都把没有遍历过且链接的东东入队,做完后取一个出队.DFS就是维护一个栈,栈的表示就是递归,搜索没有遍历过且链接的东东,找到就立刻跳转.对新结点进行搜索.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct edg&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int v;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edg&gt; edgs;</span><br><span class="line">vector&lt;int&gt; LinkNodes[100005];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int n,m;</span><br><span class="line">bool cmp(edg x,edg y)&#123;</span><br><span class="line">    if(x.v==y.v) return x.u&lt;y.u;</span><br><span class="line">    else return x.v&lt;y.v;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs_OK[100005],bfs_OK[100005];</span><br><span class="line">void bfs(int x)&#123;</span><br><span class="line">    q.push(x);</span><br><span class="line">    printf(&quot;%d &quot;,x);</span><br><span class="line">    bfs_OK[x]=true;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int k=q.front();</span><br><span class="line">        for(auto&amp;i:LinkNodes[k])&#123;</span><br><span class="line">            if(!bfs_OK[edgs[i].v])&#123;</span><br><span class="line">                q.push(edgs[i].v);</span><br><span class="line">                printf(&quot;%d &quot;,edgs[i].v);</span><br><span class="line">                bfs_OK[edgs[i].v]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(q.empty()) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    dfs_OK[x]=true;</span><br><span class="line">    printf(&quot;%d &quot;,x);</span><br><span class="line">    for(auto&amp;i:LinkNodes[x])&#123;</span><br><span class="line">        if(!dfs_OK[edgs[i].v]) dfs(edgs[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int x,y;</span><br><span class="line">    int k=m;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">        edgs.push_back((edg)&#123;x,y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edgs.begin(),edgs.end(),cmp);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        LinkNodes[edgs[i].u].push_back(i);</span><br><span class="line">    dfs(1);</span><br><span class="line">    printf(&quot;\\n&quot;);</span><br><span class="line">    bfs(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P3371-单元最短路径-邻接表版本"><a href="#P3371-单元最短路径-邻接表版本" class="headerlink" title="P3371 单元最短路径(邻接表版本)"></a>P3371 单元最短路径(邻接表版本)</h4><p>主要的思路就是先从一个点开始,然后计算从A到每个点的距离,找到最小的,假设为,把它标记.,然后再把与x相接的边(注意,边的另一边没有被标记)做一次松弛操作,选出最小的标记,以此类推…</p>
<ul>
<li>选出最小的</li>
<li>标记</li>
<li>松弛<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 500005</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int weight;</span><br><span class="line">    int next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line">int cnt;</span><br><span class="line">int ans[N];</span><br><span class="line">bool vised[N];</span><br><span class="line">int head[N];</span><br><span class="line">void add(int x,int y,int w)&#123;</span><br><span class="line">    edges[++cnt].to=y;</span><br><span class="line">    edges[cnt].weight=w;</span><br><span class="line">    edges[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">bool songchi(int x,int y,int z)&#123;</span><br><span class="line">    return x+y&lt;z;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int m,n,s;</span><br><span class="line">    int x,y,w;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;m,&amp;n,&amp;s);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        ans[i]=2147483647;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[s]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        add(x, y, w);</span><br><span class="line">    &#125;</span><br><span class="line">    int pos=s;</span><br><span class="line">    while(!vised[pos])&#123;</span><br><span class="line">        long long minn = 1145141919810;</span><br><span class="line">        vised[pos]=1;</span><br><span class="line">        for(int i=head[pos];i!=0;i=edges[i].next)&#123;</span><br><span class="line">            if(!vised[edges[i].to]&amp;&amp;ans[edges[i].to]&gt;ans[pos]+edges[i].weight)&#123;</span><br><span class="line">                ans[edges[i].to]=ans[pos]+edges[i].weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            if(!vised[i]&amp;&amp;ans[i]&lt;minn)&#123;</span><br><span class="line">                pos=i;</span><br><span class="line">                minn=ans[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="P2910-双倍经验-邻接矩阵版本"><a href="#P2910-双倍经验-邻接矩阵版本" class="headerlink" title="P2910 双倍经验(邻接矩阵版本)"></a>P2910 双倍经验(邻接矩阵版本)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define N 101</span><br><span class="line">#define M 10005</span><br><span class="line">int a[N][N];</span><br><span class="line">int ans[N];</span><br><span class="line">bool vised[N];</span><br><span class="line">int weizhi[M];</span><br><span class="line">int n,m,w;</span><br><span class="line">int dj(int x,int y)&#123;</span><br><span class="line">    int pos=x;</span><br><span class="line">    ans[pos]=0;</span><br><span class="line">    while(!vised[pos])&#123;</span><br><span class="line">        long long minn = 1145141919810;</span><br><span class="line">        vised[pos]=1;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(vised[i]) continue;</span><br><span class="line">            if(ans[pos]+a[pos][i]&lt;ans[i])&#123;</span><br><span class="line">                ans[i]=ans[pos]+a[pos][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(!vised[i]&amp;&amp;ans[i]&lt;minn)&#123;</span><br><span class="line">                pos=i;</span><br><span class="line">                minn=ans[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans[y];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;weizhi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">            a[i][j]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=2;i&lt;=m;i++)&#123;</span><br><span class="line">        memset(vised,false,sizeof(vised));</span><br><span class="line">        for (int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">            ans[i]=1145141919;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=dj(weizhi[i-1],weizhi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本是进行了多次查找的,其实也差不多…</p>
<h4 id="P3367-并查集-往上搜索的树"><a href="#P3367-并查集-往上搜索的树" class="headerlink" title="P3367 并查集(往上搜索的树)"></a>P3367 并查集(往上搜索的树)</h4><p>就是对于N个元素,一开始有N个集合,你需要完成若干次集合的合并和判断操作.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">int temp[10000];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    while(x!=temp[x]) x=temp[x]=temp[temp[x]];</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);</span><br><span class="line">    int i=1;</span><br><span class="line">    while(i&lt;=N)&#123;</span><br><span class="line">        temp[i]=i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    int op,num1,num2;</span><br><span class="line">    while(M--)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;op,&amp;num1,&amp;num2);</span><br><span class="line">        int fa_a=find(num1),fa_b=find(num2);</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            temp[fa_a]=fa_b;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(fa_a==fa_b)&#123;</span><br><span class="line">                printf(&quot;Y\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(fa_a!=fa_b)&#123;</span><br><span class="line">                printf(&quot;N\\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用temp[x]来表示树的父亲,如果<code>temp[x]=自己</code>的话就代表自己是根,对于若干个集合就相当于若干个树,判断是不是在同一个集合就看属于自己的树是不是根就好了,集合的合并也就是确立父子关系而已,这个相当于把两个树合并在一块.</p>
<h4 id="P3366-最小生成树"><a href="#P3366-最小生成树" class="headerlink" title="P3366 最小生成树"></a>P3366 最小生成树</h4><p>Prim算法:每一次选择权值最小的边,然后标记边的终点.并且保证终点是没有被搜索过的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define re register</span><br><span class="line">#define il inline</span><br><span class="line">il int read()</span><br><span class="line">&#123;</span><br><span class="line">    re int x=0,f=1;char c=getchar();</span><br><span class="line">    while(c&lt;&#x27;0&#x27;c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125;</span><br><span class="line">    while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar();</span><br><span class="line">    return x\*f;</span><br><span class="line">&#125;//快读，不理解的同学用cin代替即可</span><br><span class="line">#define inf 123456789</span><br><span class="line">#define maxn 5005</span><br><span class="line">#define maxm 200005</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">int v,w,next;</span><br><span class="line">&#125;e[maxm&lt;&lt;1];</span><br><span class="line">//注意是无向图，开两倍数组</span><br><span class="line">int head[maxn],dis[maxn],cnt,n,m,tot,now=1,ans;</span><br><span class="line">//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1-&gt;3,2-&gt;3)</span><br><span class="line">bool vis[maxn];</span><br><span class="line">//链式前向星加边</span><br><span class="line">il void add(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">e[++cnt].v=v;</span><br><span class="line">e[cnt].w=w;</span><br><span class="line">e[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//读入数据</span><br><span class="line">il void init()</span><br><span class="line">&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    for(re int i=1,u,v,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read(),v=read(),w=read();</span><br><span class="line">        add(u,v,w),add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">il int prim()</span><br><span class="line">&#123;</span><br><span class="line">//先把dis数组附为极大值</span><br><span class="line">for(re int i=2;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=inf;</span><br><span class="line">&#125;</span><br><span class="line">    //这里要注意重边，所以要用到min</span><br><span class="line">for(re int i=head[1];i;i=e[i].next)</span><br><span class="line">&#123;</span><br><span class="line">dis[e[i].v]=min(dis[e[i].v],e[i].w);</span><br><span class="line">&#125;</span><br><span class="line">    while(++tot&lt;n)//最小生成树边数等于点数-1</span><br><span class="line">    &#123;</span><br><span class="line">        re int minn=inf;//把minn置为极大值</span><br><span class="line">        vis[now]=1;//标记点已经走过</span><br><span class="line">        //枚举每一个没有使用的点</span><br><span class="line">        //找出最小值作为新边</span><br><span class="line">        //注意这里不是枚举now点的所有连边，而是1~n</span><br><span class="line">        for(re int i=1;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        //枚举now的所有连边，更新dis数组</span><br><span class="line">        for(re int i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">        re int v=e[i].v;</span><br><span class="line">        if(dis[v]&gt;e[i].w&amp;&amp;!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">        dis[v]=e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%d&quot;,prim());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P3370-字符串哈希"><a href="#P3370-字符串哈希" class="headerlink" title="P3370 字符串哈希"></a>P3370 字符串哈希</h4><p>直接使用<code>set&lt;string&gt;</code>就好了,这样就可以保证哈希了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;string&gt; a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string p;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //输入string只能用cin...</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        a.insert(p);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,a.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会不会有点阴啊…</p>
<p>所以说我们可以使用哈希查找:就是把字符串转化成一个整数,然后对整数排序,看看有没有相等的两个数就好了.(代码略)</p>
<h4 id="P1908-逆序对-归并排序"><a href="#P1908-逆序对-归并排序" class="headerlink" title="P1908 逆序对(归并排序)"></a>P1908 逆序对(归并排序)</h4><p>求一个数组的逆序对数:</p>
<p>这里是用归并的方式:判断左边的逆序对数,右边的逆序对数和跨过两边逆序对数.</p>
<p>为了方便,顺便把左右两边的归并排序也做了(方便统计) 归并排序就是左边归并右边归并,然后归并左右两边(使用双指针,哪边小保存哪边).这个时候可以统计逆序对,只要左边&gt;右边,我们就认为这是一个逆序对.(因为左右已经排好序,我们可以使用线性时间做完).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 1000000</span><br><span class="line">int a[N];</span><br><span class="line">int t[N];</span><br><span class="line">long long ans = 0;</span><br><span class="line">void merge(int l,int r)&#123;</span><br><span class="line">    if(l==r)return;</span><br><span class="line">    int mid=l+r&gt;&gt;1,i=l,k=l,j=mid+1;</span><br><span class="line">    merge(l,mid),merge(mid+1,r);</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        if(a[i]&lt;=a[j])&#123;</span><br><span class="line">            t[k++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            t[k++]=a[j++];</span><br><span class="line">            ans+=mid-i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid)t[k++]=a[i++];</span><br><span class="line">    while(j&lt;=r)t[k++]=a[j++];</span><br><span class="line">    for(int i=l;i&lt;=r;++i)a[i]=t[i];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    merge(0,n-1);</span><br><span class="line">    printf(&quot;%lld&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1309-双倍经验-逆序对"><a href="#P1309-双倍经验-逆序对" class="headerlink" title="P1309 (双倍经验) 逆序对"></a>P1309 (双倍经验) 逆序对</h4><p>2×<em>N</em> 名编号为 1∼2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第 3名和第 4名、……、第2K−1名和第2K名、…… 、第2N−1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得 0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p>
<p>这个时候我们就可以使用归并排序了.首先将选手进行排序,然后进行比拼.比拼的时候记录胜者和败者.在这个时候由于胜者都+1分,败者都不加分,所以说记录的胜者和败者都是有序的.有序的前提就是方便我们的归并.归并的方式和我们之前做的事一样的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 200005</span><br><span class="line">int n,m;</span><br><span class="line">int win[N];</span><br><span class="line">int lose[N];</span><br><span class="line">int s[N];</span><br><span class="line">int a[N];</span><br><span class="line">int p[N];</span><br><span class="line">int R,Q;</span><br><span class="line">bool cmp(int x,int y)&#123;</span><br><span class="line">    if(s[x]==s[y]) return x&lt;y;</span><br><span class="line">    else return s[x]&gt;s[y];</span><br><span class="line">&#125;</span><br><span class="line">void merge()&#123;</span><br><span class="line">    int i=1;//the position of win</span><br><span class="line">    int j=1;//the position of lose</span><br><span class="line">    int k=1;</span><br><span class="line">    //我们把win的那一部分和lose的那一部分给归并了,因为我们知道赢的那一部分和输的那一部分是有序的</span><br><span class="line">    while(i&lt;=n/2&amp;&amp;j&lt;=n/2)&#123;</span><br><span class="line">        if(cmp(win[i],lose[j]))&#123;</span><br><span class="line">            a[k++]=win[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[k++]=lose[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=n/2) a[k++]=win[i++];</span><br><span class="line">    while(j&lt;=n/2) a[k++]=lose[j++];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;R,&amp;Q);</span><br><span class="line">    n\*=2;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(a+1, a+n+1, cmp);</span><br><span class="line">    while(R--)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i+=2)&#123;</span><br><span class="line">            if(p[a[i]]&lt;p[a[i+1]])&#123;</span><br><span class="line">                s[a[i+1]]++;</span><br><span class="line">                win[(i-1)/2+1]=a[i+1];</span><br><span class="line">                lose[(i-1)/2+1]=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                s[a[i]]++;</span><br><span class="line">                win[(i-1)/2+1]=a[i];</span><br><span class="line">                lose[(i-1)/2+1]=a[i+1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        merge();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,a[Q]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1090-合并果子"><a href="#P1090-合并果子" class="headerlink" title="P1090 合并果子"></a>P1090 合并果子</h4><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>本来是想打一个区间dp的,但是发现数据样例有一点大,就直接用优先队列了,在这里记录一下优先队列的用法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">int n,x,ans;</span><br><span class="line">std::priority_queue&lt;int,std::vector&lt;int&gt;,std::greater&lt;int&gt;&gt; queue;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    while(queue.size()/2)&#123;</span><br><span class="line">        int a1=queue.top();</span><br><span class="line">        queue.pop();</span><br><span class="line">        int a2=queue.top();</span><br><span class="line">        queue.pop();</span><br><span class="line">        ans += (a1+a2);</span><br><span class="line">        queue.push(a1+a2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先队列可以保证入队的时候按照你规定的cmp函数来执行排序.</p>
<h4 id="P1138-最k小整数"><a href="#P1138-最k小整数" class="headerlink" title="P1138 最k小整数"></a>P1138 最k小整数</h4><p>这里就回忆一下sort函数的用法吧~.然后从前到后遍历一遍而已</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int a[10005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(a+1,a+n+1);</span><br><span class="line">    int temp=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(a[i]&gt;a[i-1]) temp++;</span><br><span class="line">        if(temp==k) &#123;</span><br><span class="line">            printf(&quot;%d&quot;,a[i]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(temp&lt;k) printf(&quot;NO RESULT&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1918-保龄球"><a href="#P1918-保龄球" class="headerlink" title="P1918 保龄球"></a>P1918 保龄球</h4><p>就可以使用一个map就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int,int&gt;maps;</span><br><span class="line">int n,t,q,m;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">        maps[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        printf(&quot;%d\\n&quot;,maps[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P6510-奶牛排队"><a href="#P6510-奶牛排队" class="headerlink" title="P6510 奶牛排队"></a>P6510 奶牛排队</h4><p>给定一组数据,从,找到两个一组连续的数,最左边的数是最小的,最右边的数是最大的.</p>
<p>我们调用单调栈的模版,首先求出A右侧第一个的位置,再求出B左侧第一个的位置.A右侧第一个小于A的数在B的右边,B左侧第一个大于B的数在A左边就可以了.</p>
<p>然后枚举​,看看最合适的​在哪里,遍历的方法如下:</p>
<ul>
<li>首先确定B,B左侧第一个大于B的数位.</li>
<li>然后确定A,A从K+1开始遍历,然后判断A右侧第一个小于A的位置是不是在B右边</li>
<li>计算值B的位置-A的位置+1.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct statype&#123;</span><br><span class="line">    int bhei,bpos,ahei,apos;</span><br><span class="line">&#125;sta[100010];</span><br><span class="line">int top=-1;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,ans=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        top++;</span><br><span class="line">        cin&gt;&gt;sta[top].bhei;</span><br><span class="line">        sta[top].ahei=sta[top].bhei;</span><br><span class="line">        sta[top].bpos=i;</span><br><span class="line">        sta[top].apos=i;</span><br><span class="line">        while(sta[top].bhei&gt;sta[top-1].bhei&amp;&amp;top&gt;=1)&#123;</span><br><span class="line">        if(sta[top].ahei&gt;sta[top-1].ahei)&#123;</span><br><span class="line">            sta[top].ahei=sta[top-1].ahei;</span><br><span class="line">            sta[top].apos=sta[top-1].apos;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[top-1]=sta[top];</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&lt;sta[top].bpos-sta[top].apos+1)</span><br><span class="line">        ans=sta[top].bpos-sta[top].apos+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans==1)</span><br><span class="line">    ans=0;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是遇到了左括号,就递归求括号内的元素.</li>
<li>如果是遇到了右括号,就把括号内的数据返回给上层.</li>
<li>如果是遇到了a,就把当前的结果+1即可.</li>
<li>如果是遇到了,根据max(a,b,c)&#x3D;max(a,max(b,c))的结合率进行递归求解,递归求解右边的值,与当前计算得来的值进行比较.(因为遇到了就代表当前部分的串已经结束了).、</li>
</ul>
<h4 id="P3719-rexp"><a href="#P3719-rexp" class="headerlink" title="P3719 rexp."></a>P3719 rexp.</h4><p>给出一个由(,),,a组成的序列，求化简后有多少个a。</p>
<p>1、形如aa…aaa…aaa…a的，化简结果为“”两边a的个数最多的一项，例如aaaaaa&#x3D;aaa 2、先算带括号的序列，例如(aa)aaa&#x3D;aaa</p>
<p>依次输入一个字符,分成下面几种情况:</p>
<ul>
<li>如果是遇到了左括号,就递归求括号内的元素.</li>
<li>如果是遇到了右括号,就把括号内的数据返回给上层.</li>
<li>如果是遇到了a,就把当前的结果+1即可.</li>
<li>如果是遇到了,根据max(a,b,c)&#x3D;max(a,max(b,c))的结合率进行递归求解,递归求解右边的值,与当前计算得来的值进行比较.(因为遇到了就代表当前部分的串已经结束了).</li>
</ul>
<h4 id="P1185-绘制二叉树"><a href="#P1185-绘制二叉树" class="headerlink" title="P1185 绘制二叉树"></a>P1185 绘制二叉树</h4><p>这一题是非常复杂的一个模拟,下面分成几个部分来讲:</p>
<p>首先是初始化的操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    if(n==1)&#123;</span><br><span class="line">        h=1;</span><br><span class="line">        w=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(n==2)&#123;</span><br><span class="line">        h=3;</span><br><span class="line">        w=5;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        h=3;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)h\*=2;</span><br><span class="line">        w=6\*(1&lt;&lt;(n-2))-1;//计算画布大小</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=h;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=w;j++)&#123;</span><br><span class="line">            c[i][j]=&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=1;</span><br><span class="line">    isJiedian[1]=temp;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        temp=temp+g[n-i]+1;</span><br><span class="line">        isJiedian[i+1]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先计算画布的大小,初始化成空格,然后计算对于这个画布,画布的哪几行可以存放点的信息.</p>
<p>我们用数组来模拟树,用<code>[X][Y]</code>来模拟这是树的第X行和第Y个元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">while(m--)&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">    b[x][y]=true;</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">dfs(1,w/2+1,1,1,1);</span><br></pre></td></tr></table></figure>
<p>然后标记已经被删除的点,从根结点(1,w&#x2F;2+1)开始搜索.</p>
<p>搜索分成四类,一种是非叶子结点类型.dfs(画布的行,画布的列,树的行,树的列,下一个点的类型)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(k==1)&#123;</span><br><span class="line">    c[x][y]=&#x27;o&#x27;;</span><br><span class="line">    X++;</span><br><span class="line">    Y=Y\*2-1;</span><br><span class="line">    if(!b[X][Y])&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,2);</span><br><span class="line">    &#125;</span><br><span class="line">    Y++;</span><br><span class="line">    if(!b[X][Y])&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非叶子结点可以同时往左和右搜索(前提是这个结点的左儿子和右儿子没有被删掉),X++和Y&#x3D;Y*2-1是计算左儿子和右儿子在模拟数组中的值.</p>
<p>左下和右下走的列,这种点只能往左或者是右搜索,搜索的变数就是下一行是不是应该存储的是树的结点.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">else if(k==2)&#123;</span><br><span class="line">    c[x][y]=&#x27;/&#x27;;</span><br><span class="line">    if((x+1)==isJiedian[X])&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,1);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dfs(x+1,y-1,X,Y,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    c[x][y]=92;</span><br><span class="line">    if((x+1)==isJiedian[X])&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,1);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dfs(x+1,y+1,X,Y,3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种就是叶子结点,是时候该返回了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x==h)&#123;c[x][y]=&#x27;o&#x27;;return;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P3956-棋盘"><a href="#P3956-棋盘" class="headerlink" title="P3956 棋盘"></a>P3956 棋盘</h4><p>有一个m×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。</p>
<p>任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。另外， 你可以花费 2个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？</p>
<p>转化为最短路径的问题.首先先构造图,构造图的同时我们需要找到出发点和终点.然后做djkstra算法即可.</p>
<p>那么怎么构建图?我们可以分成两种形式的问题.</p>
<ul>
<li>遍历所有带颜色的点,如果两个点相邻,这两个点之间的距离就是0和1.</li>
<li>如果这两个点只差了一格,那么距离就是2+0或者1.</li>
<li>假如说终点是没有颜色的,加上所有点到终点的边.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define N 1002</span><br><span class="line">int map[N][2],z[N][N],distance[N];</span><br><span class="line">int start,end,flag;</span><br><span class="line">int color[N];</span><br><span class="line">int m,n;</span><br><span class="line">int cloud[N];</span><br><span class="line">void makeGraph()&#123;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(abs(map[i][0]-map[j][0])+abs(map[i][1]-map[j][1])==1)&#123;</span><br><span class="line">                z[i][j]=z[j][i]=abs(color[i]-color[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(abs(map[i][0]-map[j][0])+abs(map[i][1]-map[j][1])==2)&#123;</span><br><span class="line">                z[i][j]=z[j][i]=2+abs(color[i]-color[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(abs(map[i][0]-map[end][0])+abs(map[i][1]-map[end][1])==1)&#123;</span><br><span class="line">                z[i][end]=z[end][i]=2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//对每条边进行松弛操作.</span><br><span class="line">void makeDj(int k)&#123;</span><br><span class="line">    distance[k]=0;</span><br><span class="line">    int maxn,t;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        maxn=99999999;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(cloud[j]==0&amp;&amp;distance[j]&lt;maxn)&#123;</span><br><span class="line">                maxn=distance[j];</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cloud[t]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            distance[j]=std::min(distance[t]+z[t][j],distance[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(z,1,sizeof(z));</span><br><span class="line">    memset(distance,1,sizeof(distance));</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;map[i][0],&amp;map[i][1],&amp;color[i]);</span><br><span class="line">      //在这里map记录了每个点的数据,所以说i和j可以代表点的序号</span><br><span class="line">        if(map[i][0]==1&amp;&amp;map[i][1]==1)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(map[i][0]==m&amp;&amp;map[i][1]==m)&#123;</span><br><span class="line">            end=i;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        end=n+1;</span><br><span class="line">        map[end][0]=map[end][1]=m;</span><br><span class="line">    &#125;</span><br><span class="line">    makeGraph();</span><br><span class="line">    makeDj(start);</span><br><span class="line">    if(distance[end]&lt;16843009)</span><br><span class="line">    printf(&quot;%d\\n&quot;,distance[end]);</span><br><span class="line">    else if(m!=1)&#123;</span><br><span class="line">        puts(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        puts(&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="P1983-车站分级-拓扑排序"><a href="#P1983-车站分级-拓扑排序" class="headerlink" title="P1983 车站分级(拓扑排序)"></a>P1983 车站分级(拓扑排序)</h4><p>一条单向的铁路线上，依次有编号为 1,2,…,n的 n个火车站。每个火车站都有一个级别，最低为 1 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）,现在给定了若干个停靠的关系,现在求最多有几级?</p>
<p>建图,然后拓扑排序即可.</p>
<p>首先是建图:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while(m--)&#123;</span><br><span class="line">    memset(is, 0, sizeof(is));</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;s);</span><br><span class="line">    for(int i=1;i&lt;=s;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;stations[i]);</span><br><span class="line">        is[stations[i]]=true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=stations[1];i&lt;=stations[s];i++)&#123;</span><br><span class="line">        if(!is[i])&#123;</span><br><span class="line">            for(int j=1;j&lt;=s;j++)&#123;</span><br><span class="line">                if(!tuopu[i][stations[j]]) &#123;</span><br><span class="line">                    tuopu[i][stations[j]]=1;</span><br><span class="line">                    rudu[stations[j]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一条铁路线路,我们有边:<code>[没停靠的站][停靠的站]=1</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int top=1;</span><br><span class="line">while(top)&#123;</span><br><span class="line">    top=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!rudu[i]&amp;&amp;!shanchu[i])&#123;</span><br><span class="line">            ruduweizero[top++]=i;</span><br><span class="line">            shanchu[i]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;top;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(tuopu[ruduweizero[i]][j]) &#123;</span><br><span class="line">                tuopu[ruduweizero[i]][j]=0;</span><br><span class="line">                rudu[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进行拓扑排序,把入度为1的点全部删除掉.</p>
<h4 id="P1038-神经网络"><a href="#P1038-神经网络" class="headerlink" title="P1038 神经网络"></a>P1038 神经网络</h4><p>神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连.这一级传递给下一级的激励是由上一级传递给这一级的激励决定的.</p>
<p>现在给定每个神经元一开始的激励,然后给定神经元之间的激励传递函数.求输出神经元的输出激励.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define N 105</span><br><span class="line">#define M 10005</span><br><span class="line">int n,p;</span><br><span class="line">struct egdes&#123;</span><br><span class="line">    int y;</span><br><span class="line">    int val;</span><br><span class="line">    int next;</span><br><span class="line">&#125;a[M];</span><br><span class="line">struct answers&#123;</span><br><span class="line">    int val;</span><br><span class="line">    int x;</span><br><span class="line">&#125;ans[N];</span><br><span class="line">int total;</span><br><span class="line">int c[N],u[N],rudu[N],chudu[N],head[M];</span><br><span class="line">int cnt;</span><br><span class="line">std::queue &lt;int&gt; q;</span><br><span class="line">bool vis[N];</span><br><span class="line">void add(int x,int y,int val)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    a[cnt].y=y;</span><br><span class="line">    a[cnt].val=val;</span><br><span class="line">    a[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(struct answers a,struct answers b)&#123;</span><br><span class="line">    return a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  //输入初态</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;p);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;c[i],&amp;u[i]);</span><br><span class="line">      //把初始的结点放入队列</span><br><span class="line">        if(c[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            vis[i]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        else c[i]-=u[i];</span><br><span class="line">    &#125;</span><br><span class="line">  //输入边的构造,链式前向星</span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        int x,y,val;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;val);</span><br><span class="line">        add(x, y, val);</span><br><span class="line">        rudu[y]++;</span><br><span class="line">        chudu[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">  //从初始值开始往后传递,一条边可以进行一次传递,然后把后面的点入队.这样子可以保证按照拓扑排序的顺序来进行遍历.</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int f=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[f]=0;</span><br><span class="line">        //non-exicited</span><br><span class="line">        if(c[f]&lt;0)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //the edge start from front</span><br><span class="line">        for(int i=head[f];i;i=a[i].next)&#123;</span><br><span class="line">            int y=a[i].y;</span><br><span class="line">            c[y]+=a[i].val\*c[f];</span><br><span class="line">            if(!vis[y])&#123;</span><br><span class="line">                q.push(y);</span><br><span class="line">                vis[y]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //计算所有被激活的而且出度为0的值(最终值.)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(c[i]&gt;0&amp;&amp;chudu[i]==0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            ans[total].x=i;</span><br><span class="line">            ans[total].val=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(ans+1,ans+1+total,cmp);</span><br><span class="line">    if(total)&#123;</span><br><span class="line">        for(int i=1;i&lt;=total;i++)&#123;</span><br><span class="line">            printf(&quot;%d %d\\n&quot;,ans[i].x,ans[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="P1381-单词背诵"><a href="#P1381-单词背诵" class="headerlink" title="P1381 单词背诵"></a>P1381 单词背诵</h4><p>灵梦有 n个单词想要背，但她想通过一篇文章中的一段来记住这些单词。文章由 m个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。</p>
<p>我们每次记录此时有多少个单词，若比之前多，则直接更新长度与数量。 然后在更新左边 l，若最左边的单词不想背，或后文已出现就更新，把长度去最短即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 100005</span><br><span class="line">std::map&lt;std::string,int&gt; tongji;</span><br><span class="line">std::map&lt;std::string,bool&gt; flags;</span><br><span class="line">std::string s1[N];</span><br><span class="line">std::string s2;</span><br><span class="line">int n,m,l;</span><br><span class="line">int ans1,ans2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        std::cin&gt;&gt;s2;</span><br><span class="line">        flags[s2]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    l++;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        std::cin&gt;&gt;s1[i];</span><br><span class="line">        if(flags[s1[i]]) tongji[s1[i]]++;</span><br><span class="line">        if(tongji[s1[i]]==1) &#123;</span><br><span class="line">            ans1++;</span><br><span class="line">            ans2=i-l+1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l&lt;=i)&#123;</span><br><span class="line">            //不用背</span><br><span class="line">            if(!flags[s1[l]]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //后问已经出现了</span><br><span class="line">            if(tongji[s1[l]]&gt;1)&#123;</span><br><span class="line">                tongji[s1[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ans2=std::min(ans2,i-l+1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n%d\\n&quot;,ans1,ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P1002-NOIP2002-普及组-过河卒"><a href="#P1002-NOIP2002-普及组-过河卒" class="headerlink" title="P1002 [NOIP2002 普及组] 过河卒"></a>P1002 [NOIP2002 普及组] 过河卒</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-1024x916.png"></p>
<p>dp方程:因为小兵只能往下或者右走,我们设一个二维dp数组dp[i][j]表示从起点到坐标为(i,j)的路径数,如果这个点能被马能吃掉的,那就dp[i][j]&#x3D;0,这个可以告诉它下面和右边的点,我这是不能到达的.然后输出dp[N][M]就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&gt;</span><br><span class="line">#include&amp;lt;iostream&gt;</span><br><span class="line">#include&amp;lt;algorithm&gt;</span><br><span class="line">#include&amp;lt;vector&gt;</span><br><span class="line">#include&amp;lt;stack&gt;</span><br><span class="line">#include &amp;lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 40</span><br><span class="line">int t[N];</span><br><span class="line">int a[N][N];</span><br><span class="line">long long dp[N][N];</span><br><span class="line">bool beimalanzhu[N][N]; //判断这个点有没有马拦住</span><br><span class="line">const int madex[] = &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;</span><br><span class="line">const int madey[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;</span><br><span class="line">int c,n;</span><br><span class="line">//long long count(long long a,long long b,long long p)&#123;</span><br><span class="line">//    if(b==0) return 1;</span><br><span class="line">//    if(b==1) return a%p;</span><br><span class="line">//    long long c = count(a,b/2,p)%p;</span><br><span class="line">//    return ((b%2==0?1:a)\*c\*c)%p;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int ma_x,ma_y;</span><br><span class="line">    int b_x,b_y;</span><br><span class="line">    scanf(&quot;%d %d %d %d&quot;,&amp;amp;b_x,&amp;amp;b_y,&amp;amp;ma_x,&amp;amp;ma_y);</span><br><span class="line">    ma_x+=2;</span><br><span class="line">    ma_y+=2;</span><br><span class="line">    b_x+=2;</span><br><span class="line">    b_y+=2;</span><br><span class="line">    </span><br><span class="line">    dp[2][1]=1;</span><br><span class="line">    for(int i=0;i&amp;lt;8;i++)&#123;</span><br><span class="line">        beimalanzhu[ma_x+madex[i]][ma_y+madey[i]]=true;</span><br><span class="line">    &#125;</span><br><span class="line">    //忘记讨论马自己了</span><br><span class="line">    beimalanzhu[ma_x][ma_y] = true;</span><br><span class="line">    for(int i=2;i&amp;lt;=b_x;i++)&#123;</span><br><span class="line">        for(int j=2;j&amp;lt;=b_y;j++)&#123;</span><br><span class="line">            if(beimalanzhu[i][j]) continue;</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,dp[b_x][b_y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1095-NOIP2007-普及组-守望者的逃离"><a href="#P1095-NOIP2007-普及组-守望者的逃离" class="headerlink" title="P1095 [NOIP2007 普及组] 守望者的逃离"></a>P1095 [NOIP2007 普及组] 守望者的逃离</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-1-1006x1024.png"></p>
<p>这个其实我们都知道,根据中学物理的知识都知道我们瞬移最好,但是有这么一种情况,就是你瞬移没蓝了,但是终点离你不远,这时候还不如直接开跑,等在这里等蓝还不如直接run<br>这个时候就有个最优选择了:维护一个一维的dp数组dp[T]来表示到t时间最远能run多远,那我们假设一个dp[t],dp[1,….t-1]都是已知的了,那就可以维护了dp[t]&#x3D;max[dp[t-1]+17,r[t]],r[t]就代表一直瞬移的距离,如果这个时候一直瞬移还不如现在直接跑来得快,那就选跑</p>
<p>对于这位可怜的人,一直闪现肯定是最优解,但是这里dp其实判断的是,对于这个时刻,没有蓝了,是停在原地回蓝好还是直接撒腿就跑好,是判断这俩的选择的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#define N 300005</span><br><span class="line">int dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int M,S,T;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;amp;M,&amp;amp;S,&amp;amp;T);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    int run;</span><br><span class="line">    int flash;</span><br><span class="line">    for(int i=1;i&amp;lt;=T;i++)&#123;</span><br><span class="line">        if(M&amp;gt;=10) &#123;</span><br><span class="line">            dp[i]=dp[i-1]+60;</span><br><span class="line">            M-=10;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            dp[i]=dp[i-1];</span><br><span class="line">            M+=4;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=T;i++)&#123;</span><br><span class="line">        if(dp[i]&amp;lt;dp[i-1]+17) dp[i]=dp[i-1]+17;</span><br><span class="line">        if(dp[i]&amp;gt;S)&#123;</span><br><span class="line">            printf(&quot;Yes\\n%d&quot;,i);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;No\\n%d&quot;,dp[T]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h1 id="P1048-NOIP2005-普及组-采药"><a href="#P1048-NOIP2005-普及组-采药" class="headerlink" title="P1048 [NOIP2005 普及组] 采药"></a>P1048 [NOIP2005 普及组] 采药</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-2-1024x941.png"></p>
<p>动态规划方程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int  weigth[105],value[105];</span><br><span class="line">//dp[i][j]代表处理第i个,背包容量还剩下j个</span><br><span class="line">int dp[105][1005];</span><br><span class="line">int total,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;amp;total,&amp;amp;m);</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;amp;weigth[i],&amp;amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        for(int j=total;j&amp;gt;=0;j--)&#123;</span><br><span class="line">            //表示这个元素可以选入</span><br><span class="line">            if(j&amp;gt;=weigth[i])&#123;</span><br><span class="line">                dp[i][j]=max(dp[i-1][j-weigth[i]]+value[i],dp[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //不可以</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dp[m][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1616-疯狂的采药"><a href="#P1616-疯狂的采药" class="headerlink" title="P1616 疯狂的采药"></a>P1616 疯狂的采药</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-4-1024x795.png"></p>
<p>一维dp数组,dp[m]代表用m的背包就可以获得的最大元素,还是两层循环,外循环是对物品种类进行讨论,内循环对dp方程进行处理,看看对于一个重量$j$,我要不要选择第$i$号元素放入背包中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;;</span><br><span class="line">#include&lt;iostream&amp;gt;</span><br><span class="line">#include&lt;algorithm&amp;gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int M = 1e7+5;</span><br><span class="line">long long  weigth[M],value[10005];</span><br><span class="line">//dp[i][j]代表处理第i个,背包容量还剩下j个</span><br><span class="line">long long dp[M];</span><br><span class="line">long long total,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld %lld&quot;,&amp;amp;total,&amp;amp;m);</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;amp;weigth[i],&amp;amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=m;i++)&#123;</span><br><span class="line">        for(int j=weigth[i];j&amp;lt;=total;j++)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-weigth[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,dp[total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h1><h1 id="P1091-NOIP2004-提高组-合唱队形"><a href="#P1091-NOIP2004-提高组-合唱队形" class="headerlink" title="P1091 [NOIP2004 提高组] 合唱队形"></a>P1091 [NOIP2004 提高组] 合唱队形</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-5-1024x841.png"></p>
<p>这是一个脑筋急转弯类型的题目,第一步就是计算[1,i]的最长上升子序列的长度,记在dp[i][0]中,第二步就是计算[i,n]的最长下降子序列的长度,记在dp[i][1].但是有一点就是这个最长上升子序列长度是要包括自己的.<br>记dp1[i]&#x3D;dp[i][0]+dp[i][1]<br>最后的结果就是需要找到一个点使得dp1[i]最大,这样就代表这个点左右更加光滑.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#define N 105</span><br><span class="line">int a[N];</span><br><span class="line">int dp[N][2];</span><br><span class="line">int res[N];</span><br><span class="line">//dp数组,dp[i][0]</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;amp;n);</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;a[i]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //从左到右扫描</span><br><span class="line">    for(int i=2;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&amp;lt;i;j++)&#123;</span><br><span class="line">            if(a[i]&amp;gt;a[j]&amp;amp;&amp;amp;dp[i][0]&amp;lt;=dp[j][0]+1)&#123;</span><br><span class="line">                dp[i][0]=dp[j][0]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n-1;i&amp;gt;=1;i--)&#123;</span><br><span class="line">        for(int j=i+1;j&amp;lt;=n;j++)&#123;</span><br><span class="line">            if(a[i]&amp;gt;a[j]&amp;amp;&amp;amp;dp[i][1]&amp;lt;=dp[j][1]+1)&#123;</span><br><span class="line">                dp[i][1]=dp[j][1]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        res[i]=dp[i][0]+dp[i][1]+1;</span><br><span class="line">        if(res[i]&amp;gt;result) result=res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,n-result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1439-【模板】最长公共子序列"><a href="#P1439-【模板】最长公共子序列" class="headerlink" title="P1439 【模板】最长公共子序列"></a>P1439 【模板】最长公共子序列</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-6-1024x415.png"></p>
<p>排列中没有重复元素，俩排列置换后 (重命名) 的 LCS 长度不变:不妨用置换$\sigma$将排列$P_1$$\to$[1:n].  </p>
<p>这个时候我们可以将排列$P_1$变成[1,2,3,….,n]然后排列$P_2$映射成与$P_1$相匹配的形式.排列$P_2$中第$i$个元素存储的就是原来的元素在$P_1$中的位置  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#include&amp;lt;algorithm&amp;gt;</span><br><span class="line">#define N 100005</span><br><span class="line">using namespace std;</span><br><span class="line">int a[N],b[N],c[N],found[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;amp;n);</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;a[i]);</span><br><span class="line">        c[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&amp;lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;amp;b[i]);</span><br><span class="line">        found[i]=114514;</span><br><span class="line">    &#125;</span><br><span class="line">    int LCS_length=0;</span><br><span class="line">    for (int i=1; i&amp;lt;=n; i++) &#123;</span><br><span class="line">        int l=0,r=LCS_length,mid;</span><br><span class="line">        //如果大于:直接放在后面</span><br><span class="line">        if(c[b[i]]&amp;gt;found[LCS_length])&#123;</span><br><span class="line">            found[++LCS_length]=c[b[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果小于二分查找</span><br><span class="line">        else&#123;</span><br><span class="line">            while (l&amp;lt;r) &#123;</span><br><span class="line">                mid=(l+r)/2;</span><br><span class="line">                if(found[mid]&amp;gt;c[b[i]])&#123;</span><br><span class="line">                    r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    l=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            found[l]=min(c[b[i]],found[l]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n&quot;,LCS_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P1880-NOI1995-石子合并"><a href="#P1880-NOI1995-石子合并" class="headerlink" title="P1880 [NOI1995] 石子合并"></a>P1880 [NOI1995] 石子合并</h1><p><img src="https://sukunahust.com/wp-content/uploads/2021/11/image-12-1024x719.png"></p>
<p>让dp[i][j]代表第i堆到第j堆的合并分数,我们要做的事$dp[i][i+n-1]$最大(小),只需要在区间[i][j]中找到一个最佳的分划k,让i-k,k+1,j这两个区域内部得分和合并这两个区域的得分最大(小),即$max(a[i][k]+a[k+1][j]+d(i,j))$分别代表两个区域的分划和合并两部分的得分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define N 205</span><br><span class="line">int mins[N][N];</span><br><span class="line">int maxs[N][N];</span><br><span class="line">int stones[N];</span><br><span class="line">int sums[N];//前缀和</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;stones[i]);</span><br><span class="line">        sums[i]=sums[i-1]+stones[i];</span><br><span class="line">        stones[i+n]=stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n+1;i&lt;=2\*n;i++)&#123;</span><br><span class="line">        sums[i]=sums[i-1]+stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int length=1;length&lt;n;length++)&#123;</span><br><span class="line">        for(int i=1,j=i+length;j&lt;2\*n&amp;&amp;i&lt;2\*n;i++,j=length+i)&#123;</span><br><span class="line">            mins[i][j]=1145141919;</span><br><span class="line">            for(int k=i;k&lt;j;k++)&#123;</span><br><span class="line">                maxs[i][j]=std::max(maxs[i][j],maxs[i][k]+maxs[k+1][j]+sums[j]-sums[i-1]);</span><br><span class="line">                mins[i][j]=std::min(mins[i][j],mins[i][k]+mins[k+1][j]+sums[j]-sums[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int min_res=114514;</span><br><span class="line">    int max_res=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        max_res=std::max(max_res,maxs[i][i+n-1]);</span><br><span class="line">        min_res=std::min(min_res,mins[i][i+n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\\n%d&quot;,min_res,max_res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.6 解码异或后的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) &#123;</span><br><span class="line">        int n=encoded.size()+1;</span><br><span class="line">        vector&lt;int&gt; arr(n);</span><br><span class="line">        arr[0]=first;</span><br><span class="line">        for (int i=1; i&lt;n; i++) &#123;</span><br><span class="line">            arr[i]=arr[i-1]^encoded[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>异或是满足交换律和结合律的,就是x和y异或&#x3D;z,已知x和z,y是能求出来的!</p>
<p>5.7 数组的异或操作:这个不想说了,太简单了</p>
<p>5.8 完成工作的最短时间<br>这道题我犯了四个很低级的错误:<br>1.二分查找的时候没有更新mid<br>2.传参数没有传引用,导致所有的结果都没变<br>3.判断能否完成的时候没有考虑刚好完成所带来<br>4.工作时间加了之后,如果判断不行没减回去<br>给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。<br>请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。<br>返回分配方案中尽可能 最小 的 最大工作时间 。<br>示例 1：<br>输入：jobs &#x3D; [3,2,3], k &#x3D; 3<br>输出：3<br>解释：给每位工人分配一项工作，最大工作时间是 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs">https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>这道题是一道搜索类型的题目,是一道直接搜索答案的题目,总的思路就两点<br>1.主函数做二分搜索<br>2.子函数验证这个结果对不对,来帮助主函数做二分搜索</p>
<p>这道题要注意一点,要不然时间这一块把握不住<br>1.建议使用贪心算法,就是把大的任务先安排下去<br>2.在任务已经明确不能完成或者说是一定能够完成的情况下自动退出</p>
<p>判断的方法也稍微提一下:就是给每个工人分配任务,分配任务的形式就是更改一个数组,这个数组存放了每个工人工作的总时间,分配就是依据每个总时间进行分配的,分配的方式就是递归,有一步出现问题就返回报错,到达叶节点(分配完成)就返回OK</p>
<p>如果有思路,写出代码来还是很简单的,这一种题真的和滑动窗口很像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        sort(jobs.begin(), jobs.end(), greater&lt;int&gt;());</span><br><span class="line">        int first = jobs[0], total = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        //没有达到最优解</span><br><span class="line">        while(first&lt;total)&#123;</span><br><span class="line">            //检查一下mid行不行</span><br><span class="line">            int mid = (first+total)/2;</span><br><span class="line">            if(ok(jobs,k,mid))&#123;</span><br><span class="line">                total=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                first=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    bool ok(vector&lt;int&gt;&amp; jobs, int k, int value)&#123;</span><br><span class="line">        vector&lt;int&gt; workers(k,0);</span><br><span class="line">        return check(jobs,workers,0,value);</span><br><span class="line">    &#125;</span><br><span class="line">    //递归寻找</span><br><span class="line">    bool check (vector&lt;int&gt;&amp; jobs,vector&lt;int&gt; workers, int now,int value)&#123;</span><br><span class="line">        if(jobs.size()&lt;=now)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            int cur=jobs[now];</span><br><span class="line">            for (auto&amp; workload : workers) &#123;</span><br><span class="line">                if (workload+cur&lt;=value) &#123;</span><br><span class="line">                    workload+=cur;</span><br><span class="line">                    if (check(jobs,workers,now+1,value)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    workload-=cur;</span><br><span class="line">                &#125;</span><br><span class="line">                if (workload==0workload+cur==value) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.9 制作花束的最少天数<br>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。<br>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。<br>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。<br>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>
<p>示例 1：<br>输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, <em>,</em> , <em>,</em> ] &#x2F;&#x2F; 只能制作 1 束花<br>2 天后：[x, <em>,</em> , <em>, x] &#x2F;&#x2F; 只能制作 2 束花 3 天后：[x,</em> , x, _, x] &#x2F;&#x2F; 可以制作 3 束花，答案为 3</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets">https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>这道题的思路和昨天的其实很像,就说说判断在某一天之内能否生产那么多花束的思路:其实就是一个遍历+模拟就可以完成的,就是假设这一天已经来到,看看有哪些花盛开了.就取哪些花,有连续的几朵就可以组成一个花束,这么简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123;</span><br><span class="line">        if(bloomDay.size()&lt;m\*k)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int high=0,low=INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; bloomDay.size(); i++) &#123;</span><br><span class="line">            low=min(low, bloomDay[i]);</span><br><span class="line">            high=max(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(high&gt;low)&#123;</span><br><span class="line">            int mid=(high+low)/2;</span><br><span class="line">            if(check(bloomDay,m,k,mid))&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                low=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">    bool check(vector&lt;int&gt;&amp; bloomDay, int m, int k,int days)&#123;</span><br><span class="line">        int hua=0,huashu=0;</span><br><span class="line">        for(int i=0;i&lt;bloomDay.size()&amp;&amp;huashu&lt;m;i++)&#123;</span><br><span class="line">            if(bloomDay[i]&lt;=days)&#123;</span><br><span class="line">                hua++;</span><br><span class="line">                if(hua==k)&#123;</span><br><span class="line">                    huashu++;</span><br><span class="line">                    hua=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                    hua=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return huashu&gt;=m;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面两题向我们展示了一个利用二分搜索搜索答案的思路:<br>1.主函数二分搜索<br>2.子函数验证<br>众所周知,求解比验证难许多</p>
<p>5.10 叶子相似的树</p>
<p>前序遍历就可以了.前序遍历能保证叶子是从左到右被遍历到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool leafSimilar(TreeNode\* root1, TreeNode\* root2) &#123;</span><br><span class="line">        vector&lt;int&gt; a1;</span><br><span class="line">        vector&lt;int&gt; a2;</span><br><span class="line">        if(root1) forwardTraverse(root1,a1);</span><br><span class="line">        if(root2) forwardTraverse(root2,a2);</span><br><span class="line">        return a1==a2;</span><br><span class="line">    &#125;</span><br><span class="line">    void forwardTraverse(TreeNode\* root,vector&lt;int&gt;&amp;list)&#123;</span><br><span class="line">        if(!(root-&gt;left)&amp;&amp;!(root-&gt;right))&#123;</span><br><span class="line">            list.push_back(root-&gt;val);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left) forwardTraverse(root-&gt;left,list);</span><br><span class="line">        if(root-&gt;right) forwardTraverse(root-&gt;right,list);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.11 解码异或后的排列<br>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。<br>它被加密成另一个长度为 n – 1 的整数数组 encoded ，满足 encoded[i] &#x3D; perm[i] XOR perm[i + 1] 。比方说，如果 perm &#x3D; [1,3,2] ，那么 encoded &#x3D; [2,1] 。<br>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。<br>示例 1：<br>输入：encoded &#x3D; [3,1]<br>输出：[1,2,3]<br>解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]<br>示例 2：</p>
<p>之前我们就做过异或之后的数组怎么解码:最重要的就是寻找到那个first元素,这里我们也可以寻找到first元素</p>
<p>我们知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-c34b52deeb305f9413f534b570f9fed7_l3.svg" alt="x\lxor x=0">,那我们寻找到第一个元素,就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-131d0c2aa952b43d45bba07dfc407e81_l3.svg" alt="(x_0\oplus x_1\oplus x_2...\oplus x_n)\oplus (x_1 \oplus x_2\oplus x_3....x_n)=x1"></p>
<p>我们还知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-dbe284a90142f25d096bec9394436c2a_l3.svg" alt="encode[2k+1]=a[2k]\oplus a[2k+1]">刚好对所有奇数元素的数列一异或就可以把上述式子异或符号右边的元素求出来</p>
<p>注意,原来的数据是从1-n的排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encode) &#123;</span><br><span class="line">        int n=encode.size()+1;</span><br><span class="line">        vector&lt;int&gt; decode(n,0);</span><br><span class="line">        int total=0;</span><br><span class="line">        int except_0=0;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">            total=total^i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n;i+=2)&#123;</span><br><span class="line">            except_0=except_0^encode[i];</span><br><span class="line">        &#125;</span><br><span class="line">        decode[0]=except_0^total;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            decode[i]=decode[i-1]^encode[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return decode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.12 字数组异或查询<br>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。<br>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。<br>并返回一个包含给定查询 queries 所有结果的数组。<br>示例 1：<br>输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8]<br>解释：<br>数组中元素的二进制表示形式是：<br>1 &#x3D; 0001<br>3 &#x3D; 0011<br>4 &#x3D; 0100<br>8 &#x3D; 1000<br>查询的 XOR 值为：<br>[0,1] &#x3D; 1 xor 3 &#x3D; 2<br>[1,2] &#x3D; 3 xor 4 &#x3D; 7<br>[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14<br>[3,3] &#x3D; 8</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray">https://leetcode-cn.com/problems/xor-queries-of-a-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>一个式子就可以明白:这里截取官方题解了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        vector&lt;int&gt; xors(arr.size()+1);</span><br><span class="line">        for (int i=0;i&lt;arr.size();i++) &#123;</span><br><span class="line">            xors[i+1]=xors[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(vector&lt;int&gt;temp:queries)&#123;</span><br><span class="line">            int total=0;</span><br><span class="line">            total=xors[temp[0]]^xors[temp[1]+1];</span><br><span class="line">            result.push_back(total);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.13 停在原地的方案数<br>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。<br>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。<br>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。<br>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。<br>示例 1<br>输入：steps &#x3D; 3, arrLen &#x3D; 2<br>输出：4<br>解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。<br>向右，向左，不动<br>不动，向右，向左<br>向右，不动，向左<br>不动，不动，不动</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps">https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int MODULO = 1000000007;</span><br><span class="line">    int numWays(int steps, int arrLen) &#123;</span><br><span class="line">        int maxc=min(arrLen-1,steps/2);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(steps+1, vector&lt;int&gt;(maxc+1));</span><br><span class="line">        dp[0][0]=1;</span><br><span class="line">        for(int i=1;i&lt;=steps;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=maxc;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j];</span><br><span class="line">                if(j-1&gt;=0)&#123;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i-1][j-1])%MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j+1&lt;=maxc)&#123;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i-1][j+1])%MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[steps][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>动态规划:dp[行动的步数][获得的这个结果]&#x3D;走的方案数<br>官方题解还可以优化,比如说压缩到一维动态规划<br>动态规划最重要的就是:初态+状态转移,这里的初态:<br><img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-076590b86ba207ce143e94b2e823ad03_l3.svg" alt="dp[0][0]=1,dp[0][i]=0">,状态转移:来源于三个操作:一个是向左,一个是向右,一个是不动:<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-8c01feeb7f41da7bdd5ef7afa96f778d_l3.svg" alt="dp[i][j]=dp[i-1][j]+dp[i-1][j+1]+dp[i-1][j-1](if j+1,j-1 exists)"></p>
<p>5.14 整数转罗马数字<br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-to-roman">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>变相的数位转换罢了,注意的是1000-900-500-400-100-90-50-40-10-9-5-4-1这套转化法则,一开始就是没反应过来23333</p>
<p>5.15 罗马数字转整数</p>
<p>还是一样的,读取罗马数字,如果下一个罗马数字对应的值比我这个大,那么说明应该是IX之类的问题,就要减去这个罗马数字对应的值如果小,就加这个罗马数字对应的值就行</p>
<p>5.16 数组中最大的异或值</p>
<p><strong>输入：</strong>nums &#x3D; [3,10,5,25,2,8]<br><strong>输出：</strong>28<br><strong>解释：</strong>最大运算结果是 5 XOR 25 &#x3D; 28.</p>
<p>这个代码是题解里面的</p>
<p>第一种方法是贪心算法,就是我们已经知道<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-062b76d533174cda72c813758355544f_l3.svg" alt="x=a_i \oplus a_j">所以说我们就假设x,然后找有没有适合的a_i和a_j就好了,我们按位查找,从高位到低位查找:<br>首先看最高位有没有<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-259b6415756adf3480ea5e8a80d1d578_l3.svg" alt="a_i\oplus a_j=x">有的话就取1:就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg" alt="2x+1">没有的话就取0,就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg" alt="2x">,以此类推</p>
<p>第二种方法就是字典法:</p>
<p>这个是一个字典树,每个元素从高位到低位按照0和1的顺序建立树<br>当检查x的最大性的时候的做法:<br>因为要让异或最大,那就读取一个数,从高位到低位判断,如果这个位为0,那就看看这个位有没有位1的数,反之亦然.有的话异或的值就可以<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-0ac3fe2e28e9326d90e0c98613c1491d_l3.svg" alt="2x+1">,没有的话就是<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-da4556c0a02b580047678d308649edf9_l3.svg" alt="2x"></p>
<p>这里需要说明一下二进制的求值方法:从高位到低位扫描,扫描到1的话<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-73e0257639a78306bcf13ad0c68fcbdb_l3.svg" alt="2y+1">,扫描到0的时候就为<img src="https://sukunahust.com/wp-content/ql-cache/quicklatex.com-85ca23a1e42ccdfafecd1cf9622b44c3_l3.svg" alt="2y"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">struct Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    Trie\* left = nullptr;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    Trie\* right = nullptr;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie\* root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    static constexpr int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void add(int num) &#123;</span><br><span class="line">        Trie\* cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int check(int num) &#123;</span><br><span class="line">        Trie\* cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x \* 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x \* 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x \* 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x \* 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            add(nums[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.17 二叉树的堂兄弟节点</p>
<p>这个东西就是做一遍二叉树的遍历,找到:层数+父节点,比较就行了.传参数比较麻烦的话就开全局变量就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // x 的信息</span><br><span class="line">    int x;</span><br><span class="line">    TreeNode\* x_parent;</span><br><span class="line">    int x_depth;</span><br><span class="line"></span><br><span class="line">    // y 的信息</span><br><span class="line">    int y;</span><br><span class="line">    TreeNode\* y_parent;</span><br><span class="line">    int y_depth;</span><br><span class="line"></span><br><span class="line">    void level1(TreeNode\* root,int x,int k)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val==x)&#123;</span><br><span class="line">            x_depth=k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            level1(root-&gt;left,x,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            level1(root-&gt;right,x,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void level2(TreeNode\* root,int y,int k)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val==y)&#123;</span><br><span class="line">            y_depth=k;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            level2(root-&gt;left,y,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            level2(root-&gt;right,y,k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void parent2(TreeNode\* root,int y)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val==y)&#123;</span><br><span class="line">            y_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val==y)&#123;</span><br><span class="line">            y_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            parent2(root-&gt;left,y);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            parent2(root-&gt;right,y);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void parent1(TreeNode\* root,int x)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val==x)&#123;</span><br><span class="line">            x_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val==x)&#123;</span><br><span class="line">            x_parent=root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            parent1(root-&gt;left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            parent1(root-&gt;right,x);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isCousins(TreeNode\* root, int x, int y) &#123;</span><br><span class="line">        parent1(root,x);</span><br><span class="line">        parent2(root,y);</span><br><span class="line">        level1(root,x,0);</span><br><span class="line">        level2(root,y,0);</span><br><span class="line">        return (x_depth==y_depth)&amp;&amp;(x_parent!=y_parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.18 形成两个异或相等的三元组数目</p>
<p>给你一个整数数组 arr 。<br>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;&#x3D; i &lt; j &lt;&#x3D; k &lt; arr.length) 。<br>a 和 b 定义如下：<br>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j – 1]<br>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]<br>注意：^ 表示 按位异或 操作。<br>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>还是那张图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countTriplets(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int count=arr.size();</span><br><span class="line">        vector&lt;int&gt; abab(count+1);</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            abab[i+1]=abab[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;count;j++)&#123;</span><br><span class="line">                for(int k=j;k&lt;count;k++)&#123;</span><br><span class="line">                    if(abab[i]==abab[k+1])&#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5.19 找出第K大的异或坐标值</p>
<p>最近力扣是和这个公式杠上了么…,这道题就是一个模拟就行的了,但是我们可以建表来记录(m,k)之内的元素异或的和,这三项刚好可以表示</p>
<p>给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。<br>矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;&#x3D; i &lt;&#x3D; a &lt; m 且 0 &lt;&#x3D; j &lt;&#x3D; b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。<br>请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。<br>示例 1：<br>输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1<br>输出：7<br>解释：坐标 (0,1) 的值是 5 XOR 2 &#x3D; 7 ，为最大的值。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value">https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      
        <blockquote class="article-copyright">
    <p><strong>本文作者：</strong>Sukuna @ Suwa shrine</p>
    <p><strong>本文链接：</strong><a href="https://sukunashinmyoumaru-hust.github.io/2022/04/17/luogu-al/">https://sukunashinmyoumaru-hust.github.io/2022/04/17/luogu-al/</a></p>
    
    
    
    <p><strong>本文版权：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener external nofollow noreferrer" target="_blank"><span class="icon-creative-commons"></span>BY-NC-SA</a> 许可协议。转载请注明出处！</p>
    <span class="icon-creative-commons article-copyright-bg"></span>
  </blockquote>
      
      
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/8d1e248fe0f62130.jpg" data-sizes="auto" alt="南大ics面试记录" class="lazyload">
          
        
        <a href="/2022/06/06/nju-ics/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            南大ics面试记录
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/bac1b1e69e7ebfb7.jpg" data-sizes="auto" alt="Splay模版:P3369[模版/普通平衡树]" class="lazyload">
        
      
      <a href="/2022/03/30/splay/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          Splay模版:P3369[模版/普通平衡树]
        
      </h3>
    </div>
    
  </nav>


</article>






</section>
          
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false"></div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2024
      <span class="footer-info-sep rotate"></span>
      Sukuna
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        181k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        12:44
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
  
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-2022"><span class="toc-number">1.</span> <span class="toc-text">洛谷刷题记录(2022)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P2367-%E8%AF%AD%E6%96%87%E6%88%90%E7%BB%A9-%E5%B7%AE%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">P2367 语文成绩(差分前缀和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-CF44C-Holiday-%E5%B7%AE%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">双倍经验:CF44C Holiday (差分前缀和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1160-%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92-%E9%98%9F%E5%88%97%E6%A8%A1%E7%89%88%E9%A2%98-%E5%8C%85%E5%90%AB%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">P1160 队列安排(队列模版题,包含队列的添加和删除操作)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1044-%E6%A0%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">P1044 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P1449-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%A0%88%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">P1449 后缀表达式(栈的经典问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-P1981-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">(双倍经验) P1981 表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1165-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">P1165 日志分析(模拟栈)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P5788-%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">P5788 单调栈模版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">P1886 滑动窗口&#x2F;单调队列模版.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UVA540-%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">UVA540 团体队列(队列模拟)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%90%9C"><span class="toc-number">1.0.2.</span> <span class="toc-text">P1162 填涂颜色(简单深搜)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P1042-%E4%B9%92%E4%B9%93%E7%90%83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">P1042 乒乓球(字符串小模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1553-%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E5%8D%87%E7%BA%A7%E7%89%88-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">P1553 数字反转升级版(字符串小模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1332-Logo%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%92%E5%BD%92"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">P1332 Logo语言(字符串递归)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3375-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E6%A8%A1%E7%89%88"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">P3375 KMP字符串匹配(KMP模版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1030-%E7%BB%99%E5%AE%9A%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%B1%82%E5%85%88%E5%BA%8F-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8CP1827-%E7%BE%8E%E5%9B%BD%E8%A1%80%E7%BB%9F"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">P1030 给定中序后序求先序(双倍经验P1827 美国血统)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1087-FBI%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0%E5%92%8C%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">P1087 FBI树(二叉树递归构造和模拟)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3884-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98-LCA%E2%80%93%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">P3884 二叉树问题(LCA–最近公共祖先,树链剖分)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P4913-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">P4913 二叉树深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P5318-%E6%9F%A5%E6%89%BE%E6%96%87%E7%8C%AE-BFS%E5%92%8CDFS"><span class="toc-number">1.0.2.9.</span> <span class="toc-text">P5318 查找文献(BFS和DFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3371-%E5%8D%95%E5%85%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%89%88%E6%9C%AC"><span class="toc-number">1.0.2.10.</span> <span class="toc-text">P3371 单元最短路径(邻接表版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P2910-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%89%88%E6%9C%AC"><span class="toc-number">1.0.2.11.</span> <span class="toc-text">P2910 双倍经验(邻接矩阵版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3367-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%BE%80%E4%B8%8A%E6%90%9C%E7%B4%A2%E7%9A%84%E6%A0%91"><span class="toc-number">1.0.2.12.</span> <span class="toc-text">P3367 并查集(往上搜索的树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3366-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.0.2.13.</span> <span class="toc-text">P3366 最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3370-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.0.2.14.</span> <span class="toc-text">P3370 字符串哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1908-%E9%80%86%E5%BA%8F%E5%AF%B9-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.2.15.</span> <span class="toc-text">P1908 逆序对(归并排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1309-%E5%8F%8C%E5%80%8D%E7%BB%8F%E9%AA%8C-%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.0.2.16.</span> <span class="toc-text">P1309 (双倍经验) 逆序对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="toc-number">1.0.2.17.</span> <span class="toc-text">P1090 合并果子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1138-%E6%9C%80k%E5%B0%8F%E6%95%B4%E6%95%B0"><span class="toc-number">1.0.2.18.</span> <span class="toc-text">P1138 最k小整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1918-%E4%BF%9D%E9%BE%84%E7%90%83"><span class="toc-number">1.0.2.19.</span> <span class="toc-text">P1918 保龄球</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P6510-%E5%A5%B6%E7%89%9B%E6%8E%92%E9%98%9F"><span class="toc-number">1.0.2.20.</span> <span class="toc-text">P6510 奶牛排队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3719-rexp"><span class="toc-number">1.0.2.21.</span> <span class="toc-text">P3719 rexp.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1185-%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.2.22.</span> <span class="toc-text">P1185 绘制二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P3956-%E6%A3%8B%E7%9B%98"><span class="toc-number">1.0.2.23.</span> <span class="toc-text">P3956 棋盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1983-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.2.24.</span> <span class="toc-text">P1983 车站分级(拓扑排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1038-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.0.2.25.</span> <span class="toc-text">P1038 神经网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1381-%E5%8D%95%E8%AF%8D%E8%83%8C%E8%AF%B5"><span class="toc-number">1.0.2.26.</span> <span class="toc-text">P1381 单词背诵</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92"><span class="toc-number">2.</span> <span class="toc-text">P1002 [NOIP2002 普及组] 过河卒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1095-NOIP2007-%E6%99%AE%E5%8F%8A%E7%BB%84-%E5%AE%88%E6%9C%9B%E8%80%85%E7%9A%84%E9%80%83%E7%A6%BB"><span class="toc-number">3.</span> <span class="toc-text">P1095 [NOIP2007 普及组] 守望者的逃离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1048-NOIP2005-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%87%87%E8%8D%AF"><span class="toc-number">5.</span> <span class="toc-text">P1048 [NOIP2005 普及组] 采药</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF"><span class="toc-number">6.</span> <span class="toc-text">P1616 疯狂的采药</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">线性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1091-NOIP2004-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2"><span class="toc-number">8.</span> <span class="toc-text">P1091 [NOIP2004 提高组] 合唱队形</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1439-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">P1439 【模板】最长公共子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P1880-NOI1995-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">10.</span> <span class="toc-text">P1880 [NOI1995] 石子合并</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>



  
<script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js" integrity="sha384-xneY1WY8hOfUzswrE4CrYq35N4BdVcxqxwHPr9zawE&#x2F;jMSCxD+jAPU55x&#x2F;jj3wlf" crossorigin="anonymous"></script>

  <script>
    function loadScripts(scripts, index) {
      if (index < scripts.length) {
        const script = scripts[index];
        const src = script.getAttribute('src');

        const loadScript = (scriptContent) => {
          const scriptElement = document.createElement('script');
          if (script.type) {
            scriptElement.type = script.type;
          }
          scriptElement.text = scriptContent;
          document.head.appendChild(scriptElement);
          loadScripts(scripts, index + 1);
        }

        if (src) {
          fetch(src)
            .then(response => {
              if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
              }
              return response.text();
            })
            .then(scriptContent => {
              loadScript(scriptContent);
            })
            .catch(error => {
              console.error('Failed to load script:', src, error);
            });
        } else {
          loadScript(script.text);
        }
      }
    }
    window.Pjax && new window.Pjax({
      selectors: [
        "#header img",
        "#header picture",
        "head title",
        "#header-title",
        "#subtitle-wrap",
        "#content",
        '#mobile-nav',
        '#lazy-script'
      ],
      switches: {
        "#header-title": Pjax.switches.outerHTML,
        "#subtitle-wrap": Pjax.switches.outerHTML,
        "#content": function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.outerHTML = newEl.outerHTML
          this.onSwitch()
        },
        "#mobile-nav": Pjax.switches.outerHTML,
        '#lazy-script': function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.innerHTML = newEl.innerHTML
          this.onSwitch()
        },
      },
      cacheBust: false
    })
  </script>
  
<script src="/js/pjax.js"></script>




  <script>
    function initLive2d() {
      live2d.init("https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/", {themeTipsPath: ""});
    }
  </script>
  
<script src="https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/js/live2d-autoload.js" onload="initLive2d &amp;&amp; initLive2d()" async></script>





<div id="lazy-script">
  <div>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
  
<script src="https://npm.webcache.cn/valine@1.5.1/dist/Valine.min.js" integrity="sha384-3ma91AExDeMAZ1rjTjaP8V2A2obQE+s5ltKRwYlwdpArz9xVbp0tF3b0VV2ACNPn" crossorigin="anonymous" data-pjax></script>

  <script data-pjax>
    var GUEST_INFO = ['nick', 'mail', 'link'];
    var guest_info = 'SukunaFans'.split(',').filter((item) => {
      return GUEST_INFO.indexOf(item) > -1
    });
    var recordIP = JSON.parse('true');
    var highlight = JSON.parse('true');
    var visitor = JSON.parse('false');

    new Valine({
      el: '.vcomment',
      appId: "xR5C19oD9KiPnawzBUJNSD64-gzGzoHsz",
      appKey: "BuHN9ATTBOcwMxGPy9IxuI8b",
      placeholder: "留下你的留言吧",
      pageSize: '10',
      avatar: 'mp',
      lang: 'zh-cn',
      recordIP: recordIP,
      highlight: highlight,
      visitor: visitor,
      requiredFields: guest_info,
      path: window.location.pathname
    });
  </script>









    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.0.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  
    
<script src="https://npm.webcache.cn/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6&#x2F;1Nxveei" crossorigin="anonymous" defer data-pjax></script>

    <script data-pjax>
      window.MathJax = {"tex":{"tags":"ams","useLabelIds":true,"inlineMath":[["$","$"],["\\\\(","\\\\)"]],"displayMath":[["$$","$$"],["\\\\[","\\\\]"]],"processEscapes":true,"processEnvironments":true,"autoload":{"color":[],"colorv2":["color"]},"packages":{"[+]":["noerrors"]}},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"ignoreHtmlClass":"tex2jax_ignore","processHtmlClass":"tex2jax_process"},"loader":{"load":["input/asciimath","[tex]/noerrors"]}};
    </script>
  


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
  </html>

