
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_tq6stt6tcg';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};</script>
  
  
  <title>
    力扣面试经典150题 |
    
    Suwa shrine
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="E 是Easy N 是 Normal，也就是Medium，H 是 Hard Array &#x2F; String Merge Sorted Array E  设置答案表ans，设置两个指针i和j，表示当前所指的位置，一开始指针指向表头。比较两个指针所指元素大小，谁小谁先进ans表。如果有一个指针指到了表尾就不比了，直接把剩下没处理完的内容直接放进ans表。  Remove Element E">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣面试经典150题">
<meta property="og:url" content="https://sukunashinmyoumaru-hust.github.io/2024/11/20/150/index.html">
<meta property="og:site_name" content="Suwa shrine">
<meta property="og:description" content="E 是Easy N 是 Normal，也就是Medium，H 是 Hard Array &#x2F; String Merge Sorted Array E  设置答案表ans，设置两个指针i和j，表示当前所指的位置，一开始指针指向表头。比较两个指针所指元素大小，谁小谁先进ans表。如果有一个指针指到了表尾就不比了，直接把剩下没处理完的内容直接放进ans表。  Remove Element E">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-20T15:56:31.000Z">
<meta property="article:modified_time" content="2024-12-12T03:51:20.547Z">
<meta property="article:author" content="Sukuna">
<meta name="twitter:card" content="summary">
  
  
    <link rel="alternate" href="/atom.xml" title="Suwa shrine" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
</head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie">HUST-学解</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/picture">赠画感谢</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/source">资料下载</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/travel">旅行日志</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/gbook">Sukuna冬令营</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    
      <img fetchpriority="high" src="/images/sukuna.png" alt="力扣面试经典150题">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">力扣面试经典150题</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content">
          
            <aside id="sidebar">
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-String"><span class="toc-number">1.</span> <span class="toc-text">Array &#x2F; String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Pointers"><span class="toc-number">2.</span> <span class="toc-text">Two Pointers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Window%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%91%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">Sliding Window（滑动窗口【单调队列】）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%E5%B0%B1%E6%98%AF%E5%81%9A%E6%A8%A1%E6%8B%9F%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">矩阵（大部分就是做模拟）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">HashMap（哈希表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intervals"><span class="toc-number">6.</span> <span class="toc-text">Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">7.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkList"><span class="toc-number">8.</span> <span class="toc-text">LinkList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binariy-Tree"><span class="toc-number">9.</span> <span class="toc-text">Binariy Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binariy-Tree-BFS"><span class="toc-number">10.</span> <span class="toc-text">Binariy Tree BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST"><span class="toc-number">11.</span> <span class="toc-text">BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph"><span class="toc-number">12.</span> <span class="toc-text">Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph-BFS"><span class="toc-number">13.</span> <span class="toc-text">Graph BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">Trie（字典树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">Backtracking（回溯，其实也是一种搜索）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-Conquer%EF%BC%88%E5%88%86%E6%B2%BB%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">Divide &amp; Conquer（分治）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kadane%E2%80%99s-Algorithm"><span class="toc-number">17.</span> <span class="toc-text">Kadane’s Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search%EF%BC%88%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">Binary Search（二分搜索）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap%EF%BC%88%E5%A0%86%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">Heap（堆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bit-Manipulation%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">Bit Manipulation（位运算）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">21.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1D-DP%EF%BC%88%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">1D DP（一维动态规划）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4DP"><span class="toc-number">23.</span> <span class="toc-text">多维DP</span></a></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  
  
</aside>

          
          <section id="main"><article id="post-150" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2024/11/20/150/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2024-11-20T15:56:31.000Z" itemprop="datePublished">2024-11-20</time>
    <time style="display: none;" id="post-update-time">2024-12-12</time>
  </a>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/" data-aos="zoom-in">算法题</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <p>E 是Easy N 是 Normal，也就是Medium，H 是 Hard</p>
<h2 id="Array-String"><a href="#Array-String" class="headerlink" title="Array &#x2F; String"></a>Array &#x2F; String</h2><ol>
<li>Merge Sorted Array E</li>
</ol>
<p>设置答案表ans，设置两个指针i和j，表示当前所指的位置，一开始指针指向表头。比较两个指针所指元素大小，谁小谁先进ans表。如果有一个指针指到了表尾就不比了，直接把剩下没处理完的内容直接放进ans表。</p>
<ol start="2">
<li>Remove Element E</li>
</ol>
<p>太简单，略过。至于怎么使用O(1)的空间复杂度来进行操作。可以用双指针进行操作。i是表头，j是表尾，如果i表示的元素要被删除，就从j中取一个元素放到i对应的位置。（这样就被删掉了），如果不要被删除，那么让i+1就好。</p>
<ol start="3">
<li>Remove Duplicates from Sorted Array E</li>
</ol>
<p>这是有序数组，那么一切都好办了。规定一个双指针i和j都指向开头，如果这是重复元素，就移动j，如果不是重复元素，是新元素，那就先把j上的元素放到i处，然后i和j都移动（j是快指针，i是慢指针）</p>
<ol start="4">
<li>Remove Duplicates from Sorted Array II N</li>
</ol>
<p>这和上一题的区别就是只允许存在一次和两次的区别。改动也就是重复元素的判断。上一题是判断i和i-1是不是相等，这一题是i和i-2是不是相等。</p>
<ol start="5">
<li>Majority Element E</li>
</ol>
<p>可以使用哈希表，统计每个元素出现的次数，然后输出出现次数最多的元素。如果想省空间复杂度的话可以先排序，然后最中间的那个元素就是结果（因为）</p>
<ol start="6">
<li>Rotate Array N</li>
</ol>
<p>这一题可以使用数组翻转。比如说 1 2 3 4 5 6 7，移动k下，新数组的[0,k - 1]来源于尾部的k个元素。那么可以做一次翻转（把后面的k个元素放到前面），然后对[0,k - 1]和[k,n - 1]的元素进行调转。（把顺序调整回来）</p>
<ol start="7">
<li>Best Time to Buy and Sell Stock E</li>
</ol>
<p>不知道为什么现在就出现了dp，我们可以把这个状态记录在dp[i][j]。j&#x3D;0的时候表示在第i天已经买入股票的收入最大值。j&#x3D;1的时候就是在第i天卖出股票的收入最大值。</p>
<p>那么dp[i][0] &#x3D; max(dp[i-1][0],-price[i])。dp[i][1] &#x3D; max(dp[i-1][1],dp[i][0] + price[i])。初始值dp[0][0] &#x3D; -price[0],dp[0][1] &#x3D; 0。</p>
<ol start="8">
<li>Best Time to Buy and Sell Stock II N</li>
</ol>
<p>上面一题从只可以买一次编程可以买两次。那么dp的的第二维就是有4个状态。买了一个，买了一个卖了一个，买了两个卖了一个，买了两个卖了两个。</p>
<p>dp[i][0] &#x3D; max(dp[i-1][0],-price[i])。dp[i][1] &#x3D; max(dp[i-1][1],dp[i][0] + price[i])。dp[i][2] &#x3D; max(dp[i-2][2],dp[i][1] - prices[i])。dp[i][3] &#x3D; max(dp[i-1][3],dp[i][2] + price[i])。</p>
<ol start="9">
<li>Jump Game N</li>
</ol>
<p>这一题看题解似乎是可以用贪心。但我用倒推dp做的，dp[i]记录了可以到达最后结束位置的可能性。dp[最后一个位置]肯定为1，记录一个使dp[k]&#x3D;1最小的k值，然后依次往后倒，如果nums[i] + i &lt;&#x3D; k的话就说明可以到达。dp[i] &#x3D; 1，否则为0，看看dp[0]的取值就好。</p>
<ol start="10">
<li>Jump Game II N</li>
</ol>
<p>这一题相较于上一题多了一个记录最小步数的。那么这次就用dp[i]表示从0到这里最少几步。这里可以有这样的递推方程对于j属于[i,i+nums[i]],dp[j]&#x3D;min(dp[j],dp[i]+1)</p>
<ol start="11">
<li>H-Index N</li>
</ol>
<p>对文章引用进行排序。h指的是什么，是h个index比h高的数，那就从0开始试，如果index[size - h - 1] &gt; h，说明可以往上升。</p>
<ol start="12">
<li>Insert Delete GetRandom O(1) N</li>
</ol>
<p>O(1)的CURD，空间换时间，用一个额外的哈希表记录是否有重复元素。这个哈希表不记录元素的个数，记录元素在表中的索引。添加的时候在表中添加这个元素，哈希表记录index。删除k，如果k没有，就返回false，如果k有的话，那么找到index。表的index位置替换成表尾元素。删掉表尾元素更换哈希表。在O(1)时间内查询不说，太简单。</p>
<ol start="13">
<li>Product of Array Except Self N</li>
</ol>
<p>这里为什么不能计算出所有元素的积然后再除本元素呢，是因为可能本元素是0，所以可能有问题。所以可以进行一次前缀后缀积。s[i]记录从0一直积到i的值，[i]记录从最后积到i的值，后面就是s[i-1]*b[i+1]（注意考虑一下边界）</p>
<ol start="14">
<li>Gas Station N</li>
</ol>
<p>先从0开始走，如果能绕一圈自然是好的，但是如果不能的话，在哪里走不动了，就在哪里的下一站试。为什么呢，比如说0-&gt;1-&gt;2，到2走不动了，那么从1出发从2出发也是不行的，只能试一下从3出发。这样可以减少搜索的次数。</p>
<ol start="15">
<li>Candy H</li>
</ol>
<p>分糖果，那么可以进行两次贪心。首先先从左往右走，如果i比i-1大，那么s[i] &#x3D; s[i-1] + 1，如果小，s[i] &#x3D; 1。然后从右往左走，如果i比i+1大，那么b[i] &#x3D; b[i+1] + 1，如果小那么b[i] &#x3D; 1。最后这个小孩分配的糖果数量是max(s[i],b[i])。首先这样可以保证题目的条件满足，如果是2 1 2的情况，那么就是1，如果是1 2 1的情况，那么就是max（左，右）。如果是3 2 1的情况，那么就以右边 + 1为准，右边+1怎么都比1大。所以这样做是可以保证对的。其次由于是贪心，我们可以保证分配的糖果数量是最少的。</p>
<ol start="16">
<li>Trapping Rain Water H</li>
</ol>
<p>维护一个单调栈，这里就是记录从[s[i],i]中的元素都满足单调性。（这里是单调递减）。这里说一下单调栈的维护，其实就是比较。如果元素比栈顶大，那么栈顶退出，一直到元素比栈顶小或者栈中没元素了。</p>
<p>如果栈中有元素退栈了，但是栈中元素还是不空，这是发生了什么呢？就是有水背围住了，这个时候可以记录水的数量了。这里套用题解就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int currWidth = i - left - 1;</span><br><span class="line">int currHeight = min(height[left], height[i]) - height[top];</span><br><span class="line">ans += currWidth * currHeight;</span><br></pre></td></tr></table></figure>

<p>作者：力扣官方题解<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<ol start="17">
<li>Roman to Integer E</li>
</ol>
<p>模拟即可。对字符串进行遍历。</p>
<ol start="18">
<li>Integer to Roman N</li>
</ol>
<p>贪心算法，先算有多少个1000，再算900，再算500，再算400，以此类推。然后做字符串的加运算即可，有多少个1000就加多少个’M’。</p>
<ol start="19">
<li>Integer to Roman E</li>
</ol>
<p>统计连续的非空格字符数。有一种优化方式是从后往前遍历字符串，遇到非空格字符开始计数，计数到遇到空格字符，即为答案。</p>
<ol start="20">
<li>Longest Common Prefix E</li>
</ol>
<p>找最长公共前缀。就遍历一下即可。比如说第一个单词的第一个字母是A，看看别的单词的第一个字母是不是A，是的话就把A放入答案中，以此类推，直到有差异或者到了一个单词的末尾。</p>
<ol start="21">
<li>Reverse Words in a String N</li>
</ol>
<p>这道题就是考验对字符串处理的基本功，首先把所有的单词提取出来，然后把单词逆序处理即可。提取出来的办法我想得比较笨，就是str +&#x3D; 非空格元素。遇到空格就代表单词处理完毕了，加入到一个单词表中。</p>
<ol start="22">
<li>Zigzag Conversion N</li>
</ol>
<p>数学题，首先先计算要用到的行数和列数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int route = numRows + (numRows &gt; 1? numRows - 2:0);</span><br><span class="line">int lie = numRows &lt; 2 ? 1 : numRows - 1;</span><br></pre></td></tr></table></figure>

<p>然后分配一下具体的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(r &lt; numRows) c[r][lie * p] = s[i];</span><br><span class="line">else c[2 * numRows - r - 2][lie * p + r - numRows + 1] = s[i];</span><br></pre></td></tr></table></figure>

<p>其实就是数学题，建立字符串和Zigzag的映射。</p>
<ol start="23">
<li>Find the Index of the First Occurrence in a String E</li>
</ol>
<p>可以使用KMP算法进行匹配，但这里没有使用。就是使用朴素匹配的思路就可以。当然用KMP算法会更快。</p>
<ol start="24">
<li>Text Justification</li>
</ol>
<p>暂时略过。</p>
<h2 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h2><ol start="25">
<li>Valid Palindrome E</li>
</ol>
<p>设置两个指针i和j，i指向字符串头，j指向字符串尾。i和j相等的话就往内移。不相等返回false。如果i和j相遇了(i &gt;&#x3D; j)，就可以返回true。</p>
<ol start="26">
<li>Is Subsequence E</li>
</ol>
<p>这个比字符串匹配要简单一点，设置两个指针i和j，i指向长串，j指向慢串。i和j对应的相等，则i后移j后移，否则就只有i后移。当i移动到最后j没移动到最后就返回false，否则返回true。</p>
<ol start="27">
<li>Two Sum II - Input Array Is Sorted N</li>
</ol>
<p>设置两个指针i和j，i指向表前，j指向表后。如果s[i]+s[j]大了，那就j–，如果小了i++，如果j比i小了，说明没结果。如果s[i]+s[j]刚刚好，说明结果找到了！</p>
<ol start="28">
<li>Container With Most Water N</li>
</ol>
<p>设置两个指针i和j，i指向表前，j指向表后。记录ans &#x3D; min(height[i],height[j]) * (j - i)的最大值。如果s[i] &lt; s[j]，那就i++，否则j–，一直到j &lt; i为止。（贪心+双指针）</p>
<ol start="29">
<li>3Sum N</li>
</ol>
<p>基于第27题的题目，其实在第27题的基础上加了一个遍历。遍历1-n为i，然后在i+1~n之间做一次二数之和。</p>
<h2 id="Sliding-Window（滑动窗口【单调队列】）"><a href="#Sliding-Window（滑动窗口【单调队列】）" class="headerlink" title="Sliding Window（滑动窗口【单调队列】）"></a>Sliding Window（滑动窗口【单调队列】）</h2><ol start="30">
<li>Minimum Size Subarray Sum N</li>
</ol>
<p>首先先规定滑动窗口的范围[j,k]。假设滑动窗口内部的和是p。现在遍历这个数组，下标为i</p>
<p>（1）如果p + a[i] &lt; target，让k &#x3D; i</p>
<p>（2）p + a[i] &#x3D; target，这是一个可能的结果，记录一下。</p>
<p>（3）p + a[i] &gt; target。这时候要吐出滑动窗口的元素了。做p -&#x3D; a[j++]一直到p + a[i] &lt;&#x3D; target为止。</p>
<p>对所有的可能的结果找最小值。</p>
<ol start="31">
<li>Longest Substring Without Repeating Characters N</li>
</ol>
<p>首先先规定滑动窗口的范围[j,k]，然后构造一个Hash表来维护不重复性。遍历字符串，下标为i</p>
<p>（1）s[i]不重复，可以扩展k &#x3D; i。记录一下当前滑动窗口长度。维护滑动窗口长度的最大值。</p>
<p>（2）s[i]重复，j++到不重复为止。</p>
<ol start="32">
<li>Substring with Concatenation of All Words H</li>
</ol>
<p>首先先规定滑动窗口的范围[j,k]，然后构造一个Hash表来维护不重复性。首先我们直到滑动窗口的移动是按照单词表的元素为基准的。也就是说我们的初始滑动窗口是不同的，假设单词表元素的长度为k，那么从0,1,2…k-1开始都可以。所以说要遍历（0,k-1）。</p>
<p>之后和之前的滑动窗口操作一样。但是每次取字符串都是k个k个去取。</p>
<p>（1）不在单词表里。那么滑动窗口从[i+单词表长度,i+单词表长度]开始。</p>
<p>（2）在单词表里，而且在滑动窗口内没出现过（用std::map来维护）。k+&#x3D;单词表长度。</p>
<p>（3）在单词表里，而且在滑动窗口内出现过，那就移动j一直到滑动窗口内部没出现过。</p>
<ol start="33">
<li>Minimum Window Substring H</li>
</ol>
<p>滑动窗口的范围[j,k]，首先遍历一下要判别的串K。看看串内部字母的数量。构建一个hash表记录滑动窗口内部每个字母的数量。然后遍历字符串</p>
<p>（1）没达到要求，滑动窗口向右拓展。</p>
<p>（2）达到要求了，滑动窗口往左尽量收缩，尽量的含义是，收缩到i以致于滑动窗口[i+1,k]不满足要求而[i,k]满足要求，记录答案，维护答案的最小值。</p>
<h2 id="矩阵（大部分就是做模拟）"><a href="#矩阵（大部分就是做模拟）" class="headerlink" title="矩阵（大部分就是做模拟）"></a>矩阵（大部分就是做模拟）</h2><ol start="34">
<li>Valid Sudoku N</li>
</ol>
<p>模拟，首先先把数独构造出来，然后按行按列去检查有无重复项（哈希表）</p>
<ol start="35">
<li>Spiral Matrix N</li>
</ol>
<p>这道题也是模拟。就是模拟矩阵旋转的过程。旋转可以分为四个部分，左下右上。做几次旋转可以通过min(m,n) + 1这个式子算出。左下右上每次怎么放元素的也可以算出。</p>
<ol start="36">
<li>Rotate Image N</li>
</ol>
<p>旋转矩阵，其实可以拆成四块去做的。左上到右上，右上到右下，右下到左下，左下到左上。每一次都是四个四个做的，而且可以写出映射。那么矩阵一块有多大呢，一块就是(n&#x2F;2) * (n+1&#x2F;2)大，四块的具体的划分也可以说出来。那么就做那么多次的循环交换就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int temp = matrix[i][j];</span><br><span class="line">matrix[i][j] = matrix[n - j - 1][i];</span><br><span class="line">matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];</span><br><span class="line">matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];</span><br><span class="line">matrix[j][n - i - 1] = temp;</span><br></pre></td></tr></table></figure>

<ol start="37">
<li>Set Matrix Zeroes N</li>
</ol>
<p>维护一个表b，记录哪些元素要设置为0。遍历一遍矩阵，对0元素，其所在行和所在列上所有位置，在表b中设置为1。矩阵遍历完了就统一设置为0。这样做是防止新生成出来的0会干扰操作。</p>
<ol start="38">
<li>Game of Life N</li>
</ol>
<p>暂时略过。</p>
<h2 id="HashMap（哈希表）"><a href="#HashMap（哈希表）" class="headerlink" title="HashMap（哈希表）"></a>HashMap（哈希表）</h2><ol start="39">
<li>Ransom Note E</li>
</ol>
<p>首先遍历magazine，记录magazine每个元素出现的次数，记录在哈希表中。然后遍历ransomNote，记录ransomNote每个元素出现的次数，出现比magazine多就判定false，没有的话就判定true。</p>
<ol start="40">
<li>Isomorphic Strings E</li>
</ol>
<p>将两个串进行字数统计，记录在哈希表1和2中，然后排序哈希表1和2，比较哈希表中元素数量是否相同。（当然也可以对哈希表进行再哈希）</p>
<ol start="41">
<li>Word Pattern E</li>
</ol>
<p>感觉这题并不像E的难度。将句子拆成若干个单词组，然后尝试构建一个字符串对字符的哈希映射，如果出现了哈希冲突，就是false，反之就是true。比如说dog cat cat dog和abba，就可以成功建立 dog-a cat-b的映射，dog cat cat dog和abbc，那么dog可以对a或者c，就产生了冲突，dog cat cat fog和abba，a可以对dog或者fog，也是出现了冲突。（查冲突的方法就是查哈希表的元素是否为空或者是否为不空）</p>
<ol start="42">
<li>Valid Anagram E</li>
</ol>
<p>构建两个字符串的哈希表，看哈希表是否完全相等。</p>
<ol start="43">
<li>Group Anagrams N</li>
</ol>
<p>这里本来是想让每组单词之间两两调用42题的API，结果TLE。上网看题解发现可以对字符串做sort，这样互为Anagrams的单词就是一样的。</p>
<ol start="44">
<li>Two Sum E</li>
</ol>
<p>这里本来可以使用暴力方式，搜索一遍就可以过。但是可以用哈希表。首先构建一个哈希表，然后。遍历数组，对于数组的元素x，希望能找到target-x的存在性，就搜索哈希表即可。</p>
<ol start="45">
<li>Happy Number E</li>
</ol>
<p>首先我们模拟上述的操作，然后我们用一个哈希表记录操作的结果的循环性，如果结果循环出现，我们知道时遇到了循环，就要返回false。遇到了1就返回true（我们知道如果不是快乐数就是一定遇到了循环，因为在做操作的时候，对于高位数，会单调递减，对于三位数以内的值，最多最多只能到243，所以一定会出现循环）只不过我们知道当遇到4的时候就代表遇到了循环，可以以此为着手进行优化。</p>
<ol start="46">
<li>Contains Duplicate II E</li>
</ol>
<p>在这里依然使用哈希，但是我哈希表的值记录上一次出现在数组的下标。然后每次出现就使用哈希表的值进行判断。</p>
<ol start="47">
<li>Longest Consecutive Sequence N</li>
</ol>
<p>做哈希然后找哈希表上连续元素的个数。</p>
<h2 id="Intervals"><a href="#Intervals" class="headerlink" title="Intervals"></a>Intervals</h2><ol start="48">
<li>Summary Ranges E</li>
</ol>
<p>遍历数组。记录连续的区间，记录的方法就是比较当前元素和之前元素的关系，如果满足+1，就不管，不满足+1，就意味着新的区间已经出现了。然后把记录的结果转化成字符串。</p>
<ol start="49">
<li>Merge Intervals N</li>
</ol>
<p>将区间按照左端递增的方式进行排序，然后每次比较都是比较上一个区间的右端和下一个区间的左端，观察可合并性。如果可合并，就更改右端的值作为一个新的区间。如果不可合并就重新构建新的待合并区间。（最重要的还是排序这一步）</p>
<ol start="50">
<li>Insert Interval N</li>
</ol>
<p>其实就是把新区间加进去，然后调用一次49。当然还可以直接遍历一遍所有区间，找到合适的位置进行合并。（找位置其实就是插入排序，因为左端的值是递增的，按照左端递增的规律进行插入就好）</p>
<ol start="51">
<li>Minimum Number of Arrows to Burst Balloons N</li>
</ol>
<p>按照右端递增进行排序。然后取一个p&#x3D;第一个元素的右端。如果下一个元素的左端比上一个元素的右端要大，就说明不能在一起射了，就只能ans++，p&#x3D;下一个元素的右端。如果不大，说明可以一起射，就可以不用做任何操作。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ol start="52">
<li>Valid Parentheses E</li>
</ol>
<p>非常典型的Stack问题，括号匹配，如果是左括号，入栈，右括号就和栈顶匹配。</p>
<ol start="53">
<li>Simplify Path N</li>
</ol>
<p>非常搞人心态的模拟题。首先用一个栈模拟文件夹路径。首先如果遇到了&#x2F;，就代表该往下或者往上走一步了，如果是一个dot，就啥也不用做，两个dot就退栈，如果都不是，就往栈里push一个新的文件夹名字。其实本题的难dot在dot的处理上，有量个变量k和p（只有dot和不是只有dot）来记录上一级的名字里面是不是只有dot，如果不是只有dot就一律按照普通的名字来。如果遇到了..word.，在遇到第一个dot的时候k++，第二个也是k++，在遇到w的时候就把k&#x3D;0，p&#x3D;1。当p&#x3D;1的时候，再遇到dot都不会k++了。而是保存起来。 反正是一个很折磨的模拟题。</p>
<ol start="54">
<li>Min Stack N</li>
</ol>
<p>维护最小值的栈。那就维护两个栈，一个是原始的栈，一个是到目前为止最小值的栈。在push的时候，就把要push的值push到原始栈中，要push的值和最小值栈的最小值push到最小值栈中。</p>
<ol start="55">
<li>Evaluate Reverse Polish Notation N</li>
</ol>
<p>暂时略过。</p>
<ol start="56">
<li>Basic Calculator</li>
</ol>
<p>力扣的链表数据结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><ol start="57">
<li>Linked List Cycle</li>
</ol>
<p>双指针。设置一个快指针和慢指针。快指针一次性走两次，慢指针一次性走一次。如果有环，那么快慢指针会碰面，如果没有环，那么快指针马上会指向NULL。（当然要注意边界条件，因为当链表为空或者链表根本只有一个元素不可能有环。）</p>
<ol start="58">
<li>Add Two Numbers</li>
</ol>
<p>用链表模拟加，很折磨。用数组模拟竖式加法本来就很折磨，更何况链表。构建result表，首先先判断l1和l2指针是不是为空，如果为空的话就默认这是0，不为空的话该是什么是什么（后面移动l1和l2指针也是判断是否为空，为空的话就不用做操作）。然后两个指针对应内容和上一级进位相加。得到这一级加数和进位。加数插入进result表。以此类推，一直到l1和l2都是空。都是空了之后，在result表的队尾加上carry对应的节点。</p>
<p>这题和一般的模拟一样，首先要考虑两个加数不是同一个位的情况。然后还要考虑result表要构造头指针和尾指针。</p>
<ol start="59">
<li>Merge Two Sorted Lists</li>
</ol>
<p>构建一个res表，然后构建三个指针。i，j，k。i指向链表1，j指向链表2。k指向res表。i比j小，k后面补个i，i往后移。反之k后面补个j，j往后移，一直到i或者j到了尾部，把剩下那个没到尾部的那个表补到k后面</p>
<ol start="60">
<li>Copy List with Random Pointer</li>
</ol>
<p>深拷贝复制一个链表。那就构建一个老链表结点到新链表结点的映射，新链表构建完了需要完善random指针和next指针。所以之后遍历老链表。假设现在老链表遍历到了k，那么新链表为Hash(k)，那么可以写出Hash(k)-&gt;next &#x3D; Hash(k-&gt;next[老链表])[新链表]，巧妙构建了新链表之间的联系。</p>
<ol start="61">
<li>Reverse Linked List II N</li>
</ol>
<p>详见62，62就是用了61的代码：</p>
<ol start="62">
<li>Reverse Nodes in k-Group H</li>
</ol>
<p>这一题就是折磨，狠狠地模拟了。这里Sukuna用了一个取巧的方法，用了一个Hash，把链表结点和结点所在的位置做了一次Hash。然后写了一个调换结点的代码。说白了就是对所有的next节点进行了狠狠地替换，代码非常长，算法很好懂，就是代码非常不好写：（注意一下首部的处理）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void reverseBetween(ListNode* head, int left, int right) &#123;</span><br><span class="line">    if(!head) return;</span><br><span class="line">    if(left &gt; 1) &#123;</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[left-1]-&gt;val,maps[right]-&gt;val);</span><br><span class="line">        maps[left-1]-&gt;next = maps[right];</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[left]-&gt;val,maps[right+1]-&gt;val);</span><br><span class="line">        maps[left]-&gt;next = maps[right+1];</span><br><span class="line">        for(int i = right;i &gt; left;i--)&#123;</span><br><span class="line">            //printf(&quot;Let %d to %d\n&quot;,maps[i]-&gt;val,maps[i-1]-&gt;val);</span><br><span class="line">            maps[i]-&gt;next = maps[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //return maps[1];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //printf(&quot;Let %d to %d\n&quot;,maps[1]-&gt;val,maps[right + 1]-&gt;val);</span><br><span class="line">        maps[1]-&gt;next = maps[right + 1];</span><br><span class="line">        for(int i = right;i &gt; left;i--)&#123;</span><br><span class="line">            //printf(&quot;Let %d to %d\n&quot;,maps[i]-&gt;val,maps[i-1]-&gt;val);</span><br><span class="line">            maps[i]-&gt;next = maps[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //return maps[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后以k个为一组进行替换。最后不足k个的就直接复制过去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">       if(k==1)return head;</span><br><span class="line">       int i = 1;</span><br><span class="line">       ListNode* res = head;</span><br><span class="line">       while(res)&#123;</span><br><span class="line">           maps[i] = res;</span><br><span class="line">           res = res-&gt;next; </span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       maps[i]=nullptr;</span><br><span class="line">       i--;</span><br><span class="line">       int total = i;</span><br><span class="line">       int flag = 0;</span><br><span class="line">       for(int j = 1;j + k - 1 &lt;= total;j+=k)&#123;</span><br><span class="line">           </span><br><span class="line">           //printf(&quot;Do %d %d\n&quot;,j,j+k-1);</span><br><span class="line">           reverseBetween(head,j,j+k-1);</span><br><span class="line">           ListNode* head = maps[k];</span><br><span class="line">           while(head)&#123;</span><br><span class="line">               //printf(&quot;%d &quot;,head-&gt;val);</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode* res = flag?maps[1]:maps[k];</span><br><span class="line">           flag = 1;</span><br><span class="line">           i = 1;</span><br><span class="line">           while(res)&#123;</span><br><span class="line">               maps[i] = res;</span><br><span class="line">               res = res-&gt;next; </span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           i--;</span><br><span class="line">           //printf(&quot;\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return maps[1];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="63">
<li>Remove Nth Node From End of List N</li>
</ol>
<p>链表的删除。首先计算链表的长度l，然后删除掉l - n + 1上的节点。删除的办法在C语言课上讲过了。首先找到l - n + 2上的节点，然后让l - n + 2指向l - n即可（第l个默认是NULL）这样有个好处就是，不用对空指针进行处理。</p>
<p>但是如果要删除第一个的话，可以直接让head &#x3D; head-&gt;next，就不能找到前一个了。</p>
<ol start="64">
<li>Remove Duplicates from Sorted List II N</li>
</ol>
<p>构造hash表，然后构造一个新表，把hash表里所有出现次数为1的数插到新表里。</p>
<ol start="65">
<li>Rotate List N</li>
</ol>
<p>首先要明确一点，rotate的次数 &#x3D; k % 链表的长度。然后找到最后第k个元素，记作a，第k-1个元素为a-1。然后原链表的头head和尾tail。tail-&gt;next &#x3D; head。a-1-&gt;next &#x3D; NULL。（这里要考虑边界条件，如果k&#x3D;0，就什么都不用做）</p>
<ol start="66">
<li>Partition List N</li>
</ol>
<p>构建两个表1和2，小于x的放入1，否则放入2.如果表1或者2是空表，就直接返回表2或者表1.如果不是的话表1末尾-&gt;next&#x3D;表二开头。</p>
<ol start="67">
<li>LRU Cache N</li>
</ol>
<p>暂且不表。</p>
<h2 id="Binariy-Tree"><a href="#Binariy-Tree" class="headerlink" title="Binariy Tree"></a>Binariy Tree</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<ol start="68">
<li>Maximum Depth of Binary Tree E</li>
</ol>
<p>求二叉树最大深度。那就是求左子树和右子树深度最大值+1。（如果是空树的话返回0）</p>
<ol start="69">
<li>Same Tree E</li>
</ol>
<p>先判空，如果两方有一个是空，返回false，如果两方都是空，返回true。如果都不是空，就看本节点值，左子树和右子树的一致性。(p-&gt;val &#x3D;&#x3D; q-&gt;val) &amp;&amp; (isSameTree(p-&gt;left,q-&gt;left)) &amp;&amp; (isSameTree(p-&gt;right,q-&gt;right))</p>
<ol start="70">
<li>Invert Binary Tree E</li>
</ol>
<p>如果该树为空，那就什么都不用做。如果不空，那就交换左右子树，然后对左右子树递归调用交换函数。</p>
<ol start="71">
<li>Symmetric Tree E</li>
</ol>
<p>调用一下70，把右子树进行一次调转。然后看左子树和右子树是不是一个树（69）</p>
<ol start="72">
<li>Construct Binary Tree from Preorder and Inorder Traversal N</li>
</ol>
<p>给定前序排列和中序排列，构建一个树。非常经典的数据结构题。如果排列只有一个，那么就直接返回即可。如果有两个及以上，那首先要知道前序排列的第一个元素，在中序排列的位置，假设为i，那么中序遍历的[0,i-1]就是左子树[i+1,n]是右子树。然后递归构造就好。</p>
<ol start="73">
<li>Construct Binary Tree from Inorder and Postorder Traversal N</li>
</ol>
<p>还是经典，只不过从前序改成后序，还是一样的做法。只不过是后序排列的最后一个元素，在中序的位置。</p>
<ol start="74">
<li>Populating Next Right Pointers in Each Node II N</li>
</ol>
<p>这个可以首先构造一个层次的链表数组L。然后假设一个节点r的层数为n，那么L[n]-&gt;next &#x3D; r，L[n] &#x3D; r。这样子就可以巧妙地构造一个层次表了。</p>
<ol start="75">
<li>Flatten Binary Tree to Linked List N</li>
</ol>
<p>这个可以用一个很笨的方法，就是先前序遍历，把前序遍历的结果放在一个vector内部，然后遍历vector以分配左右子树指针的朝向。</p>
<ol start="76">
<li>Path Sum E</li>
</ol>
<p>递归计算。假设target&#x3D;k，那就计算 左子树存在路径使路径和 &#x3D;&#x3D; k - val || 右子树存在路径使路径和 &#x3D;&#x3D; k - val。在递归的时候，有一个函数参数保留k - val的值。</p>
<ol start="77">
<li>Sum Root to Leaf Numbers N</li>
</ol>
<p>假设root的值是k，那么这个root对应的值可以这么表示，假设父亲传来了两个数，k和p（p是引用）【这相当于编译原理里面的综合变量和传递变量】，如果没有子树了，那么就让p +&#x3D; 10k + val。如果有子树，那么令k &#x3D; 10k + val。（这样子可以把之前几层的信息传递给最后的叶节点，让叶节点做加法有依据）。可以这么理解：就是有儿子，奖池还在继续，没有儿子了，那么就把奖池兑现。</p>
<ol start="78">
<li>Binary Tree Maximum Path Sum H</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxs = -1000000000;</span><br><span class="line">    int dfs(TreeNode* root,int isroot)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int res1 = dfs(root-&gt;left,0);</span><br><span class="line">        int res2 = dfs(root-&gt;right,0);</span><br><span class="line">        if(res1 + root-&gt;val + res2 &gt; maxs) maxs = res1 + root-&gt;val + res2;</span><br><span class="line">        if(max(res1,res2) + root-&gt;val &gt; maxs) maxs = max(res1,res2) + root-&gt;val;</span><br><span class="line">        if(root-&gt;val &gt; maxs) maxs = root-&gt;val;</span><br><span class="line">        return max(max(res1,res2),0) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        int k = dfs(root,1);</span><br><span class="line">        return max(maxs,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实这个代码用得挺笨，我也不知道我搞了个isroot有啥用。不过在这里解释一下代码是怎么做的。我们假设路径是I型和V型。I型就是直勾勾往下走，V型是在某处拐了个弯。首先先记录一下左子树和右子树的I型路径的最大值，假设为l，r。那么算上本路径的I型路径最大值是$max(l,r)+val$。</p>
<p>那么在考虑V型路径（V型路径就是左右子树两部分构成的I型路径+自己，这样可以组成一个V型路径）：if(res1 + root-&gt;val + res2 &gt; maxs) maxs &#x3D; res1 + root-&gt;val + res2;</p>
<p>那么维护一个最大值来记录答案。</p>
<ol start="79">
<li>Binary Search Tree Iterator N</li>
</ol>
<p>写一个基于二叉树的迭代器。这个非常简单，把二叉树做一次搜索，搜索结果放到stack里。</p>
<ol start="80">
<li>Count Complete Tree Nodes E</li>
</ol>
<p>左子树节点数 + 右子树节点数 + 1</p>
<ol start="81">
<li>Lowest Common Ancestor of a Binary Tree</li>
</ol>
<p>最近公共祖先（LCA）。首先维护一个dfs(k)，这个值代表k内部是否存在p和q（我们找公共祖先的节点）。</p>
<p>如果左儿子的dfs和右儿子的dfs都是true，就说明本节点是一个公共祖先。或者本节点就是p或者q，然后左儿子的dfs和右儿子的dfs有一个是true，那也可以说明本节点是一个公共祖先。</p>
<h2 id="Binariy-Tree-BFS"><a href="#Binariy-Tree-BFS" class="headerlink" title="Binariy Tree BFS"></a>Binariy Tree BFS</h2><ol start="82">
<li>Binary Tree Right Side View N</li>
</ol>
<p>到了二叉树的层次遍历了。其实还是可以和之前一样，构造一个层次表L，然后做一次dfs(k,n)【代表第k个元素再第n层】然后令L[n] &#x3D; k即可。</p>
<ol start="83">
<li>Average of Levels in Binary Tree E</li>
</ol>
<p>计算每一层的平均值。dfs一下，计算每一层的总和和结点数。除一下就好。</p>
<ol start="84">
<li>Binary Tree Level Order Traversal</li>
</ol>
<p>其实还是可以和之前一样，构造一个层次表L，然后做一次dfs(k,n)【代表第k个元素再第n层】然后令L[n].push_back(k)即可。当然还可以用队列模拟层次遍历（广度优先搜索），这样做不仅要维护一个搜索队列，还要维护一个搜索队列对应的层次队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getDepth(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return max(getDepth(root-&gt;left),getDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        int p = getDepth(root);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res = *new vector&lt;vector&lt;int&gt;&gt;(p);</span><br><span class="line">        queue&lt;int&gt; l;</span><br><span class="line">        queue&lt;TreeNode*&gt; t;</span><br><span class="line">        l.push(1);</span><br><span class="line">        if(root) t.push(root);</span><br><span class="line">        while(!t.empty())&#123;</span><br><span class="line">            TreeNode* k = t.front();</span><br><span class="line">            int i = l.front();</span><br><span class="line">            t.pop();</span><br><span class="line">            l.pop();</span><br><span class="line">            res[i-1].push_back(k-&gt;val);</span><br><span class="line">            if(k-&gt;left) &#123;t.push(k-&gt;left); l.push(i+1);&#125;</span><br><span class="line">            if(k-&gt;right)&#123;t.push(k-&gt;right);l.push(i+1);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="85">
<li>Binary Tree Zigzag Level Order Traversal N</li>
</ol>
<p>暂不讨论</p>
<h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><ol start="86">
<li>Minimum Absolute Difference in BST E</li>
</ol>
<p>BST的前序遍历是按照升序排序的。那就先前序遍历，存一下遍历的结果，然后遍历比较即可。</p>
<ol start="87">
<li>Kth Smallest Element in a BST N</li>
</ol>
<p>第K小元素，那就还是存前序遍历的结果，然后取第k个元素就好。</p>
<ol start="88">
<li>Validate Binary Search Tree N</li>
</ol>
<p>验证BST的性质，存前序遍历的结果，看是不是前面的比后面的小。</p>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><ol start="89">
<li>Number of Islands N</li>
</ol>
<p>求连通分量的题目。首先找到一个1，把所有和这个连通分量一起的1全部改成0（这需要上下左右搜索，搜索的时候要注意边界条件）。再继续找1，以此循环往复。然后答案就是循环往复的次数。</p>
<ol start="90">
<li>Surrounded Regions N</li>
</ol>
<p>这里是将被围住的O变成X，那么标记和边界的O相同连通分量的O，没被标记的O就说明被围住了，变成X。</p>
<ol start="91">
<li>Clone Graph N</li>
</ol>
<p>深拷贝一个图。做一个老结点到新节点的Hash。然后对图做一次dfs。假设dfs(k)，那么先查询Hash(k)存在否，不存在的话赋新值，对k每一个链接的节点，做一次dfs。然后把dfs的结果加入到链接表中。如果存在，就什么也不做。最后直接返回Hash(k)。其实还是和之前链表深拷贝一样，做一个老结点到新节点的Hash。</p>
<ol start="92">
<li>Evaluate Division N</li>
</ol>
<p>暂时不表</p>
<ol start="93">
<li>Course Schedule N</li>
</ol>
<p>建图。节点是课程号，边是上x课之前要上y课。这里使用邻接表。用E[x]表示所有y-&gt;x。这样很好计算入度了，那就是E[x].length。取出一个入度为0的元素，从图中删掉，更新一下邻接表。如果找不到入度为0的元素，但是还是有元素存在，说明有环，返回false。所有元素都可以被处理，返回true。</p>
<ol start="94">
<li>Course Schedule II N</li>
</ol>
<p>和之前一样，只不过把每一个入度为0的元素从图中删除的顺序记录下来而已。</p>
<h2 id="Graph-BFS"><a href="#Graph-BFS" class="headerlink" title="Graph BFS"></a>Graph BFS</h2><ol start="95">
<li>Snakes and Ladders N</li>
</ol>
<p>暂且不表</p>
<ol start="96">
<li>Minimum Genetic Mutation</li>
</ol>
<p>建图，顶点是可能出现的基因序列。边x-&gt;y，代表x可以变到y。建图之后然后求步数。求步数的方法可以使用bfs。构建一个结点队列和结点对应的步数队列，做dfs。把初始结点和0加入队列中做搜索，搜索到了返回答案，搜索不到（队列空了）就返回-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; cnt;</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        char keys[4] = &#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;&#125;;        </span><br><span class="line">        for (auto &amp; w : bank) &#123;</span><br><span class="line">            cnt.emplace(w);</span><br><span class="line">        &#125;</span><br><span class="line">        if (start == end) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!cnt.count(end)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;string&gt; qu;</span><br><span class="line">        qu.emplace(start);</span><br><span class="line">        visited.emplace(start);</span><br><span class="line">        int step = 1;</span><br><span class="line">        while (!qu.empty()) &#123;</span><br><span class="line">            int sz = qu.size();</span><br><span class="line">            for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">                string curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                for (int j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">                    for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                        if (keys[k] != curr[j]) &#123;</span><br><span class="line">                            string next = curr;</span><br><span class="line">                            next[j] = keys[k];</span><br><span class="line">                            if (!visited.count(next) &amp;&amp; cnt.count(next)) &#123;</span><br><span class="line">                                if (next == end) &#123;</span><br><span class="line">                                    return step;</span><br><span class="line">                                &#125;</span><br><span class="line">                                qu.emplace(next);</span><br><span class="line">                                visited.emplace(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="97">
<li>Word Ladder</li>
</ol>
<p>和96一样的bfs。暂且不表。</p>
<h2 id="Trie（字典树）"><a href="#Trie（字典树）" class="headerlink" title="Trie（字典树）"></a>Trie（字典树）</h2><ol start="98">
<li>Implement Trie (Prefix Tree)</li>
</ol>
<p>字典树就是前缀树，通过查前缀来判断是不是有。那就构建下面的26叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">public:</span><br><span class="line">    char c;</span><br><span class="line">    vector&lt;TrieNode*&gt; list;</span><br><span class="line">    bool end;</span><br><span class="line">    TrieNode(char c) &#123;</span><br><span class="line">        this-&gt;c = c;</span><br><span class="line">        list = vector&lt;TrieNode*&gt;(26);</span><br><span class="line">        end = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // for root</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        list = vector&lt;TrieNode*&gt;(26);</span><br><span class="line">        end = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如说插入了单词cat，那么从字典树头开始在头的list[3]建立一个新的结点，c&#x3D;’c’，然后再在这个结点的list[1]建立一个新的结点，c&#x3D;’a’。最后在这个新的结点的list[‘t’-‘a’]建立一个新的结点，标记end&#x3D;true，就是说有一个单词在这里结束了。</p>
<p>然后查cat的存在性就是按照上面的逻辑去查。如果走到某一步节点为空，说明肯定不对，如果走完了前缀存在。（如果end&#x3D;true，说明这个单词也存在）这就是字典树，一个26叉树，树中有一个end标记代表有一个完整的单词的存在。</p>
<ol start="99">
<li>Design Add and Search Words Data Structure N</li>
</ol>
<p>是98的字典树的应用。</p>
<ol start="100">
<li>Word Search II H</li>
</ol>
<p>暂且不表。</p>
<h2 id="Backtracking（回溯，其实也是一种搜索）"><a href="#Backtracking（回溯，其实也是一种搜索）" class="headerlink" title="Backtracking（回溯，其实也是一种搜索）"></a>Backtracking（回溯，其实也是一种搜索）</h2><ol start="101">
<li>Letter Combinations of a Phone Number N</li>
</ol>
<p>构建dfs(stage,target,str)。如果stage &#x3D;&#x3D; target，说明结束了，可以写入到res数组。如果是stage &lt; target，说明还要继续往下搜索。那么str +&#x3D; 所有有可出现的字母，然后搜索k次 dfs(stage+1,target,str’)（k&#x3D;所有可能出现的字母数量）</p>
<ol start="102">
<li>Combination N</li>
</ol>
<p>还是构建dfs(cur,n,k,temp)cur是当前所选的位置，n是个数，k是组合的个数。如果temp.size() &#x3D;&#x3D; k，那么temp是一个正确的答案，return。然后在考虑选择cur和不选择cur，两个问题上做搜索。一个是temp.push(cur)之后在做dfs(cur+1,n,k,temp)，做完这一部分搜索回溯之后 ，然后temp.pop()在做dfs(cur+1,n,k,temp)。</p>
<p>这里涉及到n的问题，这里就要对不满足n的要求的做一次剪枝。如果当前temp.size()+n-cur+1 &lt; k，也就是说剩下的所有元素全放进去都不够k个的，那就趁早结束，不做了。</p>
<ol start="103">
<li>Permutations N</li>
</ol>
<p>涉及选不选的问题。还是构建dfs(p,n,temp,tag)，用tag数组标记访问的情况。如果p &#x3D;&#x3D; n，说明搜索到了终点。如果p &lt; n，那么就在把所有tag&#x3D;0的元素放入搜索中。首先找一个tag&#x3D;0的数据，然后令tag&#x3D;1，temp加入这个数，做dfs(p+1,n,temp,tag)，结束搜索，也就是回溯后tag&#x3D;0，temp丢出来。</p>
<ol start="104">
<li>Combination Sum N</li>
</ol>
<p>还是搜索。dfs(now,target,index)。搜索是对数组的每一项进行选取（dfs(now.push(x),target-x,index+1)）和不选取（dfs(now,target,index+1)）的搜索。搜索到的话就是target&#x3D;0。</p>
<p>然后可以进行剪枝，就是index &#x3D; nums.size()的话，就没必要继续做了，还有target&lt;0，也没必要继续做了。</p>
<ol start="105">
<li>N-Queens II H</li>
</ol>
<p>太经典了，暂且不表。</p>
<ol start="106">
<li>Generate Parentheses N</li>
</ol>
<p>还是搜索，dfs(l,r,str,n)。对l和r构成的空间组进行搜索，要么加一个(，要么加一个)。dfs(l+1,r,str+’(‘),dfs(l,r+1,str+’)’)。搜索到了就是l&#x3D;r&#x3D;n。</p>
<p>还可以进行剪枝。如果l &gt; n，r &gt; n，l &gt; r，都是不可以的。</p>
<ol start="107">
<li>Word Search N</li>
</ol>
<p>找存不存在word。dfs(pos,l,n)。上下左右搜索没有被搜索过的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m;</span><br><span class="line">    int n;</span><br><span class="line">    int w;</span><br><span class="line">    int hashset[130];</span><br><span class="line">    int b(int i,int j)&#123;</span><br><span class="line">        return i*n + j;</span><br><span class="line">    &#125;</span><br><span class="line">    void p(int k,int&amp; i,int&amp; j)&#123;</span><br><span class="line">        i = k / n;</span><br><span class="line">        j = k % n;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(int k,int q,string word,vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;int&gt; tag)&#123;</span><br><span class="line">        if(q == w - 1) return true;</span><br><span class="line">        int i,j;</span><br><span class="line">        p(k,i,j);</span><br><span class="line">        if(i &gt; 0 &amp;&amp; tag[b(i-1,j)] == 0 &amp;&amp; board[i-1][j] == word[q+1])&#123;</span><br><span class="line">            tag[b(i-1,j)] = 1;</span><br><span class="line">            if(dfs(b(i-1,j),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i-1,j)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; m - 1 &amp;&amp; tag[b(i+1,j)] == 0 &amp;&amp; board[i+1][j] == word[q+1])&#123;</span><br><span class="line">            tag[b(i+1,j)] = 1;</span><br><span class="line">            if(dfs(b(i+1,j),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i+1,j)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &gt; 0 &amp;&amp; tag[b(i,j-1)] == 0 &amp;&amp; board[i][j-1] == word[q+1])&#123;</span><br><span class="line">            tag[b(i,j-1)] = 1;</span><br><span class="line">            if(dfs(b(i,j-1),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i,j-1)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &lt; n - 1 &amp;&amp; tag[b(i,j+1)] == 0 &amp;&amp; board[i][j+1] == word[q+1])&#123;</span><br><span class="line">            tag[b(i,j+1)] = 1;</span><br><span class="line">            if(dfs(b(i,j+1),q+1,word,board,tag)) return true;</span><br><span class="line">            tag[b(i,j+1)] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        m = board.size();</span><br><span class="line">        n = board[0].size();</span><br><span class="line">        w = word.size();</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                hashset[board[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; w;i++)&#123;</span><br><span class="line">            if(--hashset[word[i]] &lt; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tag(m*n);</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                if(board[i][j] == word[0])&#123;</span><br><span class="line">                    tag[b(i,j)] = 1;</span><br><span class="line">                    if(dfs(b(i,j),0,word,board,tag)) return true;</span><br><span class="line">                    tag[b(i,j)] = 0;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样子会超时，要加一个hash的判断。比如说单词出现了N，但是matrix里一个N都没有，就可以直接剪枝了。</p>
<h2 id="Divide-Conquer（分治）"><a href="#Divide-Conquer（分治）" class="headerlink" title="Divide &amp; Conquer（分治）"></a>Divide &amp; Conquer（分治）</h2><ol start="108">
<li>Convert Sorted Array to Binary Search Tree E</li>
</ol>
<p>有序数组转化成BST。那就做分治。设置一个constructor，输入一个有序数组返回一个BST。那就c[0,n] &#x3D; {val &#x3D; c[n &#x2F; 2],left &#x3D; c[0, n &#x2F; 2 - 1],right &#x3D; [n &#x2F; 2 + 1,n]}</p>
<ol start="109">
<li>Sort List N</li>
</ol>
<p>为链表排序。那就先用快慢指针找到链表的中间，然后做一次分支排序。l1 &#x3D; sort(head),l2 &#x3D; sort(slow).l &#x3D; merge(l1,l2)。merge的办法是构建一个新的链表，方法参考题59。</p>
<ol start="110">
<li>Construct Quad Tree N</li>
</ol>
<p>暂且不表</p>
<ol start="111">
<li>Merge k Sorted Lists H</li>
</ol>
<p>假设有k个list。（力扣的测试集很弱，你按照顺序merge k次也可以过）</p>
<p>可以只用merge logk 级的次数。就是做分治。把merge k次的任务分解成。merge[0,k&#x2F;2]和merge[k&#x2F;2+1,k]两个子问题+对于子问题的结果进行一次merge。</p>
<h2 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h2><ol start="112">
<li>Maximum Subarray N</li>
</ol>
<p>动态规划。dp[n] &#x3D; max[a[n],dp[n-1] + a[n]] 要么接着拿，要么重开。</p>
<ol start="113">
<li>Maximum Sum Circular Subarray N</li>
</ol>
<p>动态规划，正常操作：dp[n] &#x3D; max[a[n],dp[n-1] + a[n]]。现在有不涉及到循环的一个最大值max(dp[n])</p>
<p>现在考虑涉及到循环的最大值。固定最右边的元素，找到左边的元素。首先记最大前缀和l[k] &#x3D; max(l[k-1],l1+l2+…lk)</p>
<p>假设右边的元素选了k个。那么左边的元素是n-k个，假设dp1[k] &#x3D; (ln+ln-1+…l_k + l[n-k])</p>
<p>那么答案是max(max(dp[n]),max(dp1[n]))</p>
<h2 id="Binary-Search（二分搜索）"><a href="#Binary-Search（二分搜索）" class="headerlink" title="Binary Search（二分搜索）"></a>Binary Search（二分搜索）</h2><ol start="114">
<li>Search Insert Position E</li>
</ol>
<p>二分搜索。b(0,n-1,target). <code>if a[mid] &lt; target,l = mid + 1,ans = mid. else r = mid - 1.</code></p>
<ol start="115">
<li>Search a 2D Matrix N</li>
</ol>
<p>把矩阵展开成向量形式进行二分搜索。</p>
<ol start="116">
<li>Find Peak Element N</li>
</ol>
<p>如果mid比mid+1位置的元素小，说明答案很有可能是在右边。反之，说明答案很有可能在左边。然后以此为逻辑二分查找即可。</p>
<ol start="117">
<li>Search in Rotated Sorted Array N</li>
</ol>
<p>二分查找，但是这个查找相较于其他查找不同的是，数组分成两部分[A][B]。如果nums[mid] &gt;&#x3D; nums[0]。就说明mid在A区。如果target &gt;&#x3D; nums[0] 并且 target &lt; nums[mid]。就说明target在A区mid左侧。否则target在A区mid右侧或者B区。</p>
<p>如果mid在B区。那么需要保证target &gt; nums[mid]并且target &lt;&#x3D; nums[n-1]才能保证target在B区mid右侧。</p>
<ol start="118">
<li>Find First and Last Position of Element in Sorted Array N</li>
</ol>
<p>先二分查找，找到一个位置k，然后再往左往右遍历。</p>
<ol start="119">
<li>Find Minimum in Rotated Sorted Array N</li>
</ol>
<p>在这样的旋转表里找最小值。还是一样分成两部分[A][B]，我们找B区第一个。如果nums[mid] &lt; nums[r]，则说明mid在B区。那就应该在左边找。那就令r &#x3D; mid（因为mid可能是B区第一个）。的否则l &#x3D; mid + 1.</p>
<ol start="120">
<li>Median of Two Sorted Arrays H</li>
</ol>
<p>想不到特别好的办法，我这里用的是朴素思考。</p>
<h2 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h2><p>堆是一种有序队列。在C++的STL里有一个数据结构满足堆的要求，这里不需要我们搓轮子了。（下面叫优先队列）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    第三个参数是自己写的cmp函数。</span><br><span class="line">    剩下的用法就是和队列一样</span><br><span class="line">*/</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</span><br></pre></td></tr></table></figure>

<ol start="121">
<li>Kth Largest Element in an Array N</li>
</ol>
<p>放进所有元素，pop K-1个元素，取队列的top</p>
<ol start="122">
<li>IPO H</li>
</ol>
<p>这一题就是贪心。因为确保了最小投入资本capital是递增的。所以可以先找到所有满足的最小资本数 &lt;&#x3D; 持有资本数的项目。然后按照净利润递减的顺序放入优先队列里，每一次取出优先队列的最大值作为净利润，更新持有资本 &#x3D; 之前持有资本 + 净利润。</p>
<ol start="123">
<li>Find K Pairs with Smallest Sums</li>
</ol>
<p>找到K个最小的pair。下面给一个使用这个STL，自定义比较函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct lis &#123;</span><br><span class="line">    vector&lt;int&gt; p; // 存储的值</span><br><span class="line">    vector&lt;int&gt; w; // 相对数组的位置</span><br><span class="line">&#125;;</span><br><span class="line">struct compare &#123;</span><br><span class="line">    bool operator()(lis a, lis b) &#123; return a.p[0] + a.p[1] &gt; b.p[0] + b.p[1]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2,</span><br><span class="line">                                       int k) &#123;</span><br><span class="line">        priority_queue&lt;lis, vector&lt;lis&gt;, compare&gt; que;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        // 先把第1行的处理好</span><br><span class="line">        for (int i = 0; i &lt; min(m, k); i++) &#123;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            vector&lt;int&gt; temp1;</span><br><span class="line">            temp.push_back(nums1[i]);</span><br><span class="line">            temp.push_back(nums2[0]);</span><br><span class="line">            // printf(&quot;1 push %d %d %d %d\n&quot;, i, 0, nums1[i], nums2[0]);</span><br><span class="line">            temp1.push_back(i);</span><br><span class="line">            temp1.push_back(0);</span><br><span class="line">            lis l;</span><br><span class="line">            l.p = temp;</span><br><span class="line">            l.w = temp1;</span><br><span class="line">            que.push(l);</span><br><span class="line">        &#125;</span><br><span class="line">        // 取一个放一个。 取一个x，y。放一个x，y + 1</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p;</span><br><span class="line">        while (k-- &amp;&amp; !que.empty()) &#123;</span><br><span class="line"></span><br><span class="line">            lis r = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            vector&lt;int&gt; temp1;</span><br><span class="line">            p.push_back(r.p);</span><br><span class="line">            if (r.w[1] + 1 &lt; n) &#123;</span><br><span class="line">                temp.push_back(nums1[r.w[0]]);</span><br><span class="line">                temp.push_back(nums2[r.w[1] + 1]);</span><br><span class="line">                temp1.push_back(r.w[0]);</span><br><span class="line">                temp1.push_back(r.w[1] + 1);</span><br><span class="line">                lis l;</span><br><span class="line">                l.p = temp;</span><br><span class="line">                l.w = temp1;</span><br><span class="line">                que.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="124">
<li>Find Median from Data Stream H</li>
</ol>
<p>找中位数。那就构建一个递增的优先队列和一个递减的优先队列。这两个优先队列分别记录大于中位数的数和小于中位数的数。还要保证小于中位数的数量和大于中位数的数量差不多一致。</p>
<h2 id="Bit-Manipulation（位运算）"><a href="#Bit-Manipulation（位运算）" class="headerlink" title="Bit Manipulation（位运算）"></a>Bit Manipulation（位运算）</h2><ol start="125">
<li>Add Binary E</li>
</ol>
<p>位运算没有任何算法，就是纯模拟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        string ans;</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        reverse(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">        int n = max(a.size(), b.size()), carry = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.size() ? (a.at(i) == &#x27;1&#x27;) : 0;</span><br><span class="line">            carry += i &lt; b.size() ? (b.at(i) == &#x27;1&#x27;) : 0;</span><br><span class="line">            ans.push_back((carry % 2) ? &#x27;1&#x27; : &#x27;0&#x27;);</span><br><span class="line">            carry /= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (carry) &#123;</span><br><span class="line">            ans.push_back(&#x27;1&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="126">
<li>Reverse Bits E</li>
</ol>
<p>先转化成二进制，在reverse一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        for(int i = 0;i &lt; 32;i++)&#123;</span><br><span class="line">            //printf(&quot;Push back %d\n&quot;,n%2);</span><br><span class="line">            temp.push_back(n % 2);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        uint32_t res = 0;</span><br><span class="line">        uint32_t j = 1;</span><br><span class="line">        for(int i = 31;i &gt;= 0;i--)&#123;</span><br><span class="line">            res += (j * temp[i]);</span><br><span class="line">            //printf(&quot;get %d\n&quot;,temp[i]);</span><br><span class="line">            j *= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="127">
<li>Number of 1 Bits E</li>
</ol>
<p>一直÷2，然后找÷2的余数为1的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            res += (n % 2);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="128">
<li>Single Number E</li>
</ol>
<p>根据a ^ a &#x3D; 0的定律。对所有数异或在一起。剩下的那个数就是唯一一个。</p>
<ol start="129">
<li>Single Number II N</li>
</ol>
<p>这个比较搞。可以计算每一位出现1的次数。如果这一位出现1的次数 mod 3不为0，说明只出现1次的那个元素这一位为1.（看力扣题解好像可以用状态机来表示，感觉很酷）</p>
<ol start="130">
<li>Bitwise AND of Numbers Range N</li>
</ol>
<p>脑筋急转弯。对于按位与，我们知道，与里面出现一次0，那最终的答案就一定是0了。所以我们就可以推出，答案是m和n的二进制形态的公共前缀。</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ol start="131">
<li>Palindrome Number E</li>
</ol>
<p>回文数字。如果是负数就一定是错的。如果是正数的话可以构造逆数字，看看逆数字是不是和正数字一样。假设x的最后一位是k，那么令逆数字 &#x3D; 逆数字 * 10 + k。</p>
<ol start="132">
<li>Plus One E</li>
</ol>
<p>模拟加。这里需要注意万一全部为9的情况。</p>
<ol start="133">
<li>Factorial Trailing Zeroes N</li>
</ol>
<p>0的个数，大家知道0 是由 2 和 5构成的。2明显很充裕，那就是看项目中5因数的个数。（25算两个，125算三个，625算四个）</p>
<ol start="134">
<li>Sqrt(x) E</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        for(int i = 1;i &lt; 46341;i++)&#123;</span><br><span class="line">            if(i * i &gt; x) return i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 46340;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="135">
<li>Pow(x, n) N</li>
</ol>
<p>快速幂算法。这里直接搬题解的。基于x^n + x^n &#x3D; x^{2n}的道理快速算出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<ol start="136">
<li>Max Points on a Line H</li>
</ol>
<p>暂且不表</p>
<h2 id="1D-DP（一维动态规划）"><a href="#1D-DP（一维动态规划）" class="headerlink" title="1D DP（一维动态规划）"></a>1D DP（一维动态规划）</h2><p>动态规划就需要把dp递推方程给出来。给出dp递推方程就好办了。</p>
<ol start="137">
<li>Climbing Stairs E</li>
</ol>
<p>dp[n] &#x3D; dp[n-1] + dp[n-2] dp[1] &#x3D; 1,dp[2] &#x3D; 2</p>
<ol start="138">
<li>House Robber N</li>
</ol>
<p>对于第n个要么偷，要么不偷（那就算上第n-1个）。可以写出</p>
<p>dp[n] &#x3D; max(dp[n-2]+a[n],dp[n-1])<br>dp[1] &#x3D; a[1]<br>dp[2] &#x3D; max(a[1],a[2])</p>
<ol start="139">
<li>Word Break N</li>
</ol>
<p>dp[0] &#x3D; true. 如果有个单词，长度为k，单词的最后一位刚好到n处，那么dp[n] &#x3D; dp[n-k]。（这个的做法就是遍历n，然后从n往后推1，2，3….，k个字母，看构不构成单词，如果一个都构成不了，那就是false）</p>
<ol start="140">
<li>Coin Change N</li>
</ol>
<p>首先令dp[i] &#x3D; 114514。那么dp[i] &#x3D; min(dp[i],dp[i-coin[i]]+1)</p>
<ol start="141">
<li>Longest Increasing Subsequence N</li>
</ol>
<p>dp[0] &#x3D; 1. 对于所有a[n] &gt; a[k] dp[n] &#x3D; max(dp[n],dp[k] + 1)，然后找到最大的dp</p>
<p>对于dp，其递推方程的数据来源可以是一个数据（之前一个，之前两个）；也可以一组数据中最大的或者是最小的。</p>
<h2 id="多维DP"><a href="#多维DP" class="headerlink" title="多维DP"></a>多维DP</h2><ol start="142">
<li>Triangle N</li>
</ol>
<p>dp[0][0] &#x3D; a[0][0]<br>dp[i][0] &#x3D; dp[i-1][0] + a[i][0]<br>dp[i][i] &#x3D; dp[i-1][i-1] + a[i][i]<br>dp[i][k] &#x3D; min(dp[i-1][k-1],dp[i-1][k]) + a[i][k]</p>
<ol start="143">
<li>Minimum Path Sum N</li>
</ol>
<p>dp[0][0] &#x3D; a[0][0]<br>dp[i][0] &#x3D; a[i][0] + dp[i-1][0]<br>dp[0][i] &#x3D; a[0][i] + dp[0][i-1]<br>dp[i][j] &#x3D; min(dp[i-1][j],dp[i][j-1]) + a[i][j]</p>
<ol start="144">
<li>Unique Paths II N</li>
</ol>
<p>dp[0][0] &#x3D; 1<br>dp[i][0] &#x3D; 有阻碍？0 : (上一个有无阻碍？0：dp[i-1][0])<br>dp[0][i] &#x3D; 有阻碍？0 : (左一个有无阻碍？0：dp[0][i-1])<br>dp[i][j] &#x3D; 有阻碍？0 : (上一个有无阻碍？0：dp[i-1][j]) + (左一个有无阻碍？0：dp[i][j-1])</p>
<ol start="145">
<li>Longest Palindromic Substring N</li>
</ol>
<p>暂时不表</p>
<ol start="146">
<li>Interleaving String N</li>
</ol>
<p>首先看两个字符串的长度，长度不等是不可能成立的。</p>
<p>dp[0][0] &#x3D; T<br>dp[i][j] &#x3D; (dp[i-1][j] &amp; s1[i-1] &#x3D; s3[i+j-1]) | (dp[i][j-1] &amp; s2[j-1] &#x3D; s3[i+j-1])</p>
<p>解释：dp[i][j]解释了s3[i+j-1]可以被s1[0…i-1]和s2[0…j-1]构造。</p>
<ol start="147">
<li>Edit Distance N</li>
</ol>
<p>D[i][j]&#x3D;min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])&#x3D;1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)<br>​D[i][j]&#x3D;1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])</p>
<p>解释：D[i][j]是A[0..i]到B[0…j]的编辑距离。</p>
<ol start="148">
<li>Best Time to Buy and Sell Stock III H</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p[0] = -prices[0]; // buy once</span><br><span class="line">p[1] = 0; // buy 1 sell 1</span><br><span class="line">p[2] = -prices[0]; // buy 2 sell 1</span><br><span class="line">p[3] = 0; // buy 2 sell 2</span><br><span class="line">for(int i = 1;i &lt; s;i++)&#123;</span><br><span class="line">    p[0] = max(p[0],-prices[i]); // for buy 1 when buy once?</span><br><span class="line">    p[1] = max(p[1],p[0]+prices[i]);</span><br><span class="line">    p[2] = max(p[2],p[1]-prices[i]);</span><br><span class="line">    p[3] = max(p[3],p[2]+prices[i]);</span><br><span class="line">    //printf(&quot;%d %d %d %d %d\n&quot;,prices[i],p[0],p[1],p[2],p[3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="149">
<li>Best Time to Buy and Sell Stock IV H</li>
</ol>
<p>从2次到k次，很快能能找到关系，从4个状态到2k个状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1;i &lt;= k;i++)&#123;</span><br><span class="line">    p[2 * i - 1] = -prices[0];</span><br><span class="line">    p[2 * i + 0] = 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 1;j &lt; s;j++)&#123;</span><br><span class="line">    for(int i = 1;i &lt;= k;i++)&#123;</span><br><span class="line">        p[2 * i - 1] = max(p[2 * i - 1],p[2 * i - 2] - prices[j]);</span><br><span class="line">        p[2 * i + 0] = max(p[2 * i + 0],p[2 * i - 1] + prices[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="150">
<li>Maximal Square</li>
</ol>
<p>dp(i,j)&#x3D;min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1（dp为为1的边长）</p>
<p>这里我做了个很复杂的写法，贴在这里算了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        int dp[305][305];</span><br><span class="line">        dp[0][0] = matrix[0][0] - &#x27;0&#x27;;</span><br><span class="line">        for(int i = 1;i &lt; n;i++)&#123;</span><br><span class="line">            dp[0][i] =matrix[0][i] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt; m;i++)&#123;</span><br><span class="line">            dp[i][0] = matrix[i][0] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 1;j &lt; n;j++)&#123;</span><br><span class="line">                if(matrix[i][j] == &#x27;0&#x27;)&#123;</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    int flag = 1;</span><br><span class="line">                    int n = dp[i-1][j-1];</span><br><span class="line">                    int p = 0,q = 0;</span><br><span class="line">                    for(int k = 0;k &lt; n;k++)&#123;</span><br><span class="line">                        if(matrix[i][j-1-k] == &#x27;0&#x27;)&#123;</span><br><span class="line">                            flag = 0;</span><br><span class="line">                            </span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = k + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //p = min(p+1,n);</span><br><span class="line">                    for(int k = 0;k &lt; n;k++)&#123;</span><br><span class="line">                        if(matrix[i-1-k][j] == &#x27;0&#x27;)&#123;</span><br><span class="line">                            flag = 0;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q = k + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //q = min(q+1,n);</span><br><span class="line">                    if(flag) dp[i][j] = dp[i-1][j-1] + flag;</span><br><span class="line">                    else dp[i][j] = min(p,q) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                printf(&quot;%d &quot;,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int ma = 0;</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            for(int j = 0;j &lt; n;j++)&#123;</span><br><span class="line">                ma = max(ma,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ma*ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <blockquote class="article-copyright">
    <p><strong>本文作者：</strong>Sukuna @ Suwa shrine</p>
    <p><strong>本文链接：</strong><a href="https://sukunashinmyoumaru-hust.github.io/2024/11/20/150/">https://sukunashinmyoumaru-hust.github.io/2024/11/20/150/</a></p>
    
    
    
    <p><strong>本文版权：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener external nofollow noreferrer" target="_blank"><span class="icon-creative-commons"></span>BY-NC-SA</a> 许可协议。转载请注明出处！</p>
    <span class="icon-creative-commons article-copyright-bg"></span>
  </blockquote>
      
      
      
        <a data-aos="zoom-in" href="/2024/11/20/150/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2024/11/20/150/" itemprop="commentCount"></span>
          留言
        </a>
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/7d2279310f1bb2f7.jpg" data-sizes="auto" alt="一个有趣的C语言ub" class="lazyload">
          
        
        <a href="/2024/12/12/cub/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            一个有趣的C语言ub
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="https://s3.bmp.ovh/imgs/2024/06/17/c10853f5c9aee06c.jpg" data-sizes="auto" alt="Sukuna出的几道语文高考题" class="lazyload">
        
      
      <a href="/2024/11/19/chinese/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          Sukuna出的几道语文高考题
        
      </h3>
    </div>
    
  </nav>


</article>

  <section id="comments" class="vcomment" data-aos="fade-up"></section>






</section>
          
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false"></div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2024
      <span class="footer-info-sep rotate"></span>
      Sukuna
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        189.2k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        13:13
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
  
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-String"><span class="toc-number">1.</span> <span class="toc-text">Array &#x2F; String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Pointers"><span class="toc-number">2.</span> <span class="toc-text">Two Pointers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Window%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%91%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">Sliding Window（滑动窗口【单调队列】）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%E5%B0%B1%E6%98%AF%E5%81%9A%E6%A8%A1%E6%8B%9F%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">矩阵（大部分就是做模拟）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">HashMap（哈希表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intervals"><span class="toc-number">6.</span> <span class="toc-text">Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">7.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkList"><span class="toc-number">8.</span> <span class="toc-text">LinkList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binariy-Tree"><span class="toc-number">9.</span> <span class="toc-text">Binariy Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binariy-Tree-BFS"><span class="toc-number">10.</span> <span class="toc-text">Binariy Tree BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST"><span class="toc-number">11.</span> <span class="toc-text">BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph"><span class="toc-number">12.</span> <span class="toc-text">Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph-BFS"><span class="toc-number">13.</span> <span class="toc-text">Graph BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">Trie（字典树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">Backtracking（回溯，其实也是一种搜索）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-Conquer%EF%BC%88%E5%88%86%E6%B2%BB%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">Divide &amp; Conquer（分治）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kadane%E2%80%99s-Algorithm"><span class="toc-number">17.</span> <span class="toc-text">Kadane’s Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search%EF%BC%88%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">Binary Search（二分搜索）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap%EF%BC%88%E5%A0%86%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">Heap（堆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bit-Manipulation%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">Bit Manipulation（位运算）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">21.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1D-DP%EF%BC%88%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">1D DP（一维动态规划）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4DP"><span class="toc-number">23.</span> <span class="toc-text">多维DP</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/IMG_1335.PNG" data-sizes="auto" alt="Sukuna" class="lazyload">
  <div class="sidebar-author-name">Sukuna</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">29</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">3</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/Sukunashinmyoumaru-hust || github || &#34;#191717&#34; itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://twitter.com/sukuna_wireless || twitter || &#34;#00aff0&#34; itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-email sidebar-social-icon">
      <a href=sukuna@hust.edu.cn || envelope || &#34;#55acd5&#34; itemprop="url" target="_blank" aria-label="email" rel="noopener external nofollow noreferrer"></a>
    </div>
  
    <div class="icon-bilibili sidebar-social-icon">
      <a href=https://space.bilibili.com/5595530 itemprop="url" target="_blank" aria-label="bilibili" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" target="_blank" rel="noopener" href="https://github.com/SukunaShinmyoumaru-hust/Hust-opensource-Xuejie" aria-label="HUST-学解"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">HUST-学解</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/picture" aria-label="赠画感谢"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">赠画感谢</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/source" aria-label="资料下载"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">资料下载</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/travel" aria-label="旅行日志"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">旅行日志</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/gbook" aria-label="Sukuna冬令营"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">Sukuna冬令营</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>



  
<script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js" integrity="sha384-xneY1WY8hOfUzswrE4CrYq35N4BdVcxqxwHPr9zawE&#x2F;jMSCxD+jAPU55x&#x2F;jj3wlf" crossorigin="anonymous"></script>

  <script>
    function loadScripts(scripts, index) {
      if (index < scripts.length) {
        const script = scripts[index];
        const src = script.getAttribute('src');

        const loadScript = (scriptContent) => {
          const scriptElement = document.createElement('script');
          if (script.type) {
            scriptElement.type = script.type;
          }
          scriptElement.text = scriptContent;
          document.head.appendChild(scriptElement);
          loadScripts(scripts, index + 1);
        }

        if (src) {
          fetch(src)
            .then(response => {
              if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
              }
              return response.text();
            })
            .then(scriptContent => {
              loadScript(scriptContent);
            })
            .catch(error => {
              console.error('Failed to load script:', src, error);
            });
        } else {
          loadScript(script.text);
        }
      }
    }
    window.Pjax && new window.Pjax({
      selectors: [
        "#header img",
        "#header picture",
        "head title",
        "#header-title",
        "#subtitle-wrap",
        "#content",
        '#mobile-nav',
        '#lazy-script'
      ],
      switches: {
        "#header-title": Pjax.switches.outerHTML,
        "#subtitle-wrap": Pjax.switches.outerHTML,
        "#content": function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.outerHTML = newEl.outerHTML
          this.onSwitch()
        },
        "#mobile-nav": Pjax.switches.outerHTML,
        '#lazy-script': function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.innerHTML = newEl.innerHTML
          this.onSwitch()
        },
      },
      cacheBust: false
    })
  </script>
  
<script src="/js/pjax.js"></script>




  <script>
    function initLive2d() {
      live2d.init("https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/", {themeTipsPath: ""});
    }
  </script>
  
<script src="https://fastly.jsdelivr.net/gh/D-Sketon/plugin-live2d/js/live2d-autoload.js" onload="initLive2d &amp;&amp; initLive2d()" async></script>





<div id="lazy-script">
  <div>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
  
<script src="https://npm.webcache.cn/valine@1.5.1/dist/Valine.min.js" integrity="sha384-3ma91AExDeMAZ1rjTjaP8V2A2obQE+s5ltKRwYlwdpArz9xVbp0tF3b0VV2ACNPn" crossorigin="anonymous" data-pjax></script>

  <script data-pjax>
    var GUEST_INFO = ['nick', 'mail', 'link'];
    var guest_info = 'SukunaFans'.split(',').filter((item) => {
      return GUEST_INFO.indexOf(item) > -1
    });
    var recordIP = JSON.parse('true');
    var highlight = JSON.parse('true');
    var visitor = JSON.parse('false');

    new Valine({
      el: '.vcomment',
      appId: "xR5C19oD9KiPnawzBUJNSD64-gzGzoHsz",
      appKey: "BuHN9ATTBOcwMxGPy9IxuI8b",
      placeholder: "留下你的留言吧",
      pageSize: '10',
      avatar: 'mp',
      lang: 'zh-cn',
      recordIP: recordIP,
      highlight: highlight,
      visitor: visitor,
      requiredFields: guest_info,
      path: window.location.pathname
    });
  </script>









    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.0.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  
    
<script src="https://npm.webcache.cn/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6&#x2F;1Nxveei" crossorigin="anonymous" defer data-pjax></script>

    <script data-pjax>
      window.MathJax = {"tex":{"tags":"ams","useLabelIds":true,"inlineMath":[["$","$"],["\\\\(","\\\\)"]],"displayMath":[["$$","$$"],["\\\\[","\\\\]"]],"processEscapes":true,"processEnvironments":true,"autoload":{"color":[],"colorv2":["color"]},"packages":{"[+]":["noerrors"]}},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"ignoreHtmlClass":"tex2jax_ignore","processHtmlClass":"tex2jax_process"},"loader":{"load":["input/asciimath","[tex]/noerrors"]}};
    </script>
  


  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
  </html>

